{
  "author": "",
  "category": "General",
  "extensionNamespace": "",
  "fullName": "3D sprite",
  "gdevelopVersion": ">=5.5.222",
  "helpPath": "/objects/sprite/",
  "iconUrl": "data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0iVVRGLTgiPz48IURPQ1RZUEUgc3ZnIFBVQkxJQyAiLS8vVzNDLy9EVEQgU1ZHIDEuMS8vRU4iICJodHRwOi8vd3d3LnczLm9yZy9HcmFwaGljcy9TVkcvMS4xL0RURC9zdmcxMS5kdGQiPjxzdmcgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIiB4bWxuczp4bGluaz0iaHR0cDovL3d3dy53My5vcmcvMTk5OS94bGluayIgdmVyc2lvbj0iMS4xIiBpZD0ibWRpLWdob3N0LW91dGxpbmUiIHdpZHRoPSIyNCIgaGVpZ2h0PSIyNCIgdmlld0JveD0iMCAwIDI0IDI0Ij48cGF0aCBkPSJNMTIgMkM3LjAzIDIgMyA2LjAzIDMgMTFWMjJMNiAxOUw5IDIyTDEyIDE5TDE1IDIyTDE4IDE5TDIxIDIyVjExQzIxIDYuMDMgMTYuOTcgMiAxMiAyTTE5IDE3LjE3TDE4IDE2LjE3TDE2LjU5IDE3LjU5TDE1IDE5LjE3TDEzLjQxIDE3LjU5TDEyIDE2LjE3TDEwLjU5IDE3LjU5TDkgMTkuMTdMNy40MSAxNy41OUw2IDE2LjE3TDUgMTcuMTdWMTFDNSA3LjE0IDguMTQgNCAxMiA0UzE5IDcuMTQgMTkgMTFWMTcuMTdNMTEgMTBDMTEgMTEuMTEgMTAuMTEgMTIgOSAxMlM3IDExLjExIDcgMTAgNy45IDggOSA4IDExIDguOSAxMSAxME0xNyAxMEMxNyAxMS4xMSAxNi4xMSAxMiAxNSAxMlMxMyAxMS4xMSAxMyAxMCAxMy45IDggMTUgOCAxNyA4LjkgMTcgMTBaIiAvPjwvc3ZnPg==",
  "name": "Sprite3D",
  "previewIconUrl": "https://asset-resources.gdevelop.io/public-resources/Icons/3bd33ec77ed20d3f631c6c92884728b375aa2879174bc9f289c864d0e0383d59_ghost-outline.svg",
  "shortDescription": "An animated sprite in 3D.",
  "version": "0.1.2",
  "description": "The 3D sprite is an object that can be moved and rotated in 3D.",
  "origin": {
    "identifier": "Sprite3D",
    "name": "gdevelop-extension-store"
  },
  "tags": [
    "3d"
  ],
  "authorIds": [
    "IWykYNRvhCZBN3vEgKEbBPOR3Oc2",
    "sXdoMxxHF7hAXkEPRO8oZcfnBgC2"
  ],
  "dependencies": [],
  "globalVariables": [],
  "sceneVariables": [],
  "eventsFunctions": [
    {
      "description": "Define helper classes JavaScript code.",
      "fullName": "Define helper classes",
      "functionType": "Action",
      "name": "DefineHelperClasses",
      "private": true,
      "sentence": "Define helper classes JavaScript code",
      "events": [
        {
          "type": "BuiltinCommonInstructions::JsCode",
          "inlineCode": [
            "if (gdjs.__sprite3DExtension) {",
            "    return;",
            "}",
            "const vertexColors = [];",
            "",
            "class Sprite3DRenderer {",
            "    /** @type {gdjs.CustomRuntimeObject} */",
            "    object;",
            "    /** @type {THREE.Mesh} */",
            "    mesh;",
            "    /** @type {number} */",
            "    depthOffset;",
            "    /** @type {boolean} */",
            "    autoRotate;",
            "    ",
            "    /**",
            "     * @param object {gdjs.CustomRuntimeObject}",
            "     */",
            "    constructor(object) {",
            "        this.object = object;",
            "        this.depthOffset = 0;",
            "        this.autoRotate = true;",
            "        ",
            "        const geometry = new THREE.PlaneGeometry(1, -1);",
            "        const animationFrame = object.getAnimator().getCurrentFrame();",
            "        if (animationFrame) {",
            "            const material = animationFrame.texture;",
            "            ",
            "            // Enhanced transparency and depth settings",
            "            material.alphaTest = 0.5;",
            "            material.depthWrite = true;",
            "            material.depthTest = true;",
            "            material.transparent = true;",
            "            ",
            "            // Advanced professional improvements",
            "            material.side = THREE.DoubleSide;",
            "            material.shadowSide = THREE.FrontSide;",
            "            material.toneMapped = true;",
            "            material.fog = true;",
            "            material.premultipliedAlpha = true;",
            "            ",
            "            // Advanced depth settings to prevent z-fighting",
            "            material.depthFunc = THREE.LessEqualDepth;",
            "            material.polygonOffset = true;",
            "            material.polygonOffsetFactor = -1;",
            "            material.polygonOffsetUnits = -1;",
            "            ",
            "            // Professional visual effects",
            "            if (material.emissive) {",
            "                material.emissive = new THREE.Color(0x111111);",
            "                material.emissiveIntensity = 0.2;",
            "            }",
            "            ",
            "            material.needsUpdate = true;",
            "            ",
            "            this.mesh = new THREE.Mesh(geometry, material);",
            "            ",
            "            // Optimized rotation order for realism (YXZ is better for standing objects)",
            "            this.mesh.rotation.order = 'YXZ';",
            "            ",
            "            // Enable enhanced shadows",
            "            this.mesh.castShadow = true;",
            "            this.mesh.receiveShadow = true;",
            "            ",
            "            // Performance and rendering improvements",
            "            this.mesh.frustumCulled = true;",
            "            this.mesh.matrixAutoUpdate = true;",
            "            ",
            "            // Dynamic renderOrder based on Z position",
            "            this.updateRenderOrder();",
            "            ",
            "            object.get3DRendererObject().add(this.mesh);",
            "            ",
            "            // Add vertex colors for advanced coloring",
            "            vertexColors.length = geometry.attributes.position.count * 3;",
            "            vertexColors.fill(1);",
            "            geometry.setAttribute(",
            "                'color',",
            "                new THREE.BufferAttribute(new Float32Array(vertexColors), 3)",
            "            );",
            "        }",
            "        this.updateFrame();",
            "        object.getAnimator().setOnFrameChangeCallback(() => this.updateFrame());",
            "    }",
            "    ",
            "    /**",
            "     * Update render order based on depth",
            "     */",
            "    updateRenderOrder() {",
            "        if (!this.mesh) return;",
            "        ",
            "        // Calculate renderOrder based on Z and Y position to ensure correct rendering",
            "        const zPos = this.object.getZ ? this.object.getZ() : 0;",
            "        const yPos = this.object.getY ? this.object.getY() : 0;",
            "        ",
            "        // Use complex formula to get precise ordering",
            "        this.mesh.renderOrder = Math.floor(zPos * 1000 + yPos);",
            "        ",
            "        // Apply additional depth offset",
            "        this.mesh.position.z = this.depthOffset;",
            "    }",
            "    ",
            "    /**",
            "     * Apply automatic rotation angles based on position and velocity",
            "     */",
            "    applyAutoRotation() {",
            "        if (!this.autoRotate || !this.mesh) return;",
            "        ",
            "        const obj = this.object;",
            "        ",
            "        // Get velocity and direction",
            "        const velocityX = (obj._customState && obj._customState.velocityX) || 0;",
            "        const velocityY = (obj._customState && obj._customState.velocityY) || 0;",
            "        const angle = obj.getAngle ? obj.getAngle() : 0;",
            "        ",
            "        // Calculate automatic tilt on X axis (pitch) based on vertical velocity",
            "        const maxPitchAngle = 15; // degrees",
            "        const pitchFactor = Math.min(Math.abs(velocityY) / 500, 1);",
            "        const targetPitch = (velocityY < 0 ? -1 : 1) * pitchFactor * maxPitchAngle;",
            "        ",
            "        // Calculate tilt on Y axis (yaw) based on direction",
            "        const maxYawAngle = 10; // degrees",
            "        const yawFactor = Math.min(Math.abs(velocityX) / 500, 1);",
            "        const targetYaw = (velocityX < 0 ? -1 : 1) * yawFactor * maxYawAngle;",
            "        ",
            "        // Apply rotation smoothly (lerp)",
            "        const lerpFactor = 0.1;",
            "        const currentRotation = this.mesh.rotation;",
            "        ",
            "        // Convert base angle to Z rotation",
            "        const targetZ = THREE.MathUtils.degToRad(-angle);",
            "        ",
            "        // Apply smooth rotation",
            "        currentRotation.x = THREE.MathUtils.lerp(",
            "            currentRotation.x,",
            "            THREE.MathUtils.degToRad(targetPitch),",
            "            lerpFactor",
            "        );",
            "        ",
            "        currentRotation.y = THREE.MathUtils.lerp(",
            "            currentRotation.y,",
            "            THREE.MathUtils.degToRad(targetYaw),",
            "            lerpFactor",
            "        );",
            "        ",
            "        currentRotation.z = THREE.MathUtils.lerp(",
            "            currentRotation.z,",
            "            targetZ,",
            "            lerpFactor",
            "        );",
            "    }",
            "    ",
            "    /**",
            "     * Apply deep perspective effect",
            "     */",
            "    applyDepthPerspective() {",
            "        if (!this.mesh) return;",
            "        ",
            "        const obj = this.object;",
            "        const yPos = obj.getY ? obj.getY() : 0;",
            "        const zPos = obj.getZ ? obj.getZ() : 0;",
            "        ",
            "        // Calculate scale factor based on depth (perspective)",
            "        const perspectiveFactor = 1 - (zPos * 0.0001); // Reduce size of distant objects",
            "        const scaleFactor = Math.max(0.5, Math.min(1.5, perspectiveFactor));",
            "        ",
            "        // Apply additional factor based on Y (apparent height)",
            "        const heightFactor = 1 + (yPos * 0.00005);",
            "        ",
            "        // Update scale while maintaining original proportions",
            "        const frame = this.object.getAnimator().getCurrentFrame();",
            "        if (frame) {",
            "            const image = frame.texture.map.image;",
            "            const width = image.width;",
            "            const height = image.height;",
            "            ",
            "            this.mesh.scale.set(",
            "                width * scaleFactor * heightFactor,",
            "                height * scaleFactor * heightFactor,",
            "                1",
            "            );",
            "        }",
            "    }",
            "    ",
            "    updateFrame() {",
            "        const frame = this.object.getAnimator().getCurrentFrame();",
            "        if (!frame) {",
            "            return;",
            "        }",
            "        const material = frame.texture;",
            "        ",
            "        // Update basic settings",
            "        material.alphaTest = 0.5;",
            "        material.depthWrite = true;",
            "        material.depthTest = true;",
            "        material.transparent = true;",
            "        material.side = THREE.DoubleSide;",
            "        material.shadowSide = THREE.FrontSide;",
            "        material.toneMapped = true;",
            "        material.fog = true;",
            "        material.premultipliedAlpha = true;",
            "        material.depthFunc = THREE.LessEqualDepth;",
            "        material.polygonOffset = true;",
            "        material.polygonOffsetFactor = -1;",
            "        material.polygonOffsetUnits = -1;",
            "        ",
            "        // Professional visual effects",
            "        if (material.emissive) {",
            "            material.emissive = new THREE.Color(0x111111);",
            "            material.emissiveIntensity = 0.2;",
            "        }",
            "        ",
            "        material.needsUpdate = true;",
            "        ",
            "        const image = material.map.image;",
            "        const width = image.width;",
            "        const height = image.height;",
            "        const origin = frame.origin;",
            "        this.mesh.position.set(-origin.x + width / 2, -origin.y + height / 2, 0);",
            "        this.mesh.scale.set(width, height, 1);",
            "        const center = frame.center;",
            "        this.object.setRotationCenter(center.x - origin.x, center.y - origin.y);",
            "        this.mesh.material = material;",
            "        ",
            "        // Apply automatic improvements",
            "        this.updateRenderOrder();",
            "        this.applyAutoRotation();",
            "        this.applyDepthPerspective();",
            "        ",
            "        const hitBoxes = this.object._untransformedHitBoxes;",
            "        if (frame.hasCustomCollisionMask) {",
            "            let i = 0;",
            "            for (let len = frame.customCollisionMask.length; i < len; ++i) {",
            "                const polygonData = frame.customCollisionMask[i];",
            "                if (i >= hitBoxes.length) {",
            "                    hitBoxes.push(new gdjs.Polygon());",
            "                }",
            "                let j = 0;",
            "                for (const len2 = polygonData.length; j < len2; ++j) {",
            "                    const pointData = polygonData[j];",
            "                    if (j >= hitBoxes[i].vertices.length) {",
            "                        hitBoxes[i].vertices.push([0, 0]);",
            "                    }",
            "                    hitBoxes[i].vertices[j][0] = pointData.x - origin.x;",
            "                    hitBoxes[i].vertices[j][1] = pointData.y - origin.y;",
            "                }",
            "                hitBoxes[i].vertices.length = j;",
            "            }",
            "            hitBoxes.length = i;",
            "        }",
            "        else if (hitBoxes.length === 0) {",
            "            const hitBox = new gdjs.Polygon();",
            "            hitBoxes.push(hitBox);",
            "            const vertices = hitBox.vertices;",
            "            vertices.push([-origin.x, -origin.y]);",
            "            vertices.push([-origin.x + width, -origin.y]);",
            "            vertices.push([-origin.x + width, -origin.y + height]);",
            "            vertices.push([-origin.x, -origin.y + height]);",
            "        }",
            "        const aabb = this.object._unrotatedAABB;",
            "        aabb.min[0] = -origin.x;",
            "        aabb.min[1] = -origin.y;",
            "        aabb.max[0] = -origin.x + width;",
            "        aabb.max[1] = -origin.y + height;",
            "        this.object._isUntransformedHitBoxesDirty = false;",
            "    }",
            "    ",
            "    /**",
            "     * Manually set depth offset",
            "     * @param {number} offset",
            "     */",
            "    setDepthOffset(offset) {",
            "        this.depthOffset = offset;",
            "        this.updateRenderOrder();",
            "    }",
            "    ",
            "    /**",
            "     * Enable/disable automatic rotation",
            "     * @param {boolean} enabled",
            "     */",
            "    setAutoRotation(enabled) {",
            "        this.autoRotate = enabled;",
            "    }",
            "    ",
            "    /**",
            "     * Set a specific angle on a specific axis",
            "     * @param {string} axis - 'x', 'y', or 'z'",
            "     * @param {number} angle - Angle in degrees",
            "     */",
            "    setRotationAngle(axis, angle) {",
            "        if (!this.mesh) return;",
            "        ",
            "        const radians = THREE.MathUtils.degToRad(angle);",
            "        switch(axis.toLowerCase()) {",
            "            case 'x':",
            "                this.mesh.rotation.x = radians;",
            "                break;",
            "            case 'y':",
            "                this.mesh.rotation.y = radians;",
            "                break;",
            "            case 'z':",
            "                this.mesh.rotation.z = radians;",
            "                break;",
            "        }",
            "    }",
            "}",
            "",
            "gdjs.__sprite3DExtension = {",
            "    Sprite3DRenderer",
            "};"
          ],
          "parameterObjects": "",
          "useStrict": true,
          "eventsSheetExpanded": true
        }
      ],
      "parameters": [],
      "objectGroups": []
    }
  ],
  "eventsBasedBehaviors": [],
  "eventsBasedObjects": [
    {
      "areaMaxX": 64,
      "areaMaxY": 64,
      "areaMaxZ": 64,
      "areaMinX": 0,
      "areaMinY": 0,
      "areaMinZ": 0,
      "defaultName": "",
      "description": "An animated sprite in 3D.",
      "fullName": "3D sprite",
      "is3D": true,
      "isAnimatable": true,
      "isUsingLegacyInstancesRenderer": true,
      "name": "Sprite3D",
      "objects": [],
      "objectsFolderStructure": {
        "folderName": "__ROOT"
      },
      "objectsGroups": [],
      "layers": [
        {
          "ambientLightColorB": 200,
          "ambientLightColorG": 200,
          "ambientLightColorR": 200,
          "camera2DPlaneMaxDrawingDistance": 5000,
          "camera3DFarPlaneDistance": 10000,
          "camera3DFieldOfView": 45,
          "camera3DNearPlaneDistance": 3,
          "cameraType": "",
          "followBaseLayerCamera": false,
          "isLightingLayer": false,
          "isLocked": false,
          "name": "",
          "renderingType": "",
          "visibility": true,
          "cameras": [
            {
              "defaultSize": true,
              "defaultViewport": true,
              "height": 0,
              "viewportBottom": 1,
              "viewportLeft": 0,
              "viewportRight": 1,
              "viewportTop": 0,
              "width": 0
            }
          ],
          "effects": []
        }
      ],
      "instances": [],
      "editionSettings": {},
      "eventsFunctions": [
        {
          "fullName": "",
          "functionType": "Action",
          "name": "onCreated",
          "sentence": "",
          "events": [
            {
              "type": "BuiltinCommonInstructions::Standard",
              "conditions": [],
              "actions": [
                {
                  "type": {
                    "value": "Sprite3D::DefineHelperClasses"
                  },
                  "parameters": [
                    "",
                    ""
                  ]
                }
              ]
            },
            {
              "type": "BuiltinCommonInstructions::JsCode",
              "inlineCode": [
                "/** @type {gdjs.CustomRuntimeObject} */\r",
                "const object = objects[0];\r",
                "\r",
                "object.__sprite3DExtension = {};\r",
                "object.__sprite3DExtension.sprite3DRenderer = new gdjs.__sprite3DExtension.Sprite3DRenderer(object)\r",
                ""
              ],
              "parameterObjects": "Object",
              "useStrict": true,
              "eventsSheetExpanded": true
            }
          ],
          "parameters": [
            {
              "description": "Object",
              "name": "Object",
              "supplementaryInformation": "Sprite3D::Sprite3D",
              "type": "object"
            }
          ],
          "objectGroups": []
        }
      ],
      "propertyDescriptors": []
    }
  ]
}