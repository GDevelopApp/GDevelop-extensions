{
  "author": "",
  "category": "",
  "extensionNamespace": "",
  "fullName": "With Three JS",
  "helpPath": "https://pandako.itch.io/with-threejs-extension-for-gdevelop",
  "iconUrl": "data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0iVVRGLTgiPz48IURPQ1RZUEUgc3ZnIFBVQkxJQyAiLS8vVzNDLy9EVEQgU1ZHIDEuMS8vRU4iICJodHRwOi8vd3d3LnczLm9yZy9HcmFwaGljcy9TVkcvMS4xL0RURC9zdmcxMS5kdGQiPjxzdmcgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIiB4bWxuczp4bGluaz0iaHR0cDovL3d3dy53My5vcmcvMTk5OS94bGluayIgdmVyc2lvbj0iMS4xIiBpZD0ibWRpLXJvdGF0ZS0zZCIgd2lkdGg9IjI0IiBoZWlnaHQ9IjI0IiB2aWV3Qm94PSIwIDAgMjQgMjQiPjxwYXRoIGQ9Ik03LjQ3LDIxLjVDNC4yLDE5Ljk0IDEuODYsMTYuNzYgMS41LDEzSDBDMC41LDE5LjE2IDUuNjYsMjQgMTEuOTUsMjRMMTIuNjEsMjMuOTdMOC44LDIwLjE2TDcuNDcsMjEuNU04LjM2LDE0Ljk2QzguMTcsMTQuOTYgOCwxNC45MyA3Ljg0LDE0Ljg4QzcuNjgsMTQuODIgNy41NSwxNC43NSA3LjQ0LDE0LjY0QzcuMzMsMTQuNTQgNy4yNCwxNC40MiA3LjE4LDE0LjI3QzcuMTIsMTQuMTMgNy4wOSwxMy45NyA3LjA5LDEzLjhINS43OUM1Ljc5LDE0LjE2IDUuODYsMTQuNSA2LDE0Ljc1QzYuMTQsMTUgNi4zMywxNS4yNSA2LjU2LDE1LjQ0QzYuOCwxNS42MiA3LjA3LDE1Ljc2IDcuMzgsMTUuODVDNy42OCwxNS45NSA4LDE2IDguMzQsMTZDOC43MSwxNiA5LjA2LDE1Ljk1IDkuMzcsMTUuODVDOS42OSwxNS43NSA5Ljk3LDE1LjYgMTAuMiwxNS40MUMxMC40MywxNS4yMiAxMC42MiwxNSAxMC43NSwxNC42OUMxMC44OCwxNC40IDEwLjk1LDE0LjA4IDEwLjk1LDEzLjcyQzEwLjk1LDEzLjUzIDEwLjkzLDEzLjM0IDEwLjg4LDEzLjE2QzEwLjgzLDEzIDEwLjc2LDEyLjgxIDEwLjY1LDEyLjY1QzEwLjU1LDEyLjUgMTAuNDEsMTIuMzUgMTAuMjUsMTIuMjJDMTAuMDgsMTIuMDkgOS44OCwxMiA5LjY0LDExLjkxQzkuODQsMTEuODIgMTAsMTEuNzEgMTAuMTYsMTEuNThDMTAuMzEsMTEuNDUgMTAuNDMsMTEuMzEgMTAuNTMsMTEuMTZDMTAuNjMsMTEgMTAuNywxMC44NiAxMC43NSwxMC43QzEwLjgsMTAuNTQgMTAuODIsMTAuMzggMTAuODIsMTAuMjJDMTAuODIsOS44NiAxMC43Niw5LjU0IDEwLjY0LDkuMjZDMTAuNSw5IDEwLjM1LDguNzUgMTAuMTMsOC41N0M5LjkzLDguMzggOS42Niw4LjI0IDkuMzYsOC4xNEM5LjA1LDguMDUgOC43MSw4IDguMzQsOEM4LDggNy42NSw4LjA1IDcuMzQsOC4xNkM3LjA0LDguMjcgNi43Nyw4LjQyIDYuNTUsOC42MUM2LjM0LDguOCA2LjE3LDkgNi4wNCw5LjI4QzUuOTIsOS41NCA1Ljg2LDkuODIgNS44NiwxMC4xM0g3LjE2QzcuMTYsOS45NiA3LjE5LDkuODEgNy4yNSw5LjY4QzcuMzEsOS41NSA3LjM5LDkuNDMgNy41LDkuMzRDNy42MSw5LjI1IDcuNzMsOS4xNyA3Ljg4LDkuMTJDOC4wMyw5LjA3IDguMTgsOS4wNCA4LjM2LDkuMDRDOC43Niw5LjA0IDkuMDYsOS4xNCA5LjI1LDkuMzVDOS40NCw5LjU1IDkuNTQsOS44NCA5LjU0LDEwLjIxQzkuNTQsMTAuMzkgOS41LDEwLjU1IDkuNDYsMTAuN0M5LjQxLDEwLjg1IDkuMzIsMTAuOTcgOS4yMSwxMS4wN0M5LjEsMTEuMTcgOC45NiwxMS4yNSA4LjgsMTEuMzFDOC42NCwxMS4zNyA4LjQ0LDExLjQgOC4yMiwxMS40SDcuNDVWMTIuNDNIOC4yMkM4LjQ0LDEyLjQzIDguNjQsMTIuNDUgOC44MiwxMi41QzksMTIuNTUgOS4xNSwxMi42MyA5LjI3LDEyLjczQzkuMzksMTIuODQgOS41LDEyLjk3IDkuNTYsMTMuMTNDOS42MywxMy4yOSA5LjY2LDEzLjUgOS42NiwxMy43QzkuNjYsMTQuMTEgOS41NCwxNC40MiA5LjMxLDE0LjYzQzkuMDgsMTQuODYgOC43NiwxNC45NiA4LjM2LDE0Ljk2TTE2LjkxLDkuMDRDMTYuNTksOC43MSAxNi4yMSw4LjQ1IDE1Ljc3LDguMjdDMTUuMzQsOC4wOSAxNC44NSw4IDE0LjMxLDhIMTEuOTVWMTZIMTQuMjVDMTQuOCwxNiAxNS4zMSwxNS45MSAxNS43NiwxNS43M0MxNi4yMSwxNS41NSAxNi42LDE1LjMgMTYuOTIsMTQuOTdDMTcuMjQsMTQuNjQgMTcuNSwxNC4yNCAxNy42NiwxMy43OEMxNy44MywxMy4zMSAxNy45MiwxMi43OSAxNy45MiwxMi4yMVYxMS44MUMxNy45MiwxMS4yMyAxNy44MywxMC43MSAxNy42NiwxMC4yNEMxNy41LDkuNzcgMTcuMjMsOS4zNyAxNi45MSw5LjA0TTE2LjUsMTIuMkMxNi41LDEyLjYyIDE2LjQ3LDEzIDE2LjM4LDEzLjMzQzE2LjI4LDEzLjY2IDE2LjE0LDEzLjk1IDE1Ljk1LDE0LjE4QzE1Ljc2LDE0LjQxIDE1LjUsMTQuNTkgMTUuMjQsMTQuNzFDMTQuOTUsMTQuODMgMTQuNjIsMTQuODkgMTQuMjUsMTQuODlIMTMuMzRWOS4xMkgxNC4zMUMxNS4wMyw5LjEyIDE1LjU4LDkuMzUgMTUuOTUsOS44MUMxNi4zMywxMC4yNyAxNi41LDEwLjkzIDE2LjUsMTEuOE0xMS45NSwwTDExLjI5LDAuMDNMMTUuMSwzLjg0TDE2LjQzLDIuNUMxOS43LDQuMDYgMjIuMDQsNy4yMyAyMi4zOSwxMUgyMy44OUMyMy4zOSw0Ljg0IDE4LjI0LDAgMTEuOTUsMFoiIC8+PC9zdmc+",
  "name": "WithThreeJS",
  "previewIconUrl": "https://resources.gdevelop-app.com/assets/Icons/rotate-3d.svg",
  "shortDescription": "Create a simple 3D scene.",
  "version": "2.1.1",
  "description": [
    "Extension for GDevelop to create simple 3D scenes.  ",
    "This extension is intended for easy and simple 3D rendering. It does not currently aim for realistic 3D rendering.  ",
    "",
    "## 📖 How to use  ",
    "Check out this page.  ",
    "[WithThreeJs Extension for GDevelop](https://pandako.itch.io/with-threejs-extension-for-gdevelop)  ",
    "",
    "## ⚠️ Notes on updating from version 1.x.x to version 2.0.0  ",
    "The \"Create 3D Scene\", \"Load 3D Texture\", \"Play 3D Sound\" and \"Create 3D Light\" actions have been updated in version 2.0.0.  ",
    "The previous actions with the same names still work but are deprecated. (Look for the ⚠️ icon in the event.) Please use the new actions with the same names.  ",
    "",
    "## 🍩 Donation  ",
    "Currently, I'm doing development in between jobs, but if many people support me, I will be able to devote more time to the development.  ",
    "If you enjoy this extension, please consider [downloading the Example project file](https://pandako.itch.io/with-threejs-extension-for-gdevelop) to maintain this extension. (The Example project file will surely help you.😉)  ",
    "",
    "## Three.js  ",
    "Copyright 2010-2022 Three.js Authors  ",
    "https://github.com/mrdoob/three.js/blob/dev/LICENSE"
  ],
  "tags": [
    "3D"
  ],
  "authorIds": [
    "Zu55H5hcb9YmZTltIVOTAFDJQyB2"
  ],
  "dependencies": [],
  "globalVariables": [],
  "sceneVariables": [],
  "eventsFunctions": [
    {
      "fullName": "",
      "functionType": "Action",
      "name": "onFirstSceneLoaded",
      "sentence": "",
      "events": [
        {
          "type": "BuiltinCommonInstructions::Comment",
          "color": {
            "b": 109,
            "g": 230,
            "r": 255,
            "textB": 0,
            "textG": 0,
            "textR": 0
          },
          "comment": "Three.js"
        },
        {
          "type": "BuiltinCommonInstructions::Comment",
          "color": {
            "b": 109,
            "g": 230,
            "r": 255,
            "textB": 0,
            "textG": 0,
            "textR": 0
          },
          "comment": "WithThreeJS"
        },
        {
          "type": "BuiltinCommonInstructions::JsCode",
          "inlineCode": [
            "gdjs.__WithThreeJS = new Map();\r",
            "gdjs.__WithThreeJS.set(\"NoTHREE\", typeof THREE != \"object\");\r",
            "gdjs.__WithThreeJS.set(\"BuiltIn3D\", (runtimeScene.getRenderer()._threeRenderer ? true : false));\r",
            "if (gdjs.__WithThreeJS.get(\"NoTHREE\")) {\r",
            "  return;\r",
            "}\r",
            "//\r",
            "THREE.Cache.enabled = true;// ローダーのためにキャッシュの有効化\r",
            "//\r",
            "gdjs.__WithThreeJS.set(\"SceneIsReady\", false);\r",
            "gdjs.__WithThreeJS.set(\"Blend2Dto3D\", [THREE.NormalBlending, THREE.AdditiveBlending, THREE.MultiplyBlending, THREE.NormalBlending, THREE.SubtractiveBlending]);// PixiJSのSUBTRACTは28\r",
            "if (THREE.REVISION == \"152\") {\r",
            "  gdjs.__WithThreeJS.set(\"LightIntensityScale\", 1);\r",
            "  gdjs.__WithThreeJS.set(\"LightIntensityCandela\", 1);\r",
            "} else {\r",
            "  // >= \"160\"\r",
            "  gdjs.__WithThreeJS.set(\"LightIntensityScale\", Math.PI);\r",
            "  gdjs.__WithThreeJS.set(\"LightIntensityCandela\", 10000);//適当\r",
            "}\r",
            "gdjs.__WithThreeJS.set(\"ShadowMapSizeStringToValue\", {\"128px\": 128, \"256px\": 256, \"512px\": 512, \"1024px\": 1024, \"2048px\": 2048});\r",
            "gdjs.__WithThreeJS.set(\"ObjectList\", new Map());\r",
            "//\r",
            "gdjs.__WithThreeJS.set(\"SearchObject\", function(Id) {\r",
            "  let Obj = gdjs.__WithThreeJS.get(\"ObjectList\").get(Id);\r",
            "  if (!Obj) {\r",
            "    Obj = gdjs.__WithThreeJS.get(\"Scene\").getObjectByName(Id);\r",
            "    if (Obj) {\r",
            "      gdjs.__WithThreeJS.get(\"ObjectList\").set(Id, Obj);\r",
            "    }\r",
            "  }\r",
            "  return Obj;\r",
            "});\r",
            "//\r",
            "gdjs.__WithThreeJS.set(\"GetResourceFileName\", function(ResourceName, Kind) {\r",
            "  for (const V of gdjs.projectData.resources.resources) {\r",
            "    if (V.name === ResourceName && V.kind === Kind) {\r",
            "      return V.file;\r",
            "    }\r",
            "  }\r",
            "});\r",
            "//\r",
            "gdjs.__WithThreeJS.set(\"SetAllTextures\", function(Obj, Textures) {\r",
            "  const TxNum = Textures.length;\r",
            "  Obj.traverse((Child) => {\r",
            "    if (Child.material) {\r",
            "      if (Array.isArray(Child.material)) {\r",
            "        for (let i = 0; i < Child.material.length; i++) {\r",
            "          if (i < TxNum && (Child.material[i].map !== undefined)) {\r",
            "            Child.material[i].map = Textures[i];\r",
            "          }\r",
            "        }\r",
            "      } else {\r",
            "        if (Child.material.map !== undefined) {\r",
            "          Child.material.map = Textures[0];\r",
            "        }\r",
            "      }\r",
            "    }\r",
            "  });\r",
            "});\r",
            "//\r",
            "gdjs.__WithThreeJS.set(\"GetModelInfo\", function(Obj, T, Lv) {\r",
            "  const Indent = \" \".repeat(Lv * 2);\r",
            "  T += Indent + \"---\\n\";\r",
            "  T += Indent + \"Name: \" + Obj.name + \"\\n\";\r",
            "  T += Indent + \"Type: \" + Obj.type + \"\\n\";\r",
            "  for (let i = 0; i < Obj.animations.length; i++) {\r",
            "    T += Indent + \"Animation \" + i + \": \" + Obj.animations[i].name + \"\\n\";\r",
            "  }\r",
            "  if (Obj.material) {\r",
            "    if (Array.isArray(Obj.material)) {\r",
            "      for (let i = 0; i < Obj.material.length; i++) {\r",
            "        T += Indent + \"Material \" + (i + 1) + \": \" + Obj.material[i].name + \"\\n\";\r",
            "      }\r",
            "    } else {\r",
            "      T += Indent + \"Material 1: \" + Obj.material.name + \"\\n\";\r",
            "    }\r",
            "  }\r",
            "  //\r",
            "  for (let i = 0; i < Obj.children.length; i++) {\r",
            "    T = gdjs.__WithThreeJS.get(\"GetModelInfo\")(Obj.children[i], T, Lv + 1);\r",
            "  }\r",
            "  return T;\r",
            "});\r",
            "//\r",
            "// マテリアルのリストアップ\r",
            "gdjs.__WithThreeJS.set(\"GetAllMaterials\", function(Obj, Mats) {\r",
            "  Obj.traverse((Child) => {\r",
            "    if (Child.material) {\r",
            "      if (Array.isArray(Child.material)) {\r",
            "        for (let i = 0; i < Child.material.length; i++) {\r",
            "          if (!Mats.has(Child.material[i].uuid)) {\r",
            "            Mats.set(Child.material[i].uuid, Child.material[i]);\r",
            "          }\r",
            "        }\r",
            "      } else {\r",
            "        if (!Mats.has(Child.material.uuid)) {\r",
            "          Mats.set(Child.material.uuid, Child.material);\r",
            "        }\r",
            "      }\r",
            "    }\r",
            "  });\r",
            "});\r",
            "// マテリアルリストによる差し替え\r",
            "gdjs.__WithThreeJS.set(\"ReplaceMaterial\", function(Obj, Mats) {\r",
            "  Obj.traverse((Child) => {\r",
            "    if (Child.material) {\r",
            "      if (Array.isArray(Child.material)) {\r",
            "        for (let i = 0; i < Child.material.length; i++) {\r",
            "          if (Mats.has(Child.material[i].uuid)) {\r",
            "            Child.material[i] = Mats.get(Child.material[i].uuid);\r",
            "          }\r",
            "        }\r",
            "      } else {\r",
            "        if (Mats.has(Child.material.uuid)) {\r",
            "          Child.material = Mats.get(Child.material.uuid);\r",
            "        }\r",
            "      }\r",
            "    }\r",
            "  });\r",
            "});\r",
            "//\r",
            "gdjs.__WithThreeJS.set(\"GetAllObjectsName\", function(Obj, T, Lv) {\r",
            "  const Indent = \" \".repeat(Lv * 2);\r",
            "  T += Indent + \"ID: \" + Obj.name + \"\\n\";\r",
            "  //\r",
            "  for (let i = 0; i < Obj.children.length; i++) {\r",
            "    T = gdjs.__WithThreeJS.get(\"GetAllObjectsName\")(Obj.children[i], T, Lv + 1);\r",
            "  }\r",
            "  return T;\r",
            "});\r",
            "//\r",
            "gdjs.__WithThreeJS.set(\"GetSingleRadian3\", function(Obj) {\r",
            "  /*\r",
            "  3D Camera Angle でのみ使用\r",
            "  XYZそれぞれ独立して求めているので、組み合わせて使用することはできない。\r",
            "  例えば海老反り視点はこれで求めたXYZを組み合わせても再現できない。\r",
            "  */\r",
            "  const HalfPi = Math.PI / 2;/* Pi / 2 = 90度 */\r",
            "  // X\r",
            "  // オブジェクトの視点方向ベクトルと上方向ベクトルを作成\r",
            "  const DirObj = new THREE.Vector3(0, 0, -1);\r",
            "  DirObj.applyQuaternion(Obj.quaternion);\r",
            "  const UpObj = new THREE.Vector3(0, 1, 0);\r",
            "  UpObj.applyQuaternion(Obj.quaternion);\r",
            "  // 頭を上に向けて視点方向ベクトルを向いている比較用のM4を作成\r",
            "  const M4 = new THREE.Matrix4();\r",
            "  M4.lookAt(new THREE.Vector3(), DirObj, new THREE.Vector3(0, 1, 0));\r",
            "  // M4からQuaを作成し、さらに比較用の上方向ベクトルを作成\r",
            "  const Qua = new THREE.Quaternion();\r",
            "  Qua.setFromRotationMatrix(M4);\r",
            "  const Up = new THREE.Vector3(0, 1, 0);\r",
            "  Up.applyQuaternion(Qua);\r",
            "  // 方向ベクトルを平面に投影したベクトルを作成\r",
            "  const DirObjY0 = DirObj.clone();\r",
            "  DirObjY0.y = 0;// DirObjY0.projectOnPlane(new THREE.Vector3(0, 1, 0));// y=0のほうが単純\r",
            "  DirObjY0.normalize();\r",
            "  // Xラジアン\r",
            "  let RadX = DirObjY0.angleTo(DirObj);\r",
            "  // 海老反り視点の場合（上方向と比較用上方向の差で90度オーバーしているかを判定）\r",
            "  const UpToUp = UpObj.angleTo(Up);\r",
            "  if (UpToUp >= HalfPi) {\r",
            "    RadX = (HalfPi - RadX) + HalfPi;\r",
            "  }\r",
            "  // +-方向判定\r",
            "  if (DirObj.y < 0) {\r",
            "    RadX *= -1;\r",
            "  }\r",
            "  //\r",
            "  // Y\r",
            "  let RadY = new THREE.Vector3(0, 0, -1).angleTo(DirObjY0);\r",
            "  if (DirObj.x > 0) {\r",
            "    RadY *= -1;\r",
            "  }\r",
            "  //\r",
            "  // Z\r",
            "  let RadZ = UpToUp;\r",
            "  // 外積と視点の角度差で+-を判断\r",
            "  const Cross = new THREE.Vector3();\r",
            "  Cross.crossVectors(UpObj, Up);\r",
            "  if (Cross.angleTo(DirObj) >= HalfPi) {\r",
            "    RadZ *= -1;\r",
            "  }\r",
            "  //\r",
            "  return new THREE.Vector3(RadX, RadY, RadZ);\r",
            "});\r",
            "//\r",
            "gdjs.__WithThreeJS.set(\"SetBoundingBoxCollisionResult\", function(Obj1, Obj2) {\r",
            "  if (!gdjs.__WithThreeJS.has(\"BoundingBoxCollisionResult\")) {\r",
            "      gdjs.__WithThreeJS.set(\"BoundingBoxCollisionResult\", {});\r",
            "  }\r",
            "  const BoundingBoxCollisionResult = gdjs.__WithThreeJS.get(\"BoundingBoxCollisionResult\");\r",
            "  BoundingBoxCollisionResult.Hit = false;\r",
            "  BoundingBoxCollisionResult.CenterX = 0;\r",
            "  BoundingBoxCollisionResult.CenterY = 0;\r",
            "  BoundingBoxCollisionResult.CenterZ = 0;\r",
            "  BoundingBoxCollisionResult.SizeX = 0;\r",
            "  BoundingBoxCollisionResult.SizeY = 0;\r",
            "  BoundingBoxCollisionResult.SizeZ = 0;\r",
            "  BoundingBoxCollisionResult.MoveX = 0;\r",
            "  BoundingBoxCollisionResult.MoveY = 0;\r",
            "  BoundingBoxCollisionResult.MoveZ = 0;\r",
            "  //\r",
            "  // geometryを持たない場合を回避。なぜかSpriteにはgeometryがある\r",
            "  const Geo1 = Obj1.geometry;\r",
            "  const Geo2 = Obj2.geometry;\r",
            "  if (!Geo1 || !Geo2) {\r",
            "      console.warn(\"Geometry not found: \" + Obj1.name + \" or \" + Obj2.name);\r",
            "      return BoundingBoxCollisionResult;\r",
            "  }\r",
            "  //\r",
            "  const Box1 = new THREE.Box3();\r",
            "  const Box2 = new THREE.Box3();\r",
            "  // Box1.setFromObject(Obj1, false);\r",
            "  // Box2.setFromObject(Obj2, false);\r",
            "  Obj1.updateMatrixWorld(true);//必要\r",
            "  Obj2.updateMatrixWorld(true);//必要\r",
            "  Box1.copy(Geo1.boundingBox).applyMatrix4(Obj1.matrixWorld);\r",
            "  Box2.copy(Geo2.boundingBox).applyMatrix4(Obj2.matrixWorld);\r",
            "  //\r",
            "  const HitBox = Box1.clone();\r",
            "  HitBox.intersect(Box2);\r",
            "  if (HitBox.isEmpty()) {\r",
            "      return BoundingBoxCollisionResult;\r",
            "  }\r",
            "  //\r",
            "  const Box1Center = new THREE.Vector3();\r",
            "  const Box2Center = new THREE.Vector3();\r",
            "  const HitCenter = new THREE.Vector3();\r",
            "  const HitSize = new THREE.Vector3();\r",
            "  Box1.getCenter(Box1Center);\r",
            "  Box2.getCenter(Box2Center);\r",
            "  HitBox.getCenter(HitCenter);\r",
            "  HitBox.getSize(HitSize);\r",
            "  //\r",
            "  let MoveValue = {x:0, y:0, z:0};\r",
            "  if (HitSize.x <= HitSize.y && HitSize.x <= HitSize.z) {\r",
            "      if (Box1Center.x > Box2Center.x) {\r",
            "          MoveValue.x = HitSize.x;\r",
            "      } else {\r",
            "          MoveValue.x = HitSize.x * -1;\r",
            "      }\r",
            "  } else if (HitSize.y <= HitSize.x && HitSize.y <= HitSize.z) {\r",
            "      if (Box1Center.y > Box2Center.y) {\r",
            "          MoveValue.y = HitSize.y;\r",
            "      } else {\r",
            "          MoveValue.y = HitSize.y * -1;\r",
            "      }\r",
            "  } else if (HitSize.z <= HitSize.x && HitSize.z <= HitSize.y) {\r",
            "      if (Box1Center.z > Box2Center.z) {\r",
            "          MoveValue.z = HitSize.z;\r",
            "      } else {\r",
            "          MoveValue.z = HitSize.z * -1;\r",
            "      }\r",
            "  }\r",
            "  //\r",
            "  BoundingBoxCollisionResult.Hit = true;\r",
            "  BoundingBoxCollisionResult.CenterX = HitCenter.x;\r",
            "  BoundingBoxCollisionResult.CenterY = HitCenter.y;\r",
            "  BoundingBoxCollisionResult.CenterZ = HitCenter.z;\r",
            "  BoundingBoxCollisionResult.SizeX = HitSize.x;\r",
            "  BoundingBoxCollisionResult.SizeY = HitSize.y;\r",
            "  BoundingBoxCollisionResult.SizeZ = HitSize.z;\r",
            "  BoundingBoxCollisionResult.MoveX = MoveValue.x;\r",
            "  BoundingBoxCollisionResult.MoveY = MoveValue.y;\r",
            "  BoundingBoxCollisionResult.MoveZ = MoveValue.z;\r",
            "  return BoundingBoxCollisionResult;\r",
            "});\r",
            "//\r",
            "gdjs.__WithThreeJS.set(\"GetCamera\", function(Id) {\r",
            "  const AllCams = gdjs.__WithThreeJS.get(\"AllCams\");\r",
            "  return AllCams.get(\"Camera\" + gdjs.evtTools.common.clamp(Id, 1, 4));\r",
            "});\r",
            "//\r",
            "gdjs.__WithThreeJS.set(\"DisposeChildren\", function(Obj) {\r",
            "  // テクスチャは共有している場合があるので対象外\r",
            "  Obj.traverse((Child) => {\r",
            "      // Material\r",
            "      if (Child.material) {\r",
            "          if (Array.isArray(Child.material)) {\r",
            "              for (let i = Child.material.length - 1; i >= 0; i--){\r",
            "                  Child.material[i].dispose();\r",
            "              }\r",
            "          } else {\r",
            "              Child.material.dispose();\r",
            "          }\r",
            "      }\r",
            "      // Light\r",
            "      if (Child.isLight) {\r",
            "          if (Child.castShadow) {\r",
            "              Child.shadow.dispose();\r",
            "          }\r",
            "          Child.dispose();\r",
            "      }\r",
            "      // ObjectList\r",
            "      gdjs.__WithThreeJS.get(\"ObjectList\").delete(Child.name);\r",
            "  });\r",
            "});\r",
            "\r",
            ""
          ],
          "parameterObjects": "",
          "useStrict": true,
          "eventsSheetExpanded": true
        },
        {
          "type": "BuiltinCommonInstructions::Comment",
          "color": {
            "b": 109,
            "g": 230,
            "r": 255,
            "textB": 0,
            "textG": 0,
            "textR": 0
          },
          "comment": "OBJLoader (Custom)"
        },
        {
          "type": "BuiltinCommonInstructions::JsCode",
          "inlineCode": [
            "// Custom",
            "if (gdjs.__WithThreeJS.get(\"NoTHREE\")) {",
            "  return;",
            "}",
            "//",
            "( function () {",
            "",
            "\tconst _object_pattern = /^[og]\\s*(.+)?/; // mtllib file_reference",
            "",
            "\tconst _material_library_pattern = /^mtllib /; // usemtl material_name",
            "",
            "\tconst _material_use_pattern = /^usemtl /; // usemap map_name",
            "",
            "\tconst _map_use_pattern = /^usemap /;",
            "\tconst _face_vertex_data_separator_pattern = /\\s+/;",
            "",
            "\tconst _vA = new THREE.Vector3();",
            "",
            "\tconst _vB = new THREE.Vector3();",
            "",
            "\tconst _vC = new THREE.Vector3();",
            "",
            "\tconst _ab = new THREE.Vector3();",
            "",
            "\tconst _cb = new THREE.Vector3();",
            "",
            "\tconst _color = new THREE.Color();",
            "",
            "\tfunction ParserState() {",
            "",
            "\t\tconst state = {",
            "\t\t\tobjects: [],",
            "\t\t\tobject: {},",
            "\t\t\tvertices: [],",
            "\t\t\tnormals: [],",
            "\t\t\tcolors: [],",
            "\t\t\tuvs: [],",
            "\t\t\tmaterials: {},",
            "\t\t\tmaterialLibraries: [],",
            "\t\t\tstartObject: function ( name, fromDeclaration ) {",
            "",
            "\t\t\t\t// If the current object (initial from reset) is not from a g/o declaration in the parsed",
            "\t\t\t\t// file. We need to use it for the first parsed g/o to keep things in sync.",
            "\t\t\t\tif ( this.object && this.object.fromDeclaration === false ) {",
            "",
            "\t\t\t\t\tthis.object.name = name;",
            "\t\t\t\t\tthis.object.fromDeclaration = fromDeclaration !== false;",
            "\t\t\t\t\treturn;",
            "",
            "\t\t\t\t}",
            "",
            "\t\t\t\tconst previousMaterial = this.object && typeof this.object.currentMaterial === 'function' ? this.object.currentMaterial() : undefined;",
            "",
            "\t\t\t\tif ( this.object && typeof this.object._finalize === 'function' ) {",
            "",
            "\t\t\t\t\tthis.object._finalize( true );",
            "",
            "\t\t\t\t}",
            "",
            "\t\t\t\tthis.object = {",
            "\t\t\t\t\tname: name || '',",
            "\t\t\t\t\tfromDeclaration: fromDeclaration !== false,",
            "\t\t\t\t\tgeometry: {",
            "\t\t\t\t\t\tvertices: [],",
            "\t\t\t\t\t\tnormals: [],",
            "\t\t\t\t\t\tcolors: [],",
            "\t\t\t\t\t\tuvs: [],",
            "\t\t\t\t\t\thasUVIndices: false",
            "\t\t\t\t\t},",
            "\t\t\t\t\tmaterials: [],",
            "\t\t\t\t\tsmooth: true,",
            "\t\t\t\t\tstartMaterial: function ( name, libraries ) {",
            "",
            "\t\t\t\t\t\tconst previous = this._finalize( false ); // New usemtl declaration overwrites an inherited material, except if faces were declared",
            "\t\t\t\t\t\t// after the material, then it must be preserved for proper MultiMaterial continuation.",
            "",
            "",
            "\t\t\t\t\t\tif ( previous && ( previous.inherited || previous.groupCount <= 0 ) ) {",
            "",
            "\t\t\t\t\t\t\tthis.materials.splice( previous.index, 1 );",
            "",
            "\t\t\t\t\t\t}",
            "",
            "\t\t\t\t\t\tconst material = {",
            "\t\t\t\t\t\t\tindex: this.materials.length,",
            "\t\t\t\t\t\t\tname: name || '',",
            "\t\t\t\t\t\t\tmtllib: Array.isArray( libraries ) && libraries.length > 0 ? libraries[ libraries.length - 1 ] : '',",
            "\t\t\t\t\t\t\tsmooth: previous !== undefined ? previous.smooth : this.smooth,",
            "\t\t\t\t\t\t\tgroupStart: previous !== undefined ? previous.groupEnd : 0,",
            "\t\t\t\t\t\t\tgroupEnd: - 1,",
            "\t\t\t\t\t\t\tgroupCount: - 1,",
            "\t\t\t\t\t\t\tinherited: false,",
            "\t\t\t\t\t\t\tclone: function ( index ) {",
            "",
            "\t\t\t\t\t\t\t\tconst cloned = {",
            "\t\t\t\t\t\t\t\t\tindex: typeof index === 'number' ? index : this.index,",
            "\t\t\t\t\t\t\t\t\tname: this.name,",
            "\t\t\t\t\t\t\t\t\tmtllib: this.mtllib,",
            "\t\t\t\t\t\t\t\t\tsmooth: this.smooth,",
            "\t\t\t\t\t\t\t\t\tgroupStart: 0,",
            "\t\t\t\t\t\t\t\t\tgroupEnd: - 1,",
            "\t\t\t\t\t\t\t\t\tgroupCount: - 1,",
            "\t\t\t\t\t\t\t\t\tinherited: false",
            "\t\t\t\t\t\t\t\t};",
            "\t\t\t\t\t\t\t\tcloned.clone = this.clone.bind( cloned );",
            "\t\t\t\t\t\t\t\treturn cloned;",
            "",
            "\t\t\t\t\t\t\t}",
            "\t\t\t\t\t\t};",
            "\t\t\t\t\t\tthis.materials.push( material );",
            "\t\t\t\t\t\treturn material;",
            "",
            "\t\t\t\t\t},",
            "\t\t\t\t\tcurrentMaterial: function () {",
            "",
            "\t\t\t\t\t\tif ( this.materials.length > 0 ) {",
            "",
            "\t\t\t\t\t\t\treturn this.materials[ this.materials.length - 1 ];",
            "",
            "\t\t\t\t\t\t}",
            "",
            "\t\t\t\t\t\treturn undefined;",
            "",
            "\t\t\t\t\t},",
            "\t\t\t\t\t_finalize: function ( end ) {",
            "",
            "\t\t\t\t\t\tconst lastMultiMaterial = this.currentMaterial();",
            "",
            "\t\t\t\t\t\tif ( lastMultiMaterial && lastMultiMaterial.groupEnd === - 1 ) {",
            "",
            "\t\t\t\t\t\t\tlastMultiMaterial.groupEnd = this.geometry.vertices.length / 3;",
            "\t\t\t\t\t\t\tlastMultiMaterial.groupCount = lastMultiMaterial.groupEnd - lastMultiMaterial.groupStart;",
            "\t\t\t\t\t\t\tlastMultiMaterial.inherited = false;",
            "",
            "\t\t\t\t\t\t} // Ignore objects tail materials if no face declarations followed them before a new o/g started.",
            "",
            "",
            "\t\t\t\t\t\tif ( end && this.materials.length > 1 ) {",
            "",
            "\t\t\t\t\t\t\tfor ( let mi = this.materials.length - 1; mi >= 0; mi -- ) {",
            "",
            "\t\t\t\t\t\t\t\tif ( this.materials[ mi ].groupCount <= 0 ) {",
            "",
            "\t\t\t\t\t\t\t\t\tthis.materials.splice( mi, 1 );",
            "",
            "\t\t\t\t\t\t\t\t}",
            "",
            "\t\t\t\t\t\t\t}",
            "",
            "\t\t\t\t\t\t} // Guarantee at least one empty material, this makes the creation later more straight forward.",
            "",
            "",
            "\t\t\t\t\t\tif ( end && this.materials.length === 0 ) {",
            "",
            "\t\t\t\t\t\t\tthis.materials.push( {",
            "\t\t\t\t\t\t\t\tname: '',",
            "\t\t\t\t\t\t\t\tsmooth: this.smooth",
            "\t\t\t\t\t\t\t} );",
            "",
            "\t\t\t\t\t\t}",
            "",
            "\t\t\t\t\t\treturn lastMultiMaterial;",
            "",
            "\t\t\t\t\t}",
            "\t\t\t\t}; // Inherit previous objects material.",
            "\t\t\t\t// Spec tells us that a declared material must be set to all objects until a new material is declared.",
            "\t\t\t\t// If a usemtl declaration is encountered while this new object is being parsed, it will",
            "\t\t\t\t// overwrite the inherited material. Exception being that there was already face declarations",
            "\t\t\t\t// to the inherited material, then it will be preserved for proper MultiMaterial continuation.",
            "",
            "\t\t\t\tif ( previousMaterial && previousMaterial.name && typeof previousMaterial.clone === 'function' ) {",
            "",
            "\t\t\t\t\tconst declared = previousMaterial.clone( 0 );",
            "\t\t\t\t\tdeclared.inherited = true;",
            "\t\t\t\t\tthis.object.materials.push( declared );",
            "",
            "\t\t\t\t}",
            "",
            "\t\t\t\tthis.objects.push( this.object );",
            "",
            "\t\t\t},",
            "\t\t\tfinalize: function () {",
            "",
            "\t\t\t\tif ( this.object && typeof this.object._finalize === 'function' ) {",
            "",
            "\t\t\t\t\tthis.object._finalize( true );",
            "",
            "\t\t\t\t}",
            "",
            "\t\t\t},",
            "\t\t\tparseVertexIndex: function ( value, len ) {",
            "",
            "\t\t\t\tconst index = parseInt( value, 10 );",
            "\t\t\t\treturn ( index >= 0 ? index - 1 : index + len / 3 ) * 3;",
            "",
            "\t\t\t},",
            "\t\t\tparseNormalIndex: function ( value, len ) {",
            "",
            "\t\t\t\tconst index = parseInt( value, 10 );",
            "\t\t\t\treturn ( index >= 0 ? index - 1 : index + len / 3 ) * 3;",
            "",
            "\t\t\t},",
            "\t\t\tparseUVIndex: function ( value, len ) {",
            "",
            "\t\t\t\tconst index = parseInt( value, 10 );",
            "\t\t\t\treturn ( index >= 0 ? index - 1 : index + len / 2 ) * 2;",
            "",
            "\t\t\t},",
            "\t\t\taddVertex: function ( a, b, c ) {",
            "",
            "\t\t\t\tconst src = this.vertices;",
            "\t\t\t\tconst dst = this.object.geometry.vertices;",
            "\t\t\t\tdst.push( src[ a + 0 ], src[ a + 1 ], src[ a + 2 ] );",
            "\t\t\t\tdst.push( src[ b + 0 ], src[ b + 1 ], src[ b + 2 ] );",
            "\t\t\t\tdst.push( src[ c + 0 ], src[ c + 1 ], src[ c + 2 ] );",
            "",
            "\t\t\t},",
            "\t\t\taddVertexPoint: function ( a ) {",
            "",
            "\t\t\t\tconst src = this.vertices;",
            "\t\t\t\tconst dst = this.object.geometry.vertices;",
            "\t\t\t\tdst.push( src[ a + 0 ], src[ a + 1 ], src[ a + 2 ] );",
            "",
            "\t\t\t},",
            "\t\t\taddVertexLine: function ( a ) {",
            "",
            "\t\t\t\tconst src = this.vertices;",
            "\t\t\t\tconst dst = this.object.geometry.vertices;",
            "\t\t\t\tdst.push( src[ a + 0 ], src[ a + 1 ], src[ a + 2 ] );",
            "",
            "\t\t\t},",
            "\t\t\taddNormal: function ( a, b, c ) {",
            "",
            "\t\t\t\tconst src = this.normals;",
            "\t\t\t\tconst dst = this.object.geometry.normals;",
            "\t\t\t\tdst.push( src[ a + 0 ], src[ a + 1 ], src[ a + 2 ] );",
            "\t\t\t\tdst.push( src[ b + 0 ], src[ b + 1 ], src[ b + 2 ] );",
            "\t\t\t\tdst.push( src[ c + 0 ], src[ c + 1 ], src[ c + 2 ] );",
            "",
            "\t\t\t},",
            "\t\t\taddFaceNormal: function ( a, b, c ) {",
            "",
            "\t\t\t\tconst src = this.vertices;",
            "\t\t\t\tconst dst = this.object.geometry.normals;",
            "",
            "\t\t\t\t_vA.fromArray( src, a );",
            "",
            "\t\t\t\t_vB.fromArray( src, b );",
            "",
            "\t\t\t\t_vC.fromArray( src, c );",
            "",
            "\t\t\t\t_cb.subVectors( _vC, _vB );",
            "",
            "\t\t\t\t_ab.subVectors( _vA, _vB );",
            "",
            "\t\t\t\t_cb.cross( _ab );",
            "",
            "\t\t\t\t_cb.normalize();",
            "",
            "\t\t\t\tdst.push( _cb.x, _cb.y, _cb.z );",
            "\t\t\t\tdst.push( _cb.x, _cb.y, _cb.z );",
            "\t\t\t\tdst.push( _cb.x, _cb.y, _cb.z );",
            "",
            "\t\t\t},",
            "\t\t\taddColor: function ( a, b, c ) {",
            "",
            "\t\t\t\tconst src = this.colors;",
            "\t\t\t\tconst dst = this.object.geometry.colors;",
            "\t\t\t\tif ( src[ a ] !== undefined ) dst.push( src[ a + 0 ], src[ a + 1 ], src[ a + 2 ] );",
            "\t\t\t\tif ( src[ b ] !== undefined ) dst.push( src[ b + 0 ], src[ b + 1 ], src[ b + 2 ] );",
            "\t\t\t\tif ( src[ c ] !== undefined ) dst.push( src[ c + 0 ], src[ c + 1 ], src[ c + 2 ] );",
            "",
            "\t\t\t},",
            "\t\t\taddUV: function ( a, b, c ) {",
            "",
            "\t\t\t\tconst src = this.uvs;",
            "\t\t\t\tconst dst = this.object.geometry.uvs;",
            "\t\t\t\tdst.push( src[ a + 0 ], src[ a + 1 ] );",
            "\t\t\t\tdst.push( src[ b + 0 ], src[ b + 1 ] );",
            "\t\t\t\tdst.push( src[ c + 0 ], src[ c + 1 ] );",
            "",
            "\t\t\t},",
            "\t\t\taddDefaultUV: function () {",
            "",
            "\t\t\t\tconst dst = this.object.geometry.uvs;",
            "\t\t\t\tdst.push( 0, 0 );",
            "\t\t\t\tdst.push( 0, 0 );",
            "\t\t\t\tdst.push( 0, 0 );",
            "",
            "\t\t\t},",
            "\t\t\taddUVLine: function ( a ) {",
            "",
            "\t\t\t\tconst src = this.uvs;",
            "\t\t\t\tconst dst = this.object.geometry.uvs;",
            "\t\t\t\tdst.push( src[ a + 0 ], src[ a + 1 ] );",
            "",
            "\t\t\t},",
            "\t\t\taddFace: function ( a, b, c, ua, ub, uc, na, nb, nc ) {",
            "",
            "\t\t\t\tconst vLen = this.vertices.length;",
            "\t\t\t\tlet ia = this.parseVertexIndex( a, vLen );",
            "\t\t\t\tlet ib = this.parseVertexIndex( b, vLen );",
            "\t\t\t\tlet ic = this.parseVertexIndex( c, vLen );",
            "\t\t\t\tthis.addVertex( ia, ib, ic );",
            "\t\t\t\tthis.addColor( ia, ib, ic ); // normals",
            "",
            "\t\t\t\tif ( na !== undefined && na !== '' ) {",
            "",
            "\t\t\t\t\tconst nLen = this.normals.length;",
            "\t\t\t\t\tia = this.parseNormalIndex( na, nLen );",
            "\t\t\t\t\tib = this.parseNormalIndex( nb, nLen );",
            "\t\t\t\t\tic = this.parseNormalIndex( nc, nLen );",
            "\t\t\t\t\tthis.addNormal( ia, ib, ic );",
            "",
            "\t\t\t\t} else {",
            "",
            "\t\t\t\t\tthis.addFaceNormal( ia, ib, ic );",
            "",
            "\t\t\t\t} // uvs",
            "",
            "",
            "\t\t\t\tif ( ua !== undefined && ua !== '' ) {",
            "",
            "\t\t\t\t\tconst uvLen = this.uvs.length;",
            "\t\t\t\t\tia = this.parseUVIndex( ua, uvLen );",
            "\t\t\t\t\tib = this.parseUVIndex( ub, uvLen );",
            "\t\t\t\t\tic = this.parseUVIndex( uc, uvLen );",
            "\t\t\t\t\tthis.addUV( ia, ib, ic );",
            "\t\t\t\t\tthis.object.geometry.hasUVIndices = true;",
            "",
            "\t\t\t\t} else {",
            "",
            "\t\t\t\t\t// add placeholder values (for inconsistent face definitions)",
            "\t\t\t\t\tthis.addDefaultUV();",
            "",
            "\t\t\t\t}",
            "",
            "\t\t\t},",
            "\t\t\taddPointGeometry: function ( vertices ) {",
            "",
            "\t\t\t\tthis.object.geometry.type = 'Points';",
            "\t\t\t\tconst vLen = this.vertices.length;",
            "",
            "\t\t\t\tfor ( let vi = 0, l = vertices.length; vi < l; vi ++ ) {",
            "",
            "\t\t\t\t\tconst index = this.parseVertexIndex( vertices[ vi ], vLen );",
            "\t\t\t\t\tthis.addVertexPoint( index );",
            "\t\t\t\t\tthis.addColor( index );",
            "",
            "\t\t\t\t}",
            "",
            "\t\t\t},",
            "\t\t\taddLineGeometry: function ( vertices, uvs ) {",
            "",
            "\t\t\t\tthis.object.geometry.type = 'Line';",
            "\t\t\t\tconst vLen = this.vertices.length;",
            "\t\t\t\tconst uvLen = this.uvs.length;",
            "",
            "\t\t\t\tfor ( let vi = 0, l = vertices.length; vi < l; vi ++ ) {",
            "",
            "\t\t\t\t\tthis.addVertexLine( this.parseVertexIndex( vertices[ vi ], vLen ) );",
            "",
            "\t\t\t\t}",
            "",
            "\t\t\t\tfor ( let uvi = 0, l = uvs.length; uvi < l; uvi ++ ) {",
            "",
            "\t\t\t\t\tthis.addUVLine( this.parseUVIndex( uvs[ uvi ], uvLen ) );",
            "",
            "\t\t\t\t}",
            "",
            "\t\t\t}",
            "\t\t};",
            "\t\tstate.startObject( '', false );",
            "\t\treturn state;",
            "",
            "\t} //",
            "",
            "",
            "\tclass OBJLoader extends THREE.Loader {",
            "",
            "\t\tconstructor( manager ) {",
            "",
            "\t\t\tsuper( manager );",
            "\t\t\tthis.materials = null;",
            "",
            "\t\t}",
            "",
            "\t\tload( url, onLoad, onProgress, onError ) {",
            "",
            "\t\t\tconst scope = this;",
            "\t\t\tconst loader = new THREE.FileLoader( this.manager );",
            "\t\t\tloader.setPath( this.path );",
            "\t\t\tloader.setRequestHeader( this.requestHeader );",
            "\t\t\tloader.setWithCredentials( this.withCredentials );",
            "\t\t\tloader.load( url, function ( text ) {",
            "",
            "\t\t\t\ttry {",
            "",
            "\t\t\t\t\tonLoad( scope.parse( text ) );",
            "",
            "\t\t\t\t} catch ( e ) {",
            "",
            "\t\t\t\t\tif ( onError ) {",
            "",
            "\t\t\t\t\t\tonError( e );",
            "",
            "\t\t\t\t\t} else {",
            "",
            "\t\t\t\t\t\tconsole.error( e );",
            "",
            "\t\t\t\t\t}",
            "",
            "\t\t\t\t\tscope.manager.itemError( url );",
            "",
            "\t\t\t\t}",
            "",
            "\t\t\t}, onProgress, onError );",
            "",
            "\t\t}",
            "",
            "\t\tsetMaterials( materials ) {",
            "",
            "\t\t\tthis.materials = materials;",
            "\t\t\treturn this;",
            "",
            "\t\t}",
            "",
            "\t\tparse( text ) {",
            "",
            "\t\t\tconst state = new ParserState();",
            "",
            "\t\t\tif ( text.indexOf( '\\r\\n' ) !== - 1 ) {",
            "",
            "\t\t\t\t// This is faster than String.split with regex that splits on both",
            "\t\t\t\ttext = text.replace( /\\r\\n/g, '\\n' );",
            "",
            "\t\t\t}",
            "",
            "\t\t\tif ( text.indexOf( '\\\\\\n' ) !== - 1 ) {",
            "",
            "\t\t\t\t// join lines separated by a line continuation character (\\)",
            "\t\t\t\ttext = text.replace( /\\\\\\n/g, '' );",
            "",
            "\t\t\t}",
            "",
            "\t\t\tconst lines = text.split( '\\n' );",
            "\t\t\tlet result = [];",
            "",
            "\t\t\tfor ( let i = 0, l = lines.length; i < l; i ++ ) {",
            "",
            "\t\t\t\tconst line = lines[ i ].trimStart();",
            "\t\t\t\tif ( line.length === 0 ) continue;",
            "\t\t\t\tconst lineFirstChar = line.charAt( 0 ); // @todo invoke passed in handler if any",
            "",
            "\t\t\t\tif ( lineFirstChar === '#' ) continue;",
            "",
            "\t\t\t\tif ( lineFirstChar === 'v' ) {",
            "",
            "\t\t\t\t\tconst data = line.split( _face_vertex_data_separator_pattern );",
            "",
            "\t\t\t\t\tswitch ( data[ 0 ] ) {",
            "",
            "\t\t\t\t\t\tcase 'v':",
            "\t\t\t\t\t\t\tstate.vertices.push( parseFloat( data[ 1 ] ), parseFloat( data[ 2 ] ), parseFloat( data[ 3 ] ) );",
            "",
            "\t\t\t\t\t\t\tif ( data.length >= 7 ) {",
            "",
            "\t\t\t\t\t\t\t\t_color.setRGB( parseFloat( data[ 4 ] ), parseFloat( data[ 5 ] ), parseFloat( data[ 6 ] ) ).convertSRGBToLinear();",
            "",
            "\t\t\t\t\t\t\t\tstate.colors.push( _color.r, _color.g, _color.b );",
            "",
            "\t\t\t\t\t\t\t} else {",
            "",
            "\t\t\t\t\t\t\t\t// if no colors are defined, add placeholders so color and vertex indices match",
            "\t\t\t\t\t\t\t\tstate.colors.push( undefined, undefined, undefined );",
            "",
            "\t\t\t\t\t\t\t}",
            "",
            "\t\t\t\t\t\t\tbreak;",
            "",
            "\t\t\t\t\t\tcase 'vn':",
            "\t\t\t\t\t\t\tstate.normals.push( parseFloat( data[ 1 ] ), parseFloat( data[ 2 ] ), parseFloat( data[ 3 ] ) );",
            "\t\t\t\t\t\t\tbreak;",
            "",
            "\t\t\t\t\t\tcase 'vt':",
            "\t\t\t\t\t\t\tstate.uvs.push( parseFloat( data[ 1 ] ), parseFloat( data[ 2 ] ) );",
            "\t\t\t\t\t\t\tbreak;",
            "",
            "\t\t\t\t\t}",
            "",
            "\t\t\t\t} else if ( lineFirstChar === 'f' ) {",
            "",
            "\t\t\t\t\tconst lineData = line.slice( 1 ).trim();",
            "\t\t\t\t\tconst vertexData = lineData.split( _face_vertex_data_separator_pattern );",
            "\t\t\t\t\tconst faceVertices = []; // Parse the face vertex data into an easy to work with format",
            "",
            "\t\t\t\t\tfor ( let j = 0, jl = vertexData.length; j < jl; j ++ ) {",
            "",
            "\t\t\t\t\t\tconst vertex = vertexData[ j ];",
            "",
            "\t\t\t\t\t\tif ( vertex.length > 0 ) {",
            "",
            "\t\t\t\t\t\t\tconst vertexParts = vertex.split( '/' );",
            "\t\t\t\t\t\t\tfaceVertices.push( vertexParts );",
            "",
            "\t\t\t\t\t\t}",
            "",
            "\t\t\t\t\t} // Draw an edge between the first vertex and all subsequent vertices to form an n-gon",
            "",
            "",
            "\t\t\t\t\tconst v1 = faceVertices[ 0 ];",
            "",
            "\t\t\t\t\tfor ( let j = 1, jl = faceVertices.length - 1; j < jl; j ++ ) {",
            "",
            "\t\t\t\t\t\tconst v2 = faceVertices[ j ];",
            "\t\t\t\t\t\tconst v3 = faceVertices[ j + 1 ];",
            "\t\t\t\t\t\tstate.addFace( v1[ 0 ], v2[ 0 ], v3[ 0 ], v1[ 1 ], v2[ 1 ], v3[ 1 ], v1[ 2 ], v2[ 2 ], v3[ 2 ] );",
            "",
            "\t\t\t\t\t}",
            "",
            "\t\t\t\t} else if ( lineFirstChar === 'l' ) {",
            "",
            "\t\t\t\t\tconst lineParts = line.substring( 1 ).trim().split( ' ' );",
            "\t\t\t\t\tlet lineVertices = [];",
            "\t\t\t\t\tconst lineUVs = [];",
            "",
            "\t\t\t\t\tif ( line.indexOf( '/' ) === - 1 ) {",
            "",
            "\t\t\t\t\t\tlineVertices = lineParts;",
            "",
            "\t\t\t\t\t} else {",
            "",
            "\t\t\t\t\t\tfor ( let li = 0, llen = lineParts.length; li < llen; li ++ ) {",
            "",
            "\t\t\t\t\t\t\tconst parts = lineParts[ li ].split( '/' );",
            "\t\t\t\t\t\t\tif ( parts[ 0 ] !== '' ) lineVertices.push( parts[ 0 ] );",
            "\t\t\t\t\t\t\tif ( parts[ 1 ] !== '' ) lineUVs.push( parts[ 1 ] );",
            "",
            "\t\t\t\t\t\t}",
            "",
            "\t\t\t\t\t}",
            "",
            "\t\t\t\t\tstate.addLineGeometry( lineVertices, lineUVs );",
            "",
            "\t\t\t\t} else if ( lineFirstChar === 'p' ) {",
            "",
            "\t\t\t\t\tconst lineData = line.slice( 1 ).trim();",
            "\t\t\t\t\tconst pointData = lineData.split( ' ' );",
            "\t\t\t\t\tstate.addPointGeometry( pointData );",
            "",
            "\t\t\t\t} else if ( ( result = _object_pattern.exec( line ) ) !== null ) {",
            "",
            "\t\t\t\t\t// o object_name",
            "\t\t\t\t\t// or",
            "\t\t\t\t\t// g group_name",
            "\t\t\t\t\t// WORKAROUND: https://bugs.chromium.org/p/v8/issues/detail?id=2869",
            "\t\t\t\t\t// let name = result[ 0 ].slice( 1 ).trim();",
            "\t\t\t\t\tconst name = ( ' ' + result[ 0 ].slice( 1 ).trim() ).slice( 1 );",
            "\t\t\t\t\tstate.startObject( name );",
            "",
            "\t\t\t\t} else if ( _material_use_pattern.test( line ) ) {",
            "",
            "\t\t\t\t\t// material",
            "\t\t\t\t\tstate.object.startMaterial( line.substring( 7 ).trim(), state.materialLibraries );",
            "",
            "\t\t\t\t} else if ( _material_library_pattern.test( line ) ) {",
            "",
            "\t\t\t\t\t// mtl file",
            "\t\t\t\t\tstate.materialLibraries.push( line.substring( 7 ).trim() );",
            "",
            "\t\t\t\t} else if ( _map_use_pattern.test( line ) ) {",
            "",
            "\t\t\t\t\t// the line is parsed but ignored since the loader assumes textures are defined MTL files",
            "\t\t\t\t\t// (according to https://www.okino.com/conv/imp_wave.htm, 'usemap' is the old-style Wavefront texture reference method)",
            "\t\t\t\t\tconsole.warn( 'THREE.OBJLoader: Rendering identifier \"usemap\" not supported. Textures must be defined in MTL files.' );",
            "",
            "\t\t\t\t} else if ( lineFirstChar === 's' ) {",
            "",
            "\t\t\t\t\tresult = line.split( ' ' ); // smooth shading",
            "\t\t\t\t\t// @todo Handle files that have varying smooth values for a set of faces inside one geometry,",
            "\t\t\t\t\t// but does not define a usemtl for each face set.",
            "\t\t\t\t\t// This should be detected and a dummy material created (later MultiMaterial and geometry groups).",
            "\t\t\t\t\t// This requires some care to not create extra material on each smooth value for \"normal\" obj files.",
            "\t\t\t\t\t// where explicit usemtl defines geometry groups.",
            "\t\t\t\t\t// Example asset: examples/models/obj/cerberus/Cerberus.obj",
            "",
            "\t\t\t\t\t/*",
            "        \t * http://paulbourke.net/dataformats/obj/",
            "        \t *",
            "        \t * From chapter \"Grouping\" Syntax explanation \"s group_number\":",
            "        \t * \"group_number is the smoothing group number. To turn off smoothing groups, use a value of 0 or off.",
            "        \t * Polygonal elements use group numbers to put elements in different smoothing groups. For free-form",
            "        \t * surfaces, smoothing groups are either turned on or off; there is no difference between values greater",
            "        \t * than 0.\"",
            "        \t */",
            "",
            "\t\t\t\t\tif ( result.length > 1 ) {",
            "",
            "\t\t\t\t\t\tconst value = result[ 1 ].trim().toLowerCase();",
            "\t\t\t\t\t\tstate.object.smooth = value !== '0' && value !== 'off';",
            "",
            "\t\t\t\t\t} else {",
            "",
            "\t\t\t\t\t\t// ZBrush can produce \"s\" lines #11707",
            "\t\t\t\t\t\tstate.object.smooth = true;",
            "",
            "\t\t\t\t\t}",
            "",
            "\t\t\t\t\tconst material = state.object.currentMaterial();",
            "\t\t\t\t\tif ( material ) material.smooth = state.object.smooth;",
            "",
            "\t\t\t\t} else {",
            "",
            "\t\t\t\t\t// Handle null terminated files without exception",
            "\t\t\t\t\tif ( line === '\\0' ) continue;",
            "\t\t\t\t\tconsole.warn( 'THREE.OBJLoader: Unexpected line: \"' + line + '\"' );",
            "",
            "\t\t\t\t}",
            "",
            "\t\t\t}",
            "",
            "\t\t\tstate.finalize();",
            "\t\t\tconst container = new THREE.Group();",
            "\t\t\tcontainer.materialLibraries = [].concat( state.materialLibraries );",
            "\t\t\tconst hasPrimitives = ! ( state.objects.length === 1 && state.objects[ 0 ].geometry.vertices.length === 0 );",
            "",
            "\t\t\tif ( hasPrimitives === true ) {",
            "",
            "\t\t\t\tfor ( let i = 0, l = state.objects.length; i < l; i ++ ) {",
            "",
            "\t\t\t\t\tconst object = state.objects[ i ];",
            "\t\t\t\t\tconst geometry = object.geometry;",
            "\t\t\t\t\tconst materials = object.materials;",
            "\t\t\t\t\tconst isLine = geometry.type === 'Line';",
            "\t\t\t\t\tconst isPoints = geometry.type === 'Points';",
            "\t\t\t\t\tlet hasVertexColors = false; // Skip o/g line declarations that did not follow with any faces",
            "",
            "\t\t\t\t\tif ( geometry.vertices.length === 0 ) continue;",
            "\t\t\t\t\tconst buffergeometry = new THREE.BufferGeometry();",
            "\t\t\t\t\tbuffergeometry.setAttribute( 'position', new THREE.Float32BufferAttribute( geometry.vertices, 3 ) );",
            "",
            "\t\t\t\t\tif ( geometry.normals.length > 0 ) {",
            "",
            "\t\t\t\t\t\tbuffergeometry.setAttribute( 'normal', new THREE.Float32BufferAttribute( geometry.normals, 3 ) );",
            "",
            "\t\t\t\t\t}",
            "",
            "\t\t\t\t\tif ( geometry.colors.length > 0 ) {",
            "",
            "\t\t\t\t\t\thasVertexColors = true;",
            "\t\t\t\t\t\tbuffergeometry.setAttribute( 'color', new THREE.Float32BufferAttribute( geometry.colors, 3 ) );",
            "",
            "\t\t\t\t\t}",
            "",
            "\t\t\t\t\tif ( geometry.hasUVIndices === true ) {",
            "",
            "\t\t\t\t\t\tbuffergeometry.setAttribute( 'uv', new THREE.Float32BufferAttribute( geometry.uvs, 2 ) );",
            "",
            "\t\t\t\t\t} // Create materials",
            "",
            "",
            "\t\t\t\t\tconst createdMaterials = [];",
            "",
            "\t\t\t\t\tfor ( let mi = 0, miLen = materials.length; mi < miLen; mi ++ ) {",
            "",
            "\t\t\t\t\t\tconst sourceMaterial = materials[ mi ];",
            "\t\t\t\t\t\tconst materialHash = sourceMaterial.name + '_' + sourceMaterial.smooth + '_' + hasVertexColors;",
            "\t\t\t\t\t\tlet material = state.materials[ materialHash ];",
            "",
            "\t\t\t\t\t\tif ( this.materials !== null ) {",
            "",
            "\t\t\t\t\t\t\tmaterial = this.materials.create( sourceMaterial.name ); // mtl etc. loaders probably can't create line materials correctly, copy properties to a line material.",
            "",
            "\t\t\t\t\t\t\tif ( isLine && material && ! ( material instanceof THREE.LineBasicMaterial ) ) {",
            "",
            "\t\t\t\t\t\t\t\tconst materialLine = new THREE.LineBasicMaterial();",
            "\t\t\t\t\t\t\t\tTHREE.Material.prototype.copy.call( materialLine, material );",
            "\t\t\t\t\t\t\t\tmaterialLine.color.copy( material.color );",
            "\t\t\t\t\t\t\t\tmaterial = materialLine;",
            "",
            "\t\t\t\t\t\t\t} else if ( isPoints && material && ! ( material instanceof THREE.PointsMaterial ) ) {",
            "",
            "\t\t\t\t\t\t\t\tconst materialPoints = new THREE.PointsMaterial( {",
            "\t\t\t\t\t\t\t\t\tsize: 10,",
            "\t\t\t\t\t\t\t\t\tsizeAttenuation: false",
            "\t\t\t\t\t\t\t\t} );",
            "\t\t\t\t\t\t\t\tTHREE.Material.prototype.copy.call( materialPoints, material );",
            "\t\t\t\t\t\t\t\tmaterialPoints.color.copy( material.color );",
            "\t\t\t\t\t\t\t\tmaterialPoints.map = material.map;",
            "\t\t\t\t\t\t\t\tmaterial = materialPoints;",
            "",
            "\t\t\t\t\t\t\t}",
            "",
            "\t\t\t\t\t\t}",
            "",
            "\t\t\t\t\t\tif ( material === undefined ) {",
            "",
            "\t\t\t\t\t\t\tif ( isLine ) {",
            "",
            "\t\t\t\t\t\t\t\tmaterial = new THREE.LineBasicMaterial();",
            "",
            "\t\t\t\t\t\t\t} else if ( isPoints ) {",
            "",
            "\t\t\t\t\t\t\t\tmaterial = new THREE.PointsMaterial( {",
            "\t\t\t\t\t\t\t\t\tsize: 1,",
            "\t\t\t\t\t\t\t\t\tsizeAttenuation: false",
            "\t\t\t\t\t\t\t\t} );",
            "",
            "\t\t\t\t\t\t\t} else {",
            "",
            "\t\t\t\t\t\t\t\t// material = new THREE.MeshPhongMaterial();",
            "\t\t\t\t\t\t\t\t// material = new THREE.MeshBasicMaterial();// Custom",
            "        \t\t\t\t\t\tmaterial = new THREE.MeshLambertMaterial();// Custom",
            "",
            "",
            "\t\t\t\t\t\t\t}",
            "",
            "\t\t\t\t\t\t\tmaterial.name = sourceMaterial.name;",
            "\t\t\t\t\t\t\t// material.flatShading = sourceMaterial.smooth ? false : true;// Custom (MeshBasicMaterial)",
            "\t\t\t\t\t\t\tmaterial.flatShading = sourceMaterial.smooth ? false : true;// Custom (MeshLambertMaterial)",
            "\t\t\t\t\t\t\tmaterial.vertexColors = hasVertexColors;",
            "\t\t\t\t\t\t\tstate.materials[ materialHash ] = material;",
            "",
            "\t\t\t\t\t\t}",
            "",
            "\t\t\t\t\t\tcreatedMaterials.push( material );",
            "",
            "\t\t\t\t\t} // Create mesh",
            "",
            "",
            "\t\t\t\t\tlet mesh;",
            "",
            "\t\t\t\t\tif ( createdMaterials.length > 1 ) {",
            "",
            "\t\t\t\t\t\tfor ( let mi = 0, miLen = materials.length; mi < miLen; mi ++ ) {",
            "",
            "\t\t\t\t\t\t\tconst sourceMaterial = materials[ mi ];",
            "\t\t\t\t\t\t\tbuffergeometry.addGroup( sourceMaterial.groupStart, sourceMaterial.groupCount, mi );",
            "",
            "\t\t\t\t\t\t}",
            "",
            "\t\t\t\t\t\tif ( isLine ) {",
            "",
            "\t\t\t\t\t\t\tmesh = new THREE.LineSegments( buffergeometry, createdMaterials );",
            "",
            "\t\t\t\t\t\t} else if ( isPoints ) {",
            "",
            "\t\t\t\t\t\t\tmesh = new THREE.Points( buffergeometry, createdMaterials );",
            "",
            "\t\t\t\t\t\t} else {",
            "",
            "\t\t\t\t\t\t\tmesh = new THREE.Mesh( buffergeometry, createdMaterials );",
            "",
            "\t\t\t\t\t\t}",
            "",
            "\t\t\t\t\t} else {",
            "",
            "\t\t\t\t\t\tif ( isLine ) {",
            "",
            "\t\t\t\t\t\t\tmesh = new THREE.LineSegments( buffergeometry, createdMaterials[ 0 ] );",
            "",
            "\t\t\t\t\t\t} else if ( isPoints ) {",
            "",
            "\t\t\t\t\t\t\tmesh = new THREE.Points( buffergeometry, createdMaterials[ 0 ] );",
            "",
            "\t\t\t\t\t\t} else {",
            "",
            "\t\t\t\t\t\t\tmesh = new THREE.Mesh( buffergeometry, createdMaterials[ 0 ] );",
            "",
            "\t\t\t\t\t\t}",
            "",
            "\t\t\t\t\t}",
            "",
            "\t\t\t\t\tmesh.geometry.computeBoundingBox();// Custom",
            "\t\t\t\t\tmesh.name = object.name;",
            "\t\t\t\t\tcontainer.add( mesh );",
            "",
            "\t\t\t\t}",
            "",
            "\t\t\t} else {",
            "",
            "\t\t\t\t// if there is only the default parser state object with no geometry data, interpret data as point cloud",
            "\t\t\t\tif ( state.vertices.length > 0 ) {",
            "",
            "\t\t\t\t\tconst material = new THREE.PointsMaterial( {",
            "\t\t\t\t\t\tsize: 1,",
            "\t\t\t\t\t\tsizeAttenuation: false",
            "\t\t\t\t\t} );",
            "\t\t\t\t\tconst buffergeometry = new THREE.BufferGeometry();",
            "\t\t\t\t\tbuffergeometry.setAttribute( 'position', new THREE.Float32BufferAttribute( state.vertices, 3 ) );",
            "",
            "\t\t\t\t\tif ( state.colors.length > 0 && state.colors[ 0 ] !== undefined ) {",
            "",
            "\t\t\t\t\t\tbuffergeometry.setAttribute( 'color', new THREE.Float32BufferAttribute( state.colors, 3 ) );",
            "\t\t\t\t\t\tmaterial.vertexColors = true;",
            "",
            "\t\t\t\t\t}",
            "",
            "\t\t\t\t\tconst points = new THREE.Points( buffergeometry, material );",
            "\t\t\t\t\tpoints.geometry.computeBoundingBox();// Custom",
            "\t\t\t\t\tcontainer.add( points );",
            "",
            "\t\t\t\t}",
            "",
            "\t\t\t}",
            "",
            "\t\t\treturn container;",
            "",
            "\t\t}",
            "",
            "\t}",
            "",
            "\tTHREE.OBJLoader = OBJLoader;",
            "",
            "} )();",
            ""
          ],
          "parameterObjects": "",
          "useStrict": true,
          "eventsSheetExpanded": false
        },
        {
          "type": "BuiltinCommonInstructions::Comment",
          "color": {
            "b": 109,
            "g": 230,
            "r": 255,
            "textB": 0,
            "textG": 0,
            "textR": 0
          },
          "comment": "OBB (Custom)"
        },
        {
          "type": "BuiltinCommonInstructions::JsCode",
          "inlineCode": [
            "// Custom",
            "if (gdjs.__WithThreeJS.get(\"NoTHREE\")) {",
            "  return;",
            "}",
            "/* // Custom",
            "import {",
            "\tBox3,",
            "\tMathUtils,",
            "\tMatrix4,",
            "\tMatrix3,",
            "\tRay,",
            "\tVector3",
            "} from 'three';",
            "*/",
            "",
            "// module scope helper variables",
            "",
            "const a = {",
            "\tc: null, // center",
            "\tu: [ new THREE.Vector3(), new THREE.Vector3(), new THREE.Vector3() ], // basis vectors // Custom",
            "\te: [] // half width",
            "};",
            "",
            "const b = {",
            "\tc: null, // center",
            "\tu: [ new THREE.Vector3(), new THREE.Vector3(), new THREE.Vector3() ], // basis vectors // Custom",
            "\te: [] // half width",
            "};",
            "",
            "const R = [[], [], []];",
            "const AbsR = [[], [], []];",
            "const t = [];",
            "",
            "const xAxis = new THREE.Vector3(); // Custom",
            "const yAxis = new THREE.Vector3(); // Custom",
            "const zAxis = new THREE.Vector3(); // Custom",
            "const v1 = new THREE.Vector3(); // Custom",
            "const size = new THREE.Vector3(); // Custom",
            "const closestPoint = new THREE.Vector3(); // Custom",
            "const rotationMatrix = new THREE.Matrix3(); // Custom",
            "const aabb = new THREE.Box3(); // Custom",
            "const matrix = new THREE.Matrix4(); // Custom",
            "const inverse = new THREE.Matrix4(); // Custom",
            "const localRay = new THREE.Ray(); // Custom",
            "",
            "// OBB",
            "",
            "class OBB {",
            "",
            "\tconstructor( center = new THREE.Vector3(), halfSize = new THREE.Vector3(), rotation = new THREE.Matrix3() ) { // Custom",
            "",
            "\t\tthis.center = center;",
            "\t\tthis.halfSize = halfSize;",
            "\t\tthis.rotation = rotation;",
            "",
            "\t}",
            "",
            "\tset( center, halfSize, rotation ) {",
            "",
            "\t\tthis.center = center;",
            "\t\tthis.halfSize = halfSize;",
            "\t\tthis.rotation = rotation;",
            "",
            "\t\treturn this;",
            "",
            "\t}",
            "",
            "\tcopy( obb ) {",
            "",
            "\t\tthis.center.copy( obb.center );",
            "\t\tthis.halfSize.copy( obb.halfSize );",
            "\t\tthis.rotation.copy( obb.rotation );",
            "",
            "\t\treturn this;",
            "",
            "\t}",
            "",
            "\tclone() {",
            "",
            "\t\treturn new this.constructor().copy( this );",
            "",
            "\t}",
            "",
            "\tgetSize( result ) {",
            "",
            "\t\treturn result.copy( this.halfSize ).multiplyScalar( 2 );",
            "",
            "\t}",
            "",
            "\t/**",
            "\t* Reference: Closest Point on OBB to Point in Real-Time Collision Detection",
            "\t* by Christer Ericson (chapter 5.1.4)",
            "\t*/",
            "\tclampPoint( point, result ) {",
            "",
            "\t\tconst halfSize = this.halfSize;",
            "",
            "\t\tv1.subVectors( point, this.center );",
            "\t\tthis.rotation.extractBasis( xAxis, yAxis, zAxis );",
            "",
            "\t\t// start at the center position of the OBB",
            "",
            "\t\tresult.copy( this.center );",
            "",
            "\t\t// project the target onto the OBB axes and walk towards that point",
            "",
            "\t\tconst x = MathUtils.clamp( v1.dot( xAxis ), - halfSize.x, halfSize.x );",
            "\t\tresult.add( xAxis.multiplyScalar( x ) );",
            "",
            "\t\tconst y = MathUtils.clamp( v1.dot( yAxis ), - halfSize.y, halfSize.y );",
            "\t\tresult.add( yAxis.multiplyScalar( y ) );",
            "",
            "\t\tconst z = MathUtils.clamp( v1.dot( zAxis ), - halfSize.z, halfSize.z );",
            "\t\tresult.add( zAxis.multiplyScalar( z ) );",
            "",
            "\t\treturn result;",
            "",
            "\t}",
            "",
            "\tcontainsPoint( point ) {",
            "",
            "\t\tv1.subVectors( point, this.center );",
            "\t\tthis.rotation.extractBasis( xAxis, yAxis, zAxis );",
            "",
            "\t\t// project v1 onto each axis and check if these points lie inside the OBB",
            "",
            "\t\treturn Math.abs( v1.dot( xAxis ) ) <= this.halfSize.x &&",
            "\t\t\t\tMath.abs( v1.dot( yAxis ) ) <= this.halfSize.y &&",
            "\t\t\t\tMath.abs( v1.dot( zAxis ) ) <= this.halfSize.z;",
            "",
            "\t}",
            "",
            "\tintersectsBox3( box3 ) {",
            "",
            "\t\treturn this.intersectsOBB( obb.fromBox3( box3 ) );",
            "",
            "\t}",
            "",
            "\tintersectsSphere( sphere ) {",
            "",
            "\t\t// find the point on the OBB closest to the sphere center",
            "",
            "\t\tthis.clampPoint( sphere.center, closestPoint );",
            "",
            "\t\t// if that point is inside the sphere, the OBB and sphere intersect",
            "",
            "\t\treturn closestPoint.distanceToSquared( sphere.center ) <= ( sphere.radius * sphere.radius );",
            "",
            "\t}",
            "",
            "\t/**",
            "\t* Reference: OBB-OBB Intersection in Real-Time Collision Detection",
            "\t* by Christer Ericson (chapter 4.4.1)",
            "\t*",
            "\t*/",
            "\tintersectsOBB( obb, epsilon = Number.EPSILON ) {",
            "",
            "\t\t// prepare data structures (the code uses the same nomenclature like the reference)",
            "",
            "\t\ta.c = this.center;",
            "\t\ta.e[ 0 ] = this.halfSize.x;",
            "\t\ta.e[ 1 ] = this.halfSize.y;",
            "\t\ta.e[ 2 ] = this.halfSize.z;",
            "\t\tthis.rotation.extractBasis( a.u[ 0 ], a.u[ 1 ], a.u[ 2 ] );",
            "",
            "\t\tb.c = obb.center;",
            "\t\tb.e[ 0 ] = obb.halfSize.x;",
            "\t\tb.e[ 1 ] = obb.halfSize.y;",
            "\t\tb.e[ 2 ] = obb.halfSize.z;",
            "\t\tobb.rotation.extractBasis( b.u[ 0 ], b.u[ 1 ], b.u[ 2 ] );",
            "",
            "\t\t// compute rotation matrix expressing b in a's coordinate frame",
            "",
            "\t\tfor ( let i = 0; i < 3; i ++ ) {",
            "",
            "\t\t\tfor ( let j = 0; j < 3; j ++ ) {",
            "",
            "\t\t\t\tR[ i ][ j ] = a.u[ i ].dot( b.u[ j ] );",
            "",
            "\t\t\t}",
            "",
            "\t\t}",
            "",
            "\t\t// compute translation vector",
            "",
            "\t\tv1.subVectors( b.c, a.c );",
            "",
            "\t\t// bring translation into a's coordinate frame",
            "",
            "\t\tt[ 0 ] = v1.dot( a.u[ 0 ] );",
            "\t\tt[ 1 ] = v1.dot( a.u[ 1 ] );",
            "\t\tt[ 2 ] = v1.dot( a.u[ 2 ] );",
            "",
            "\t\t// compute common subexpressions. Add in an epsilon term to",
            "\t\t// counteract arithmetic errors when two edges are parallel and",
            "\t\t// their cross product is (near) null",
            "",
            "\t\tfor ( let i = 0; i < 3; i ++ ) {",
            "",
            "\t\t\tfor ( let j = 0; j < 3; j ++ ) {",
            "",
            "\t\t\t\tAbsR[ i ][ j ] = Math.abs( R[ i ][ j ] ) + epsilon;",
            "",
            "\t\t\t}",
            "",
            "\t\t}",
            "",
            "\t\tlet ra, rb;",
            "",
            "\t\t// test axes L = A0, L = A1, L = A2",
            "",
            "\t\tfor ( let i = 0; i < 3; i ++ ) {",
            "",
            "\t\t\tra = a.e[ i ];",
            "\t\t\trb = b.e[ 0 ] * AbsR[ i ][ 0 ] + b.e[ 1 ] * AbsR[ i ][ 1 ] + b.e[ 2 ] * AbsR[ i ][ 2 ];",
            "\t\t\tif ( Math.abs( t[ i ] ) > ra + rb ) return false;",
            "",
            "",
            "\t\t}",
            "",
            "\t\t// test axes L = B0, L = B1, L = B2",
            "",
            "\t\tfor ( let i = 0; i < 3; i ++ ) {",
            "",
            "\t\t\tra = a.e[ 0 ] * AbsR[ 0 ][ i ] + a.e[ 1 ] * AbsR[ 1 ][ i ] + a.e[ 2 ] * AbsR[ 2 ][ i ];",
            "\t\t\trb = b.e[ i ];",
            "\t\t\tif ( Math.abs( t[ 0 ] * R[ 0 ][ i ] + t[ 1 ] * R[ 1 ][ i ] + t[ 2 ] * R[ 2 ][ i ] ) > ra + rb ) return false;",
            "",
            "\t\t}",
            "",
            "\t\t// test axis L = A0 x B0",
            "",
            "\t\tra = a.e[ 1 ] * AbsR[ 2 ][ 0 ] + a.e[ 2 ] * AbsR[ 1 ][ 0 ];",
            "\t\trb = b.e[ 1 ] * AbsR[ 0 ][ 2 ] + b.e[ 2 ] * AbsR[ 0 ][ 1 ];",
            "\t\tif ( Math.abs( t[ 2 ] * R[ 1 ][ 0 ] - t[ 1 ] * R[ 2 ][ 0 ] ) > ra + rb ) return false;",
            "",
            "\t\t// test axis L = A0 x B1",
            "",
            "\t\tra = a.e[ 1 ] * AbsR[ 2 ][ 1 ] + a.e[ 2 ] * AbsR[ 1 ][ 1 ];",
            "\t\trb = b.e[ 0 ] * AbsR[ 0 ][ 2 ] + b.e[ 2 ] * AbsR[ 0 ][ 0 ];",
            "\t\tif ( Math.abs( t[ 2 ] * R[ 1 ][ 1 ] - t[ 1 ] * R[ 2 ][ 1 ] ) > ra + rb ) return false;",
            "",
            "\t\t// test axis L = A0 x B2",
            "",
            "\t\tra = a.e[ 1 ] * AbsR[ 2 ][ 2 ] + a.e[ 2 ] * AbsR[ 1 ][ 2 ];",
            "\t\trb = b.e[ 0 ] * AbsR[ 0 ][ 1 ] + b.e[ 1 ] * AbsR[ 0 ][ 0 ];",
            "\t\tif ( Math.abs( t[ 2 ] * R[ 1 ][ 2 ] - t[ 1 ] * R[ 2 ][ 2 ] ) > ra + rb ) return false;",
            "",
            "\t\t// test axis L = A1 x B0",
            "",
            "\t\tra = a.e[ 0 ] * AbsR[ 2 ][ 0 ] + a.e[ 2 ] * AbsR[ 0 ][ 0 ];",
            "\t\trb = b.e[ 1 ] * AbsR[ 1 ][ 2 ] + b.e[ 2 ] * AbsR[ 1 ][ 1 ];",
            "\t\tif ( Math.abs( t[ 0 ] * R[ 2 ][ 0 ] - t[ 2 ] * R[ 0 ][ 0 ] ) > ra + rb ) return false;",
            "",
            "\t\t// test axis L = A1 x B1",
            "",
            "\t\tra = a.e[ 0 ] * AbsR[ 2 ][ 1 ] + a.e[ 2 ] * AbsR[ 0 ][ 1 ];",
            "\t\trb = b.e[ 0 ] * AbsR[ 1 ][ 2 ] + b.e[ 2 ] * AbsR[ 1 ][ 0 ];",
            "\t\tif ( Math.abs( t[ 0 ] * R[ 2 ][ 1 ] - t[ 2 ] * R[ 0 ][ 1 ] ) > ra + rb ) return false;",
            "",
            "\t\t// test axis L = A1 x B2",
            "",
            "\t\tra = a.e[ 0 ] * AbsR[ 2 ][ 2 ] + a.e[ 2 ] * AbsR[ 0 ][ 2 ];",
            "\t\trb = b.e[ 0 ] * AbsR[ 1 ][ 1 ] + b.e[ 1 ] * AbsR[ 1 ][ 0 ];",
            "\t\tif ( Math.abs( t[ 0 ] * R[ 2 ][ 2 ] - t[ 2 ] * R[ 0 ][ 2 ] ) > ra + rb ) return false;",
            "",
            "\t\t// test axis L = A2 x B0",
            "",
            "\t\tra = a.e[ 0 ] * AbsR[ 1 ][ 0 ] + a.e[ 1 ] * AbsR[ 0 ][ 0 ];",
            "\t\trb = b.e[ 1 ] * AbsR[ 2 ][ 2 ] + b.e[ 2 ] * AbsR[ 2 ][ 1 ];",
            "\t\tif ( Math.abs( t[ 1 ] * R[ 0 ][ 0 ] - t[ 0 ] * R[ 1 ][ 0 ] ) > ra + rb ) return false;",
            "",
            "\t\t// test axis L = A2 x B1",
            "",
            "\t\tra = a.e[ 0 ] * AbsR[ 1 ][ 1 ] + a.e[ 1 ] * AbsR[ 0 ][ 1 ];",
            "\t\trb = b.e[ 0 ] * AbsR[ 2 ][ 2 ] + b.e[ 2 ] * AbsR[ 2 ][ 0 ];",
            "\t\tif ( Math.abs( t[ 1 ] * R[ 0 ][ 1 ] - t[ 0 ] * R[ 1 ][ 1 ] ) > ra + rb ) return false;",
            "",
            "\t\t// test axis L = A2 x B2",
            "",
            "\t\tra = a.e[ 0 ] * AbsR[ 1 ][ 2 ] + a.e[ 1 ] * AbsR[ 0 ][ 2 ];",
            "\t\trb = b.e[ 0 ] * AbsR[ 2 ][ 1 ] + b.e[ 1 ] * AbsR[ 2 ][ 0 ];",
            "\t\tif ( Math.abs( t[ 1 ] * R[ 0 ][ 2 ] - t[ 0 ] * R[ 1 ][ 2 ] ) > ra + rb ) return false;",
            "",
            "\t\t// since no separating axis is found, the OBBs must be intersecting",
            "",
            "\t\treturn true;",
            "",
            "\t}",
            "",
            "\t/**",
            "\t* Reference: Testing Box Against Plane in Real-Time Collision Detection",
            "\t* by Christer Ericson (chapter 5.2.3)",
            "\t*/",
            "\tintersectsPlane( plane ) {",
            "",
            "\t\tthis.rotation.extractBasis( xAxis, yAxis, zAxis );",
            "",
            "\t\t// compute the projection interval radius of this OBB onto L(t) = this->center + t * p.normal;",
            "",
            "\t\tconst r = this.halfSize.x * Math.abs( plane.normal.dot( xAxis ) ) +",
            "\t\t\t\tthis.halfSize.y * Math.abs( plane.normal.dot( yAxis ) ) +",
            "\t\t\t\tthis.halfSize.z * Math.abs( plane.normal.dot( zAxis ) );",
            "",
            "\t\t// compute distance of the OBB's center from the plane",
            "",
            "\t\tconst d = plane.normal.dot( this.center ) - plane.constant;",
            "",
            "\t\t// Intersection occurs when distance d falls within [-r,+r] interval",
            "",
            "\t\treturn Math.abs( d ) <= r;",
            "",
            "\t}",
            "",
            "\t/**",
            "\t* Performs a ray/OBB intersection test and stores the intersection point",
            "\t* to the given 3D vector. If no intersection is detected, *null* is returned.",
            "\t*/",
            "\tintersectRay( ray, result ) {",
            "",
            "\t\t// the idea is to perform the intersection test in the local space",
            "\t\t// of the OBB.",
            "",
            "\t\tthis.getSize( size );",
            "\t\taabb.setFromCenterAndSize( v1.set( 0, 0, 0 ), size );",
            "",
            "\t\t// create a 4x4 transformation matrix",
            "",
            "\t\tmatrix.setFromMatrix3( this.rotation );",
            "\t\tmatrix.setPosition( this.center );",
            "",
            "\t\t// transform ray to the local space of the OBB",
            "",
            "\t\tinverse.copy( matrix ).invert();",
            "\t\tlocalRay.copy( ray ).applyMatrix4( inverse );",
            "",
            "\t\t// perform ray <-> AABB intersection test",
            "",
            "\t\tif ( localRay.intersectBox( aabb, result ) ) {",
            "",
            "\t\t\t// transform the intersection point back to world space",
            "",
            "\t\t\treturn result.applyMatrix4( matrix );",
            "",
            "\t\t} else {",
            "",
            "\t\t\treturn null;",
            "",
            "\t\t}",
            "",
            "\t}",
            "",
            "\t/**",
            "\t* Performs a ray/OBB intersection test. Returns either true or false if",
            "\t* there is a intersection or not.",
            "\t*/",
            "\tintersectsRay( ray ) {",
            "",
            "\t\treturn this.intersectRay( ray, v1 ) !== null;",
            "",
            "\t}",
            "",
            "\tfromBox3( box3 ) {",
            "",
            "\t\tbox3.getCenter( this.center );",
            "",
            "\t\tbox3.getSize( this.halfSize ).multiplyScalar( 0.5 );",
            "",
            "\t\tthis.rotation.identity();",
            "",
            "\t\treturn this;",
            "",
            "\t}",
            "",
            "\tequals( obb ) {",
            "",
            "\t\treturn obb.center.equals( this.center ) &&",
            "\t\t\tobb.halfSize.equals( this.halfSize ) &&",
            "\t\t\tobb.rotation.equals( this.rotation );",
            "",
            "\t}",
            "",
            "\tapplyMatrix4( matrix ) {",
            "",
            "\t\tconst e = matrix.elements;",
            "",
            "\t\tlet sx = v1.set( e[ 0 ], e[ 1 ], e[ 2 ] ).length();",
            "\t\tconst sy = v1.set( e[ 4 ], e[ 5 ], e[ 6 ] ).length();",
            "\t\tconst sz = v1.set( e[ 8 ], e[ 9 ], e[ 10 ] ).length();",
            "",
            "\t\tconst det = matrix.determinant();",
            "\t\tif ( det < 0 ) sx = - sx;",
            "",
            "\t\trotationMatrix.setFromMatrix4( matrix );",
            "",
            "\t\tconst invSX = 1 / sx;",
            "\t\tconst invSY = 1 / sy;",
            "\t\tconst invSZ = 1 / sz;",
            "",
            "\t\trotationMatrix.elements[ 0 ] *= invSX;",
            "\t\trotationMatrix.elements[ 1 ] *= invSX;",
            "\t\trotationMatrix.elements[ 2 ] *= invSX;",
            "",
            "\t\trotationMatrix.elements[ 3 ] *= invSY;",
            "\t\trotationMatrix.elements[ 4 ] *= invSY;",
            "\t\trotationMatrix.elements[ 5 ] *= invSY;",
            "",
            "\t\trotationMatrix.elements[ 6 ] *= invSZ;",
            "\t\trotationMatrix.elements[ 7 ] *= invSZ;",
            "\t\trotationMatrix.elements[ 8 ] *= invSZ;",
            "",
            "\t\tthis.rotation.multiply( rotationMatrix );",
            "",
            "\t\tthis.halfSize.x *= sx;",
            "\t\tthis.halfSize.y *= sy;",
            "\t\tthis.halfSize.z *= sz;",
            "",
            "\t\tv1.setFromMatrixPosition( matrix );",
            "\t\tthis.center.add( v1 );",
            "",
            "\t\treturn this;",
            "",
            "\t}",
            "",
            "}",
            "",
            "// const obb = new OBB();// Custom",
            "",
            "// export { OBB };// Custom",
            "",
            "THREE.OBB = OBB;// Custom"
          ],
          "parameterObjects": "",
          "useStrict": true,
          "eventsSheetExpanded": false
        },
        {
          "type": "BuiltinCommonInstructions::Comment",
          "color": {
            "b": 109,
            "g": 230,
            "r": 255,
            "textB": 0,
            "textG": 0,
            "textR": 0
          },
          "comment": "This is required to import the Tween."
        },
        {
          "type": "BuiltinCommonInstructions::Standard",
          "conditions": [
            {
              "type": {
                "value": "Tween::SceneTweenExists"
              },
              "parameters": [
                "",
                "\"Dummy\""
              ]
            }
          ],
          "actions": [
            {
              "type": {
                "value": "Tween::RemoveSceneTween"
              },
              "parameters": [
                "",
                "\"Dummy\""
              ]
            }
          ]
        }
      ],
      "parameters": [],
      "objectGroups": []
    },
    {
      "fullName": "",
      "functionType": "Action",
      "name": "onScenePostEvents",
      "sentence": "",
      "events": [
        {
          "type": "BuiltinCommonInstructions::JsCode",
          "inlineCode": [
            "// console.log(\"Three.js post events\");",
            "if (!gdjs.__WithThreeJS.has(\"Renderer\")) {",
            "  return;",
            "}",
            "const Canvas2D = gdjs.__WithThreeJS.get(\"Canvas2D\");",
            "const Rect = Canvas2D.getBoundingClientRect();",
            "const Scene = gdjs.__WithThreeJS.get(\"Scene\");",
            "const AllCams = gdjs.__WithThreeJS.get(\"AllCams\");",
            "const Renderer = gdjs.__WithThreeJS.get(\"Renderer\");",
            "const AnimationMixer = gdjs.__WithThreeJS.get(\"AnimationMixer\");",
            "//",
            "AnimationMixer.update(runtimeScene.getElapsedTime() / 1000);",
            "for (const [K, V] of AllCams) {",
            "  if (V.userData.CameraStatus.Active) {",
            "    const X = V.userData.CameraStatus.X;",
            "    const Y = V.userData.CameraStatus.Y;",
            "    const W = V.userData.CameraStatus.W;",
            "    const H = V.userData.CameraStatus.H;",
            "    Renderer.setViewport(X, Y, W, H);",
            "    Renderer.setScissor(X, Y, W, H);",
            "    Renderer.render( Scene, V );",
            "  }",
            "}",
            "",
            ""
          ],
          "parameterObjects": "",
          "useStrict": true,
          "eventsSheetExpanded": true
        }
      ],
      "parameters": [],
      "objectGroups": []
    },
    {
      "fullName": "",
      "functionType": "Action",
      "name": "onSceneUnloading",
      "sentence": "",
      "events": [
        {
          "type": "BuiltinCommonInstructions::Standard",
          "conditions": [
            {
              "type": {
                "value": "BuiltinCommonInstructions::CompareStrings"
              },
              "parameters": [
                "CurrentSceneName()",
                "=",
                "WithThreeJS::CreatedSceneName()"
              ]
            }
          ],
          "actions": [
            {
              "type": {
                "value": "WithThreeJS::Clear3DScene"
              },
              "parameters": [
                "",
                ""
              ]
            }
          ],
          "events": [
            {
              "type": "BuiltinCommonInstructions::JsCode",
              "inlineCode": [
                "if (gdjs.__WithThreeJS.get(\"BuiltIn3D\")) {",
                "    if (runtimeScene.getRenderer()._threeRenderer._render_WithThreeJS) {",
                "        runtimeScene.getRenderer()._threeRenderer.render = runtimeScene.getRenderer()._threeRenderer._render_WithThreeJS;",
                "        runtimeScene.getRenderer()._threeRenderer._render_WithThreeJS = null;",
                "    };",
                "    if (runtimeScene.getRenderer().getPIXIRenderer()._clear_WithThreeJS) {",
                "        runtimeScene.getRenderer().getPIXIRenderer().clear = runtimeScene.getRenderer().getPIXIRenderer()._clear_WithThreeJS;",
                "        runtimeScene.getRenderer().getPIXIRenderer()._clear_WithThreeJS = null;",
                "    };",
                "}",
                "if (runtimeScene.getRenderer().getPIXIRenderer().background) {",
                "    runtimeScene.getRenderer().getPIXIRenderer().background.alpha = 1;// For PixiJS 7",
                "} else {",
                "    runtimeScene.getRenderer().getPIXIRenderer().backgroundAlpha = 1;// For PixiJS 6",
                "}",
                "gdjs.__WithThreeJS.set(\"SceneIsReady\", false);",
                "",
                ""
              ],
              "parameterObjects": "",
              "useStrict": true,
              "eventsSheetExpanded": true
            }
          ]
        }
      ],
      "parameters": [],
      "objectGroups": []
    },
    {
      "description": "Create a 3D Scene and initialize all 3D Cameras.",
      "fullName": "Create 3D Scene V1 (Deprecated)",
      "functionType": "Action",
      "group": "3D Scene",
      "name": "Create3DScene",
      "private": true,
      "sentence": "⚠️ Create 3D Scene V1 (Background: _PARAM1_, _PARAM2_, Ambient: _PARAM3_, Fog: _PARAM4_, _PARAM5_, _PARAM6_, Projection Scale: _PARAM7_, View Mode: _PARAM8_)",
      "events": [
        {
          "type": "BuiltinCommonInstructions::JsCode",
          "inlineCode": [
            "// console.log(\"Three.js create scene\");",
            "// v5.1.162 以上で Built-In 3D がゲームに含まれている",
            "const BuiltIn3D = gdjs.__WithThreeJS.get(\"BuiltIn3D\");",
            "if (BuiltIn3D) {",
            "  // runtimescene-pixi-renderer.ts カスタム",
            "  console.log(\"[WithThreeJS] Built-in 3D is enabled.\");",
            "  if (!runtimeScene.getRenderer()._threeRenderer._render_WithThreeJS) {",
            "    runtimeScene.getRenderer()._threeRenderer._render_WithThreeJS = runtimeScene.getRenderer()._threeRenderer.render;",
            "    runtimeScene.getRenderer()._threeRenderer.render = function(S, C) {",
            "      // Three.js のレンダラーが利用される場合の透過設定",
            "      runtimeScene.getLayer(\"\").getRenderer().getThreeScene().background = null;",
            "      this._render_WithThreeJS(S, C);",
            "    }",
            "  }",
            "  if (!runtimeScene.getRenderer().getPIXIRenderer()._clear_WithThreeJS) {",
            "    runtimeScene.getRenderer().getPIXIRenderer()._clear_WithThreeJS = runtimeScene.getRenderer().getPIXIRenderer().clear;",
            "    runtimeScene.getRenderer().getPIXIRenderer().clear = function() {",
            "      // PixiJS のレンダラーが利用される場合の透過設定",
            "      runtimeScene.setBackgroundColor(0,0,0);",
            "      if (this.background) {",
            "        this.background.alpha = 0;// For PixiJS 7",
            "      } else {",
            "        this.backgroundAlpha = 0;// For PixiJS 6",
            "      }",
            "      this._clear_WithThreeJS();",
            "    }",
            "  }",
            "} else {",
            "  console.log(\"[WithThreeJS] Built-in 3D is disabled.\");",
            "  // 警告表示",
            "  let AlertElement = document.createElement('div');",
            "  AlertElement.innerHTML = `<strong>Warning from WithThreeJS</strong><br>",
            "  Please add an \"Enable WithThreeJS\" object to a scene.<br>",
            "  For more information, <a href=\"https://pandako.itch.io/with-threejs-extension-for-gdevelop/devlog/631434/about-the-warning-please-add-an-enable-withthreejs-object-to-a-scene\" target=\"_blank\" style=\"color:yellow\">please click here</a>.`;",
            "  AlertElement.style.position = \"absolute\";",
            "  AlertElement.style.zIndex = 999;",
            "  AlertElement.style.top = 0;",
            "  AlertElement.style.left = 0;",
            "  AlertElement.style.backgroundColor = \"red\";",
            "  AlertElement.style.color = \"white\";",
            "  AlertElement.style.padding = \"0.5em\";",
            "  document.body.appendChild(AlertElement);",
            "  return;",
            "}",
            "//",
            "const ProjectionScale = eventsFunctionContext.getArgument(\"ProjectionScale\") || 1;",
            "let ViewMode = eventsFunctionContext.getArgument(\"ViewMode\");",
            "if (ViewMode !== \"Top Down\" && ViewMode !== \"Side\") {",
            "  ViewMode = \"Top Down\";",
            "}",
            "gdjs.__WithThreeJS.set(\"ProjectionScale\", ProjectionScale);",
            "gdjs.__WithThreeJS.set(\"ViewMode\", ViewMode);",
            "//",
            "const Canvas2D = document.getElementsByTagName(\"canvas\")[0];",
            "gdjs.__WithThreeJS.set(\"Canvas2D\", Canvas2D);",
            "const Rect = Canvas2D.getBoundingClientRect();",
            "//",
            "let Scene;",
            "if (gdjs.__WithThreeJS.has(\"Scene\")) {",
            "  Scene = gdjs.__WithThreeJS.get(\"Scene\");",
            "} else {",
            "  Scene = new THREE.Scene();",
            "  gdjs.__WithThreeJS.set(\"Scene\", Scene);",
            "}",
            "Scene.name =\"Scene\";",
            "gdjs.__WithThreeJS.set(\"SceneIsReady\", true);",
            "//",
            "const BG_RGB = eventsFunctionContext.getArgument(\"BackGroundColor\") || \"0;0;0\";",
            "const BG_Img = eventsFunctionContext.getArgument(\"BackGroundImage\") || \"\";",
            "const Ambient_RGB = eventsFunctionContext.getArgument(\"AmbientColor\") || \"255;255;255\";",
            "const FogColor = eventsFunctionContext.getArgument(\"FogColor\") || \"\";",
            "const FogNear = eventsFunctionContext.getArgument(\"FogNear\") || 1;",
            "const FogFar = eventsFunctionContext.getArgument(\"FogFar\") || 1000;",
            "//",
            "if (Scene.background) {",
            "  if (Scene.background.isTexture) {",
            "    Scene.background.dispose();",
            "    Scene.background = null;",
            "  }",
            "}",
            "//",
            "if (BG_Img !== \"\") {",
            "  const Resource = runtimeScene.getGame().getImageManager().getPIXITexture(BG_Img).baseTexture.resource;",
            "  const ResourceWidth = Resource.width;",
            "  const ResourceHeight = Resource.height;",
            "  const BGTexture = new THREE.Texture();",
            "  BGTexture.image = Resource.source;",
            "  if (ResourceWidth == ResourceHeight * 2) {",
            "    BGTexture.mapping = THREE.EquirectangularReflectionMapping;",
            "  }",
            "  BGTexture.colorSpace = THREE.SRGBColorSpace;",
            "  BGTexture.needsUpdate = true;//必須",
            "  Scene.background = BGTexture;",
            "} else {",
            "  const RGB = BG_RGB.split(\";\");",
            "  Scene.background = new THREE.Color(`rgb(${RGB[0]}, ${RGB[1]}, ${RGB[2]})`);",
            "}",
            "//",
            "let AmbientLight;",
            "const AmbientColor = Ambient_RGB.split(\";\");",
            "if (gdjs.__WithThreeJS.has(\"AmbientLight\")) {",
            "  AmbientLight = gdjs.__WithThreeJS.get(\"AmbientLight\");",
            "} else {",
            "  AmbientLight = new THREE.AmbientLight();",
            "  AmbientLight.intensity = gdjs.__WithThreeJS.get(\"LightIntensityScale\");// Three.js r160",
            "  gdjs.__WithThreeJS.set(\"AmbientLight\", AmbientLight);",
            "}",
            "Scene.add(AmbientLight);",
            "AmbientLight.color.set(`rgb(${AmbientColor[0]}, ${AmbientColor[1]}, ${AmbientColor[2]})`);",
            "//",
            "if (FogColor === \"\") {",
            "  Scene.fog = null;",
            "} else {",
            "  const RGB = FogColor.split(\";\");",
            "  Scene.fog = new THREE.Fog(`rgb(${RGB[0]}, ${RGB[1]}, ${RGB[2]})`, FogNear, FogFar);",
            "  // Scene.fog = new THREE.FogExp2(\"rgb(0,0,0)\", 0.005);",
            "}",
            "//",
            "// 複数カメラ",
            "let AllCams, Camera1, Camera2, Camera3, Camera4;",
            "if (gdjs.__WithThreeJS.has(\"AllCams\")) {",
            "  AllCams = gdjs.__WithThreeJS.get(\"AllCams\");",
            "  Camera1 = AllCams.get(\"Camera1\");",
            "  Camera2 = AllCams.get(\"Camera2\");",
            "  Camera3 = AllCams.get(\"Camera3\");",
            "  Camera4 = AllCams.get(\"Camera4\");",
            "} else {",
            "  AllCams = new Map();",
            "  Camera1 = new THREE.PerspectiveCamera();",
            "  Camera2 = new THREE.PerspectiveCamera();",
            "  Camera3 = new THREE.PerspectiveCamera();",
            "  Camera4 = new THREE.PerspectiveCamera();",
            "  AllCams.set(\"Camera1\", Camera1);",
            "  AllCams.set(\"Camera2\", Camera2);",
            "  AllCams.set(\"Camera3\", Camera3);",
            "  AllCams.set(\"Camera4\", Camera4);",
            "  gdjs.__WithThreeJS.set(\"AllCams\", AllCams);",
            "}",
            "for (const [K, V] of AllCams) {",
            "  V.name = K;",
            "  V.fov = 50;",
            "  V.aspect = Rect.width / Rect.height;",
            "  V.near = 0.1;",
            "  V.far = 10000;//1000",
            "  V.position.set(0, 0, 0);",
            "  V.rotation.set(0, 0, 0);",
            "  V.updateProjectionMatrix();//必須",
            "  V.userData.CameraStatus = {};",
            "  V.userData.CameraStatus.Active = false;",
            "  V.userData.CameraStatus.T = 1;",
            "  V.userData.CameraStatus.B = 0;",
            "  V.userData.CameraStatus.L = 0;",
            "  V.userData.CameraStatus.R = 1;",
            "  V.userData.CameraStatus.X = 0;",
            "  V.userData.CameraStatus.Y = 0;",
            "  V.userData.CameraStatus.W = Rect.width;",
            "  V.userData.CameraStatus.H = Rect.height;",
            "}",
            "Camera1.userData.CameraStatus.Active = true;",
            "//",
            "let Listener;",
            "if (gdjs.__WithThreeJS.has(\"Listener\")) {",
            "  Listener = gdjs.__WithThreeJS.get(\"Listener\");",
            "} else {",
            "  Listener = new THREE.AudioListener();",
            "  gdjs.__WithThreeJS.set(\"Listener\", Listener);",
            "}",
            "Listener.name =\"Listener\";",
            "Camera1.add(Listener);",
            "//",
            "let Renderer;",
            "if (gdjs.__WithThreeJS.has(\"Renderer\")) {",
            "  Renderer = gdjs.__WithThreeJS.get(\"Renderer\");",
            "} else {",
            "  Renderer = new THREE.WebGLRenderer();",
            "  document.body.appendChild( Renderer.domElement );",
            "  gdjs.__WithThreeJS.set(\"Renderer\", Renderer);",
            "}",
            "Renderer.setPixelRatio(window.devicePixelRatio);",
            "// Renderer.setSize( window.innerWidth, window.innerHeight );",
            "Renderer.setSize(Rect.width, Rect.height);",
            "Renderer.domElement.id = \"WithThreeJS_Canvas\";",
            "Renderer.domElement.style.position = \"absolute\";",
            "Renderer.domElement.style.zIndex = -99;",
            "Renderer.domElement.style.left = Rect.left + \"px\";",
            "Renderer.domElement.style.top = Rect.top + \"px\";",
            "Renderer.setScissorTest(true);",
            "Renderer.shadowMap.enabled = false;",
            "// Renderer.shadowMap.type = THREE.PCFShadowMap;//THREE.BasicShadowMap THREE.PCFShadowMap THREE.PCFSoftShadowMap THREE.VSMShadowMap",
            "// Renderer.outputColorSpace = THREE.LinearSRGBColorSpace;//NoColorSpace SRGBColorSpace LinearSRGBColorSpace",
            "//",
            "let AnimationMixer;",
            "if (gdjs.__WithThreeJS.has(\"AnimationMixer\")) {",
            "  AnimationMixer = gdjs.__WithThreeJS.get(\"AnimationMixer\");",
            "} else {",
            "  AnimationMixer = new THREE.AnimationMixer(Scene);",
            "  gdjs.__WithThreeJS.set(\"AnimationMixer\", AnimationMixer);",
            "}",
            "//",
            "let AnimationActions;",
            "if (gdjs.__WithThreeJS.has(\"AnimationActions\")) {",
            "  AnimationActions = gdjs.__WithThreeJS.get(\"AnimationActions\");",
            "} else {",
            "  AnimationActions = new Map();",
            "  gdjs.__WithThreeJS.set(\"AnimationActions\", AnimationActions);",
            "}",
            "//",
            "// Resize",
            "window.addEventListener('resize', () => {",
            "  const Rect = Canvas2D.getBoundingClientRect();",
            "",
            "  // レンダラーのサイズを調整する",
            "  Renderer.setPixelRatio(window.devicePixelRatio);",
            "  Renderer.setSize(Rect.width, Rect.height);",
            "",
            "  // カメラのアスペクト比を正す",
            "  // Camera.aspect = Rect.width / Rect.height;",
            "  // Camera.updateProjectionMatrix();",
            "  for (const [K, V] of AllCams) {",
            "    const T = V.userData.CameraStatus.T;",
            "    const B = V.userData.CameraStatus.B;",
            "    const L = V.userData.CameraStatus.L;",
            "    const R = V.userData.CameraStatus.R;",
            "    const X = V.userData.CameraStatus.X = L * Rect.width;",
            "    const Y = V.userData.CameraStatus.Y = B * Rect.height;",
            "    const W = V.userData.CameraStatus.W = (R - L) * Rect.width;",
            "    const H = V.userData.CameraStatus.H = (T - B) * Rect.height;",
            "    V.aspect = W / H;",
            "    V.updateProjectionMatrix();",
            "  }",
            "",
            "  // CSS",
            "  Renderer.domElement.style.position = \"absolute\";",
            "  Renderer.domElement.style.zIndex = -99;",
            "  Renderer.domElement.style.left = Rect.left + \"px\";",
            "  Renderer.domElement.style.top = Rect.top + \"px\";",
            "});",
            "",
            "",
            ""
          ],
          "parameterObjects": "",
          "useStrict": true,
          "eventsSheetExpanded": true
        }
      ],
      "parameters": [
        {
          "description": "Background Color",
          "name": "BackGroundColor",
          "type": "color"
        },
        {
          "description": "Background Image (GDevelop Resource Name) (\"\" => No Background Image)",
          "longDescription": "Escape is required. example: \"assets\\\\Image.png\" -> \"assets\\\\\\\\Image.png\"  \n\"\" => No Background Image  \nImage ratio 2:1 (e.g. 1024 x 512 pixels) => Skybox  \nOther image ratio => Flat Background Image",
          "name": "BackGroundImage",
          "type": "string"
        },
        {
          "description": "Ambient Light Color",
          "name": "AmbientColor",
          "type": "color"
        },
        {
          "description": "Fog Color (\"\" is none fog)",
          "name": "FogColor",
          "type": "color"
        },
        {
          "description": "Fog Start Distance (Default: 1)",
          "longDescription": "Distance to start applying fog.",
          "name": "FogNear",
          "type": "expression"
        },
        {
          "description": "Fog Maximum Distance (Default: 1000)",
          "longDescription": "Distance to maximum fog.",
          "name": "FogFar",
          "type": "expression"
        },
        {
          "description": "Projection Scale (Recommended: 1)",
          "longDescription": "Only affects WithThreeJS Behaviors and WithThreeJS Custom Objects.  \nAffects X, Y, Z and Width, Height, Depth.",
          "name": "ProjectionScale",
          "type": "expression"
        },
        {
          "description": "View Mode",
          "longDescription": "Only affects WithThreeJS Behaviors and WithThreeJS Custom Objects.  \nTop Down: 2D[X, Y, Z-Order] -> 3D[X, Z-Order, Y] or Side: 2D[X, Y, Z-Order] -> 3D[X, -Y, Z-Order]",
          "name": "ViewMode",
          "supplementaryInformation": "[\"Top Down\",\"Side\"]",
          "type": "stringWithSelector"
        }
      ],
      "objectGroups": []
    },
    {
      "description": "Create a 3D Scene and initialize all 3D Cameras.\nThe second parameter is the background image.\nBackground image ratio 2:1 (e.g. 1024 x 512 pixels) => Skybox.\nOther image ratio => Flat background image.\nNo image specified => No Background Image.",
      "fullName": "🏞️Create 3D Scene",
      "functionType": "Action",
      "group": "3D Scene",
      "name": "Create3DSceneV2",
      "sentence": "🏞️Create 3D Scene (Background: _PARAM1_, _PARAM2_, Ambient: _PARAM3_, Fog: _PARAM4_, _PARAM5_, _PARAM6_, Projection Scale: _PARAM7_, View Mode: _PARAM8_)",
      "events": [
        {
          "type": "BuiltinCommonInstructions::JsCode",
          "inlineCode": [
            "// console.log(\"Three.js create scene\");",
            "// v5.1.162 以上で Built-In 3D がゲームに含まれている",
            "const BuiltIn3D = gdjs.__WithThreeJS.get(\"BuiltIn3D\");",
            "if (BuiltIn3D) {",
            "  // runtimescene-pixi-renderer.ts カスタム",
            "  console.log(\"[WithThreeJS] Built-in 3D is enabled.\");",
            "  if (!runtimeScene.getRenderer()._threeRenderer._render_WithThreeJS) {",
            "    runtimeScene.getRenderer()._threeRenderer._render_WithThreeJS = runtimeScene.getRenderer()._threeRenderer.render;",
            "    runtimeScene.getRenderer()._threeRenderer.render = function(S, C) {",
            "      // Three.js のレンダラーが利用される場合の透過設定",
            "      runtimeScene.getLayer(\"\").getRenderer().getThreeScene().background = null;",
            "      this._render_WithThreeJS(S, C);",
            "    }",
            "  }",
            "  if (!runtimeScene.getRenderer().getPIXIRenderer()._clear_WithThreeJS) {",
            "    runtimeScene.getRenderer().getPIXIRenderer()._clear_WithThreeJS = runtimeScene.getRenderer().getPIXIRenderer().clear;",
            "    runtimeScene.getRenderer().getPIXIRenderer().clear = function() {",
            "      // PixiJS のレンダラーが利用される場合の透過設定",
            "      runtimeScene.setBackgroundColor(0,0,0);",
            "      if (this.background) {",
            "        this.background.alpha = 0;// For PixiJS 7",
            "      } else {",
            "        this.backgroundAlpha = 0;// For PixiJS 6",
            "      }",
            "      this._clear_WithThreeJS();",
            "    }",
            "  }",
            "} else {",
            "  console.log(\"[WithThreeJS] Built-in 3D is disabled.\");",
            "  // 警告表示",
            "  let AlertElement = document.createElement('div');",
            "  AlertElement.innerHTML = `<strong>Warning from WithThreeJS</strong><br>",
            "  Please add an \"Enable WithThreeJS\" object to a scene.<br>",
            "  For more information, <a href=\"https://pandako.itch.io/with-threejs-extension-for-gdevelop/devlog/631434/about-the-warning-please-add-an-enable-withthreejs-object-to-a-scene\" target=\"_blank\" style=\"color:yellow\">please click here</a>.`;",
            "  AlertElement.style.position = \"absolute\";",
            "  AlertElement.style.zIndex = 999;",
            "  AlertElement.style.top = 0;",
            "  AlertElement.style.left = 0;",
            "  AlertElement.style.backgroundColor = \"red\";",
            "  AlertElement.style.color = \"white\";",
            "  AlertElement.style.padding = \"0.5em\";",
            "  document.body.appendChild(AlertElement);",
            "  return;",
            "}",
            "//",
            "const ProjectionScale = eventsFunctionContext.getArgument(\"ProjectionScale\") || 1;",
            "let ViewMode = eventsFunctionContext.getArgument(\"ViewMode\");",
            "if (ViewMode !== \"Top Down\" && ViewMode !== \"Side\") {",
            "  ViewMode = \"Top Down\";",
            "}",
            "gdjs.__WithThreeJS.set(\"ProjectionScale\", ProjectionScale);",
            "gdjs.__WithThreeJS.set(\"ViewMode\", ViewMode);",
            "//",
            "const Canvas2D = document.getElementsByTagName(\"canvas\")[0];",
            "gdjs.__WithThreeJS.set(\"Canvas2D\", Canvas2D);",
            "const Rect = Canvas2D.getBoundingClientRect();",
            "//",
            "let Scene;",
            "if (gdjs.__WithThreeJS.has(\"Scene\")) {",
            "  Scene = gdjs.__WithThreeJS.get(\"Scene\");",
            "} else {",
            "  Scene = new THREE.Scene();",
            "  gdjs.__WithThreeJS.set(\"Scene\", Scene);",
            "}",
            "Scene.name =\"Scene\";",
            "if (!gdjs.__WithThreeJS.get(\"SceneIsReady\")) {",
            "  gdjs.__WithThreeJS.set(\"SceneIsReady\", runtimeScene.getName());",
            "}",
            "//",
            "const BG_RGB = eventsFunctionContext.getArgument(\"BackGroundColor\") || \"0;0;0\";",
            "const BG_Img = eventsFunctionContext.getArgument(\"BackGroundImage\");",
            "const Ambient_RGB = eventsFunctionContext.getArgument(\"AmbientColor\") || \"255;255;255\";",
            "const FogColor = eventsFunctionContext.getArgument(\"FogColor\") || \"\";",
            "const FogNear = eventsFunctionContext.getArgument(\"FogNear\") || 1;",
            "const FogFar = eventsFunctionContext.getArgument(\"FogFar\") || 1000;",
            "//",
            "if (Scene.background) {",
            "  if (Scene.background.isTexture) {",
            "    Scene.background.dispose();",
            "    Scene.background = null;",
            "  }",
            "}",
            "//",
            "if (BG_Img !== \"\") {",
            "  const Resource = runtimeScene.getGame().getImageManager().getPIXITexture(BG_Img).baseTexture.resource;",
            "  const ResourceWidth = Resource.width;",
            "  const ResourceHeight = Resource.height;",
            "  const BGTexture = new THREE.Texture();",
            "  BGTexture.image = Resource.source;",
            "  if (ResourceWidth == ResourceHeight * 2) {",
            "    BGTexture.mapping = THREE.EquirectangularReflectionMapping;",
            "  }",
            "  BGTexture.colorSpace = THREE.SRGBColorSpace;",
            "  BGTexture.needsUpdate = true;//必須",
            "  Scene.background = BGTexture;",
            "} else {",
            "  const RGB = gdjs.rgbOrHexToRGBColor(BG_RGB);",
            "  Scene.background = new THREE.Color(`rgb(${RGB[0]}, ${RGB[1]}, ${RGB[2]})`);",
            "}",
            "//",
            "let AmbientLight;",
            "const AmbientColor = Ambient_RGB.split(\";\");",
            "if (gdjs.__WithThreeJS.has(\"AmbientLight\")) {",
            "  AmbientLight = gdjs.__WithThreeJS.get(\"AmbientLight\");",
            "} else {",
            "  AmbientLight = new THREE.AmbientLight();",
            "  AmbientLight.intensity = gdjs.__WithThreeJS.get(\"LightIntensityScale\");// Three.js r160",
            "  gdjs.__WithThreeJS.set(\"AmbientLight\", AmbientLight);",
            "}",
            "Scene.add(AmbientLight);",
            "AmbientLight.color.set(`rgb(${AmbientColor[0]}, ${AmbientColor[1]}, ${AmbientColor[2]})`);",
            "//",
            "if (FogColor === \"\") {",
            "  Scene.fog = null;",
            "} else {",
            "  const RGB = FogColor.split(\";\");",
            "  Scene.fog = new THREE.Fog(`rgb(${RGB[0]}, ${RGB[1]}, ${RGB[2]})`, FogNear, FogFar);",
            "  // Scene.fog = new THREE.FogExp2(\"rgb(0,0,0)\", 0.005);",
            "}",
            "//",
            "// 複数カメラ",
            "let AllCams, Camera1, Camera2, Camera3, Camera4;",
            "if (gdjs.__WithThreeJS.has(\"AllCams\")) {",
            "  AllCams = gdjs.__WithThreeJS.get(\"AllCams\");",
            "  Camera1 = AllCams.get(\"Camera1\");",
            "  Camera2 = AllCams.get(\"Camera2\");",
            "  Camera3 = AllCams.get(\"Camera3\");",
            "  Camera4 = AllCams.get(\"Camera4\");",
            "} else {",
            "  AllCams = new Map();",
            "  Camera1 = new THREE.PerspectiveCamera();",
            "  Camera2 = new THREE.PerspectiveCamera();",
            "  Camera3 = new THREE.PerspectiveCamera();",
            "  Camera4 = new THREE.PerspectiveCamera();",
            "  AllCams.set(\"Camera1\", Camera1);",
            "  AllCams.set(\"Camera2\", Camera2);",
            "  AllCams.set(\"Camera3\", Camera3);",
            "  AllCams.set(\"Camera4\", Camera4);",
            "  gdjs.__WithThreeJS.set(\"AllCams\", AllCams);",
            "}",
            "for (const [K, V] of AllCams) {",
            "  V.name = K;",
            "  V.fov = 50;",
            "  V.aspect = Rect.width / Rect.height;",
            "  V.near = 0.1;",
            "  V.far = 10000;//1000",
            "  V.position.set(0, 0, 0);",
            "  V.rotation.set(0, 0, 0);",
            "  V.zoom = 1;",
            "  V.layers.enable(0);",
            "  V.layers.enable(1);",
            "  V.updateProjectionMatrix();//必須",
            "  V.userData.CameraStatus = {};",
            "  V.userData.CameraStatus.Active = false;",
            "  V.userData.CameraStatus.T = 1;",
            "  V.userData.CameraStatus.B = 0;",
            "  V.userData.CameraStatus.L = 0;",
            "  V.userData.CameraStatus.R = 1;",
            "  V.userData.CameraStatus.X = 0;",
            "  V.userData.CameraStatus.Y = 0;",
            "  V.userData.CameraStatus.W = Rect.width;",
            "  V.userData.CameraStatus.H = Rect.height;",
            "}",
            "Camera1.userData.CameraStatus.Active = true;",
            "//",
            "let Listener;",
            "if (gdjs.__WithThreeJS.has(\"Listener\")) {",
            "  Listener = gdjs.__WithThreeJS.get(\"Listener\");",
            "} else {",
            "  Listener = new THREE.AudioListener();",
            "  gdjs.__WithThreeJS.set(\"Listener\", Listener);",
            "}",
            "Listener.name =\"Listener\";",
            "Camera1.add(Listener);",
            "//",
            "let Renderer;",
            "if (gdjs.__WithThreeJS.has(\"Renderer\")) {",
            "  Renderer = gdjs.__WithThreeJS.get(\"Renderer\");",
            "} else {",
            "  Renderer = new THREE.WebGLRenderer();",
            "  document.body.appendChild( Renderer.domElement );",
            "  gdjs.__WithThreeJS.set(\"Renderer\", Renderer);",
            "}",
            "Renderer.setPixelRatio(window.devicePixelRatio);",
            "// Renderer.setSize( window.innerWidth, window.innerHeight );",
            "Renderer.setSize(Rect.width, Rect.height);",
            "Renderer.domElement.id = \"WithThreeJS_Canvas\";",
            "Renderer.domElement.style.position = \"absolute\";",
            "Renderer.domElement.style.zIndex = -99;",
            "Renderer.domElement.style.left = Rect.left + \"px\";",
            "Renderer.domElement.style.top = Rect.top + \"px\";",
            "Renderer.setScissorTest(true);",
            "Renderer.shadowMap.enabled = false;",
            "Renderer.shadowMap.type = THREE.PCFSoftShadowMap;//THREE.BasicShadowMap THREE.PCFShadowMap THREE.PCFSoftShadowMap THREE.VSMShadowMap",
            "// Renderer.outputColorSpace = THREE.LinearSRGBColorSpace;//NoColorSpace SRGBColorSpace LinearSRGBColorSpace",
            "//",
            "let AnimationMixer;",
            "if (gdjs.__WithThreeJS.has(\"AnimationMixer\")) {",
            "  AnimationMixer = gdjs.__WithThreeJS.get(\"AnimationMixer\");",
            "} else {",
            "  AnimationMixer = new THREE.AnimationMixer(Scene);",
            "  gdjs.__WithThreeJS.set(\"AnimationMixer\", AnimationMixer);",
            "}",
            "//",
            "let AnimationActions;",
            "if (gdjs.__WithThreeJS.has(\"AnimationActions\")) {",
            "  AnimationActions = gdjs.__WithThreeJS.get(\"AnimationActions\");",
            "} else {",
            "  AnimationActions = new Map();",
            "  gdjs.__WithThreeJS.set(\"AnimationActions\", AnimationActions);",
            "}",
            "//",
            "// Resize",
            "window.addEventListener('resize', () => {",
            "  const Rect = Canvas2D.getBoundingClientRect();",
            "",
            "  // レンダラーのサイズを調整する",
            "  Renderer.setPixelRatio(window.devicePixelRatio);",
            "  Renderer.setSize(Rect.width, Rect.height);",
            "",
            "  // カメラのアスペクト比を正す",
            "  // Camera.aspect = Rect.width / Rect.height;",
            "  // Camera.updateProjectionMatrix();",
            "  for (const [K, V] of AllCams) {",
            "    const T = V.userData.CameraStatus.T;",
            "    const B = V.userData.CameraStatus.B;",
            "    const L = V.userData.CameraStatus.L;",
            "    const R = V.userData.CameraStatus.R;",
            "    const X = V.userData.CameraStatus.X = L * Rect.width;",
            "    const Y = V.userData.CameraStatus.Y = B * Rect.height;",
            "    const W = V.userData.CameraStatus.W = (R - L) * Rect.width;",
            "    const H = V.userData.CameraStatus.H = (T - B) * Rect.height;",
            "    V.aspect = W / H;",
            "    V.updateProjectionMatrix();",
            "  }",
            "",
            "  // CSS",
            "  Renderer.domElement.style.position = \"absolute\";",
            "  Renderer.domElement.style.zIndex = -99;",
            "  Renderer.domElement.style.left = Rect.left + \"px\";",
            "  Renderer.domElement.style.top = Rect.top + \"px\";",
            "});",
            "",
            "",
            ""
          ],
          "parameterObjects": "",
          "useStrict": true,
          "eventsSheetExpanded": true
        }
      ],
      "parameters": [
        {
          "description": "Background Color",
          "name": "BackGroundColor",
          "type": "color"
        },
        {
          "description": "Background Image",
          "name": "BackGroundImage",
          "type": "imageResource"
        },
        {
          "description": "Ambient Light Color",
          "name": "AmbientColor",
          "type": "color"
        },
        {
          "description": "Fog Color (\"\" is none fog)",
          "name": "FogColor",
          "type": "color"
        },
        {
          "description": "Fog Start Distance (Default: 1)",
          "longDescription": "Distance to start applying fog.",
          "name": "FogNear",
          "type": "expression"
        },
        {
          "description": "Fog Maximum Distance (Default: 1000)",
          "longDescription": "Distance to maximum fog.",
          "name": "FogFar",
          "type": "expression"
        },
        {
          "description": "Projection Scale (Recommended: 1)",
          "longDescription": "Only affects WithThreeJS Behaviors and WithThreeJS Custom Objects.  \nAffects X, Y, Z and Width, Height, Depth.",
          "name": "ProjectionScale",
          "type": "expression"
        },
        {
          "description": "View Mode",
          "longDescription": "Only affects WithThreeJS Behaviors and WithThreeJS Custom Objects.  \nTop Down: 2D[X, Y, Z-Order] -> 3D[X, Z-Order, Y] or Side: 2D[X, Y, Z-Order] -> 3D[X, -Y, Z-Order]",
          "name": "ViewMode",
          "supplementaryInformation": "[\"Top Down\",\"Side\"]",
          "type": "stringWithSelector"
        }
      ],
      "objectGroups": []
    },
    {
      "fullName": "Created Scene Name (Private)",
      "functionType": "StringExpression",
      "name": "CreatedSceneName",
      "private": true,
      "sentence": "",
      "events": [
        {
          "type": "BuiltinCommonInstructions::JsCode",
          "inlineCode": "eventsFunctionContext.returnValue = gdjs.__WithThreeJS.get(\"SceneIsReady\");",
          "parameterObjects": "",
          "useStrict": true,
          "eventsSheetExpanded": false
        }
      ],
      "expressionType": {
        "type": "string"
      },
      "parameters": [],
      "objectGroups": []
    },
    {
      "description": "Clear 3D Scene. Removes all 3D Objects in the 3D Scene.\nAs a result, this action also removes 2D Objects that have 3D Projection Behaviors.\nThis action does not clear the loaded 3D Texture data and the loaded 3D Model data.\nThey will continue to be accessible by ID.",
      "fullName": "🗑️Clear 3D Scene",
      "functionType": "Action",
      "group": "3D Scene",
      "name": "Clear3DScene",
      "sentence": "🗑️Clear 3D Scene",
      "events": [
        {
          "type": "BuiltinCommonInstructions::JsCode",
          "inlineCode": [
            "if (!gdjs.__WithThreeJS.has(\"Renderer\")) {",
            "    // console.warn(\"!\");",
            "    return;",
            "}",
            "const Scene = gdjs.__WithThreeJS.get(\"Scene\");",
            "const AnimationMixer = gdjs.__WithThreeJS.get(\"AnimationMixer\");",
            "const AnimationActions = gdjs.__WithThreeJS.get(\"AnimationActions\");",
            "//",
            "const All = runtimeScene.getAdhocListOfAllInstances();",
            "for (let i = All.length - 1; i >= 0; i--){",
            "    if (",
            "           All[i].hasBehavior(\"SpriteProjection\")",
            "        || All[i].hasBehavior(\"BoardProjection\")",
            "        || All[i].hasBehavior(\"PlaneProjectionFromTiled\")",
            "        || All[i].hasBehavior(\"BoxProjectionFromTiled\")",
            "        || All[i].type == \"WithThreeJS::Box3D\"",
            "        || All[i].hasBehavior(\"LinkedLight\")",
            "        ) {",
            "        All[i].deleteFromScene(runtimeScene);",
            "    }",
            "}",
            "//",
            "Scene.traverse((Child) => {",
            "    if (Child.type === \"Audio\") {",
            "        if (Child.isPlaying) {",
            "            Child.stop();",
            "        }",
            "    }",
            "});",
            "//",
            "AnimationMixer.stopAllAction();",
            "for (const [K, V] of AnimationActions) {",
            "    for (const [KK, VV] of V) {",
            "        AnimationMixer.uncacheAction(VV.getClip(), VV.getRoot());",
            "        AnimationMixer.uncacheClip(VV.getClip());",
            "        AnimationMixer.uncacheRoot(VV.getRoot());",
            "    }",
            "}",
            "AnimationActions.clear();",
            "//",
            "gdjs.__WithThreeJS.get(\"ObjectList\").clear();",
            "Scene.clear();",
            "",
            ""
          ],
          "parameterObjects": "",
          "useStrict": true,
          "eventsSheetExpanded": true
        }
      ],
      "parameters": [],
      "objectGroups": []
    },
    {
      "description": "Load image from GDevelop resources and create 3D Texture.",
      "fullName": "Load 3D Texture V2 (Deprecated)",
      "functionType": "Action",
      "group": "3D Scene",
      "name": "Load3DTextureV2",
      "private": true,
      "sentence": "⚠️ Load 3D Texture V2 (Resource: _PARAM1_, ID: _PARAM2_, Repeat: _PARAM3_, _PARAM4_, Anti-Aliasing: _PARAM5_)",
      "events": [
        {
          "type": "BuiltinCommonInstructions::JsCode",
          "inlineCode": [
            "if (!gdjs.__WithThreeJS.has(\"Renderer\")) {",
            "    console.warn(\"!\");",
            "    return;",
            "}",
            "if (!gdjs.__WithThreeJS.has(\"Textures\")) {",
            "    gdjs.__WithThreeJS.set(\"Textures\", new Map());",
            "}",
            "let Textures = gdjs.__WithThreeJS.get(\"Textures\");",
            "const ResourceName = eventsFunctionContext.getArgument(\"ResourceName\");",
            "const TextureId = eventsFunctionContext.getArgument(\"TextureId\");",
            "const RepeatU = eventsFunctionContext.getArgument(\"RepeatU\");",
            "const RepeatV = eventsFunctionContext.getArgument(\"RepeatV\");",
            "const AntiAliasing = eventsFunctionContext.getArgument(\"AntiAliasing\");",
            "//",
            "if (!Textures.has(TextureId)) {",
            "    const T = new THREE.Texture();",
            "    T.image = runtimeScene.getGame().getImageManager().getPIXITexture(ResourceName).baseTexture.resource.source;",
            "    T.wrapS = THREE.RepeatWrapping;",
            "    T.wrapT = THREE.RepeatWrapping;",
            "    T.repeat.set(RepeatU, RepeatV);",
            "    if (!AntiAliasing) {",
            "        T.magFilter = THREE.NearestFilter;// THREE.LinearFilter",
            "        T.minFilter = THREE.NearestFilter;// THREE.LinearMipmapLinearFilter",
            "    }",
            "    T.colorSpace = THREE.SRGBColorSpace;//NoColorSpace SRGBColorSpace LinearSRGBColorSpace",
            "    T.needsUpdate = true;//必須",
            "    Textures.set(TextureId, T);",
            "}",
            "",
            ""
          ],
          "parameterObjects": "",
          "useStrict": true,
          "eventsSheetExpanded": true
        }
      ],
      "parameters": [
        {
          "description": "GDevelop Resource Name (Image)",
          "longDescription": "Escape is required. example: \"assets\\\\Image.png\" -> \"assets\\\\\\\\Image.png\"",
          "name": "ResourceName",
          "type": "string"
        },
        {
          "description": "3D Texture ID",
          "name": "TextureId",
          "supplementaryInformation": "scene3D Texture ID",
          "type": "identifier"
        },
        {
          "description": "Texture Repeat U",
          "name": "RepeatU",
          "type": "expression"
        },
        {
          "description": "Texture Repeat V",
          "name": "RepeatV",
          "type": "expression"
        },
        {
          "defaultValue": "True",
          "description": "Anti-Aliasing",
          "name": "AntiAliasing",
          "optional": true,
          "supplementaryInformation": "[\"Antialiased\",\"No Antialiasing\"]",
          "type": "trueorfalse"
        }
      ],
      "objectGroups": []
    },
    {
      "description": "Load image from GDevelop resources and create 3D Texture.",
      "fullName": "📥Load 3D Texture",
      "functionType": "Action",
      "group": "3D Scene",
      "name": "Load3DTextureV3",
      "sentence": "📥Load 3D Texture (Resource: _PARAM1_, ID: _PARAM2_, Repeat: _PARAM3_, _PARAM4_, Anti-Aliasing: _PARAM5_)",
      "events": [
        {
          "type": "BuiltinCommonInstructions::JsCode",
          "inlineCode": [
            "if (!gdjs.__WithThreeJS.has(\"Renderer\")) {",
            "    console.warn(\"!\");",
            "    return;",
            "}",
            "if (!gdjs.__WithThreeJS.has(\"Textures\")) {",
            "    gdjs.__WithThreeJS.set(\"Textures\", new Map());",
            "}",
            "let Textures = gdjs.__WithThreeJS.get(\"Textures\");",
            "const ResourceName = eventsFunctionContext.getArgument(\"ResourceName\");",
            "const TextureId = eventsFunctionContext.getArgument(\"TextureId\");",
            "const RepeatU = eventsFunctionContext.getArgument(\"RepeatU\");",
            "const RepeatV = eventsFunctionContext.getArgument(\"RepeatV\");",
            "const AntiAliasing = eventsFunctionContext.getArgument(\"AntiAliasing\");",
            "//",
            "if (!Textures.has(TextureId)) {",
            "    const T = new THREE.Texture();",
            "    T.image = runtimeScene.getGame().getImageManager().getPIXITexture(ResourceName).baseTexture.resource.source;",
            "    T.wrapS = THREE.RepeatWrapping;",
            "    T.wrapT = THREE.RepeatWrapping;",
            "    T.repeat.set(RepeatU, RepeatV);",
            "    if (!AntiAliasing) {",
            "        T.magFilter = THREE.NearestFilter;// THREE.LinearFilter",
            "        T.minFilter = THREE.NearestFilter;// THREE.LinearMipmapLinearFilter",
            "    }",
            "    T.colorSpace = THREE.SRGBColorSpace;//NoColorSpace SRGBColorSpace LinearSRGBColorSpace",
            "    T.needsUpdate = true;//必須",
            "    Textures.set(TextureId, T);",
            "}",
            "",
            ""
          ],
          "parameterObjects": "",
          "useStrict": true,
          "eventsSheetExpanded": true
        }
      ],
      "parameters": [
        {
          "description": "GDevelop Resource Name (Image)",
          "name": "ResourceName",
          "type": "imageResource"
        },
        {
          "description": "3D Texture ID",
          "name": "TextureId",
          "supplementaryInformation": "scene3D Texture ID",
          "type": "identifier"
        },
        {
          "description": "Texture Repeat U",
          "name": "RepeatU",
          "type": "expression"
        },
        {
          "description": "Texture Repeat V",
          "name": "RepeatV",
          "type": "expression"
        },
        {
          "defaultValue": "True",
          "description": "Anti-Aliasing",
          "name": "AntiAliasing",
          "optional": true,
          "supplementaryInformation": "[\"Antialiased\",\"No Antialiasing\"]",
          "type": "trueorfalse"
        }
      ],
      "objectGroups": []
    },
    {
      "fullName": "📥Load 3D Model From OBJ",
      "functionType": "Action",
      "group": "3D Scene",
      "name": "Load3DModelFromOBJ",
      "sentence": "📥Load 3D Model From OBJ (ID: _PARAM2_)",
      "events": [
        {
          "type": "BuiltinCommonInstructions::JsCode",
          "inlineCode": [
            "if (!gdjs.__WithThreeJS.has(\"Renderer\")) {",
            "    console.warn(\"!\");",
            "    return;",
            "}",
            "if (!gdjs.__WithThreeJS.has(\"Models\")) {",
            "    gdjs.__WithThreeJS.set(\"Models\", new Map());",
            "}",
            "const Models = gdjs.__WithThreeJS.get(\"Models\");",
            "const OBJ = eventsFunctionContext.getArgument(\"OBJ\");",
            "const ModelId = eventsFunctionContext.getArgument(\"ModelId\");",
            "//",
            "const OBJLoader = new THREE.OBJLoader();",
            "const Model = OBJLoader.parse(OBJ);",
            "Models.set(ModelId, Model);",
            "",
            ""
          ],
          "parameterObjects": "",
          "useStrict": true,
          "eventsSheetExpanded": true
        }
      ],
      "parameters": [
        {
          "description": "OBJ",
          "longDescription": "Paste the contents of the OBJ file.",
          "name": "OBJ",
          "type": "string"
        },
        {
          "description": "3D Model ID",
          "name": "ModelId",
          "supplementaryInformation": "scene3D Model ID",
          "type": "identifier"
        }
      ],
      "objectGroups": []
    },
    {
      "description": "Do a Raycast.\nYou can get the count of 3D Objects in the result with the \"Raycast Result Count\" expression.\nThe result can be accessed via the \"Raycast Result Number\" expression or the \"Raycast Result String\" string expression.",
      "fullName": "🔎Raycast",
      "functionType": "Action",
      "group": "3D Raycast",
      "name": "Raycast",
      "sentence": "🔎Raycast (From: _PARAM1_, _PARAM2_, _PARAM3_, To: _PARAM4_, _PARAM5_, _PARAM6_)",
      "events": [
        {
          "type": "BuiltinCommonInstructions::JsCode",
          "inlineCode": [
            "if (!gdjs.__WithThreeJS.has(\"Renderer\")) {",
            "    console.warn(\"!\");",
            "    return;",
            "}",
            "if (!gdjs.__WithThreeJS.has(\"Raycaster\")) {",
            "    gdjs.__WithThreeJS.set(\"Raycaster\", new THREE.Raycaster());",
            "    gdjs.__WithThreeJS.set(\"RaycastResult\", new Array());",
            "}",
            "const Scene = gdjs.__WithThreeJS.get(\"Scene\");",
            "// const Camera = gdjs.__WithThreeJS.get(\"Camera\");",
            "const Camera = gdjs.__WithThreeJS.get(\"GetCamera\")(1);// 現状は1で固定",
            "const Raycaster = gdjs.__WithThreeJS.get(\"Raycaster\");",
            "//",
            "const FromX = eventsFunctionContext.getArgument(\"FromX\");",
            "const FromY = eventsFunctionContext.getArgument(\"FromY\");",
            "const FromZ = eventsFunctionContext.getArgument(\"FromZ\");",
            "const ToX = eventsFunctionContext.getArgument(\"ToX\");",
            "const ToY = eventsFunctionContext.getArgument(\"ToY\");",
            "const ToZ = eventsFunctionContext.getArgument(\"ToZ\");",
            "//",
            "const From = new THREE.Vector3(FromX, FromY, FromZ);",
            "const To = new THREE.Vector3(ToX, ToY, ToZ);",
            "const Distance = From.distanceTo(To);",
            "const Direction = new THREE.Vector3().subVectors(To, From).normalize();",
            "//",
            "Raycaster.camera = Camera;",
            "Raycaster.set(From, Direction);",
            "Raycaster.far = Distance;",
            "Raycaster.layers.enable(0);",
            "Raycaster.layers.enable(2);",
            "gdjs.__WithThreeJS.set(\"RaycastResult\", Raycaster.intersectObjects(Scene.children, true));",
            "",
            ""
          ],
          "parameterObjects": "",
          "useStrict": true,
          "eventsSheetExpanded": true
        }
      ],
      "parameters": [
        {
          "description": "From World Position X",
          "name": "FromX",
          "type": "expression"
        },
        {
          "description": "From World Position Y",
          "name": "FromY",
          "type": "expression"
        },
        {
          "description": "From World Position Z",
          "name": "FromZ",
          "type": "expression"
        },
        {
          "description": "To World Position X",
          "name": "ToX",
          "type": "expression"
        },
        {
          "description": "To World Position Y",
          "name": "ToY",
          "type": "expression"
        },
        {
          "description": "To World Position Z",
          "name": "ToZ",
          "type": "expression"
        }
      ],
      "objectGroups": []
    },
    {
      "description": "Do a Raycast from the 3D Camera.\nYou can get the count of 3D Objects in the result with the \"Raycast Result Count\" expression.\nThe result can be accessed via the \"Raycast Result Number\" expression or the \"Raycast Result String\" string expression.",
      "fullName": "🔎Raycast From 3D Camera",
      "functionType": "Action",
      "group": "3D Raycast",
      "name": "RaycastFrom3DCamera",
      "sentence": "🔎Raycast From 3D Camera (ID: _PARAM1_, Screen: _PARAM2_, _PARAM3_)",
      "events": [
        {
          "type": "BuiltinCommonInstructions::JsCode",
          "inlineCode": [
            "if (!gdjs.__WithThreeJS.has(\"Renderer\")) {",
            "    console.warn(\"!\");",
            "    return;",
            "}",
            "if (!gdjs.__WithThreeJS.has(\"Raycaster\")) {",
            "    gdjs.__WithThreeJS.set(\"Raycaster\", new THREE.Raycaster());",
            "    gdjs.__WithThreeJS.set(\"RaycastResult\", new Array());",
            "}",
            "const Scene = gdjs.__WithThreeJS.get(\"Scene\");",
            "// const Camera = gdjs.__WithThreeJS.get(\"Camera\");",
            "const Raycaster = gdjs.__WithThreeJS.get(\"Raycaster\");",
            "//",
            "const Id = eventsFunctionContext.getArgument(\"Id\");",
            "const Camera = gdjs.__WithThreeJS.get(\"GetCamera\")(Id);",
            "const ScreenX = eventsFunctionContext.getArgument(\"ScreenX\");",
            "const ScreenY = eventsFunctionContext.getArgument(\"ScreenY\");",
            "const ScreenPoint = new THREE.Vector2();",
            "//",
            "Camera.updateWorldMatrix(false, false);//必要",
            "const T = Camera.userData.CameraStatus.T;",
            "const B = Camera.userData.CameraStatus.B;",
            "const L = Camera.userData.CameraStatus.L;",
            "const R = Camera.userData.CameraStatus.R;",
            "const GameResolutionWidth = runtimeScene.getGame().getGameResolutionWidth();",
            "const GameResolutionHeight = runtimeScene.getGame().getGameResolutionHeight();",
            "const ScreenResolutionWidth = GameResolutionWidth * (R - L);",
            "const ScreenResolutionHeight = GameResolutionHeight * (T - B);",
            "const CameraScreenX = ScreenX - (L * GameResolutionWidth);",
            "const CameraScreenY = ScreenY - ((1 - T) * GameResolutionHeight);",
            "//",
            "ScreenPoint.x = (CameraScreenX / ScreenResolutionWidth) * 2 - 1;",
            "ScreenPoint.y = -(CameraScreenY / ScreenResolutionHeight) * 2 + 1;",
            "//",
            "Raycaster.setFromCamera(ScreenPoint, Camera);",
            "Raycaster.far = Camera.far;",
            "Raycaster.layers.enable(0);",
            "Raycaster.layers.enable(2);",
            "gdjs.__WithThreeJS.set(\"RaycastResult\", Raycaster.intersectObjects(Scene.children, true));",
            "",
            ""
          ],
          "parameterObjects": "",
          "useStrict": true,
          "eventsSheetExpanded": true
        }
      ],
      "parameters": [
        {
          "description": "3D Camera ID (1 to 4)",
          "name": "Id",
          "type": "expression"
        },
        {
          "description": "Screen X",
          "name": "ScreenX",
          "type": "expression"
        },
        {
          "description": "Screen Y",
          "name": "ScreenY",
          "type": "expression"
        }
      ],
      "objectGroups": []
    },
    {
      "description": "Do a Raycast from the 3D Object. (Z axis direction)\nYou can get the count of 3D Objects in the result with the \"Raycast Result Count\" expression.\nThe result can be accessed via the \"Raycast Result Number\" expression or the \"Raycast Result String\" string expression.",
      "fullName": "🔎Raycast From 3D Object",
      "functionType": "Action",
      "group": "3D Raycast",
      "name": "RaycastFrom3DObject",
      "sentence": "🔎Raycast From 3D Object (ID: _PARAM1_, Distance: _PARAM2_)",
      "events": [
        {
          "type": "BuiltinCommonInstructions::JsCode",
          "inlineCode": [
            "if (!gdjs.__WithThreeJS.has(\"Renderer\")) {",
            "    console.warn(\"!\");",
            "    return;",
            "}",
            "if (!gdjs.__WithThreeJS.has(\"Raycaster\")) {",
            "    gdjs.__WithThreeJS.set(\"Raycaster\", new THREE.Raycaster());",
            "    gdjs.__WithThreeJS.set(\"RaycastResult\", new Array());",
            "}",
            "const Scene = gdjs.__WithThreeJS.get(\"Scene\");",
            "const Camera = gdjs.__WithThreeJS.get(\"GetCamera\")(1);// 現状は1で固定",
            "const Raycaster = gdjs.__WithThreeJS.get(\"Raycaster\");",
            "//",
            "const Id = eventsFunctionContext.getArgument(\"Id\");",
            "const Distance = eventsFunctionContext.getArgument(\"Distance\");",
            "//",
            "const Obj = gdjs.__WithThreeJS.get(\"SearchObject\")(Id);",
            "if (!Obj) {",
            "    console.warn(\"3D Object not found: \" + Id);",
            "    return;",
            "}",
            "const WorldPosition = new THREE.Vector3();",
            "const WorldDirection = new THREE.Vector3();",
            "Obj.getWorldPosition(WorldPosition);",
            "Obj.getWorldDirection(WorldDirection);",
            "//",
            "Raycaster.camera = Camera;",
            "Raycaster.set(WorldPosition, WorldDirection);",
            "Raycaster.far = Distance;",
            "Raycaster.layers.enable(0);",
            "Raycaster.layers.enable(2);",
            "gdjs.__WithThreeJS.set(\"RaycastResult\", Raycaster.intersectObjects(Scene.children, true));",
            "",
            ""
          ],
          "parameterObjects": "",
          "useStrict": true,
          "eventsSheetExpanded": true
        }
      ],
      "parameters": [
        {
          "description": "3D Object ID",
          "name": "Id",
          "supplementaryInformation": "scene3D Object ID",
          "type": "identifier"
        },
        {
          "description": "Distance",
          "name": "Distance",
          "type": "expression"
        }
      ],
      "objectGroups": []
    },
    {
      "fullName": "🔎Place 3D Object Using Raycast Result",
      "functionType": "Action",
      "group": "3D Raycast",
      "name": "Place3DObjectUsingRaycastResult",
      "sentence": "🔎Place 3D Object Using Raycast Result (ID: _PARAM1_, Result: _PARAM2_, Position: _PARAM3_, Normal: _PARAM4_)",
      "events": [
        {
          "type": "BuiltinCommonInstructions::JsCode",
          "inlineCode": [
            "if (!gdjs.__WithThreeJS.has(\"Renderer\")) {",
            "    console.warn(\"!\");",
            "    return;",
            "}",
            "if (!gdjs.__WithThreeJS.has(\"RaycastResult\")) {",
            "    console.warn(\"No Raycast has been done yet.\");",
            "    return;",
            "}",
            "const Scene = gdjs.__WithThreeJS.get(\"Scene\");",
            "const RaycastResult = gdjs.__WithThreeJS.get(\"RaycastResult\");",
            "//",
            "const Id = eventsFunctionContext.getArgument(\"Id\");",
            "const Index = eventsFunctionContext.getArgument(\"Index\");",
            "const Position = eventsFunctionContext.getArgument(\"Position\");",
            "const Normal = eventsFunctionContext.getArgument(\"Normal\");",
            "//",
            "const Obj = gdjs.__WithThreeJS.get(\"SearchObject\")(Id);",
            "if (!Obj) {",
            "    console.warn(\"3D Object not found: \" + Id);",
            "    return;",
            "}",
            "if (Index < 0 || RaycastResult.length <= Index) {",
            "    console.warn(\"Incorrect Raycast Result index.\");",
            "    return;",
            "}",
            "//",
            "const Parent = Obj.parent;",
            "Scene.attach(Obj);",
            "if (Position) {",
            "    Obj.position.copy(RaycastResult[Index].point);",
            "}",
            "if (Normal && RaycastResult[Index].normal) {",
            "    const DirY = new THREE.Vector3(0, 1, 0);",
            "    const DifQua = new THREE.Quaternion();",
            "    DirY.applyQuaternion(Obj.quaternion);",
            "    DifQua.setFromUnitVectors(DirY, RaycastResult[Index].normal);",
            "    Obj.applyQuaternion(DifQua);",
            "}",
            "Parent.attach(Obj);",
            "",
            ""
          ],
          "parameterObjects": "",
          "useStrict": true,
          "eventsSheetExpanded": true
        }
      ],
      "parameters": [
        {
          "description": "3D Object ID",
          "name": "Id",
          "supplementaryInformation": "scene3D Object ID",
          "type": "identifier"
        },
        {
          "description": "Index of Raycast Result (0 or more)",
          "name": "Index",
          "type": "expression"
        },
        {
          "defaultValue": "yes",
          "description": "Position",
          "name": "Position",
          "optional": true,
          "type": "yesorno"
        },
        {
          "defaultValue": "yes",
          "description": "Normal",
          "name": "Normal",
          "optional": true,
          "type": "yesorno"
        }
      ],
      "objectGroups": []
    },
    {
      "description": "Count of 3D Objects in Raycast Result",
      "fullName": "Raycast Result Count",
      "functionType": "Expression",
      "group": "3D Raycast",
      "name": "RaycastResultCount",
      "sentence": "Raycast (From: _PARAM1_, _PARAM2_, _PARAM3_, To: _PARAM4_, _PARAM5_, _PARAM6_)",
      "events": [
        {
          "type": "BuiltinCommonInstructions::JsCode",
          "inlineCode": [
            "if (!gdjs.__WithThreeJS.has(\"Renderer\")) {",
            "    console.warn(\"!\");",
            "    return;",
            "}",
            "if (!gdjs.__WithThreeJS.has(\"RaycastResult\")) {",
            "    console.warn(\"No Raycast has been done yet.\");",
            "    return;",
            "}",
            "const RaycastResult = gdjs.__WithThreeJS.get(\"RaycastResult\");",
            "eventsFunctionContext.returnValue = RaycastResult.length;",
            "",
            ""
          ],
          "parameterObjects": "",
          "useStrict": true,
          "eventsSheetExpanded": true
        }
      ],
      "expressionType": {
        "type": "expression"
      },
      "parameters": [],
      "objectGroups": []
    },
    {
      "fullName": "Raycast Result Number",
      "functionType": "Expression",
      "group": "3D Raycast",
      "name": "RaycastResultNumber",
      "sentence": "Raycast (From: _PARAM1_, _PARAM2_, _PARAM3_, To: _PARAM4_, _PARAM5_, _PARAM6_)",
      "events": [
        {
          "type": "BuiltinCommonInstructions::JsCode",
          "inlineCode": [
            "if (!gdjs.__WithThreeJS.has(\"Renderer\")) {",
            "    console.warn(\"!\");",
            "    return;",
            "}",
            "if (!gdjs.__WithThreeJS.has(\"RaycastResult\")) {",
            "    console.warn(\"No Raycast has been done yet.\");",
            "    return;",
            "}",
            "const RaycastResult = gdjs.__WithThreeJS.get(\"RaycastResult\");",
            "//",
            "const Index = eventsFunctionContext.getArgument(\"Index\");",
            "const Item = eventsFunctionContext.getArgument(\"Item\");",
            "//",
            "if (Index < 0 || RaycastResult.length <= Index) {",
            "    // console.warn(\"Incorrect index.\");",
            "    eventsFunctionContext.returnValue = 0;",
            "    return;",
            "}",
            "if (Item == \"Distance\") {",
            "    eventsFunctionContext.returnValue = RaycastResult[Index].distance;",
            "} else if (Item == \"Point X\") {",
            "    eventsFunctionContext.returnValue = RaycastResult[Index].point.x;",
            "} else if (Item == \"Point Y\") {",
            "    eventsFunctionContext.returnValue = RaycastResult[Index].point.y;",
            "} else if (Item == \"Point Z\") {",
            "    eventsFunctionContext.returnValue = RaycastResult[Index].point.z;",
            "} else if (Item == \"Normal X\") {",
            "    eventsFunctionContext.returnValue = RaycastResult[Index].normal.x;",
            "} else if (Item == \"Normal Y\") {",
            "    eventsFunctionContext.returnValue = RaycastResult[Index].normal.y;",
            "} else if (Item == \"Normal Z\") {",
            "    eventsFunctionContext.returnValue = RaycastResult[Index].normal.z;",
            "}",
            "",
            ""
          ],
          "parameterObjects": "",
          "useStrict": true,
          "eventsSheetExpanded": true
        }
      ],
      "expressionType": {
        "type": "expression"
      },
      "parameters": [
        {
          "description": "Index (0 or more)",
          "name": "Index",
          "type": "expression"
        },
        {
          "description": "Item",
          "name": "Item",
          "supplementaryInformation": "[\"Distance\",\"Point X\",\"Point Y\",\"Point Z\",\"Normal X\",\"Normal Y\",\"Normal Z\"]",
          "type": "stringWithSelector"
        }
      ],
      "objectGroups": []
    },
    {
      "fullName": "Raycast Result String",
      "functionType": "StringExpression",
      "group": "3D Raycast",
      "name": "RaycastResultString",
      "sentence": "Raycast (From: _PARAM1_, _PARAM2_, _PARAM3_, To: _PARAM4_, _PARAM5_, _PARAM6_)",
      "events": [
        {
          "type": "BuiltinCommonInstructions::JsCode",
          "inlineCode": [
            "if (!gdjs.__WithThreeJS.has(\"Renderer\")) {",
            "    console.warn(\"!\");",
            "    return;",
            "}",
            "if (!gdjs.__WithThreeJS.has(\"RaycastResult\")) {",
            "    console.warn(\"No Raycast has been done yet.\");",
            "    return;",
            "}",
            "const RaycastResult = gdjs.__WithThreeJS.get(\"RaycastResult\");",
            "//",
            "const Index = eventsFunctionContext.getArgument(\"Index\");",
            "const Item = eventsFunctionContext.getArgument(\"Item\");",
            "//",
            "if (Index < 0 || RaycastResult.length <= Index) {",
            "    // console.warn(\"Incorrect index.\");",
            "    eventsFunctionContext.returnValue = \"\";",
            "    return;",
            "}",
            "if (Item == \"3D Object ID\") {",
            "    eventsFunctionContext.returnValue = RaycastResult[Index].object.name;",
            "} else if (Item == \"Parent 3D Object ID\") {",
            "    if (RaycastResult[Index].object.parent) {",
            "        eventsFunctionContext.returnValue = RaycastResult[Index].object.parent.name;",
            "    }",
            "}",
            "",
            ""
          ],
          "parameterObjects": "",
          "useStrict": true,
          "eventsSheetExpanded": true
        }
      ],
      "expressionType": {
        "type": "string"
      },
      "parameters": [
        {
          "description": "Index (0 or more)",
          "name": "Index",
          "type": "expression"
        },
        {
          "description": "Item",
          "name": "Item",
          "supplementaryInformation": "[\"3D Object ID\",\"Parent 3D Object ID\"]",
          "type": "stringWithSelector"
        }
      ],
      "objectGroups": []
    },
    {
      "fullName": "✨Create 3D Sprite",
      "functionType": "Action",
      "group": "3D Object",
      "name": "Create3DSprite",
      "sentence": "✨Create 3D Sprite (ID: _PARAM1_, X: _PARAM2_, Y: _PARAM3_, Z: _PARAM4_, Scale: _PARAM5_, Texture: _PARAM6_, αTest: _PARAM7_, Opacity: _PARAM8_, Blend: _PARAM9_)",
      "events": [
        {
          "type": "BuiltinCommonInstructions::JsCode",
          "inlineCode": [
            "if (!gdjs.__WithThreeJS.has(\"Renderer\")) {",
            "    console.warn(\"!\");",
            "    return;",
            "}",
            "if (!gdjs.__WithThreeJS.has(\"Textures\")) {",
            "    console.warn(\"!\");",
            "    return;",
            "}",
            "const Scene = gdjs.__WithThreeJS.get(\"Scene\");",
            "const Textures = gdjs.__WithThreeJS.get(\"Textures\");",
            "const TextureId = eventsFunctionContext.getArgument(\"TextureId\");",
            "if (!Textures.has(TextureId)) {",
            "    console.warn(\"3D Texture not found: \" + TextureId);",
            "    return;",
            "}",
            "const Id = eventsFunctionContext.getArgument(\"Id\");",
            "const X = eventsFunctionContext.getArgument(\"X\");",
            "const Y = eventsFunctionContext.getArgument(\"Y\");",
            "const Z = eventsFunctionContext.getArgument(\"Z\");",
            "const Scale = eventsFunctionContext.getArgument(\"Scale\");",
            "const AlphaTest = eventsFunctionContext.getArgument(\"AlphaTest\");",
            "const Opacity = eventsFunctionContext.getArgument(\"Opacity\");",
            "const Transparent = (AlphaTest !== 0 || Opacity !== 1);",
            "let Blend = THREE.NormalBlending;",
            "if (eventsFunctionContext.getArgument(\"Blend\") == \"Additive\") {",
            "    Blend = THREE.AdditiveBlending;",
            "} else if (eventsFunctionContext.getArgument(\"Blend\") == \"Subtractive\") {",
            "    Blend = THREE.SubtractiveBlending;",
            "} else if (eventsFunctionContext.getArgument(\"Blend\") == \"Multiply\") {",
            "    Blend = THREE.MultiplyBlending;",
            "}",
            "//",
            "const Texture = Textures.get(TextureId);",
            "const TextureWidth = Texture.image.width;",
            "const TextureHeight = Texture.image.height;",
            "const Material = new THREE.SpriteMaterial({map:Texture, transparent:Transparent, alphaTest:AlphaTest, blending:Blend, opacity:Opacity});",
            "const Sprite = new THREE.Sprite(Material);",
            "Sprite.geometry.computeBoundingBox();",
            "Sprite.position.set(X, Y, Z);",
            "Sprite.scale.set(TextureWidth * Scale, TextureHeight * Scale, 1);",
            "Sprite.name = Id;",
            "Scene.add(Sprite);",
            "",
            ""
          ],
          "parameterObjects": "",
          "useStrict": true,
          "eventsSheetExpanded": true
        }
      ],
      "parameters": [
        {
          "description": "3D Object ID",
          "name": "Id",
          "supplementaryInformation": "scene3D Object ID",
          "type": "identifier"
        },
        {
          "description": "X",
          "name": "X",
          "type": "expression"
        },
        {
          "description": "Y",
          "name": "Y",
          "type": "expression"
        },
        {
          "description": "Z",
          "name": "Z",
          "type": "expression"
        },
        {
          "description": "Scale",
          "longDescription": "Recommended value: 1",
          "name": "Scale",
          "type": "expression"
        },
        {
          "description": "3D Texture ID",
          "name": "TextureId",
          "supplementaryInformation": "scene3D Texture ID",
          "type": "identifier"
        },
        {
          "description": "Alpha Channel Test (0 to 1)",
          "longDescription": "Recommended values: 0 or 0.5  \nIf the texture is opaque, you can set the value to 0 to reduce the drawing load.",
          "name": "AlphaTest",
          "type": "expression"
        },
        {
          "description": "Opacity (0 to 1)",
          "longDescription": "1 is fully opaque.  \nIf the object is opaque, you can set the value to 1 to reduce the drawing load.",
          "name": "Opacity",
          "type": "expression"
        },
        {
          "description": "Blend Mode",
          "name": "Blend",
          "supplementaryInformation": "[\"Normal\",\"Additive\",\"Subtractive\",\"Multiply\"]",
          "type": "stringWithSelector"
        }
      ],
      "objectGroups": []
    },
    {
      "fullName": "✨Create 3D Plane",
      "functionType": "Action",
      "group": "3D Object",
      "name": "Create3DPlane",
      "sentence": "✨Create 3D Plane (ID: _PARAM1_, X: _PARAM2_, Y: _PARAM3_, Z: _PARAM4_, AX: _PARAM5_, AY: _PARAM6_, AZ: _PARAM7_, W: _PARAM8_, H: _PARAM9_, Texture: _PARAM10_, αTest: _PARAM11_, Opacity: _PARAM12_, Blend: _PARAM13_)",
      "events": [
        {
          "type": "BuiltinCommonInstructions::JsCode",
          "inlineCode": [
            "if (!gdjs.__WithThreeJS.has(\"Renderer\")) {",
            "    console.warn(\"!\");",
            "    return;",
            "}",
            "if (!gdjs.__WithThreeJS.has(\"Textures\")) {",
            "    console.warn(\"!\");",
            "    return;",
            "}",
            "const Scene = gdjs.__WithThreeJS.get(\"Scene\");",
            "const Textures = gdjs.__WithThreeJS.get(\"Textures\");",
            "const TextureId = eventsFunctionContext.getArgument(\"TextureId\");",
            "if (!Textures.has(TextureId)) {",
            "    console.warn(\"3D Texture not found: \" + TextureId);",
            "    return;",
            "}",
            "const Id = eventsFunctionContext.getArgument(\"Id\");",
            "const X = eventsFunctionContext.getArgument(\"X\");",
            "const Y = eventsFunctionContext.getArgument(\"Y\");",
            "const Z = eventsFunctionContext.getArgument(\"Z\");",
            "const AngleX = eventsFunctionContext.getArgument(\"AngleX\");",
            "const AngleY = eventsFunctionContext.getArgument(\"AngleY\");",
            "const AngleZ = eventsFunctionContext.getArgument(\"AngleZ\");",
            "const Width = eventsFunctionContext.getArgument(\"Width\");",
            "const Height = eventsFunctionContext.getArgument(\"Height\");",
            "const AlphaTest = eventsFunctionContext.getArgument(\"AlphaTest\");",
            "const Opacity = eventsFunctionContext.getArgument(\"Opacity\");",
            "const Transparent = (AlphaTest !== 0 || Opacity !== 1);",
            "let Blend = THREE.NormalBlending;",
            "if (eventsFunctionContext.getArgument(\"Blend\") == \"Additive\") {",
            "    Blend = THREE.AdditiveBlending;",
            "} else if (eventsFunctionContext.getArgument(\"Blend\") == \"Subtractive\") {",
            "    Blend = THREE.SubtractiveBlending;",
            "} else if (eventsFunctionContext.getArgument(\"Blend\") == \"Multiply\") {",
            "    Blend = THREE.MultiplyBlending;",
            "}",
            "//",
            "const Texture = Textures.get(TextureId);",
            "// const Material = new THREE.MeshBasicMaterial({map: Texture, side: THREE.DoubleSide, transparent:Transparent, alphaTest:AlphaTest, blending:Blend, opacity:Opacity});//transparent:false, alphaTest:0, opacity:1.0",
            "const Material = new THREE.MeshLambertMaterial({map: Texture, side: THREE.DoubleSide, transparent:Transparent, alphaTest:AlphaTest, blending:Blend, opacity:Opacity});//transparent:false, alphaTest:0, opacity:1.0",
            "const Geometry = new THREE.PlaneGeometry(Width, Height, 1, 1);",
            "Geometry.computeBoundingBox();",
            "const Plane = new THREE.Mesh(Geometry, Material);",
            "Plane.position.set(X, Y, Z);",
            "Plane.rotation.set(gdjs.toRad(AngleX), gdjs.toRad(AngleY), gdjs.toRad(AngleZ));",
            "Plane.name = Id;",
            "Scene.add(Plane);",
            "",
            ""
          ],
          "parameterObjects": "",
          "useStrict": true,
          "eventsSheetExpanded": true
        }
      ],
      "parameters": [
        {
          "description": "3D Object ID",
          "name": "Id",
          "supplementaryInformation": "scene3D Object ID",
          "type": "identifier"
        },
        {
          "description": "X",
          "name": "X",
          "type": "expression"
        },
        {
          "description": "Y",
          "name": "Y",
          "type": "expression"
        },
        {
          "description": "Z",
          "name": "Z",
          "type": "expression"
        },
        {
          "description": "Angle X Axis",
          "name": "AngleX",
          "type": "expression"
        },
        {
          "description": "Angle Y Axis",
          "name": "AngleY",
          "type": "expression"
        },
        {
          "description": "Angle Z Axis",
          "name": "AngleZ",
          "type": "expression"
        },
        {
          "description": "Width",
          "name": "Width",
          "type": "expression"
        },
        {
          "description": "Height",
          "name": "Height",
          "type": "expression"
        },
        {
          "description": "3D Texture ID",
          "name": "TextureId",
          "supplementaryInformation": "scene3D Texture ID",
          "type": "identifier"
        },
        {
          "description": "Alpha Channel Test (0 to 1)",
          "longDescription": "Recommended values: 0 or 0.5  \nIf the texture is opaque, you can set the value to 0 to reduce the drawing load.",
          "name": "AlphaTest",
          "type": "expression"
        },
        {
          "description": "Opacity (0 to 1)",
          "longDescription": "1 is fully opaque.  \nIf the object is opaque, you can set the value to 1 to reduce the drawing load.",
          "name": "Opacity",
          "type": "expression"
        },
        {
          "description": "Blend Mode",
          "name": "Blend",
          "supplementaryInformation": "[\"Normal\",\"Additive\",\"Subtractive\",\"Multiply\"]",
          "type": "stringWithSelector"
        }
      ],
      "objectGroups": []
    },
    {
      "fullName": "✨Create 3D Box",
      "functionType": "Action",
      "group": "3D Object",
      "name": "Create3DBox",
      "sentence": "✨Create 3D Box (ID: _PARAM1_, X: _PARAM2_, Y: _PARAM3_, Z: _PARAM4_, AX: _PARAM5_, AY: _PARAM6_, AZ: _PARAM7_, W: _PARAM8_, H: _PARAM9_, D: _PARAM10_, Texture: _PARAM11_, αTest: _PARAM12_, Opacity: _PARAM13_, Blend: _PARAM14_)",
      "events": [
        {
          "type": "BuiltinCommonInstructions::JsCode",
          "inlineCode": [
            "if (!gdjs.__WithThreeJS.has(\"Renderer\")) {",
            "    console.warn(\"!\");",
            "    return;",
            "}",
            "if (!gdjs.__WithThreeJS.has(\"Textures\")) {",
            "    console.warn(\"!\");",
            "    return;",
            "}",
            "const Scene = gdjs.__WithThreeJS.get(\"Scene\");",
            "const Textures = gdjs.__WithThreeJS.get(\"Textures\");",
            "//",
            "const Id = eventsFunctionContext.getArgument(\"Id\");",
            "const X = eventsFunctionContext.getArgument(\"X\");",
            "const Y = eventsFunctionContext.getArgument(\"Y\");",
            "const Z = eventsFunctionContext.getArgument(\"Z\");",
            "const AngleX = eventsFunctionContext.getArgument(\"AngleX\");",
            "const AngleY = eventsFunctionContext.getArgument(\"AngleY\");",
            "const AngleZ = eventsFunctionContext.getArgument(\"AngleZ\");",
            "const Width = eventsFunctionContext.getArgument(\"Width\");",
            "const Height = eventsFunctionContext.getArgument(\"Height\");",
            "const Depth = eventsFunctionContext.getArgument(\"Depth\");",
            "const TextureIdList = eventsFunctionContext.getArgument(\"TextureIdList\");",
            "const AlphaTest = eventsFunctionContext.getArgument(\"AlphaTest\");",
            "const Opacity = eventsFunctionContext.getArgument(\"Opacity\");",
            "const Transparent = (AlphaTest !== 0 || Opacity !== 1);",
            "let Blend = THREE.NormalBlending;",
            "if (eventsFunctionContext.getArgument(\"Blend\") == \"Additive\") {",
            "    Blend = THREE.AdditiveBlending;",
            "} else if (eventsFunctionContext.getArgument(\"Blend\") == \"Subtractive\") {",
            "    Blend = THREE.SubtractiveBlending;",
            "} else if (eventsFunctionContext.getArgument(\"Blend\") == \"Multiply\") {",
            "    Blend = THREE.MultiplyBlending;",
            "}",
            "//",
            "let TextureList = [];",
            "for (const V of TextureIdList.split(\"\\n\")) {",
            "    if (V != \"\") {",
            "        if (!Textures.has(V)) {",
            "            console.warn(\"3D Texture not found: \" + V);",
            "        } else {",
            "            TextureList.push(Textures.get(V));",
            "        }",
            "    }",
            "}",
            "//",
            "let Materials;",
            "if (TextureList.length === 1) {",
            "    // Materials = new THREE.MeshBasicMaterial({map:TextureList[0], transparent:Transparent, alphaTest:AlphaTest, blending:Blend, opacity:Opacity});",
            "    Materials = new THREE.MeshLambertMaterial({map:TextureList[0], transparent:Transparent, alphaTest:AlphaTest, blending:Blend, opacity:Opacity});",
            "} else if (TextureList.length == 6) {",
            "    Materials = [];",
            "    for (let i = 0; i < TextureList.length; i++) {",
            "        // Materials.push(new THREE.MeshBasicMaterial({map:TextureList[i], transparent:Transparent, alphaTest:AlphaTest, blending:Blend, opacity:Opacity}));//side:THREE.FrontSide, transparent:false, alphaTest:0, opacity:1.0",
            "        Materials.push(new THREE.MeshLambertMaterial({map:TextureList[i], transparent:Transparent, alphaTest:AlphaTest, blending:Blend, opacity:Opacity}));//side:THREE.FrontSide, transparent:false, alphaTest:0, opacity:1.0",
            "    }",
            "} else {",
            "    console.warn(\"Requires 1 or 6 Texture IDs\");",
            "    return;",
            "}",
            "const Geometry = new THREE.BoxGeometry(Width, Height, Depth);",
            "Geometry.computeBoundingBox();",
            "const Box = new THREE.Mesh(Geometry, Materials);",
            "Box.position.set(X, Y, Z);",
            "Box.rotation.set(gdjs.toRad(AngleX), gdjs.toRad(AngleY), gdjs.toRad(AngleZ));",
            "Box.name = Id;",
            "Scene.add(Box);",
            "",
            ""
          ],
          "parameterObjects": "",
          "useStrict": true,
          "eventsSheetExpanded": true
        }
      ],
      "parameters": [
        {
          "description": "3D Object ID",
          "name": "Id",
          "supplementaryInformation": "scene3D Object ID",
          "type": "identifier"
        },
        {
          "description": "X",
          "name": "X",
          "type": "expression"
        },
        {
          "description": "Y",
          "name": "Y",
          "type": "expression"
        },
        {
          "description": "Z",
          "name": "Z",
          "type": "expression"
        },
        {
          "description": "Angle X Axis",
          "name": "AngleX",
          "type": "expression"
        },
        {
          "description": "Angle Y Axis",
          "name": "AngleY",
          "type": "expression"
        },
        {
          "description": "Angle Z Axis",
          "name": "AngleZ",
          "type": "expression"
        },
        {
          "description": "Width",
          "name": "Width",
          "type": "expression"
        },
        {
          "description": "Height",
          "name": "Height",
          "type": "expression"
        },
        {
          "description": "Depth",
          "name": "Depth",
          "type": "expression"
        },
        {
          "description": "3D Texture ID List",
          "longDescription": "One Texture ID per line. Requires 1 or 6 Texture IDs. 3D Object with 6 textures increase the drawing load.",
          "name": "TextureIdList",
          "supplementaryInformation": "scene3D Texture ID",
          "type": "identifier"
        },
        {
          "description": "Alpha Channel Test (0 to 1)",
          "longDescription": "Recommended values: 0 or 0.5  \nIf the texture is opaque, you can set the value to 0 to reduce the drawing load.  \nThe same value is set for multiple textures.",
          "name": "AlphaTest",
          "type": "expression"
        },
        {
          "description": "Opacity (0 to 1)",
          "longDescription": "1 is fully opaque.  \nIf the object is opaque, you can set the value to 1 to reduce the drawing load.  \nThe same value is set for multiple textures.",
          "name": "Opacity",
          "type": "expression"
        },
        {
          "description": "Blend Mode",
          "longDescription": "The same value is set for multiple textures.",
          "name": "Blend",
          "supplementaryInformation": "[\"Normal\",\"Additive\",\"Subtractive\",\"Multiply\"]",
          "type": "stringWithSelector"
        }
      ],
      "objectGroups": []
    },
    {
      "description": "Create a new 3D model from the 3D model loaded with the \"Load 3D Model From OBJ\" action.",
      "fullName": "💎Create 3D Model",
      "functionType": "Action",
      "group": "3D Object",
      "name": "Create3DModel",
      "sentence": "💎Create 3D Model (3D Model: _PARAM1_, ID: _PARAM2_, X: _PARAM3_, Y: _PARAM4_, Z: _PARAM5_, AX: _PARAM6_, AY: _PARAM7_, AZ: _PARAM8_, Scale: _PARAM9_, Texture: _PARAM10_, αTest: _PARAM11_, Opacity: _PARAM12_, Blend: _PARAM13_)",
      "events": [
        {
          "type": "BuiltinCommonInstructions::JsCode",
          "inlineCode": [
            "if (!gdjs.__WithThreeJS.has(\"Renderer\")) {",
            "    console.warn(\"!\");",
            "    return;",
            "}",
            "if (!gdjs.__WithThreeJS.has(\"Textures\")) {",
            "    console.warn(\"!\");",
            "    return;",
            "}",
            "if (!gdjs.__WithThreeJS.has(\"Models\")) {",
            "    console.warn(\"!\");",
            "    return;",
            "}",
            "const Scene = gdjs.__WithThreeJS.get(\"Scene\");",
            "const Textures = gdjs.__WithThreeJS.get(\"Textures\");",
            "const Models = gdjs.__WithThreeJS.get(\"Models\");",
            "//",
            "const ModelId = eventsFunctionContext.getArgument(\"ModelId\");",
            "const Id = eventsFunctionContext.getArgument(\"Id\");",
            "const X = eventsFunctionContext.getArgument(\"X\");",
            "const Y = eventsFunctionContext.getArgument(\"Y\");",
            "const Z = eventsFunctionContext.getArgument(\"Z\");",
            "const AngleX = eventsFunctionContext.getArgument(\"AngleX\");",
            "const AngleY = eventsFunctionContext.getArgument(\"AngleY\");",
            "const AngleZ = eventsFunctionContext.getArgument(\"AngleZ\");",
            "const Scale = eventsFunctionContext.getArgument(\"Scale\");",
            "const TextureIdList = eventsFunctionContext.getArgument(\"TextureIdList\");",
            "const AlphaTest = eventsFunctionContext.getArgument(\"AlphaTest\");",
            "const Opacity = eventsFunctionContext.getArgument(\"Opacity\");",
            "const Transparent = (AlphaTest !== 0 || Opacity !== 1);",
            "let Blend = THREE.NormalBlending;",
            "if (eventsFunctionContext.getArgument(\"Blend\") == \"Additive\") {",
            "    Blend = THREE.AdditiveBlending;",
            "} else if (eventsFunctionContext.getArgument(\"Blend\") == \"Subtractive\") {",
            "    Blend = THREE.SubtractiveBlending;",
            "} else if (eventsFunctionContext.getArgument(\"Blend\") == \"Multiply\") {",
            "    Blend = THREE.MultiplyBlending;",
            "}",
            "//",
            "let TextureList = [];",
            "for (const V of TextureIdList.split(\"\\n\")) {",
            "    if (V != \"\") {",
            "        if (!Textures.has(V)) {",
            "            console.warn(\"3D Texture not found: \" + V);",
            "        } else {",
            "            TextureList.push(Textures.get(V));",
            "        }",
            "    }",
            "}",
            "//",
            "if (!Models.has(ModelId)) {",
            "    console.warn(\"3D Model not found: \" + ModelId);",
            "    return;",
            "}",
            "//",
            "const Model = Models.get(ModelId).clone();",
            "//",
            "const Mats = new Map();",
            "gdjs.__WithThreeJS.get(\"GetAllMaterials\")(Model, Mats);",
            "for (const [K, V] of Mats) {",
            "    const CloneMaterial = V.clone();",
            "    CloneMaterial.transparent = Transparent;",
            "    CloneMaterial.alphaTest = AlphaTest;",
            "    CloneMaterial.blending = Blend;",
            "    CloneMaterial.opacity = Opacity;",
            "    Mats.set(K, CloneMaterial);",
            "}",
            "gdjs.__WithThreeJS.get(\"ReplaceMaterial\")(Model, Mats);",
            "//",
            "Model.position.set(X, Y, Z);",
            "Model.rotation.set(gdjs.toRad(AngleX), gdjs.toRad(AngleY), gdjs.toRad(AngleZ));",
            "Model.name = Id;",
            "Model.scale.setScalar(Scale);",
            "gdjs.__WithThreeJS.get(\"SetAllTextures\")(Model, TextureList);",
            "Scene.add(Model);",
            "",
            ""
          ],
          "parameterObjects": "",
          "useStrict": true,
          "eventsSheetExpanded": true
        }
      ],
      "parameters": [
        {
          "description": "3D Model ID",
          "name": "ModelId",
          "supplementaryInformation": "scene3D Model ID",
          "type": "identifier"
        },
        {
          "description": "3D Object ID",
          "name": "Id",
          "supplementaryInformation": "scene3D Object ID",
          "type": "identifier"
        },
        {
          "description": "X",
          "name": "X",
          "type": "expression"
        },
        {
          "description": "Y",
          "name": "Y",
          "type": "expression"
        },
        {
          "description": "Z",
          "name": "Z",
          "type": "expression"
        },
        {
          "description": "Angle X Axis",
          "name": "AngleX",
          "type": "expression"
        },
        {
          "description": "Angle Y Axis",
          "name": "AngleY",
          "type": "expression"
        },
        {
          "description": "Angle Z Axis",
          "name": "AngleZ",
          "type": "expression"
        },
        {
          "description": "Scale",
          "name": "Scale",
          "type": "expression"
        },
        {
          "description": "3D Texture ID List",
          "longDescription": "One Texture ID per line.",
          "name": "TextureIdList",
          "supplementaryInformation": "scene3D Texture ID",
          "type": "identifier"
        },
        {
          "description": "Alpha Channel Test (0 to 1)",
          "longDescription": "Recommended values: 0 or 0.5  \nIf the texture is opaque, you can set the value to 0 to reduce the drawing load.  \nThe same value is set for multiple textures.",
          "name": "AlphaTest",
          "type": "expression"
        },
        {
          "description": "Opacity (0 to 1)",
          "longDescription": "1 is fully opaque.  \nIf the object is opaque, you can set the value to 1 to reduce the drawing load.  \nThe same value is set for multiple textures.",
          "name": "Opacity",
          "type": "expression"
        },
        {
          "description": "Blend Mode",
          "longDescription": "The same value is set for multiple textures.",
          "name": "Blend",
          "supplementaryInformation": "[\"Normal\",\"Additive\",\"Subtractive\",\"Multiply\"]",
          "type": "stringWithSelector"
        }
      ],
      "objectGroups": []
    },
    {
      "description": "The only valid object properties are \"3D model\" and \"Material modifier\".",
      "fullName": "💎Create 3D Model From Built-In 3D Model",
      "functionType": "Action",
      "group": "3D Object",
      "name": "Create3DModelFromBuiltIn",
      "sentence": "💎Create 3D Model From Built-In (3D Model: _PARAM1_, ID: _PARAM2_, X: _PARAM3_, Y: _PARAM4_, Z: _PARAM5_, AX: _PARAM6_, AY: _PARAM7_, AZ: _PARAM8_, Scale: _PARAM9_)",
      "events": [
        {
          "type": "BuiltinCommonInstructions::JsCode",
          "inlineCode": [
            "if (!gdjs.__WithThreeJS.has(\"Renderer\")) {",
            "    console.warn(\"!\");",
            "    return;",
            "}",
            "if (!gdjs.__WithThreeJS.get(\"BuiltIn3D\")) {",
            "    console.warn(\"!\");",
            "    return;",
            "}",
            "if (!gdjs.__WithThreeJS.has(\"Models\")) {",
            "    gdjs.__WithThreeJS.set(\"Models\", new Map());",
            "}",
            "const Models = gdjs.__WithThreeJS.get(\"Models\");",
            "const Scene = gdjs.__WithThreeJS.get(\"Scene\");",
            "//",
            "const ModelObject = eventsFunctionContext.getObjectsLists(\"ModelObject\");",
            "const ModelObjectName = ModelObject.firstKey();",
            "const ModelResourceName = runtimeScene._objects.get(ModelObjectName).content.modelResourceName;",
            "const MaterialType = runtimeScene._objects.get(ModelObjectName).content.materialType;//\"Basic\", \"StandardWithoutMetalness\", \"KeepOriginal\"",
            "const Id = eventsFunctionContext.getArgument(\"Id\");",
            "const X = eventsFunctionContext.getArgument(\"X\");",
            "const Y = eventsFunctionContext.getArgument(\"Y\");",
            "const Z = eventsFunctionContext.getArgument(\"Z\");",
            "const AngleX = eventsFunctionContext.getArgument(\"AngleX\");",
            "const AngleY = eventsFunctionContext.getArgument(\"AngleY\");",
            "const AngleZ = eventsFunctionContext.getArgument(\"AngleZ\");",
            "const Scale = eventsFunctionContext.getArgument(\"Scale\");",
            "//",
            "if (!Models.has(ModelResourceName)) {",
            "    const ResourceModel = runtimeScene.getGame().getModel3DManager().getModel(ModelResourceName).scene;",
            "    const ResourceAnimations = runtimeScene.getGame().getModel3DManager().getModel(ModelResourceName).animations;",
            "    ResourceModel.animations = ResourceAnimations;",
            "    //",
            "    if (MaterialType != \"KeepOriginal\") {",
            "        // MeshStandardMaterial から指定のマテリアルへ変換",
            "        const Mats = new Map();",
            "        gdjs.__WithThreeJS.get(\"GetAllMaterials\")(ResourceModel, Mats);",
            "        for (const [K, V] of Mats) {",
            "            let NewMaterial;",
            "            if (MaterialType == \"Basic\") {",
            "                NewMaterial = new THREE.MeshBasicMaterial();",
            "            } else {",
            "                NewMaterial = new THREE.MeshLambertMaterial();",
            "            }",
            "            for(const KK of Object.keys(V)) {",
            "                // console.log(`V.${KK} = ${V[KK]}`);",
            "                if (KK === \"isMaterial\") {",
            "                    continue;",
            "                }",
            "                if (KK === \"uuid\") {",
            "                    continue;",
            "                }",
            "                if (KK === \"id\") {",
            "                    continue;",
            "                }",
            "                if (KK === \"type\") {",
            "                    continue;",
            "                }",
            "                if (NewMaterial[KK] !== undefined) {",
            "                    NewMaterial[KK] = V[KK];",
            "                }",
            "            }",
            "            NewMaterial.side = THREE.FrontSide;",
            "            V.dispose();// ここで実行して意味ある？",
            "            Mats.set(K, NewMaterial);",
            "        }",
            "        gdjs.__WithThreeJS.get(\"ReplaceMaterial\")(ResourceModel, Mats);",
            "    }",
            "    Models.set(ModelResourceName, ResourceModel);",
            "    // console.log(ResourceModel, ResourceAnimations);",
            "}",
            "// const Model = Models.get(ModelResourceName).clone();// これだとボーンが機能しなくなる",
            "const Model = THREE_ADDONS.SkeletonUtils.clone(Models.get(ModelResourceName));",
            "//",
            "const Mats = new Map();",
            "gdjs.__WithThreeJS.get(\"GetAllMaterials\")(Model, Mats);",
            "for (const [K, V] of Mats) {",
            "    const CloneMaterial = V.clone();",
            "    Mats.set(K, CloneMaterial);",
            "}",
            "gdjs.__WithThreeJS.get(\"ReplaceMaterial\")(Model, Mats);",
            "//",
            "Model.position.set(X, Y, Z);",
            "Model.rotation.set(gdjs.toRad(AngleX), gdjs.toRad(AngleY), gdjs.toRad(AngleZ));",
            "Model.name = Id;",
            "Model.scale.setScalar(Scale);",
            "Scene.add(Model);",
            "",
            ""
          ],
          "parameterObjects": "",
          "useStrict": true,
          "eventsSheetExpanded": true
        }
      ],
      "parameters": [
        {
          "description": "3D Model Object",
          "name": "ModelObject",
          "supplementaryInformation": "Scene3D::Model3DObject",
          "type": "objectList"
        },
        {
          "description": "3D Object ID",
          "name": "Id",
          "supplementaryInformation": "scene3D Object ID",
          "type": "identifier"
        },
        {
          "description": "X",
          "name": "X",
          "type": "expression"
        },
        {
          "description": "Y",
          "name": "Y",
          "type": "expression"
        },
        {
          "description": "Z",
          "name": "Z",
          "type": "expression"
        },
        {
          "description": "Angle X Axis",
          "name": "AngleX",
          "type": "expression"
        },
        {
          "description": "Angle Y Axis",
          "name": "AngleY",
          "type": "expression"
        },
        {
          "description": "Angle Z Axis",
          "name": "AngleZ",
          "type": "expression"
        },
        {
          "description": "Scale",
          "name": "Scale",
          "type": "expression"
        }
      ],
      "objectGroups": []
    },
    {
      "description": "⚠️ 3D Lights are highly loaded.\n3D Directional Light and 3D Spot Light emit light in the -Z direction.\n3D Lights can be handled like 3D Objects.",
      "fullName": "Create 3D Light V1 (Deprecated)",
      "functionType": "Action",
      "group": "3D Light",
      "name": "Create3DLight",
      "private": true,
      "sentence": "⚠️ Create 3D Light V1 (ID: _PARAM1_, Type: _PARAM2_, Color: _PARAM3_, Intensity: _PARAM4_, Distance: _PARAM5_, SpotAngle: _PARAM6_, SpotPenumbra: _PARAM7_, Pos: _PARAM8_, _PARAM9_, _PARAM10_, Ang: _PARAM11_, _PARAM12_, _PARAM13_)",
      "events": [
        {
          "type": "BuiltinCommonInstructions::JsCode",
          "inlineCode": [
            "if (!gdjs.__WithThreeJS.has(\"Renderer\")) {",
            "    console.warn(\"!\");",
            "    return;",
            "}",
            "const Scene = gdjs.__WithThreeJS.get(\"Scene\");",
            "//",
            "const LightId = eventsFunctionContext.getArgument(\"LightId\");",
            "const LightType = eventsFunctionContext.getArgument(\"Type\");",
            "const Color = eventsFunctionContext.getArgument(\"Color\") || \"255;255;255\";",
            "let Intensity = eventsFunctionContext.getArgument(\"Intensity\");",
            "const Distance = eventsFunctionContext.getArgument(\"Distance\");",
            "const Decay = 2;",
            "const SpotAngle = eventsFunctionContext.getArgument(\"SpotAngle\");",
            "const SpotPenumbra = eventsFunctionContext.getArgument(\"SpotPenumbra\");",
            "const X = eventsFunctionContext.getArgument(\"X\");",
            "const Y = eventsFunctionContext.getArgument(\"Y\");",
            "const Z = eventsFunctionContext.getArgument(\"Z\");",
            "const AngleX = eventsFunctionContext.getArgument(\"AngleX\");",
            "const AngleY = eventsFunctionContext.getArgument(\"AngleY\");",
            "const AngleZ = eventsFunctionContext.getArgument(\"AngleZ\");",
            "//",
            "const RGB = Color.split(\";\");",
            "let Light;",
            "if (LightType == \"Directional Light\") {",
            "    Intensity *= gdjs.__WithThreeJS.get(\"LightIntensityScale\");// Three.js r160",
            "    Light = new THREE.DirectionalLight(`rgb(${RGB[0]}, ${RGB[1]}, ${RGB[2]})`, Intensity);",
            "    const Target = new THREE.Group();",
            "    Target.translateZ(-1);",
            "    Light.add(Target);",
            "    Light.target = Target;",
            "} else if (LightType == \"Spot Light\") {",
            "    Intensity *= gdjs.__WithThreeJS.get(\"LightIntensityCandela\");// Three.js r160",
            "    Light = new THREE.SpotLight(`rgb(${RGB[0]}, ${RGB[1]}, ${RGB[2]})`, Intensity, Distance, gdjs.toRad(SpotAngle), SpotPenumbra, Decay);",
            "    const Target = new THREE.Group();",
            "    Target.translateZ(-1);",
            "    Light.add(Target);",
            "    Light.target = Target;",
            "} else {",
            "    // Point",
            "    Intensity *= gdjs.__WithThreeJS.get(\"LightIntensityCandela\");// Three.js r160",
            "    Light = new THREE.PointLight(`rgb(${RGB[0]}, ${RGB[1]}, ${RGB[2]})`, Intensity, Distance, Decay);",
            "}",
            "Light.name = LightId;",
            "Light.position.set(X, Y, Z);",
            "Light.rotation.set(gdjs.toRad(AngleX), gdjs.toRad(AngleY), gdjs.toRad(AngleZ));",
            "Scene.add(Light);",
            "",
            ""
          ],
          "parameterObjects": "",
          "useStrict": true,
          "eventsSheetExpanded": true
        }
      ],
      "parameters": [
        {
          "description": "3D Light ID (3D Object ID)",
          "name": "LightId",
          "supplementaryInformation": "scene3D Object ID",
          "type": "identifier"
        },
        {
          "description": "Light Type",
          "name": "Type",
          "supplementaryInformation": "[\"Directional Light\",\"Point Light\",\"Spot Light\"]",
          "type": "stringWithSelector"
        },
        {
          "description": "Color",
          "name": "Color",
          "type": "color"
        },
        {
          "description": "Intensity (Default: 1)",
          "name": "Intensity",
          "type": "expression"
        },
        {
          "description": "Distance (Default: 0)",
          "longDescription": "For Point and Spot Lights.\n0 is no limit.",
          "name": "Distance",
          "type": "expression"
        },
        {
          "description": "Spot Angle (0 to 180)",
          "longDescription": "For Spot Lights.",
          "name": "SpotAngle",
          "type": "expression"
        },
        {
          "description": "Spot Penumbra (0 to 1)",
          "longDescription": "For Spot Lights.",
          "name": "SpotPenumbra",
          "type": "expression"
        },
        {
          "description": "X",
          "name": "X",
          "type": "expression"
        },
        {
          "description": "Y",
          "name": "Y",
          "type": "expression"
        },
        {
          "description": "Z",
          "name": "Z",
          "type": "expression"
        },
        {
          "description": "Angle X Axis",
          "name": "AngleX",
          "type": "expression"
        },
        {
          "description": "Angle Y Axis",
          "name": "AngleY",
          "type": "expression"
        },
        {
          "description": "Angle Z Axis",
          "name": "AngleZ",
          "type": "expression"
        }
      ],
      "objectGroups": []
    },
    {
      "description": "⚠️ 3D Lights are highly loaded.\n3D Directional Light and 3D Spot Light emit light in the -Z direction.\n3D Lights can be handled like 3D Objects.",
      "fullName": "💡Create 3D Light",
      "functionType": "Action",
      "group": "3D Light",
      "name": "Create3DLightV2",
      "sentence": "💡Create 3D Light (ID: _PARAM1_, Type: _PARAM2_, Color: _PARAM3_, Intensity: _PARAM4_, Distance: _PARAM5_, SpotAngle: _PARAM6_, SpotPenumbra: _PARAM7_, Pos: _PARAM8_, _PARAM9_, _PARAM10_, Ang: _PARAM11_, _PARAM12_, _PARAM13_, Shadow: _PARAM14_, Size: _PARAM15_, Range: _PARAM16_, Bias: _PARAM17_, _PARAM18_, Helper: _PARAM19_, _PARAM20_)",
      "events": [
        {
          "type": "BuiltinCommonInstructions::JsCode",
          "inlineCode": [
            "if (!gdjs.__WithThreeJS.has(\"Renderer\")) {",
            "    console.warn(\"!\");",
            "    return;",
            "}",
            "const Scene = gdjs.__WithThreeJS.get(\"Scene\");",
            "const Renderer = gdjs.__WithThreeJS.get(\"Renderer\");",
            "//",
            "const LightId = eventsFunctionContext.getArgument(\"LightId\");",
            "const LightType = eventsFunctionContext.getArgument(\"Type\");",
            "const Color = eventsFunctionContext.getArgument(\"Color\") || \"255;255;255\";",
            "let Intensity = eventsFunctionContext.getArgument(\"Intensity\");",
            "const Distance = eventsFunctionContext.getArgument(\"Distance\");",
            "const Decay = 2;",
            "const SpotAngle = eventsFunctionContext.getArgument(\"SpotAngle\");",
            "const SpotPenumbra = eventsFunctionContext.getArgument(\"SpotPenumbra\");",
            "const X = eventsFunctionContext.getArgument(\"X\");",
            "const Y = eventsFunctionContext.getArgument(\"Y\");",
            "const Z = eventsFunctionContext.getArgument(\"Z\");",
            "const AngleX = eventsFunctionContext.getArgument(\"AngleX\");",
            "const AngleY = eventsFunctionContext.getArgument(\"AngleY\");",
            "const AngleZ = eventsFunctionContext.getArgument(\"AngleZ\");",
            "const CastShadow = eventsFunctionContext.getArgument(\"CastShadow\");",
            "const ShadowMapSize = gdjs.__WithThreeJS.get(\"ShadowMapSizeStringToValue\")[eventsFunctionContext.getArgument(\"ShadowMapSize\")];",
            "const ShadowRange = eventsFunctionContext.getArgument(\"ShadowRange\");",
            "const ShadowBias = eventsFunctionContext.getArgument(\"ShadowBias\");",
            "const ShadowNormalBias = eventsFunctionContext.getArgument(\"ShadowNormalBias\");",
            "const LightHelper = eventsFunctionContext.getArgument(\"LightHelper\");",
            "const ShadowHelper = eventsFunctionContext.getArgument(\"ShadowHelper\");",
            "//",
            "const RGB = Color.split(\";\");",
            "let Light;",
            "if (LightType == \"Directional Light\") {",
            "    Intensity *= gdjs.__WithThreeJS.get(\"LightIntensityScale\");// Three.js r160",
            "    Light = new THREE.DirectionalLight(`rgb(${RGB[0]}, ${RGB[1]}, ${RGB[2]})`, Intensity);",
            "    const Target = new THREE.Group();",
            "    Target.translateZ(-128);",
            "    Light.add(Target);",
            "    Light.target = Target;",
            "    //",
            "    Light.shadow.camera.top = ShadowRange / 2;",
            "    Light.shadow.camera.right = ShadowRange / 2;",
            "    Light.shadow.camera.bottom = -ShadowRange / 2;",
            "    Light.shadow.camera.left = -ShadowRange / 2;",
            "    Light.shadow.camera.near = 0.5;// default",
            "    Light.shadow.camera.far = ShadowRange;",
            "    //",
            "    if (LightHelper) {",
            "        const DirectionalLightHelper = new THREE.DirectionalLightHelper(Light, 128);",
            "        DirectionalLightHelper.name = LightId + \"_DirectionalLightHelper\";",
            "        Scene.add(DirectionalLightHelper);",
            "    }",
            "} else if (LightType == \"Spot Light\") {",
            "    Intensity *= gdjs.__WithThreeJS.get(\"LightIntensityCandela\");// Three.js r160",
            "    Light = new THREE.SpotLight(`rgb(${RGB[0]}, ${RGB[1]}, ${RGB[2]})`, Intensity, Distance, gdjs.toRad(SpotAngle), SpotPenumbra, Decay);",
            "    const Target = new THREE.Group();",
            "    Target.translateZ(-1);",
            "    Light.add(Target);",
            "    Light.target = Target;",
            "    //",
            "    Light.shadow.camera.near = 0.5;// default",
            "    Light.shadow.camera.far = ShadowRange;",
            "    Light.shadow.focus = 1; // default",
            "    //",
            "    if (LightHelper) {",
            "        const SpotLightHelper = new THREE.SpotLightHelper(Light);",
            "        SpotLightHelper.name = LightId + \"_SpotLightHelper\";",
            "        Scene.add(SpotLightHelper);",
            "    }",
            "} else {",
            "    // Point",
            "    Intensity *= gdjs.__WithThreeJS.get(\"LightIntensityCandela\");// Three.js r160",
            "    Light = new THREE.PointLight(`rgb(${RGB[0]}, ${RGB[1]}, ${RGB[2]})`, Intensity, Distance, Decay);",
            "    //",
            "    Light.shadow.camera.near = 0.5;// default",
            "    Light.shadow.camera.far = ShadowRange;",
            "    //",
            "    if (LightHelper) {",
            "        const PointLightHelper = new THREE.PointLightHelper(Light, 16);",
            "        PointLightHelper.name = LightId + \"_PointLightHelper\";",
            "        Scene.add(PointLightHelper);",
            "    }",
            "}",
            "Renderer.shadowMap.enabled = Renderer.shadowMap.enabled ? true : CastShadow;",
            "Light.castShadow = CastShadow;",
            "Light.shadow.mapSize.width = ShadowMapSize;",
            "Light.shadow.mapSize.height = ShadowMapSize;",
            "Light.shadow.bias = ShadowBias;",
            "Light.shadow.normalBias = ShadowNormalBias;",
            "Light.shadow.updateMatrices(Light);// 必須",
            "Light.shadow.camera.updateProjectionMatrix();",
            "//",
            "Light.name = LightId;",
            "Light.position.set(X, Y, Z);",
            "Light.rotation.set(gdjs.toRad(AngleX), gdjs.toRad(AngleY), gdjs.toRad(AngleZ));",
            "Scene.add(Light);",
            "//",
            "if (ShadowHelper && CastShadow) {",
            "    let CameraHelper;",
            "    if (LightType != \"Point Light\") {",
            "        CameraHelper = new THREE.CameraHelper(Light.shadow.camera);",
            "        Scene.add(CameraHelper);",
            "    } else {",
            "        const Geometry = new THREE.IcosahedronGeometry(Light.shadow.camera.far, 2); ",
            "        const Material = new THREE.MeshBasicMaterial( {color: 0xffaa00, wireframe: true} );",
            "        CameraHelper = new THREE.Mesh(Geometry, Material);",
            "        Light.add(CameraHelper);",
            "    }",
            "    CameraHelper.name = LightId + \"_CameraHelper\";",
            "}",
            "",
            ""
          ],
          "parameterObjects": "",
          "useStrict": true,
          "eventsSheetExpanded": true
        }
      ],
      "parameters": [
        {
          "description": "3D Light ID (3D Object ID)",
          "name": "LightId",
          "supplementaryInformation": "scene3D Object ID",
          "type": "identifier"
        },
        {
          "description": "Light Type",
          "name": "Type",
          "supplementaryInformation": "[\"Directional Light\",\"Point Light\",\"Spot Light\"]",
          "type": "stringWithSelector"
        },
        {
          "description": "Color",
          "name": "Color",
          "type": "color"
        },
        {
          "description": "Intensity (Default: 1)",
          "name": "Intensity",
          "type": "expression"
        },
        {
          "description": "Distance (Default: 0)",
          "longDescription": "For Point and Spot Lights.  \n0 is no limit.",
          "name": "Distance",
          "type": "expression"
        },
        {
          "description": "Spot Angle (0 to 180)",
          "longDescription": "For Spot Lights.  \nThe narrower the angle, the better the shadow quality.  \nIf it is a multiple of 90, the shadow will not be cast correctly.",
          "name": "SpotAngle",
          "type": "expression"
        },
        {
          "description": "Spot Penumbra (0 to 1)",
          "longDescription": "For Spot Lights.",
          "name": "SpotPenumbra",
          "type": "expression"
        },
        {
          "description": "X",
          "name": "X",
          "type": "expression"
        },
        {
          "description": "Y",
          "name": "Y",
          "type": "expression"
        },
        {
          "description": "Z",
          "name": "Z",
          "type": "expression"
        },
        {
          "description": "Angle X Axis",
          "name": "AngleX",
          "type": "expression"
        },
        {
          "description": "Angle Y Axis",
          "name": "AngleY",
          "type": "expression"
        },
        {
          "description": "Angle Z Axis",
          "name": "AngleZ",
          "type": "expression"
        },
        {
          "description": "Cast Shadow",
          "longDescription": "⚠️ This is expensive and requires tweaking to get shadows looking right.",
          "name": "CastShadow",
          "type": "yesorno"
        },
        {
          "description": "Shadow Map Size (Default: 512px)",
          "longDescription": "The larger the map, the better the shadow quality, but the greater the load.",
          "name": "ShadowMapSize",
          "supplementaryInformation": "[\"128px\",\"256px\",\"512px\",\"1024px\",\"2048px\"]",
          "type": "stringWithSelector"
        },
        {
          "description": "Range to Draw Shadows (Default: 256)",
          "longDescription": "The smaller the range, the better the shadow quality.  \nFor Point and Spot Lights, this value is valid only if the Distance is 0.",
          "name": "ShadowRange",
          "type": "expression"
        },
        {
          "description": "Shadow Depth Bias (Default: 0.002)",
          "longDescription": "It is mainly effective for filling gaps between objects and shadows.  \nReference value: [Directional Light: 0.002] [Point Light: 0.001] [Spot Light: 0.00001]",
          "name": "ShadowDepthBias",
          "type": "expression"
        },
        {
          "description": "Shadow Normal Bias (Default: 2)",
          "longDescription": "It is mainly effective in reducing striped patterns.  \nReference value: [Directional Light: 2] [Point Light: 1] [Spot Light: 1]",
          "name": "ShadowNormalBias",
          "type": "expression"
        },
        {
          "description": "Light Helper",
          "name": "LightHelper",
          "type": "yesorno"
        },
        {
          "description": "Shadow Range Helper",
          "name": "ShadowHelper",
          "type": "yesorno"
        }
      ],
      "objectGroups": []
    },
    {
      "description": "This 3D Object without geometry is useful for grouping other 3D Objects together or changing their center point.",
      "fullName": "👥Create 3D Group",
      "functionType": "Action",
      "group": "3D Object",
      "name": "Create3DGroup",
      "sentence": "👥Create 3D Group (ID: _PARAM1_, X: _PARAM2_, Y: _PARAM3_, Z: _PARAM4_, AX: _PARAM5_, AY: _PARAM6_, AZ: _PARAM7_)",
      "events": [
        {
          "type": "BuiltinCommonInstructions::JsCode",
          "inlineCode": [
            "if (!gdjs.__WithThreeJS.has(\"Renderer\")) {",
            "    console.warn(\"!\");",
            "    return;",
            "}",
            "const Scene = gdjs.__WithThreeJS.get(\"Scene\");",
            "const Id = eventsFunctionContext.getArgument(\"Id\");",
            "const X = eventsFunctionContext.getArgument(\"X\");",
            "const Y = eventsFunctionContext.getArgument(\"Y\");",
            "const Z = eventsFunctionContext.getArgument(\"Z\");",
            "const AngleX = eventsFunctionContext.getArgument(\"AngleX\");",
            "const AngleY = eventsFunctionContext.getArgument(\"AngleY\");",
            "const AngleZ = eventsFunctionContext.getArgument(\"AngleZ\");",
            "const Group = new THREE.Group();",
            "Group.position.set(X, Y, Z);",
            "Group.rotation.set(gdjs.toRad(AngleX), gdjs.toRad(AngleY), gdjs.toRad(AngleZ));",
            "Group.name = Id;",
            "Scene.add(Group);",
            "",
            ""
          ],
          "parameterObjects": "",
          "useStrict": true,
          "eventsSheetExpanded": true
        }
      ],
      "parameters": [
        {
          "description": "3D Object ID",
          "name": "Id",
          "supplementaryInformation": "scene3D Object ID",
          "type": "identifier"
        },
        {
          "description": "X",
          "name": "X",
          "type": "expression"
        },
        {
          "description": "Y",
          "name": "Y",
          "type": "expression"
        },
        {
          "description": "Z",
          "name": "Z",
          "type": "expression"
        },
        {
          "description": "Angle X Axis",
          "name": "AngleX",
          "type": "expression"
        },
        {
          "description": "Angle Y Axis",
          "name": "AngleY",
          "type": "expression"
        },
        {
          "description": "Angle Z Axis",
          "name": "AngleZ",
          "type": "expression"
        }
      ],
      "objectGroups": []
    },
    {
      "description": "Move a 3D Camera.\n'=' is relative to the parent axis.\n\"+\" and \"-\" are relative to the local axis.",
      "fullName": "↔️Move 3D Camera",
      "functionType": "Action",
      "group": "3D Camera",
      "name": "Move3DCamera",
      "sentence": "↔️Move 3D Camera (ID: _PARAM1_, _PARAM2_, X: _PARAM3_, Y: _PARAM4_, Z: _PARAM5_)",
      "events": [
        {
          "type": "BuiltinCommonInstructions::JsCode",
          "inlineCode": [
            "if (!gdjs.__WithThreeJS.has(\"Renderer\")) {",
            "    console.warn(\"!\");",
            "    return;",
            "}",
            "// const Camera = gdjs.__WithThreeJS.get(\"Camera\");",
            "const Id = eventsFunctionContext.getArgument(\"Id\");",
            "const Camera = gdjs.__WithThreeJS.get(\"GetCamera\")(Id);",
            "const Operator = eventsFunctionContext.getArgument(\"Operator\");",
            "const X = eventsFunctionContext.getArgument(\"X\");",
            "const Y = eventsFunctionContext.getArgument(\"Y\");",
            "const Z = eventsFunctionContext.getArgument(\"Z\");",
            "//",
            "if (Operator == \"=\") {",
            "    Camera.position.set(X, Y, Z);",
            "} else if (Operator == \"+\") {",
            "    Camera.translateX(X);",
            "    Camera.translateY(Y);",
            "    Camera.translateZ(Z);",
            "} else {",
            "    Camera.translateX(-X);",
            "    Camera.translateY(-Y);",
            "    Camera.translateZ(-Z);",
            "}",
            "",
            ""
          ],
          "parameterObjects": "",
          "useStrict": true,
          "eventsSheetExpanded": true
        }
      ],
      "parameters": [
        {
          "description": "3D Camera ID (1 to 4)",
          "name": "Id",
          "type": "expression"
        },
        {
          "description": "Operator",
          "name": "Operator",
          "supplementaryInformation": "[\"=\",\"+\",\"-\"]",
          "type": "stringWithSelector"
        },
        {
          "description": "X",
          "name": "X",
          "type": "expression"
        },
        {
          "description": "Y",
          "name": "Y",
          "type": "expression"
        },
        {
          "description": "Z",
          "name": "Z",
          "type": "expression"
        }
      ],
      "objectGroups": []
    },
    {
      "description": "Rotate the 3D Camera in the order X, Y, Z.",
      "fullName": "🔄️Rotate 3D Camera",
      "functionType": "Action",
      "group": "3D Camera",
      "name": "Rotate3DCamera",
      "sentence": "🔄️Rotate 3D Camera (ID: _PARAM1_, _PARAM2_, X: _PARAM3_, Y: _PARAM4_, Z: _PARAM5_)",
      "events": [
        {
          "type": "BuiltinCommonInstructions::JsCode",
          "inlineCode": [
            "if (!gdjs.__WithThreeJS.has(\"Renderer\")) {",
            "    console.warn(\"!\");",
            "    return;",
            "}",
            "// const Camera = gdjs.__WithThreeJS.get(\"Camera\");",
            "const Id = eventsFunctionContext.getArgument(\"Id\");",
            "const Camera = gdjs.__WithThreeJS.get(\"GetCamera\")(Id);",
            "const Operator = eventsFunctionContext.getArgument(\"Operator\");",
            "const AngleX = eventsFunctionContext.getArgument(\"AngleX\");",
            "const AngleY = eventsFunctionContext.getArgument(\"AngleY\");",
            "const AngleZ = eventsFunctionContext.getArgument(\"AngleZ\");",
            "//",
            "if (Operator == \"=\") {",
            "    Camera.rotation.set(gdjs.toRad(AngleX), gdjs.toRad(AngleY), gdjs.toRad(AngleZ));",
            "} else if (Operator == \"+\") {",
            "    Camera.rotateX(gdjs.toRad(AngleX));",
            "    Camera.rotateY(gdjs.toRad(AngleY));",
            "    Camera.rotateZ(gdjs.toRad(AngleZ));",
            "} else {",
            "    Camera.rotateX(gdjs.toRad(-AngleX));",
            "    Camera.rotateY(gdjs.toRad(-AngleY));",
            "    Camera.rotateZ(gdjs.toRad(-AngleZ));",
            "}",
            "",
            ""
          ],
          "parameterObjects": "",
          "useStrict": true,
          "eventsSheetExpanded": true
        }
      ],
      "parameters": [
        {
          "description": "3D Camera ID (1 to 4)",
          "name": "Id",
          "type": "expression"
        },
        {
          "description": "Operator",
          "name": "Operator",
          "supplementaryInformation": "[\"=\",\"+\",\"-\"]",
          "type": "stringWithSelector"
        },
        {
          "description": "Angle X",
          "name": "AngleX",
          "type": "expression"
        },
        {
          "description": "Angle Y",
          "name": "AngleY",
          "type": "expression"
        },
        {
          "description": "Angle Z",
          "name": "AngleZ",
          "type": "expression"
        }
      ],
      "objectGroups": []
    },
    {
      "description": "Rotate the 3D Camera in the order X, Y, Z on the world axis.",
      "fullName": "🔄️Rotate 3D Camera On World",
      "functionType": "Action",
      "group": "3D Camera",
      "name": "Rotate3DCameraOnWorld",
      "sentence": "🔄️Rotate 3D Camera On World (ID: _PARAM1_, _PARAM2_, X: _PARAM3_, Y: _PARAM4_, Z: _PARAM5_)",
      "events": [
        {
          "type": "BuiltinCommonInstructions::JsCode",
          "inlineCode": [
            "if (!gdjs.__WithThreeJS.has(\"Renderer\")) {",
            "    console.warn(\"!\");",
            "    return;",
            "}",
            "// const Camera = gdjs.__WithThreeJS.get(\"Camera\");",
            "const Id = eventsFunctionContext.getArgument(\"Id\");",
            "const Camera = gdjs.__WithThreeJS.get(\"GetCamera\")(Id);",
            "const Operator = eventsFunctionContext.getArgument(\"Operator\");",
            "const AngleX = eventsFunctionContext.getArgument(\"AngleX\");",
            "const AngleY = eventsFunctionContext.getArgument(\"AngleY\");",
            "const AngleZ = eventsFunctionContext.getArgument(\"AngleZ\");",
            "//",
            "if (Operator == \"=\") {",
            "    Camera.rotation.set(0, 0, 0);",
            "    Camera.rotateOnWorldAxis(new THREE.Vector3(1, 0, 0), gdjs.toRad(AngleX));",
            "    Camera.rotateOnWorldAxis(new THREE.Vector3(0, 1, 0), gdjs.toRad(AngleY));",
            "    Camera.rotateOnWorldAxis(new THREE.Vector3(0, 0, 1), gdjs.toRad(AngleZ));",
            "} else if (Operator == \"+\") {",
            "    Camera.rotateOnWorldAxis(new THREE.Vector3(1, 0, 0), gdjs.toRad(AngleX));",
            "    Camera.rotateOnWorldAxis(new THREE.Vector3(0, 1, 0), gdjs.toRad(AngleY));",
            "    Camera.rotateOnWorldAxis(new THREE.Vector3(0, 0, 1), gdjs.toRad(AngleZ));",
            "} else {",
            "    Camera.rotateOnWorldAxis(new THREE.Vector3(1, 0, 0), gdjs.toRad(-AngleX));",
            "    Camera.rotateOnWorldAxis(new THREE.Vector3(0, 1, 0), gdjs.toRad(-AngleY));",
            "    Camera.rotateOnWorldAxis(new THREE.Vector3(0, 0, 1), gdjs.toRad(-AngleZ));",
            "}",
            "",
            ""
          ],
          "parameterObjects": "",
          "useStrict": true,
          "eventsSheetExpanded": true
        }
      ],
      "parameters": [
        {
          "description": "3D Camera ID (1 to 4)",
          "name": "Id",
          "type": "expression"
        },
        {
          "description": "Operator",
          "name": "Operator",
          "supplementaryInformation": "[\"=\",\"+\",\"-\"]",
          "type": "stringWithSelector"
        },
        {
          "description": "Angle X",
          "name": "AngleX",
          "type": "expression"
        },
        {
          "description": "Angle Y",
          "name": "AngleY",
          "type": "expression"
        },
        {
          "description": "Angle Z",
          "name": "AngleZ",
          "type": "expression"
        }
      ],
      "objectGroups": []
    },
    {
      "description": "Rotate the 3D Camera first in the world Y axis, then on the local X and Z axes.",
      "fullName": "🔄️Rotate 3D Camera Like Head",
      "functionType": "Action",
      "group": "3D Camera",
      "name": "Rotate3DCameraLikeHead",
      "sentence": "🔄️Rotate 3D Camera Like Head (ID: _PARAM1_, _PARAM2_, X: _PARAM3_, Y: _PARAM4_, Z: _PARAM5_)",
      "events": [
        {
          "type": "BuiltinCommonInstructions::JsCode",
          "inlineCode": [
            "if (!gdjs.__WithThreeJS.has(\"Renderer\")) {",
            "    console.warn(\"!\");",
            "    return;",
            "}",
            "// const Camera = gdjs.__WithThreeJS.get(\"Camera\");",
            "const Id = eventsFunctionContext.getArgument(\"Id\");",
            "const Camera = gdjs.__WithThreeJS.get(\"GetCamera\")(Id);",
            "const Operator = eventsFunctionContext.getArgument(\"Operator\");",
            "const AngleX = eventsFunctionContext.getArgument(\"AngleX\");",
            "const AngleY = eventsFunctionContext.getArgument(\"AngleY\");",
            "const AngleZ = eventsFunctionContext.getArgument(\"AngleZ\");",
            "//",
            "if (Operator == \"=\") {",
            "    // Camera.rotation.set(gdjs.toRad(AngleX), gdjs.toRad(AngleY), gdjs.toRad(AngleZ), \"YXZ\");",
            "    Camera.rotation.set(0, 0, 0);",
            "    Camera.rotateY(gdjs.toRad(AngleY));",
            "    Camera.rotateX(gdjs.toRad(AngleX));",
            "    Camera.rotateZ(gdjs.toRad(AngleZ));",
            "} else if (Operator == \"+\") {",
            "    Camera.rotateX(gdjs.toRad(AngleX));",
            "    Camera.rotateOnWorldAxis(new THREE.Vector3(0, 1, 0), gdjs.toRad(AngleY));",
            "    Camera.rotateZ(gdjs.toRad(AngleZ));",
            "} else {",
            "    Camera.rotateX(gdjs.toRad(-AngleX));",
            "    Camera.rotateOnWorldAxis(new THREE.Vector3(0, 1, 0), gdjs.toRad(-AngleY));",
            "    Camera.rotateZ(gdjs.toRad(-AngleZ));",
            "}",
            "",
            ""
          ],
          "parameterObjects": "",
          "useStrict": true,
          "eventsSheetExpanded": true
        }
      ],
      "parameters": [
        {
          "description": "3D Camera ID (1 to 4)",
          "name": "Id",
          "type": "expression"
        },
        {
          "description": "Operator",
          "name": "Operator",
          "supplementaryInformation": "[\"=\",\"+\",\"-\"]",
          "type": "stringWithSelector"
        },
        {
          "description": "Angle X",
          "name": "AngleX",
          "type": "expression"
        },
        {
          "description": "Angle Y",
          "name": "AngleY",
          "type": "expression"
        },
        {
          "description": "Angle Z",
          "name": "AngleZ",
          "type": "expression"
        }
      ],
      "objectGroups": []
    },
    {
      "fullName": "👀3D Camera Look At 3D Object",
      "functionType": "Action",
      "group": "3D Camera",
      "name": "CameraLookAt3DObject",
      "sentence": "👀3D Camera Look At 3D Object (Camera ID: _PARAM1_, Target ID: _PARAM2_)",
      "events": [
        {
          "type": "BuiltinCommonInstructions::JsCode",
          "inlineCode": [
            "if (!gdjs.__WithThreeJS.has(\"Renderer\")) {",
            "    console.warn(\"!\");",
            "    return;",
            "}",
            "const Scene = gdjs.__WithThreeJS.get(\"Scene\");",
            "// const Camera = gdjs.__WithThreeJS.get(\"Camera\");",
            "const Id = eventsFunctionContext.getArgument(\"Id\");",
            "const Camera = gdjs.__WithThreeJS.get(\"GetCamera\")(Id);",
            "const TargetId = eventsFunctionContext.getArgument(\"TargetId\");",
            "//",
            "const Obj = gdjs.__WithThreeJS.get(\"SearchObject\")(TargetId);",
            "if (!Obj) {",
            "    console.warn(\"3D Object not found: \" + TargetId);",
            "    return;",
            "}",
            "//",
            "const WPos = new THREE.Vector3();",
            "Obj.getWorldPosition(WPos);",
            "Camera.lookAt(WPos);",
            "",
            ""
          ],
          "parameterObjects": "",
          "useStrict": true,
          "eventsSheetExpanded": true
        }
      ],
      "parameters": [
        {
          "description": "3D Camera ID (1 to 4)",
          "name": "Id",
          "type": "expression"
        },
        {
          "description": "Target 3D Object ID",
          "name": "TargetId",
          "supplementaryInformation": "scene3D Object ID",
          "type": "identifier"
        }
      ],
      "objectGroups": []
    },
    {
      "description": "Change the Field Of View of the 3D Camera.",
      "fullName": "🎥Change 3D Camera FOV",
      "functionType": "Action",
      "group": "3D Camera",
      "name": "Change3DCameraFOV",
      "sentence": "🎥Change 3D Camera FOV (ID: _PARAM1_, _PARAM2_, Fov: _PARAM3_)",
      "events": [
        {
          "type": "BuiltinCommonInstructions::JsCode",
          "inlineCode": [
            "if (!gdjs.__WithThreeJS.has(\"Renderer\")) {",
            "    console.warn(\"!\");",
            "    return;",
            "}",
            "// const Camera = gdjs.__WithThreeJS.get(\"Camera\");",
            "const Id = eventsFunctionContext.getArgument(\"Id\");",
            "const Camera = gdjs.__WithThreeJS.get(\"GetCamera\")(Id);",
            "const Operator = eventsFunctionContext.getArgument(\"Operator\");",
            "const Fov = eventsFunctionContext.getArgument(\"Fov\");",
            "//",
            "if (Operator == \"=\") {",
            "    Camera.fov = Fov;",
            "} else if (Operator == \"+\") {",
            "    Camera.fov += Fov;",
            "} else if (Operator == \"-\") {",
            "    Camera.fov -= Fov;",
            "}",
            "Camera.updateProjectionMatrix();",
            "",
            ""
          ],
          "parameterObjects": "",
          "useStrict": true,
          "eventsSheetExpanded": true
        }
      ],
      "parameters": [
        {
          "description": "3D Camera ID (1 to 4)",
          "name": "Id",
          "type": "expression"
        },
        {
          "description": "Operator",
          "name": "Operator",
          "supplementaryInformation": "[\"=\",\"+\",\"-\"]",
          "type": "stringWithSelector"
        },
        {
          "description": "Field Of View (Default: 50)",
          "name": "Fov",
          "type": "expression"
        }
      ],
      "objectGroups": []
    },
    {
      "description": "Change the near property of the 3D Camera.\nThe 3D Camera will not render 3D Objects closer than this distance.",
      "fullName": "🎥Change 3D Camera Near",
      "functionType": "Action",
      "group": "3D Camera",
      "name": "Change3DCameraNear",
      "sentence": "🎥Change 3D Camera Near (ID: _PARAM1_, _PARAM2_, Near: _PARAM3_)",
      "events": [
        {
          "type": "BuiltinCommonInstructions::JsCode",
          "inlineCode": [
            "if (!gdjs.__WithThreeJS.has(\"Renderer\")) {",
            "    console.warn(\"!\");",
            "    return;",
            "}",
            "// const Camera = gdjs.__WithThreeJS.get(\"Camera\");",
            "const Id = eventsFunctionContext.getArgument(\"Id\");",
            "const Camera = gdjs.__WithThreeJS.get(\"GetCamera\")(Id);",
            "const Operator = eventsFunctionContext.getArgument(\"Operator\");",
            "const Near = eventsFunctionContext.getArgument(\"Near\");",
            "//",
            "if (Operator == \"=\") {",
            "    Camera.near = Near;",
            "} else if (Operator == \"+\") {",
            "    Camera.near += Near;",
            "} else if (Operator == \"-\") {",
            "    Camera.near -= Near;",
            "}",
            "Camera.updateProjectionMatrix();",
            "",
            ""
          ],
          "parameterObjects": "",
          "useStrict": true,
          "eventsSheetExpanded": true
        }
      ],
      "parameters": [
        {
          "description": "3D Camera ID (1 to 4)",
          "name": "Id",
          "type": "expression"
        },
        {
          "description": "Operator",
          "name": "Operator",
          "supplementaryInformation": "[\"=\",\"+\",\"-\"]",
          "type": "stringWithSelector"
        },
        {
          "description": "Near (Default: 0.1) (Greater than 0)",
          "name": "Near",
          "type": "expression"
        }
      ],
      "objectGroups": []
    },
    {
      "description": "Change the far property of 3D Camera.\nThe 3D Camera will not render 3D Objects farther than this distance.",
      "fullName": "🎥Change 3D Camera Far",
      "functionType": "Action",
      "group": "3D Camera",
      "name": "Change3DCameraFar",
      "sentence": "🎥Change 3D Camera Far (ID: _PARAM1_, _PARAM2_, Far: _PARAM3_)",
      "events": [
        {
          "type": "BuiltinCommonInstructions::JsCode",
          "inlineCode": [
            "if (!gdjs.__WithThreeJS.has(\"Renderer\")) {",
            "    console.warn(\"!\");",
            "    return;",
            "}",
            "// const Camera = gdjs.__WithThreeJS.get(\"Camera\");",
            "const Id = eventsFunctionContext.getArgument(\"Id\");",
            "const Camera = gdjs.__WithThreeJS.get(\"GetCamera\")(Id);",
            "const Operator = eventsFunctionContext.getArgument(\"Operator\");",
            "const Far = eventsFunctionContext.getArgument(\"Far\");",
            "//",
            "if (Operator == \"=\") {",
            "    Camera.far = Far;",
            "} else if (Operator == \"+\") {",
            "    Camera.far += Far;",
            "} else if (Operator == \"-\") {",
            "    Camera.far -= Far;",
            "}",
            "Camera.updateProjectionMatrix();",
            "",
            ""
          ],
          "parameterObjects": "",
          "useStrict": true,
          "eventsSheetExpanded": true
        }
      ],
      "parameters": [
        {
          "description": "3D Camera ID (1 to 4)",
          "name": "Id",
          "type": "expression"
        },
        {
          "description": "Operator",
          "name": "Operator",
          "supplementaryInformation": "[\"=\",\"+\",\"-\"]",
          "type": "stringWithSelector"
        },
        {
          "description": "Far (Default: 10000)",
          "name": "Far",
          "type": "expression"
        }
      ],
      "objectGroups": []
    },
    {
      "fullName": "🎥Change 3D Camera Zoom",
      "functionType": "Action",
      "group": "3D Camera",
      "name": "Change3DCameraZoom",
      "sentence": "🎥Change 3D Camera Zoom (ID: _PARAM1_, _PARAM2_, Zoom: _PARAM3_)",
      "events": [
        {
          "type": "BuiltinCommonInstructions::JsCode",
          "inlineCode": [
            "if (!gdjs.__WithThreeJS.has(\"Renderer\")) {",
            "    console.warn(\"!\");",
            "    return;",
            "}",
            "// const Camera = gdjs.__WithThreeJS.get(\"Camera\");",
            "const Id = eventsFunctionContext.getArgument(\"Id\");",
            "const Camera = gdjs.__WithThreeJS.get(\"GetCamera\")(Id);",
            "const Operator = eventsFunctionContext.getArgument(\"Operator\");",
            "const Zoom = eventsFunctionContext.getArgument(\"Zoom\");",
            "//",
            "if (Operator == \"=\") {",
            "    Camera.zoom = Zoom;",
            "} else if (Operator == \"+\") {",
            "    Camera.zoom += Zoom;",
            "} else if (Operator == \"-\") {",
            "    Camera.zoom -= Zoom;",
            "}",
            "Camera.updateProjectionMatrix();",
            "",
            ""
          ],
          "parameterObjects": "",
          "useStrict": true,
          "eventsSheetExpanded": true
        }
      ],
      "parameters": [
        {
          "description": "3D Camera ID (1 to 4)",
          "name": "Id",
          "type": "expression"
        },
        {
          "description": "Operator",
          "name": "Operator",
          "supplementaryInformation": "[\"=\",\"+\",\"-\"]",
          "type": "stringWithSelector"
        },
        {
          "description": "Zoom (Default: 1)",
          "name": "Zoom",
          "type": "expression"
        }
      ],
      "objectGroups": []
    },
    {
      "description": "Note that rendering time increases by the number of enabled 3D Cameras.",
      "fullName": "🎥Setup Multiple 3D Cameras",
      "functionType": "Action",
      "group": "3D Camera",
      "name": "SetupMultiple3DCameras",
      "sentence": "🎥Setup Multiple 3D Cameras (Camera2: _PARAM5_, Camera3: _PARAM10_, Camera4: _PARAM15_)",
      "events": [
        {
          "type": "BuiltinCommonInstructions::JsCode",
          "inlineCode": [
            "if (!gdjs.__WithThreeJS.has(\"Renderer\")) {",
            "    console.warn(\"!\");",
            "    return;",
            "}",
            "// const Camera = gdjs.__WithThreeJS.get(\"Camera\");",
            "const Canvas2D = gdjs.__WithThreeJS.get(\"Canvas2D\");",
            "const Rect = Canvas2D.getBoundingClientRect();",
            "const AllCams = gdjs.__WithThreeJS.get(\"AllCams\");",
            "const Arguments = {};",
            "Arguments.Camera1 = {};",
            "Arguments.Camera1.Active = true;",
            "Arguments.Camera1.Top = eventsFunctionContext.getArgument(\"Top1\") || 0;",
            "Arguments.Camera1.Bottom = eventsFunctionContext.getArgument(\"Bottom1\") || 1;",
            "Arguments.Camera1.Left = eventsFunctionContext.getArgument(\"Left1\") || 0;",
            "Arguments.Camera1.Right = eventsFunctionContext.getArgument(\"Right1\") || 1;",
            "Arguments.Camera2 = {};",
            "Arguments.Camera2.Active = eventsFunctionContext.getArgument(\"Active2\") || false;",
            "Arguments.Camera2.Top = eventsFunctionContext.getArgument(\"Top2\") || 0;",
            "Arguments.Camera2.Bottom = eventsFunctionContext.getArgument(\"Bottom2\") || 1;",
            "Arguments.Camera2.Left = eventsFunctionContext.getArgument(\"Left2\") || 0;",
            "Arguments.Camera2.Right = eventsFunctionContext.getArgument(\"Right2\") || 1;",
            "Arguments.Camera3 = {};",
            "Arguments.Camera3.Active = eventsFunctionContext.getArgument(\"Active3\") || false;",
            "Arguments.Camera3.Top = eventsFunctionContext.getArgument(\"Top3\") || 0;",
            "Arguments.Camera3.Bottom = eventsFunctionContext.getArgument(\"Bottom3\") || 1;",
            "Arguments.Camera3.Left = eventsFunctionContext.getArgument(\"Left3\") || 0;",
            "Arguments.Camera3.Right = eventsFunctionContext.getArgument(\"Right3\") || 1;",
            "Arguments.Camera4 = {};",
            "Arguments.Camera4.Active = eventsFunctionContext.getArgument(\"Active4\") || false;",
            "Arguments.Camera4.Top = eventsFunctionContext.getArgument(\"Top4\") || 0;",
            "Arguments.Camera4.Bottom = eventsFunctionContext.getArgument(\"Bottom4\") || 1;",
            "Arguments.Camera4.Left = eventsFunctionContext.getArgument(\"Left4\") || 0;",
            "Arguments.Camera4.Right = eventsFunctionContext.getArgument(\"Right4\") || 1;",
            "//",
            "for (const [K, V] of AllCams) {",
            "    const C = Arguments[K];",
            "    V.userData.CameraStatus.Active = C.Active;",
            "    const T = V.userData.CameraStatus.T = 1 - C.Top;",
            "    const B = V.userData.CameraStatus.B = 1 - C.Bottom;",
            "    const L = V.userData.CameraStatus.L = C.Left;",
            "    const R = V.userData.CameraStatus.R = C.Right;",
            "    V.userData.CameraStatus.X = L * Rect.width;",
            "    V.userData.CameraStatus.Y = B * Rect.height;",
            "    const W = V.userData.CameraStatus.W = (R - L) * Rect.width;",
            "    const H = V.userData.CameraStatus.H = (T - B) * Rect.height;",
            "    V.aspect = W / H;",
            "    V.updateProjectionMatrix();",
            "}",
            "",
            ""
          ],
          "parameterObjects": "",
          "useStrict": true,
          "eventsSheetExpanded": true
        }
      ],
      "parameters": [
        {
          "description": "Camera1 Viewport: Top (0 to 1, Default: 0)",
          "name": "Top1",
          "type": "expression"
        },
        {
          "description": "Camera1 Viewport: Bottom (0 to 1, Default: 1)",
          "name": "Bottom1",
          "type": "expression"
        },
        {
          "description": "Camera1 Viewport: Left (0 to 1, Default: 0)",
          "name": "Left1",
          "supplementaryInformation": "[\"=\",\"+\",\"-\"]",
          "type": "expression"
        },
        {
          "description": "Camera1 Viewport: Right (0 to 1, Default: 1)",
          "name": "Right1",
          "type": "expression"
        },
        {
          "defaultValue": "no",
          "description": "Enable 3D Camera2",
          "name": "Active2",
          "optional": true,
          "type": "yesorno"
        },
        {
          "description": "Camera2 Viewport: Top (0 to 1)",
          "name": "Top2",
          "type": "expression"
        },
        {
          "description": "Camera2 Viewport: Bottom (0 to 1)",
          "name": "Bottom2",
          "type": "expression"
        },
        {
          "description": "Camera2 Viewport: Left (0 to 1)",
          "name": "Left2",
          "type": "expression"
        },
        {
          "description": "Camera2 Viewport: Right (0 to 1)",
          "name": "Right2",
          "type": "expression"
        },
        {
          "description": "Enable 3D Camera3",
          "name": "Active3",
          "type": "yesorno"
        },
        {
          "description": "Camera3 Viewport: Top (0 to 1)",
          "name": "Top3",
          "type": "expression"
        },
        {
          "description": "Camera3 Viewport: Bottom (0 to 1)",
          "name": "Bottom3",
          "type": "expression"
        },
        {
          "description": "Camera3 Viewport: Left (0 to 1)",
          "name": "Left3",
          "type": "expression"
        },
        {
          "description": "Camera3 Viewport: Right (0 to 1)",
          "name": "Right3",
          "type": "expression"
        },
        {
          "description": "Enable 3D Camera4",
          "name": "Active4",
          "type": "yesorno"
        },
        {
          "description": "Camera4 Viewport: Top (0 to 1)",
          "name": "Top4",
          "type": "expression"
        },
        {
          "description": "Camera4 Viewport: Bottom (0 to 1)",
          "name": "Bottom4",
          "type": "expression"
        },
        {
          "description": "Camera4 Viewport: Left (0 to 1)",
          "name": "Left4",
          "type": "expression"
        },
        {
          "description": "Camera4 Viewport: Right (0 to 1)",
          "name": "Right4",
          "type": "expression"
        }
      ],
      "objectGroups": []
    },
    {
      "fullName": "🔜Linearly interpolate 3D Camera",
      "functionType": "Action",
      "group": "3D Camera",
      "name": "LerpCamera",
      "sentence": "🔜Linearly Interpolate 3D Camera (Camera ID: _PARAM1_, Target ID: _PARAM2_, Position: _PARAM3_, Rotation: _PARAM4_)",
      "events": [
        {
          "type": "BuiltinCommonInstructions::JsCode",
          "inlineCode": [
            "if (!gdjs.__WithThreeJS.has(\"Renderer\")) {",
            "    console.warn(\"!\");",
            "    return;",
            "}",
            "const Scene = gdjs.__WithThreeJS.get(\"Scene\");",
            "const Id = eventsFunctionContext.getArgument(\"Id\");",
            "const Camera = gdjs.__WithThreeJS.get(\"GetCamera\")(Id);",
            "const TargetId = eventsFunctionContext.getArgument(\"TargetId\");",
            "const FactorP = eventsFunctionContext.getArgument(\"FactorP\");",
            "const FactorR = eventsFunctionContext.getArgument(\"FactorR\");",
            "//",
            "const Obj = gdjs.__WithThreeJS.get(\"SearchObject\")(TargetId);",
            "if (!Obj) {",
            "    console.warn(\"3D Object not found: \" + TargetId);",
            "    return;",
            "}",
            "//",
            "if (FactorP) {",
            "    const WPos = new THREE.Vector3();",
            "    Obj.getWorldPosition(WPos);",
            "    Camera.position.lerp(WPos, FactorP);",
            "}",
            "if (FactorR) {",
            "    const WQua = new THREE.Quaternion();",
            "    Obj.getWorldQuaternion(WQua);",
            "    Camera.quaternion.slerp(WQua, FactorR);",
            "}",
            "",
            ""
          ],
          "parameterObjects": "",
          "useStrict": true,
          "eventsSheetExpanded": true
        }
      ],
      "parameters": [
        {
          "description": "3D Camera ID (1 to 4)",
          "name": "Id",
          "type": "expression"
        },
        {
          "description": "Target 3D Object ID",
          "name": "TargetId",
          "supplementaryInformation": "scene3D Object ID",
          "type": "identifier"
        },
        {
          "description": "Position interpolation factor (0 to 1)",
          "longDescription": "Disable with 0",
          "name": "FactorP",
          "type": "expression"
        },
        {
          "description": "Rotation interpolation factor (0 to 1)",
          "longDescription": "Disable with 0",
          "name": "FactorR",
          "type": "expression"
        }
      ],
      "objectGroups": []
    },
    {
      "fullName": "3D Camera Position",
      "functionType": "Expression",
      "group": "3D Camera",
      "name": "CameraPosition",
      "sentence": "",
      "events": [
        {
          "type": "BuiltinCommonInstructions::JsCode",
          "inlineCode": [
            "if (!gdjs.__WithThreeJS.has(\"Renderer\")) {",
            "    console.warn(\"!\");",
            "    return;",
            "}",
            "// const Camera = gdjs.__WithThreeJS.get(\"Camera\");",
            "const Id = eventsFunctionContext.getArgument(\"Id\");",
            "const Camera = gdjs.__WithThreeJS.get(\"GetCamera\")(Id);",
            "const Axis = eventsFunctionContext.getArgument(\"Axis\");",
            "if (Axis == \"X\") {",
            "    eventsFunctionContext.returnValue = Camera.position.x;",
            "} else if (Axis == \"Y\") {",
            "    eventsFunctionContext.returnValue = Camera.position.y;",
            "} else {",
            "    eventsFunctionContext.returnValue = Camera.position.z;",
            "}",
            "",
            ""
          ],
          "parameterObjects": "",
          "useStrict": true,
          "eventsSheetExpanded": true
        }
      ],
      "expressionType": {
        "type": "expression"
      },
      "parameters": [
        {
          "description": "3D Camera ID (1 to 4)",
          "name": "Id",
          "type": "expression"
        },
        {
          "description": "Axis",
          "name": "Axis",
          "supplementaryInformation": "[\"X\",\"Y\",\"Z\"]",
          "type": "stringWithSelector"
        }
      ],
      "objectGroups": []
    },
    {
      "fullName": "3D Camera Rotation",
      "functionType": "Expression",
      "group": "3D Camera",
      "name": "CameraRotation",
      "sentence": "",
      "events": [
        {
          "type": "BuiltinCommonInstructions::JsCode",
          "inlineCode": [
            "if (!gdjs.__WithThreeJS.has(\"Renderer\")) {",
            "    console.warn(\"!\");",
            "    return;",
            "}",
            "// const Camera = gdjs.__WithThreeJS.get(\"Camera\");",
            "const Id = eventsFunctionContext.getArgument(\"Id\");",
            "const Camera = gdjs.__WithThreeJS.get(\"GetCamera\")(Id);",
            "const Axis = eventsFunctionContext.getArgument(\"Axis\");",
            "if (Axis == \"X\") {",
            "    eventsFunctionContext.returnValue = gdjs.toDegrees(Camera.rotation.x);",
            "} else if (Axis == \"Y\") {",
            "    eventsFunctionContext.returnValue = gdjs.toDegrees(Camera.rotation.y);",
            "} else {",
            "    eventsFunctionContext.returnValue = gdjs.toDegrees(Camera.rotation.z);",
            "}",
            "",
            ""
          ],
          "parameterObjects": "",
          "useStrict": true,
          "eventsSheetExpanded": true
        }
      ],
      "expressionType": {
        "type": "expression"
      },
      "parameters": [
        {
          "description": "3D Camera ID (1 to 4)",
          "name": "Id",
          "type": "expression"
        },
        {
          "description": "Axis",
          "name": "Axis",
          "supplementaryInformation": "[\"X\",\"Y\",\"Z\"]",
          "type": "stringWithSelector"
        }
      ],
      "objectGroups": []
    },
    {
      "description": "3D Camera Angle for GDevelop.\nReturns the angle of an individual axis.\nNote that combining the resulting XYZ values may not reproduce the original rotation.",
      "fullName": "3D Camera Angle (Deprecated)",
      "functionType": "Expression",
      "group": "3D Camera",
      "name": "CameraAngle",
      "private": true,
      "sentence": "",
      "events": [
        {
          "type": "BuiltinCommonInstructions::JsCode",
          "inlineCode": [
            "if (!gdjs.__WithThreeJS.has(\"Renderer\")) {",
            "    console.warn(\"!\");",
            "    return;",
            "}",
            "// const Camera = gdjs.__WithThreeJS.get(\"Camera\");",
            "const Id = eventsFunctionContext.getArgument(\"Id\");",
            "const Camera = gdjs.__WithThreeJS.get(\"GetCamera\")(Id);",
            "const Axis = eventsFunctionContext.getArgument(\"Axis\");",
            "const Rad3 = gdjs.__WithThreeJS.get(\"GetSingleRadian3\")(Camera);",
            "",
            "if (Axis == \"X\") {",
            "    eventsFunctionContext.returnValue = gdjs.toDegrees(Rad3.x * -1);",
            "} else if (Axis == \"Y\") {",
            "    eventsFunctionContext.returnValue = gdjs.toDegrees(Rad3.y * -1);",
            "} else {",
            "    eventsFunctionContext.returnValue = gdjs.toDegrees(Rad3.z * -1);",
            "}",
            "",
            ""
          ],
          "parameterObjects": "",
          "useStrict": true,
          "eventsSheetExpanded": true
        }
      ],
      "expressionType": {
        "type": "expression"
      },
      "parameters": [
        {
          "description": "3D Camera ID (1 to 4)",
          "name": "Id",
          "type": "expression"
        },
        {
          "description": "Axis",
          "name": "Axis",
          "supplementaryInformation": "[\"X\",\"Y\",\"Z\"]",
          "type": "stringWithSelector"
        }
      ],
      "objectGroups": []
    },
    {
      "description": "Normalized direction vector of 3D camera.\n(3D Camera is shooting in the negative Z axis direction)",
      "fullName": "3D Camera Direction",
      "functionType": "Expression",
      "group": "3D Camera",
      "name": "CameraDirection",
      "sentence": "",
      "events": [
        {
          "type": "BuiltinCommonInstructions::JsCode",
          "inlineCode": [
            "if (!gdjs.__WithThreeJS.has(\"Renderer\")) {",
            "    console.warn(\"!\");",
            "    return;",
            "}",
            "// const Camera = gdjs.__WithThreeJS.get(\"Camera\");",
            "const Id = eventsFunctionContext.getArgument(\"Id\");",
            "const Camera = gdjs.__WithThreeJS.get(\"GetCamera\")(Id);",
            "const Axis = eventsFunctionContext.getArgument(\"Axis\");",
            "const WorldDirection = new THREE.Vector3();",
            "Camera.getWorldDirection(WorldDirection);",
            "//",
            "if (Axis == \"X\") {",
            "    eventsFunctionContext.returnValue = WorldDirection.x;",
            "} else if (Axis == \"Y\") {",
            "    eventsFunctionContext.returnValue = WorldDirection.y;",
            "} else {",
            "    eventsFunctionContext.returnValue = WorldDirection.z;",
            "}",
            "",
            ""
          ],
          "parameterObjects": "",
          "useStrict": true,
          "eventsSheetExpanded": true
        }
      ],
      "expressionType": {
        "type": "expression"
      },
      "parameters": [
        {
          "description": "3D Camera ID (1 to 4)",
          "name": "Id",
          "type": "expression"
        },
        {
          "description": "Axis",
          "name": "Axis",
          "supplementaryInformation": "[\"X\",\"Y\",\"Z\"]",
          "type": "stringWithSelector"
        }
      ],
      "objectGroups": []
    },
    {
      "fullName": "Distance From 3D Camera To 3D Object",
      "functionType": "Expression",
      "group": "3D Camera",
      "name": "DistanceFrom3DCameraTo3DObject",
      "sentence": "",
      "events": [
        {
          "type": "BuiltinCommonInstructions::JsCode",
          "inlineCode": [
            "if (!gdjs.__WithThreeJS.has(\"Renderer\")) {",
            "    console.warn(\"!\");",
            "    return;",
            "}",
            "const Scene = gdjs.__WithThreeJS.get(\"Scene\");",
            "// const Camera = gdjs.__WithThreeJS.get(\"Camera\");",
            "const CameraId = eventsFunctionContext.getArgument(\"CameraId\");",
            "const Camera = gdjs.__WithThreeJS.get(\"GetCamera\")(CameraId);",
            "const Id = eventsFunctionContext.getArgument(\"Id\");",
            "//",
            "const Obj = gdjs.__WithThreeJS.get(\"SearchObject\")(Id);",
            "if (!Obj) {",
            "    console.warn(\"3D Object not found: \" + Id);",
            "    return;",
            "}",
            "//",
            "const WPos1 = new THREE.Vector3();",
            "const WPos2 = new THREE.Vector3();",
            "Camera.getWorldPosition(WPos1);",
            "Obj.getWorldPosition(WPos2);",
            "eventsFunctionContext.returnValue = WPos1.distanceTo(WPos2);",
            "",
            ""
          ],
          "parameterObjects": "",
          "useStrict": true,
          "eventsSheetExpanded": true
        }
      ],
      "expressionType": {
        "type": "expression"
      },
      "parameters": [
        {
          "description": "From 3D Camera ID (1 to 4)",
          "name": "CameraId",
          "type": "expression"
        },
        {
          "description": "To 3D Object ID",
          "name": "Id",
          "supplementaryInformation": "scene3D Object ID",
          "type": "identifier"
        }
      ],
      "objectGroups": []
    },
    {
      "fullName": "3D Camera FOV",
      "functionType": "Expression",
      "group": "3D Camera",
      "name": "CameraFOV",
      "sentence": "",
      "events": [
        {
          "type": "BuiltinCommonInstructions::JsCode",
          "inlineCode": [
            "if (!gdjs.__WithThreeJS.has(\"Renderer\")) {",
            "    console.warn(\"!\");",
            "    return;",
            "}",
            "// const Camera = gdjs.__WithThreeJS.get(\"Camera\");",
            "const Id = eventsFunctionContext.getArgument(\"Id\");",
            "const Camera = gdjs.__WithThreeJS.get(\"GetCamera\")(Id);",
            "eventsFunctionContext.returnValue = Camera.fov;",
            "",
            ""
          ],
          "parameterObjects": "",
          "useStrict": true,
          "eventsSheetExpanded": true
        }
      ],
      "expressionType": {
        "type": "expression"
      },
      "parameters": [
        {
          "description": "3D Camera ID (1 to 4)",
          "name": "Id",
          "type": "expression"
        }
      ],
      "objectGroups": []
    },
    {
      "description": "The camera will not render objects closer than this distance.",
      "fullName": "3D Camera Near",
      "functionType": "Expression",
      "group": "3D Camera",
      "name": "CameraNear",
      "sentence": "",
      "events": [
        {
          "type": "BuiltinCommonInstructions::JsCode",
          "inlineCode": [
            "if (!gdjs.__WithThreeJS.has(\"Renderer\")) {",
            "    console.warn(\"!\");",
            "    return;",
            "}",
            "// const Camera = gdjs.__WithThreeJS.get(\"Camera\");",
            "const Id = eventsFunctionContext.getArgument(\"Id\");",
            "const Camera = gdjs.__WithThreeJS.get(\"GetCamera\")(Id);",
            "eventsFunctionContext.returnValue = Camera.near;",
            "",
            ""
          ],
          "parameterObjects": "",
          "useStrict": true,
          "eventsSheetExpanded": true
        }
      ],
      "expressionType": {
        "type": "expression"
      },
      "parameters": [
        {
          "description": "3D Camera ID (1 to 4)",
          "name": "Id",
          "type": "expression"
        }
      ],
      "objectGroups": []
    },
    {
      "fullName": "3D Camera Far",
      "functionType": "Expression",
      "group": "3D Camera",
      "name": "CameraFar",
      "sentence": "",
      "events": [
        {
          "type": "BuiltinCommonInstructions::JsCode",
          "inlineCode": [
            "if (!gdjs.__WithThreeJS.has(\"Renderer\")) {",
            "    console.warn(\"!\");",
            "    return;",
            "}",
            "// const Camera = gdjs.__WithThreeJS.get(\"Camera\");",
            "const Id = eventsFunctionContext.getArgument(\"Id\");",
            "const Camera = gdjs.__WithThreeJS.get(\"GetCamera\")(Id);",
            "eventsFunctionContext.returnValue = Camera.far;",
            "",
            ""
          ],
          "parameterObjects": "",
          "useStrict": true,
          "eventsSheetExpanded": true
        }
      ],
      "expressionType": {
        "type": "expression"
      },
      "parameters": [
        {
          "description": "3D Camera ID (1 to 4)",
          "name": "Id",
          "type": "expression"
        }
      ],
      "objectGroups": []
    },
    {
      "fullName": "3D Camera Zoom",
      "functionType": "Expression",
      "group": "3D Camera",
      "name": "CameraZoom",
      "sentence": "",
      "events": [
        {
          "type": "BuiltinCommonInstructions::JsCode",
          "inlineCode": [
            "if (!gdjs.__WithThreeJS.has(\"Renderer\")) {",
            "    console.warn(\"!\");",
            "    return;",
            "}",
            "// const Camera = gdjs.__WithThreeJS.get(\"Camera\");",
            "const Id = eventsFunctionContext.getArgument(\"Id\");",
            "const Camera = gdjs.__WithThreeJS.get(\"GetCamera\")(Id);",
            "eventsFunctionContext.returnValue = Camera.zoom;",
            "",
            ""
          ],
          "parameterObjects": "",
          "useStrict": true,
          "eventsSheetExpanded": true
        }
      ],
      "expressionType": {
        "type": "expression"
      },
      "parameters": [
        {
          "description": "3D Camera ID (1 to 4)",
          "name": "Id",
          "type": "expression"
        }
      ],
      "objectGroups": []
    },
    {
      "fullName": "Point Of 3D Object On 3D Camera",
      "functionType": "Expression",
      "group": "3D Camera",
      "name": "PointOf3DObjectOn3DCamera",
      "sentence": "",
      "events": [
        {
          "type": "BuiltinCommonInstructions::JsCode",
          "inlineCode": [
            "if (!gdjs.__WithThreeJS.has(\"Renderer\")) {",
            "    console.warn(\"!\");",
            "    return;",
            "}",
            "const Scene = gdjs.__WithThreeJS.get(\"Scene\");",
            "const CameraId = eventsFunctionContext.getArgument(\"CameraId\");",
            "const Camera = gdjs.__WithThreeJS.get(\"GetCamera\")(CameraId);",
            "const Id = eventsFunctionContext.getArgument(\"Id\");",
            "const Axis = eventsFunctionContext.getArgument(\"Axis\");",
            "//",
            "const Obj = gdjs.__WithThreeJS.get(\"SearchObject\")(Id);",
            "if (!Obj) {",
            "    console.warn(\"3D Object not found: \" + Id);",
            "    return;",
            "}",
            "//",
            "const WorldPosition = new THREE.Vector3();",
            "Obj.getWorldPosition(WorldPosition);",
            "const Project = WorldPosition.project(Camera);",
            "//",
            "const T = Camera.userData.CameraStatus.T;",
            "const B = Camera.userData.CameraStatus.B;",
            "const L = Camera.userData.CameraStatus.L;",
            "const R = Camera.userData.CameraStatus.R;",
            "const GameResolutionWidth = runtimeScene.getGame().getGameResolutionWidth();",
            "const GameResolutionHeight = runtimeScene.getGame().getGameResolutionHeight();",
            "const ScreenResolutionWidth = GameResolutionWidth * (R - L);",
            "const ScreenResolutionHeight = GameResolutionHeight * (T - B);",
            "const CameraScreenX = L * GameResolutionWidth;",
            "const CameraScreenY = (1 - T) * GameResolutionHeight;",
            "//",
            "const PointX = CameraScreenX + ((ScreenResolutionWidth / 2) * (Project.x + 1.0));",
            "const PointY = CameraScreenY + ((ScreenResolutionHeight / 2) * ((Project.y * -1) + 1.0));",
            "//",
            "if (Axis == \"X\") {",
            "    eventsFunctionContext.returnValue = PointX;",
            "} else {",
            "    eventsFunctionContext.returnValue = PointY;",
            "}",
            "",
            ""
          ],
          "parameterObjects": "",
          "useStrict": true,
          "eventsSheetExpanded": true
        }
      ],
      "expressionType": {
        "type": "expression"
      },
      "parameters": [
        {
          "description": "3D Camera ID (1 to 4)",
          "name": "CameraId",
          "type": "expression"
        },
        {
          "description": "3D Object ID",
          "name": "Id",
          "supplementaryInformation": "scene3D Object ID",
          "type": "identifier"
        },
        {
          "description": "Axis Of Return Value",
          "name": "Axis",
          "supplementaryInformation": "[\"X\",\"Y\"]",
          "type": "stringWithSelector"
        }
      ],
      "objectGroups": []
    },
    {
      "fullName": "Point Of World Position On 3D Camera",
      "functionType": "Expression",
      "group": "3D Camera",
      "name": "PointOfPositionOn3DCamera",
      "sentence": "",
      "events": [
        {
          "type": "BuiltinCommonInstructions::JsCode",
          "inlineCode": [
            "if (!gdjs.__WithThreeJS.has(\"Renderer\")) {",
            "    console.warn(\"!\");",
            "    return;",
            "}",
            "const CameraId = eventsFunctionContext.getArgument(\"CameraId\");",
            "const Camera = gdjs.__WithThreeJS.get(\"GetCamera\")(CameraId);",
            "const X = eventsFunctionContext.getArgument(\"X\");",
            "const Y = eventsFunctionContext.getArgument(\"Y\");",
            "const Z = eventsFunctionContext.getArgument(\"Z\");",
            "const Axis = eventsFunctionContext.getArgument(\"Axis\");",
            "//",
            "const WorldPosition = new THREE.Vector3(X, Y, Z);",
            "const Project = WorldPosition.project(Camera);",
            "//",
            "const T = Camera.userData.CameraStatus.T;",
            "const B = Camera.userData.CameraStatus.B;",
            "const L = Camera.userData.CameraStatus.L;",
            "const R = Camera.userData.CameraStatus.R;",
            "const GameResolutionWidth = runtimeScene.getGame().getGameResolutionWidth();",
            "const GameResolutionHeight = runtimeScene.getGame().getGameResolutionHeight();",
            "const ScreenResolutionWidth = GameResolutionWidth * (R - L);",
            "const ScreenResolutionHeight = GameResolutionHeight * (T - B);",
            "const CameraScreenX = L * GameResolutionWidth;",
            "const CameraScreenY = (1 - T) * GameResolutionHeight;",
            "//",
            "const PointX = CameraScreenX + ((ScreenResolutionWidth / 2) * (Project.x + 1.0));",
            "const PointY = CameraScreenY + ((ScreenResolutionHeight / 2) * ((Project.y * -1) + 1.0));",
            "//",
            "if (Axis == \"X\") {",
            "    eventsFunctionContext.returnValue = PointX;",
            "} else {",
            "    eventsFunctionContext.returnValue = PointY;",
            "}",
            "",
            ""
          ],
          "parameterObjects": "",
          "useStrict": true,
          "eventsSheetExpanded": true
        }
      ],
      "expressionType": {
        "type": "expression"
      },
      "parameters": [
        {
          "description": "3D Camera ID (1 to 4)",
          "name": "CameraId",
          "type": "expression"
        },
        {
          "description": "World Position X",
          "name": "X",
          "supplementaryInformation": "scene3D Object ID",
          "type": "expression"
        },
        {
          "description": "World Position Y",
          "name": "Y",
          "type": "expression"
        },
        {
          "description": "World Position Z",
          "name": "Z",
          "type": "expression"
        },
        {
          "description": "Axis Of Return Value",
          "name": "Axis",
          "supplementaryInformation": "[\"X\",\"Y\"]",
          "type": "stringWithSelector"
        }
      ],
      "objectGroups": []
    },
    {
      "description": "Move a 3D Object.\n'=' is relative to the parent axis.\n\"+\" and \"-\" are relative to the local axis.",
      "fullName": "↔️Move 3D Object",
      "functionType": "Action",
      "group": "3D Object",
      "name": "Move3DObject",
      "sentence": "↔️Move 3D Object (ID: _PARAM1_, _PARAM2_, X: _PARAM3_, Y: _PARAM4_, Z: _PARAM5_)",
      "events": [
        {
          "type": "BuiltinCommonInstructions::JsCode",
          "inlineCode": [
            "if (!gdjs.__WithThreeJS.has(\"Renderer\")) {",
            "    console.warn(\"!\");",
            "    return;",
            "}",
            "const Scene = gdjs.__WithThreeJS.get(\"Scene\");",
            "const Id = eventsFunctionContext.getArgument(\"Id\");",
            "const Operator = eventsFunctionContext.getArgument(\"Operator\");",
            "const X = eventsFunctionContext.getArgument(\"X\");",
            "const Y = eventsFunctionContext.getArgument(\"Y\");",
            "const Z = eventsFunctionContext.getArgument(\"Z\");",
            "//",
            "const Obj = gdjs.__WithThreeJS.get(\"SearchObject\")(Id);",
            "if (!Obj) {",
            "    console.warn(\"3D Object not found: \" + Id);",
            "    return;",
            "}",
            "//",
            "if (Operator == \"=\") {",
            "    Obj.position.set(X, Y, Z);",
            "} else if (Operator == \"+\") {",
            "    Obj.translateX(X);",
            "    Obj.translateY(Y);",
            "    Obj.translateZ(Z);",
            "} else {",
            "    Obj.translateX(-X);",
            "    Obj.translateY(-Y);",
            "    Obj.translateZ(-Z);",
            "}",
            "",
            ""
          ],
          "parameterObjects": "",
          "useStrict": true,
          "eventsSheetExpanded": true
        }
      ],
      "parameters": [
        {
          "description": "3D Object ID",
          "name": "Id",
          "supplementaryInformation": "scene3D Object ID",
          "type": "identifier"
        },
        {
          "description": "Operator",
          "name": "Operator",
          "supplementaryInformation": "[\"=\",\"+\",\"-\"]",
          "type": "stringWithSelector"
        },
        {
          "description": "X",
          "name": "X",
          "type": "expression"
        },
        {
          "description": "Y",
          "name": "Y",
          "type": "expression"
        },
        {
          "description": "Z",
          "name": "Z",
          "type": "expression"
        }
      ],
      "objectGroups": []
    },
    {
      "description": "Move a 3D Object on the world axis.\n\"=\", \"+\" and \"-\" are relative to the world axis.",
      "fullName": "↔️Move 3D Object On World",
      "functionType": "Action",
      "group": "3D Object",
      "name": "Move3DObjectOnWorld",
      "sentence": "↔️Move 3D Object On World (ID: _PARAM1_, _PARAM2_, X: _PARAM3_, Y: _PARAM4_, Z: _PARAM5_)",
      "events": [
        {
          "type": "BuiltinCommonInstructions::JsCode",
          "inlineCode": [
            "if (!gdjs.__WithThreeJS.has(\"Renderer\")) {",
            "    console.warn(\"!\");",
            "    return;",
            "}",
            "const Scene = gdjs.__WithThreeJS.get(\"Scene\");",
            "const Id = eventsFunctionContext.getArgument(\"Id\");",
            "const Operator = eventsFunctionContext.getArgument(\"Operator\");",
            "const X = eventsFunctionContext.getArgument(\"X\");",
            "const Y = eventsFunctionContext.getArgument(\"Y\");",
            "const Z = eventsFunctionContext.getArgument(\"Z\");",
            "//",
            "const Obj = gdjs.__WithThreeJS.get(\"SearchObject\")(Id);",
            "if (!Obj) {",
            "    console.warn(\"3D Object not found: \" + Id);",
            "    return;",
            "}",
            "//",
            "const Parent = Obj.parent;",
            "const WorldPosition = new THREE.Vector3();",
            "Obj.getWorldPosition(WorldPosition);",
            "if (Operator == \"=\") {",
            "    WorldPosition.set(X, Y, Z);",
            "} else if (Operator == \"+\") {",
            "    WorldPosition.add(new THREE.Vector3(X, Y, Z));",
            "} else {",
            "    WorldPosition.sub(new THREE.Vector3(X, Y, Z));",
            "}",
            "Parent.worldToLocal(WorldPosition);",
            "Obj.position.set(WorldPosition.x, WorldPosition.y, WorldPosition.z);",
            "",
            ""
          ],
          "parameterObjects": "",
          "useStrict": true,
          "eventsSheetExpanded": true
        }
      ],
      "parameters": [
        {
          "description": "3D Object ID",
          "name": "Id",
          "supplementaryInformation": "scene3D Object ID",
          "type": "identifier"
        },
        {
          "description": "Operator",
          "name": "Operator",
          "supplementaryInformation": "[\"=\",\"+\",\"-\"]",
          "type": "stringWithSelector"
        },
        {
          "description": "X",
          "name": "X",
          "type": "expression"
        },
        {
          "description": "Y",
          "name": "Y",
          "type": "expression"
        },
        {
          "description": "Z",
          "name": "Z",
          "type": "expression"
        }
      ],
      "objectGroups": []
    },
    {
      "description": "Rotate the 3D Object in the order X, Y, Z.",
      "fullName": "🔄️Rotate 3D Object",
      "functionType": "Action",
      "group": "3D Object",
      "name": "Rotate3DObject",
      "sentence": "🔄️Rotate 3D Object (ID: _PARAM1_, _PARAM2_, X: _PARAM3_, Y: _PARAM4_, Z: _PARAM5_)",
      "events": [
        {
          "type": "BuiltinCommonInstructions::JsCode",
          "inlineCode": [
            "if (!gdjs.__WithThreeJS.has(\"Renderer\")) {",
            "    console.warn(\"!\");",
            "    return;",
            "}",
            "const Scene = gdjs.__WithThreeJS.get(\"Scene\");",
            "const Id = eventsFunctionContext.getArgument(\"Id\");",
            "const Operator = eventsFunctionContext.getArgument(\"Operator\");",
            "const AngleX = eventsFunctionContext.getArgument(\"AngleX\");",
            "const AngleY = eventsFunctionContext.getArgument(\"AngleY\");",
            "const AngleZ = eventsFunctionContext.getArgument(\"AngleZ\");",
            "//",
            "const Obj = gdjs.__WithThreeJS.get(\"SearchObject\")(Id);",
            "if (!Obj) {",
            "    console.warn(\"3D Object not found: \" + Id);",
            "    return;",
            "}",
            "//",
            "if (Operator == \"=\") {",
            "    Obj.rotation.set(gdjs.toRad(AngleX), gdjs.toRad(AngleY), gdjs.toRad(AngleZ));",
            "} else if (Operator == \"+\") {",
            "    Obj.rotateX(gdjs.toRad(AngleX));",
            "    Obj.rotateY(gdjs.toRad(AngleY));",
            "    Obj.rotateZ(gdjs.toRad(AngleZ));",
            "} else {",
            "    Obj.rotateX(gdjs.toRad(-AngleX));",
            "    Obj.rotateY(gdjs.toRad(-AngleY));",
            "    Obj.rotateZ(gdjs.toRad(-AngleZ));",
            "}",
            "",
            ""
          ],
          "parameterObjects": "",
          "useStrict": true,
          "eventsSheetExpanded": true
        }
      ],
      "parameters": [
        {
          "description": "3D Object ID",
          "name": "Id",
          "supplementaryInformation": "scene3D Object ID",
          "type": "identifier"
        },
        {
          "description": "Operator",
          "name": "Operator",
          "supplementaryInformation": "[\"=\",\"+\",\"-\"]",
          "type": "stringWithSelector"
        },
        {
          "description": "Angle X",
          "name": "AngleX",
          "type": "expression"
        },
        {
          "description": "Angle Y",
          "name": "AngleY",
          "type": "expression"
        },
        {
          "description": "Angle Z",
          "name": "AngleZ",
          "type": "expression"
        }
      ],
      "objectGroups": []
    },
    {
      "description": "Rotate the 3D Object first in the world Y axis, then on the local X and Z axes.",
      "fullName": "🔄️Rotate 3D Object Like Head",
      "functionType": "Action",
      "group": "3D Object",
      "name": "Rotate3DObjectLikeHead",
      "sentence": "🔄️Rotate 3D Object Like Head (ID: _PARAM1_, _PARAM2_, X: _PARAM3_, Y: _PARAM4_, Z: _PARAM5_)",
      "events": [
        {
          "type": "BuiltinCommonInstructions::JsCode",
          "inlineCode": [
            "if (!gdjs.__WithThreeJS.has(\"Renderer\")) {",
            "    console.warn(\"!\");",
            "    return;",
            "}",
            "const Scene = gdjs.__WithThreeJS.get(\"Scene\");",
            "const Id = eventsFunctionContext.getArgument(\"Id\");",
            "const Operator = eventsFunctionContext.getArgument(\"Operator\");",
            "const AngleX = eventsFunctionContext.getArgument(\"AngleX\");",
            "const AngleY = eventsFunctionContext.getArgument(\"AngleY\");",
            "const AngleZ = eventsFunctionContext.getArgument(\"AngleZ\");",
            "//",
            "const Obj = gdjs.__WithThreeJS.get(\"SearchObject\")(Id);",
            "if (!Obj) {",
            "    console.warn(\"3D Object not found: \" + Id);",
            "    return;",
            "}",
            "//",
            "const Parent = Obj.parent;",
            "Scene.attach(Obj);",
            "if (Operator == \"=\") {",
            "    Obj.rotation.set(0, 0, 0);",
            "    Obj.rotateY(gdjs.toRad(AngleY));",
            "    Obj.rotateX(gdjs.toRad(AngleX));",
            "    Obj.rotateZ(gdjs.toRad(AngleZ));",
            "} else if (Operator == \"+\") {",
            "    Obj.rotateX(gdjs.toRad(AngleX));",
            "    Obj.rotateOnWorldAxis(new THREE.Vector3(0, 1, 0), gdjs.toRad(AngleY));",
            "    Obj.rotateZ(gdjs.toRad(AngleZ));",
            "} else {",
            "    Obj.rotateX(gdjs.toRad(-AngleX));",
            "    Obj.rotateOnWorldAxis(new THREE.Vector3(0, 1, 0), gdjs.toRad(-AngleY));",
            "    Obj.rotateZ(gdjs.toRad(-AngleZ));",
            "}",
            "Parent.attach(Obj);",
            "",
            ""
          ],
          "parameterObjects": "",
          "useStrict": true,
          "eventsSheetExpanded": true
        }
      ],
      "parameters": [
        {
          "description": "3D Object ID",
          "name": "Id",
          "supplementaryInformation": "scene3D Object ID",
          "type": "identifier"
        },
        {
          "description": "Operator",
          "name": "Operator",
          "supplementaryInformation": "[\"=\",\"+\",\"-\"]",
          "type": "stringWithSelector"
        },
        {
          "description": "Angle X",
          "name": "AngleX",
          "type": "expression"
        },
        {
          "description": "Angle Y",
          "name": "AngleY",
          "type": "expression"
        },
        {
          "description": "Angle Z",
          "name": "AngleZ",
          "type": "expression"
        }
      ],
      "objectGroups": []
    },
    {
      "description": "Rotate the 3D Object in the order X, Y, Z on the world axis.",
      "fullName": "🔄️Rotate 3D Object On World",
      "functionType": "Action",
      "group": "3D Object",
      "name": "Rotate3DObjectOnWorld",
      "sentence": "🔄️Rotate 3D Object On World (ID: _PARAM1_, _PARAM2_, X: _PARAM3_, Y: _PARAM4_, Z: _PARAM5_)",
      "events": [
        {
          "type": "BuiltinCommonInstructions::JsCode",
          "inlineCode": [
            "if (!gdjs.__WithThreeJS.has(\"Renderer\")) {",
            "    console.warn(\"!\");",
            "    return;",
            "}",
            "const Scene = gdjs.__WithThreeJS.get(\"Scene\");",
            "const Id = eventsFunctionContext.getArgument(\"Id\");",
            "const Operator = eventsFunctionContext.getArgument(\"Operator\");",
            "const AngleX = eventsFunctionContext.getArgument(\"AngleX\");",
            "const AngleY = eventsFunctionContext.getArgument(\"AngleY\");",
            "const AngleZ = eventsFunctionContext.getArgument(\"AngleZ\");",
            "//",
            "const Obj = gdjs.__WithThreeJS.get(\"SearchObject\")(Id);",
            "if (!Obj) {",
            "    console.warn(\"3D Object not found: \" + Id);",
            "    return;",
            "}",
            "//",
            "const Parent = Obj.parent;",
            "Scene.attach(Obj);",
            "if (Operator == \"=\") {",
            "    Obj.rotation.set(0, 0, 0);",
            "    Obj.rotateOnWorldAxis(new THREE.Vector3(1, 0, 0), gdjs.toRad(AngleX));",
            "    Obj.rotateOnWorldAxis(new THREE.Vector3(0, 1, 0), gdjs.toRad(AngleY));",
            "    Obj.rotateOnWorldAxis(new THREE.Vector3(0, 0, 1), gdjs.toRad(AngleZ));",
            "} else if (Operator == \"+\") {",
            "    Obj.rotateOnWorldAxis(new THREE.Vector3(1, 0, 0), gdjs.toRad(AngleX));",
            "    Obj.rotateOnWorldAxis(new THREE.Vector3(0, 1, 0), gdjs.toRad(AngleY));",
            "    Obj.rotateOnWorldAxis(new THREE.Vector3(0, 0, 1), gdjs.toRad(AngleZ));",
            "} else {",
            "    Obj.rotateOnWorldAxis(new THREE.Vector3(1, 0, 0), gdjs.toRad(-AngleX));",
            "    Obj.rotateOnWorldAxis(new THREE.Vector3(0, 1, 0), gdjs.toRad(-AngleY));",
            "    Obj.rotateOnWorldAxis(new THREE.Vector3(0, 0, 1), gdjs.toRad(-AngleZ));",
            "}",
            "Parent.attach(Obj);",
            "",
            ""
          ],
          "parameterObjects": "",
          "useStrict": true,
          "eventsSheetExpanded": true
        }
      ],
      "parameters": [
        {
          "description": "3D Object ID",
          "name": "Id",
          "supplementaryInformation": "scene3D Object ID",
          "type": "identifier"
        },
        {
          "description": "Operator",
          "name": "Operator",
          "supplementaryInformation": "[\"=\",\"+\",\"-\"]",
          "type": "stringWithSelector"
        },
        {
          "description": "Angle X",
          "name": "AngleX",
          "type": "expression"
        },
        {
          "description": "Angle Y",
          "name": "AngleY",
          "type": "expression"
        },
        {
          "description": "Angle Z",
          "name": "AngleZ",
          "type": "expression"
        }
      ],
      "objectGroups": []
    },
    {
      "fullName": "👀Look At 3D Object",
      "functionType": "Action",
      "group": "3D Object",
      "name": "LookAt3DObject",
      "sentence": "👀Look At 3D Object (ID: _PARAM1_, Target ID: _PARAM2_)",
      "events": [
        {
          "type": "BuiltinCommonInstructions::JsCode",
          "inlineCode": [
            "if (!gdjs.__WithThreeJS.has(\"Renderer\")) {",
            "    console.warn(\"!\");",
            "    return;",
            "}",
            "const Scene = gdjs.__WithThreeJS.get(\"Scene\");",
            "const Id = eventsFunctionContext.getArgument(\"Id\");",
            "const TargetId = eventsFunctionContext.getArgument(\"TargetId\");",
            "//",
            "const Obj = gdjs.__WithThreeJS.get(\"SearchObject\")(Id);",
            "const TargetObj = gdjs.__WithThreeJS.get(\"SearchObject\")(TargetId);",
            "if (!Obj || !TargetObj) {",
            "    console.warn(\"3D Object not found: \" + Id + \" or \" + TargetId);",
            "    return;",
            "}",
            "//",
            "const WPos = new THREE.Vector3();",
            "TargetObj.getWorldPosition(WPos);",
            "Obj.lookAt(WPos);",
            "",
            ""
          ],
          "parameterObjects": "",
          "useStrict": true,
          "eventsSheetExpanded": true
        }
      ],
      "parameters": [
        {
          "description": "3D Object ID",
          "name": "Id",
          "supplementaryInformation": "scene3D Object ID",
          "type": "identifier"
        },
        {
          "description": "Target 3D Object ID",
          "name": "TargetId",
          "supplementaryInformation": "scene3D Object ID",
          "type": "identifier"
        }
      ],
      "objectGroups": []
    },
    {
      "fullName": "👀Look At 3D Camera",
      "functionType": "Action",
      "group": "3D Object",
      "name": "LookAt3DCamera",
      "sentence": "👀Look At 3D Camera (Object ID: _PARAM1_, Camera ID: _PARAM2_)",
      "events": [
        {
          "type": "BuiltinCommonInstructions::JsCode",
          "inlineCode": [
            "if (!gdjs.__WithThreeJS.has(\"Renderer\")) {",
            "    console.warn(\"!\");",
            "    return;",
            "}",
            "const Scene = gdjs.__WithThreeJS.get(\"Scene\");",
            "const Id = eventsFunctionContext.getArgument(\"Id\");",
            "// const Camera = gdjs.__WithThreeJS.get(\"Camera\");",
            "const CameraId = eventsFunctionContext.getArgument(\"CameraId\");",
            "const Camera = gdjs.__WithThreeJS.get(\"GetCamera\")(CameraId);",
            "//",
            "const Obj = gdjs.__WithThreeJS.get(\"SearchObject\")(Id);",
            "if (!Obj) {",
            "    console.warn(\"3D Object not found: \" + Id);",
            "    return;",
            "}",
            "//",
            "Obj.lookAt(Camera.position);",
            "",
            ""
          ],
          "parameterObjects": "",
          "useStrict": true,
          "eventsSheetExpanded": true
        }
      ],
      "parameters": [
        {
          "description": "3D Object ID",
          "name": "Id",
          "supplementaryInformation": "scene3D Object ID",
          "type": "identifier"
        },
        {
          "description": "3D Camera ID (1 to 4)",
          "name": "CameraId",
          "type": "expression"
        }
      ],
      "objectGroups": []
    },
    {
      "description": "Remove a 3D Object from the 3D Scene.\nThis action cannot remove 3D Objects created by 3D Projection Behaviors.\nThis action does not clear the loaded 3D Texture data and the loaded 3D Model data.\nThey will continue to be accessible by ID.",
      "fullName": "🗑️Remove 3D Object",
      "functionType": "Action",
      "group": "3D Object",
      "name": "Remove3DObject",
      "sentence": "🗑️Remove 3D Object (ID: _PARAM1_)",
      "events": [
        {
          "type": "BuiltinCommonInstructions::JsCode",
          "inlineCode": [
            "if (!gdjs.__WithThreeJS.has(\"Renderer\")) {",
            "    console.warn(\"!\");",
            "    return;",
            "}",
            "const Scene = gdjs.__WithThreeJS.get(\"Scene\");",
            "const Id = eventsFunctionContext.getArgument(\"Id\");",
            "//",
            "const Obj = gdjs.__WithThreeJS.get(\"SearchObject\")(Id);",
            "if (!Obj) {",
            "    console.warn(\"3D Object not found: \" + Id);",
            "    return;",
            "}",
            "if (Obj.userData.Use3DProjectionBehavior) {",
            "    console.warn(\"3D Object could not be removed.\");",
            "    return;",
            "}",
            "//",
            "// Obj.clear();",
            "gdjs.__WithThreeJS.get(\"DisposeChildren\")(Obj);",
            "Obj.removeFromParent();",
            "",
            ""
          ],
          "parameterObjects": "",
          "useStrict": true,
          "eventsSheetExpanded": true
        }
      ],
      "parameters": [
        {
          "description": "3D Object ID",
          "name": "Id",
          "supplementaryInformation": "scene3D Object ID",
          "type": "identifier"
        }
      ],
      "objectGroups": []
    },
    {
      "description": "Change the 3D Texture of a 3D Object.",
      "fullName": "🧱Change 3D Texture",
      "functionType": "Action",
      "group": "3D Object",
      "name": "Change3DTexture",
      "sentence": "🧱Change 3D Texture (ID: _PARAM1_, Texture: _PARAM2_)",
      "events": [
        {
          "type": "BuiltinCommonInstructions::JsCode",
          "inlineCode": [
            "if (!gdjs.__WithThreeJS.has(\"Renderer\")) {",
            "    console.warn(\"!\");",
            "    return;",
            "}",
            "if (!gdjs.__WithThreeJS.has(\"Textures\")) {",
            "    console.warn(\"!\");",
            "    return;",
            "}",
            "const Scene = gdjs.__WithThreeJS.get(\"Scene\");",
            "const Textures = gdjs.__WithThreeJS.get(\"Textures\");",
            "//",
            "const Id = eventsFunctionContext.getArgument(\"Id\");",
            "const TextureIdList = eventsFunctionContext.getArgument(\"TextureIdList\");",
            "//",
            "const Obj = gdjs.__WithThreeJS.get(\"SearchObject\")(Id);",
            "if (!Obj) {",
            "    console.warn(\"3D Object not found: \" + Id);",
            "    return;",
            "}",
            "let TextureList = [];",
            "for (const V of TextureIdList.split(\"\\n\")) {",
            "    if (V != \"\") {",
            "        if (!Textures.has(V)) {",
            "            console.warn(\"3D Texture not found: \" + V);",
            "        } else {",
            "            TextureList.push(Textures.get(V));",
            "        }",
            "    }",
            "}",
            "//",
            "gdjs.__WithThreeJS.get(\"SetAllTextures\")(Obj, TextureList);",
            "",
            ""
          ],
          "parameterObjects": "",
          "useStrict": true,
          "eventsSheetExpanded": true
        }
      ],
      "parameters": [
        {
          "description": "3D Object ID",
          "name": "Id",
          "supplementaryInformation": "scene3D Object ID",
          "type": "identifier"
        },
        {
          "description": "3D Texture ID List",
          "longDescription": "One Texture ID per line.",
          "name": "TextureIdList",
          "supplementaryInformation": "scene3D Texture ID",
          "type": "identifier"
        }
      ],
      "objectGroups": []
    },
    {
      "description": "Change the visibility of a 3D Object.",
      "fullName": "🌗Change 3D Object Visibility",
      "functionType": "Action",
      "group": "3D Object",
      "name": "ChangeVisibility",
      "sentence": "🌗Change 3D Object Visibility (ID: _PARAM1_, Visible: _PARAM2_, Inherit: _PARAM3_)",
      "events": [
        {
          "type": "BuiltinCommonInstructions::JsCode",
          "inlineCode": [
            "if (!gdjs.__WithThreeJS.has(\"Renderer\")) {",
            "    console.warn(\"!\");",
            "    return;",
            "}",
            "const Scene = gdjs.__WithThreeJS.get(\"Scene\");",
            "//",
            "const Id = eventsFunctionContext.getArgument(\"Id\");",
            "const Visible = eventsFunctionContext.getArgument(\"Visible\");",
            "const Inherit = eventsFunctionContext.getArgument(\"Inherit\");",
            "//",
            "const Obj = gdjs.__WithThreeJS.get(\"SearchObject\")(Id);",
            "if (!Obj) {",
            "    console.warn(\"3D Object not found: \" + Id);",
            "    return;",
            "}",
            "//",
            "if (Inherit) {",
            "    Obj.visible = Visible;",
            "} else {",
            "    if (Obj.material) {",
            "        if (Array.isArray(Obj.material)) {",
            "            for (let i = 0; i < Obj.material.length; i++) {",
            "                Obj.material[i].visible = Visible;",
            "            }",
            "        } else {",
            "            Obj.material.visible = Visible;",
            "        }",
            "    } else {",
            "        // Obj.visible = Visible;",
            "    }",
            "}",
            "",
            ""
          ],
          "parameterObjects": "",
          "useStrict": true,
          "eventsSheetExpanded": true
        }
      ],
      "parameters": [
        {
          "description": "3D Object ID",
          "name": "Id",
          "supplementaryInformation": "scene3D Object ID",
          "type": "identifier"
        },
        {
          "defaultValue": "yes",
          "description": "Visible",
          "name": "Visible",
          "optional": true,
          "type": "yesorno"
        },
        {
          "defaultValue": "no",
          "description": "Inherit to Children",
          "longDescription": "The visibility of a child 3D Object that has been changed by inheritance cannot be changed individually.  \nSimilarly, the visibility of an individually changed child 3D Object cannot be changed by inheritance.",
          "name": "Inherit",
          "optional": true,
          "type": "yesorno"
        }
      ],
      "objectGroups": []
    },
    {
      "description": "Change the Opacity of a 3D Object.\nThe same value is set for multiple textures.",
      "fullName": "🥛Change 3D Object Opacity",
      "functionType": "Action",
      "group": "3D Object",
      "name": "ChangeOpacity",
      "sentence": "🥛Change 3D Object Opacity (ID: _PARAM1_, _PARAM2_, Opacity: _PARAM3_)",
      "events": [
        {
          "type": "BuiltinCommonInstructions::JsCode",
          "inlineCode": [
            "if (!gdjs.__WithThreeJS.has(\"Renderer\")) {",
            "    console.warn(\"!\");",
            "    return;",
            "}",
            "const Scene = gdjs.__WithThreeJS.get(\"Scene\");",
            "//",
            "const Id = eventsFunctionContext.getArgument(\"Id\");",
            "const Operator = eventsFunctionContext.getArgument(\"Operator\");",
            "const Opacity = eventsFunctionContext.getArgument(\"Opacity\");",
            "//",
            "const Obj = gdjs.__WithThreeJS.get(\"SearchObject\")(Id);",
            "if (!Obj) {",
            "    console.warn(\"3D Object not found: \" + Id);",
            "    return;",
            "}",
            "//",
            "Obj.traverse((Child) => {",
            "    if (Child.material) {",
            "        if (Array.isArray(Child.material)) {",
            "            for (let i = 0; i < Child.material.length; i++) {",
            "                if (!Child.material[i].transparent) {",
            "                    Child.material[i].transparent = true;",
            "                    Child.material[i].needsUpdate = true;",
            "                }",
            "                if (Operator == \"=\") {",
            "                    Child.material[i].opacity = Opacity;",
            "                } else if (Operator == \"+\") {",
            "                    Child.material[i].opacity += Opacity;",
            "                } else {",
            "                    Child.material[i].opacity -= Opacity;",
            "                }",
            "                if (Child.material[i].opacity < 0) Child.material[i].opacity = 0;",
            "                if (Child.material[i].opacity > 1) Child.material[i].opacity = 1;",
            "            }",
            "        } else {",
            "            if (!Child.material.transparent) {",
            "                Child.material.transparent = true;",
            "                Child.material.needsUpdate = true;",
            "            }",
            "            if (Operator == \"=\") {",
            "                Child.material.opacity = Opacity;",
            "            } else if (Operator == \"+\") {",
            "                Child.material.opacity += Opacity;",
            "            } else {",
            "                Child.material.opacity -= Opacity;",
            "            }",
            "            if (Child.material.opacity < 0) Child.material.opacity = 0;",
            "            if (Child.material.opacity > 1) Child.material.opacity = 1;",
            "        }",
            "    }",
            "});",
            "",
            ""
          ],
          "parameterObjects": "",
          "useStrict": true,
          "eventsSheetExpanded": true
        }
      ],
      "parameters": [
        {
          "description": "3D Object ID",
          "name": "Id",
          "supplementaryInformation": "scene3D Object ID",
          "type": "identifier"
        },
        {
          "description": "Operator",
          "name": "Operator",
          "supplementaryInformation": "[\"=\",\"+\",\"-\"]",
          "type": "stringWithSelector"
        },
        {
          "description": "Opacity (0 to 1)",
          "longDescription": "1 is fully opaque.",
          "name": "Opacity",
          "type": "expression"
        }
      ],
      "objectGroups": []
    },
    {
      "description": "Change the Scale of a 3D Object.\nNote that 3D Sprite and 3D Model were scaled when created.",
      "fullName": "↕️Change 3D Object Scale",
      "functionType": "Action",
      "group": "3D Object",
      "name": "ChangeScale",
      "sentence": "↕️Change 3D Object Scale (ID: _PARAM1_, _PARAM2_, X: _PARAM3_, Y: _PARAM4_, Z: _PARAM5_)",
      "events": [
        {
          "type": "BuiltinCommonInstructions::JsCode",
          "inlineCode": [
            "if (!gdjs.__WithThreeJS.has(\"Renderer\")) {",
            "    console.warn(\"!\");",
            "    return;",
            "}",
            "const Scene = gdjs.__WithThreeJS.get(\"Scene\");",
            "const Id = eventsFunctionContext.getArgument(\"Id\");",
            "const Operator = eventsFunctionContext.getArgument(\"Operator\");",
            "const X = eventsFunctionContext.getArgument(\"X\");",
            "const Y = eventsFunctionContext.getArgument(\"Y\");",
            "const Z = eventsFunctionContext.getArgument(\"Z\");",
            "//",
            "const Obj = gdjs.__WithThreeJS.get(\"SearchObject\")(Id);",
            "if (!Obj) {",
            "    console.warn(\"3D Object not found: \" + Id);",
            "    return;",
            "}",
            "//",
            "if (Obj.isSprite) {",
            "    const Texture = Obj.material.map;",
            "    const TextureWidth = Texture.image.width;",
            "    const TextureHeight = Texture.image.height;",
            "    if (Operator == \"=\") {",
            "        Obj.scale.set(TextureWidth * X, TextureHeight * Y, 1);",
            "    } else if (Operator == \"+\") {",
            "        Obj.scale.x += TextureWidth * X;",
            "        Obj.scale.y += TextureHeight * Y;",
            "    } else if (Operator == \"-\") {",
            "        Obj.scale.x -= TextureWidth * X;",
            "        Obj.scale.y -= TextureHeight * Y;",
            "    } else {",
            "        Obj.scale.x *= TextureWidth * X;",
            "        Obj.scale.y *= TextureHeight * Y;",
            "    }",
            "} else {",
            "    if (Operator == \"=\") {",
            "        Obj.scale.set(X, Y, Z);",
            "    } else if (Operator == \"+\") {",
            "        Obj.scale.x += X;",
            "        Obj.scale.y += Y;",
            "        Obj.scale.z += Z;",
            "    } else if (Operator == \"-\") {",
            "        Obj.scale.x -= X;",
            "        Obj.scale.y -= Y;",
            "        Obj.scale.z -= Z;",
            "    } else {",
            "        Obj.scale.x *= X;",
            "        Obj.scale.y *= Y;",
            "        Obj.scale.z *= Z;",
            "    }",
            "}",
            "",
            ""
          ],
          "parameterObjects": "",
          "useStrict": true,
          "eventsSheetExpanded": true
        }
      ],
      "parameters": [
        {
          "description": "3D Object ID",
          "name": "Id",
          "supplementaryInformation": "scene3D Object ID",
          "type": "identifier"
        },
        {
          "description": "Operator",
          "name": "Operator",
          "supplementaryInformation": "[\"=\",\"+\",\"-\",\"*\"]",
          "type": "stringWithSelector"
        },
        {
          "description": "Scale X Axis",
          "name": "X",
          "type": "expression"
        },
        {
          "description": "Scale Y Axis",
          "name": "Y",
          "type": "expression"
        },
        {
          "description": "Scale Z Axis",
          "name": "Z",
          "type": "expression"
        }
      ],
      "objectGroups": []
    },
    {
      "description": "Change the DepthWrite of a 3D Object.\nWhether rendering this 3D Object has any effect on the depth buffer.\nIf transparent 3D Objects overlap and render incorrectly, you may be able to obtain ideal rendering results by setting the DepthWrite of that 3D Object to No.\nDefault is Yes.",
      "fullName": "🧱Change 3D Object DepthWrite",
      "functionType": "Action",
      "group": "3D Object",
      "name": "ChangeDepthWrite",
      "sentence": "🧱Change 3D Object DepthWrite (ID: _PARAM1_, Write: _PARAM2_)",
      "events": [
        {
          "type": "BuiltinCommonInstructions::JsCode",
          "inlineCode": [
            "if (!gdjs.__WithThreeJS.has(\"Renderer\")) {",
            "    console.warn(\"!\");",
            "    return;",
            "}",
            "const Scene = gdjs.__WithThreeJS.get(\"Scene\");",
            "//",
            "const Id = eventsFunctionContext.getArgument(\"Id\");",
            "const Write = eventsFunctionContext.getArgument(\"Write\");",
            "//",
            "const Obj = gdjs.__WithThreeJS.get(\"SearchObject\")(Id);",
            "if (!Obj) {",
            "    console.warn(\"3D Object not found: \" + Id);",
            "    return;",
            "}",
            "//",
            "Obj.traverse((Child) => {",
            "  if (Child.material) {",
            "    if (Array.isArray(Child.material)) {",
            "      for (let i = 0; i < Child.material.length; i++) {",
            "        Child.material[i].depthWrite = Write;",
            "      }",
            "    } else {",
            "      Child.material.depthWrite = Write;",
            "    }",
            "  }",
            "});",
            "",
            ""
          ],
          "parameterObjects": "",
          "useStrict": true,
          "eventsSheetExpanded": true
        }
      ],
      "parameters": [
        {
          "description": "3D Object ID",
          "name": "Id",
          "supplementaryInformation": "scene3D Object ID",
          "type": "identifier"
        },
        {
          "defaultValue": "yes",
          "description": "Depth Write",
          "name": "Write",
          "optional": true,
          "type": "yesorno"
        }
      ],
      "objectGroups": []
    },
    {
      "description": "Change all animations speed scale of a 3D Object.\n0 is pause.\nNegative values play backwards.",
      "fullName": "🎞️Change 3D Object All Animations Speed Scale",
      "functionType": "Action",
      "group": "3D Object",
      "name": "ChangeAllAnimationsSpeedScale",
      "sentence": "🎞️Change All Animations Speed Scale (ID: _PARAM1_, _PARAM2_, Speed: _PARAM3_)",
      "events": [
        {
          "type": "BuiltinCommonInstructions::JsCode",
          "inlineCode": [
            "if (!gdjs.__WithThreeJS.has(\"Renderer\")) {",
            "    console.warn(\"!\");",
            "    return;",
            "}",
            "const Scene = gdjs.__WithThreeJS.get(\"Scene\");",
            "const AnimationActions = gdjs.__WithThreeJS.get(\"AnimationActions\");",
            "const Id = eventsFunctionContext.getArgument(\"Id\");",
            "const Operator = eventsFunctionContext.getArgument(\"Operator\");",
            "const Speed = eventsFunctionContext.getArgument(\"Speed\");",
            "//",
            "const Obj = gdjs.__WithThreeJS.get(\"SearchObject\")(Id);",
            "if (!Obj) {",
            "    console.warn(\"3D Object not found: \" + Id);",
            "    return;",
            "}",
            "//",
            "const OBJ_UUID = Obj.uuid;",
            "if (AnimationActions.has(OBJ_UUID)) {",
            "    for (const [K, V] of AnimationActions.get(OBJ_UUID)) {",
            "        if (Operator == \"=\") {",
            "            V.timeScale = Speed;",
            "        } else if (Operator == \"+\") {",
            "            V.timeScale += Speed;",
            "        } else {",
            "            V.timeScale -= Speed;",
            "        }",
            "    }",
            "}",
            "",
            ""
          ],
          "parameterObjects": "",
          "useStrict": true,
          "eventsSheetExpanded": true
        }
      ],
      "parameters": [
        {
          "description": "3D Object ID",
          "name": "Id",
          "supplementaryInformation": "scene3D Object ID",
          "type": "identifier"
        },
        {
          "description": "Operator",
          "name": "Operator",
          "supplementaryInformation": "[\"=\",\"+\",\"-\"]",
          "type": "stringWithSelector"
        },
        {
          "description": "Animation Speed Scale (Default: 1)",
          "name": "Speed",
          "type": "expression"
        }
      ],
      "objectGroups": []
    },
    {
      "description": "Change the Blend Mode of a 3D Object.",
      "fullName": "🧱Change 3D Object Blend Mode",
      "functionType": "Action",
      "group": "3D Object",
      "name": "ChangeBlendMode",
      "sentence": "🧱Change 3D Object Blend Mode (ID: _PARAM1_, Blend Mode: _PARAM2_)",
      "events": [
        {
          "type": "BuiltinCommonInstructions::JsCode",
          "inlineCode": [
            "if (!gdjs.__WithThreeJS.has(\"Renderer\")) {",
            "    console.warn(\"!\");",
            "    return;",
            "}",
            "const Scene = gdjs.__WithThreeJS.get(\"Scene\");",
            "const Id = eventsFunctionContext.getArgument(\"Id\");",
            "let Blend = THREE.NormalBlending;",
            "if (eventsFunctionContext.getArgument(\"Blend\") == \"Additive\") {",
            "    Blend = THREE.AdditiveBlending;",
            "} else if (eventsFunctionContext.getArgument(\"Blend\") == \"Subtractive\") {",
            "    Blend = THREE.SubtractiveBlending;",
            "} else if (eventsFunctionContext.getArgument(\"Blend\") == \"Multiply\") {",
            "    Blend = THREE.MultiplyBlending;",
            "}",
            "//",
            "const Obj = gdjs.__WithThreeJS.get(\"SearchObject\")(Id);",
            "if (!Obj) {",
            "    console.warn(\"3D Object not found: \" + Id);",
            "    return;",
            "}",
            "//",
            "Obj.traverse((Child) => {",
            "    if (Child.material) {",
            "        if (Array.isArray(Child.material)) {",
            "            for (let i = 0; i < Child.material.length; i++) {",
            "                Child.material[i].blending = Blend;",
            "            }",
            "        } else {",
            "            Child.material.blending = Blend;",
            "        }",
            "    }",
            "});",
            "",
            ""
          ],
          "parameterObjects": "",
          "useStrict": true,
          "eventsSheetExpanded": true
        }
      ],
      "parameters": [
        {
          "description": "3D Object ID",
          "name": "Id",
          "supplementaryInformation": "scene3D Object ID",
          "type": "identifier"
        },
        {
          "description": "Blend Mode",
          "longDescription": "The same value is set for multiple textures.",
          "name": "Blend",
          "supplementaryInformation": "[\"Normal\",\"Additive\",\"Subtractive\",\"Multiply\"]",
          "type": "stringWithSelector"
        }
      ],
      "objectGroups": []
    },
    {
      "description": "Determines whether the 3D Object can be detected by Raycast.\nDefault is detectable (Yes).",
      "fullName": "🔎Change 3D Object Raycast Detection",
      "functionType": "Action",
      "group": "3D Object",
      "name": "ChangeRaycastDetection",
      "sentence": "🔎Change 3D Object Raycast Detection (ID: _PARAM1_, Raycast Detection: _PARAM2_)",
      "events": [
        {
          "type": "BuiltinCommonInstructions::JsCode",
          "inlineCode": [
            "if (!gdjs.__WithThreeJS.has(\"Renderer\")) {",
            "    console.warn(\"!\");",
            "    return;",
            "}",
            "const Scene = gdjs.__WithThreeJS.get(\"Scene\");",
            "//",
            "const Id = eventsFunctionContext.getArgument(\"Id\");",
            "const Detection = eventsFunctionContext.getArgument(\"Detection\");",
            "//",
            "const Obj = gdjs.__WithThreeJS.get(\"SearchObject\")(Id);",
            "if (!Obj) {",
            "    console.warn(\"3D Object not found: \" + Id);",
            "    return;",
            "}",
            "//",
            "Obj.traverse((Child) => {",
            "    if (Child.layers) {",
            "        if (Detection) {",
            "            Child.layers.set(0);",
            "        } else {",
            "            Child.layers.set(1);",
            "        }",
            "    }",
            "});",
            "",
            ""
          ],
          "parameterObjects": "",
          "useStrict": true,
          "eventsSheetExpanded": true
        }
      ],
      "parameters": [
        {
          "description": "3D Object ID",
          "name": "Id",
          "supplementaryInformation": "scene3D Object ID",
          "type": "identifier"
        },
        {
          "description": "Raycast Detection (Default: Yes)",
          "name": "Detection",
          "supplementaryInformation": "scene3D Object ID",
          "type": "yesorno"
        }
      ],
      "objectGroups": []
    },
    {
      "description": "Resolve collisions between Bounding Boxes.\nIt is not necessary to use the \"Check Bounding Box Collision\" condition beforehand. (It will do almost the same processing)\nNote that the 3D Objects are still in contact after resolution. (\"Check Bounding Box Collision\" condition will not be false.)\n3D Object thickness too thin for the amount of movement will not resolve correctly.\nThis action updates the \"Bounding Box Collision Result\".\n\"Bounding Box Collision Result\" stores the value when the Target 3D Object is unmoved.",
      "fullName": "💥Resolve Bounding Box Collision",
      "functionType": "Action",
      "group": "3D Object",
      "name": "ResolveBoundingBoxCollisionV2",
      "sentence": "💥Resolve Bounding Box Collision (ID: _PARAM1_, Target: _PARAM2_, Unmoved: _PARAM3_)",
      "events": [
        {
          "type": "BuiltinCommonInstructions::JsCode",
          "inlineCode": [
            "if (!gdjs.__WithThreeJS.has(\"Renderer\")) {",
            "    console.warn(\"!\");",
            "    return;",
            "}",
            "const Scene = gdjs.__WithThreeJS.get(\"Scene\");",
            "const Id = eventsFunctionContext.getArgument(\"Id\");",
            "const TargetId = eventsFunctionContext.getArgument(\"TargetId\");",
            "const Unmoved = eventsFunctionContext.getArgument(\"Unmoved\");",
            "//",
            "const Obj = gdjs.__WithThreeJS.get(\"SearchObject\")(Id);",
            "const TargetObj = gdjs.__WithThreeJS.get(\"SearchObject\")(TargetId);",
            "if (!Obj || !TargetObj) {",
            "    console.warn(\"3D Object not found: \" + Id + \" or \" + TargetId);",
            "    return;",
            "}",
            "//",
            "const BoundingBoxCollisionResult = gdjs.__WithThreeJS.get(\"SetBoundingBoxCollisionResult\")(Obj, TargetObj);",
            "const Move3 = new THREE.Vector3(BoundingBoxCollisionResult.MoveX, BoundingBoxCollisionResult.MoveY, BoundingBoxCollisionResult.MoveZ);",
            "if (Unmoved) {",
            "    const WorldPosition = new THREE.Vector3();",
            "    Obj.getWorldPosition(WorldPosition);",
            "    WorldPosition.add(Move3);",
            "    Obj.position.copy(Obj.parent.worldToLocal(WorldPosition));",
            "} else {",
            "    Move3.divideScalar(2);",
            "    const Move3Neg = Move3.clone().negate();",
            "    //",
            "    const WorldPosition1 = new THREE.Vector3();",
            "    const WorldPosition2 = new THREE.Vector3();",
            "    Obj.getWorldPosition(WorldPosition1);",
            "    TargetObj.getWorldPosition(WorldPosition2);",
            "    WorldPosition1.add(Move3);",
            "    WorldPosition2.add(Move3Neg);",
            "    Obj.position.copy(Obj.parent.worldToLocal(WorldPosition1));",
            "    TargetObj.position.copy(TargetObj.parent.worldToLocal(WorldPosition2));",
            "}",
            "",
            ""
          ],
          "parameterObjects": "",
          "useStrict": true,
          "eventsSheetExpanded": true
        }
      ],
      "parameters": [
        {
          "description": "3D Object ID",
          "name": "Id",
          "supplementaryInformation": "scene3D Object ID",
          "type": "identifier"
        },
        {
          "description": "Target 3D Object ID",
          "name": "TargetId",
          "supplementaryInformation": "scene3D Object ID",
          "type": "identifier"
        },
        {
          "defaultValue": "True",
          "description": "Target 3D Object is unmoved",
          "name": "Unmoved",
          "optional": true,
          "type": "trueorfalse"
        }
      ],
      "objectGroups": []
    },
    {
      "description": "Add 3D Object as child to 3D object.",
      "fullName": "👥Add Child",
      "functionType": "Action",
      "group": "3D Object",
      "name": "AddChild",
      "sentence": "👥Add Child (ID: _PARAM1_, Child: _PARAM2_)",
      "events": [
        {
          "type": "BuiltinCommonInstructions::JsCode",
          "inlineCode": [
            "if (!gdjs.__WithThreeJS.has(\"Renderer\")) {",
            "    console.warn(\"!\");",
            "    return;",
            "}",
            "const Scene = gdjs.__WithThreeJS.get(\"Scene\");",
            "const ParentId = eventsFunctionContext.getArgument(\"ParentId\");",
            "const ChildId = eventsFunctionContext.getArgument(\"ChildId\");",
            "//",
            "const Parent = gdjs.__WithThreeJS.get(\"SearchObject\")(ParentId);",
            "const Child = gdjs.__WithThreeJS.get(\"SearchObject\")(ChildId);",
            "if (!Parent || !Child) {",
            "    console.warn(\"3D Object not found: \" + ParentId + \" or \" + ChildId);",
            "    return;",
            "}",
            "Parent.attach(Child);",
            "",
            ""
          ],
          "parameterObjects": "",
          "useStrict": true,
          "eventsSheetExpanded": true
        }
      ],
      "parameters": [
        {
          "description": "Parent 3D Object ID",
          "name": "ParentId",
          "supplementaryInformation": "scene3D Object ID",
          "type": "identifier"
        },
        {
          "description": "Child 3D Object ID",
          "name": "ChildId",
          "supplementaryInformation": "scene3D Object ID",
          "type": "identifier"
        }
      ],
      "objectGroups": []
    },
    {
      "description": "Detach a 3D Object from its parent.\n(Set Parent to Scene)",
      "fullName": "👥Detach From Parent",
      "functionType": "Action",
      "group": "3D Object",
      "name": "DetachFromParent",
      "sentence": "👥Detach From Parent (ID: _PARAM1_)",
      "events": [
        {
          "type": "BuiltinCommonInstructions::JsCode",
          "inlineCode": [
            "if (!gdjs.__WithThreeJS.has(\"Renderer\")) {",
            "    console.warn(\"!\");",
            "    return;",
            "}",
            "const Scene = gdjs.__WithThreeJS.get(\"Scene\");",
            "const Id = eventsFunctionContext.getArgument(\"Id\");",
            "//",
            "const Obj = gdjs.__WithThreeJS.get(\"SearchObject\")(Id);",
            "if (!Obj) {",
            "    console.warn(\"3D Object not found: \" + Id);",
            "    return;",
            "}",
            "Scene.attach(Obj);",
            "",
            ""
          ],
          "parameterObjects": "",
          "useStrict": true,
          "eventsSheetExpanded": true
        }
      ],
      "parameters": [
        {
          "description": "3D Object ID",
          "name": "Id",
          "supplementaryInformation": "scene3D Object ID",
          "type": "identifier"
        }
      ],
      "objectGroups": []
    },
    {
      "description": "Set 3D Object ID of all children to scene variable as array.",
      "fullName": "👥Set 3D Object ID Of Children To Scene Variable (Deprecated)",
      "functionType": "Action",
      "group": "3D Object",
      "name": "SetChildrenIdToSceneVariable",
      "sentence": "⚠️Set 3D Object ID Of Children To Scene Variable (ID: _PARAM1_, Variable: _PARAM2_)",
      "events": [
        {
          "type": "BuiltinCommonInstructions::JsCode",
          "inlineCode": [
            "if (!gdjs.__WithThreeJS.has(\"Renderer\")) {",
            "    console.warn(\"!\");",
            "    return;",
            "}",
            "const Scene = gdjs.__WithThreeJS.get(\"Scene\");",
            "const Id = eventsFunctionContext.getArgument(\"Id\");",
            "const SceneVariable = eventsFunctionContext.getArgument(\"Variable\");",
            "//",
            "const Obj = gdjs.__WithThreeJS.get(\"SearchObject\")(Id);",
            "if (!Obj) {",
            "    console.warn(\"3D Object not found: \" + Id);",
            "    return;",
            "}",
            "//",
            "let Children = [];",
            "for (const V of Obj.children) {",
            "    Children.push(V.name);",
            "}",
            "SceneVariable.fromJSObject(Children);",
            "",
            ""
          ],
          "parameterObjects": "",
          "useStrict": true,
          "eventsSheetExpanded": true
        }
      ],
      "parameters": [
        {
          "description": "Parent 3D Object ID",
          "name": "Id",
          "supplementaryInformation": "scene3D Object ID",
          "type": "identifier"
        },
        {
          "description": "Scene Variable",
          "name": "Variable",
          "type": "scenevar"
        }
      ],
      "objectGroups": []
    },
    {
      "description": "Set 3D Object ID of all children to variable (Global, Scene or Local) as array.",
      "fullName": "👥Set 3D Object ID Of Children To Variable",
      "functionType": "Action",
      "group": "3D Object",
      "name": "SetChildrenIdToVariable",
      "sentence": "👥Set 3D Object ID Of Children To Variable (ID: _PARAM1_, Variable: _PARAM2_)",
      "events": [
        {
          "type": "BuiltinCommonInstructions::JsCode",
          "inlineCode": [
            "if (!gdjs.__WithThreeJS.has(\"Renderer\")) {",
            "    console.warn(\"!\");",
            "    return;",
            "}",
            "const Scene = gdjs.__WithThreeJS.get(\"Scene\");",
            "const Id = eventsFunctionContext.getArgument(\"Id\");",
            "const GeneralVariable = eventsFunctionContext.getArgument(\"Variable\");",
            "//",
            "const Obj = gdjs.__WithThreeJS.get(\"SearchObject\")(Id);",
            "if (!Obj) {",
            "    console.warn(\"3D Object not found: \" + Id);",
            "    return;",
            "}",
            "//",
            "let Children = [];",
            "for (const V of Obj.children) {",
            "    Children.push(V.name);",
            "}",
            "GeneralVariable.fromJSObject(Children);",
            "",
            ""
          ],
          "parameterObjects": "",
          "useStrict": true,
          "eventsSheetExpanded": true
        }
      ],
      "parameters": [
        {
          "description": "Parent 3D Object ID",
          "name": "Id",
          "supplementaryInformation": "scene3D Object ID",
          "type": "identifier"
        },
        {
          "description": "Variable",
          "name": "Variable",
          "type": "variable"
        }
      ],
      "objectGroups": []
    },
    {
      "description": "Play 3D animation.\nIf already playing, only the \"Animation Speed Scale\" and \"Loop\" properties are updated.",
      "fullName": "🎞️Play 3D Animation",
      "functionType": "Action",
      "group": "3D Object",
      "name": "Play3DAnimation",
      "sentence": "🎞️Play 3D Animation (ID: _PARAM1_, Animation: _PARAM2_, Speed: _PARAM3_, Loop: _PARAM4_, Fade: _PARAM5_)",
      "events": [
        {
          "type": "BuiltinCommonInstructions::JsCode",
          "inlineCode": [
            "if (!gdjs.__WithThreeJS.has(\"Renderer\")) {",
            "    console.warn(\"!\");",
            "    return;",
            "}",
            "const Scene = gdjs.__WithThreeJS.get(\"Scene\");",
            "const AnimationMixer = gdjs.__WithThreeJS.get(\"AnimationMixer\");",
            "const AnimationActions = gdjs.__WithThreeJS.get(\"AnimationActions\");",
            "const Id = eventsFunctionContext.getArgument(\"Id\");",
            "const ANumber = eventsFunctionContext.getArgument(\"ANumber\");",
            "const Speed = eventsFunctionContext.getArgument(\"Speed\");",
            "const Duration = eventsFunctionContext.getArgument(\"Duration\");",
            "let Loop = eventsFunctionContext.getArgument(\"Loop\");",
            "if (Loop == \"Once\") {",
            "    Loop = THREE.LoopOnce;",
            "} else if (Loop == \"PingPong\") {",
            "    Loop = THREE.LoopPingPong;",
            "} else {",
            "    Loop = THREE.LoopRepeat;",
            "}",
            "//",
            "const Obj = gdjs.__WithThreeJS.get(\"SearchObject\")(Id);",
            "if (!Obj) {",
            "    console.warn(\"3D Object not found: \" + Id);",
            "    return;",
            "}",
            "const Clip = Obj.animations[ANumber];",
            "if (!Clip) {",
            "    console.warn(\"3D Animation not found: \" + ANumber);",
            "    return;",
            "}",
            "//",
            "let Action;",
            "const OBJ_UUID = Obj.uuid;",
            "const Clip_UUID = Clip.uuid;",
            "if (AnimationActions.has(OBJ_UUID)) {",
            "    if (AnimationActions.get(OBJ_UUID).has(Clip_UUID)) {",
            "        Action = AnimationActions.get(OBJ_UUID).get(Clip_UUID);",
            "        if (Action.isRunning()) {",
            "            Action.timeScale = Speed;",
            "            Action.setLoop(Loop, Infinity);",
            "            return;",
            "        }",
            "    }",
            "}",
            "//",
            "if (AnimationActions.has(OBJ_UUID)) {",
            "    for (const [K, V] of AnimationActions.get(OBJ_UUID)) {",
            "        if (K != Clip_UUID) {",
            "            if (Duration === 0) {",
            "                V.stop();",
            "            } else {",
            "                V.fadeOut(Duration);  ",
            "            }",
            "        }",
            "    }",
            "} else {",
            "    AnimationActions.set(OBJ_UUID, new Map());",
            "}",
            "if (Action === undefined) {",
            "    Action = AnimationMixer.clipAction(Clip, Obj);",
            "    AnimationActions.get(OBJ_UUID).set(Clip_UUID, Action);",
            "}",
            "Action.timeScale = Speed;",
            "Action.setLoop(Loop, Infinity);",
            "Action.clampWhenFinished = true;",
            "if (Speed >= 0) {",
            "    Action.reset().play().fadeIn(Duration);",
            "} else {",
            "    Action.reset();",
            "    Action.time = Clip.duration;",
            "    Action.play().fadeIn(Duration);",
            "}",
            "",
            ""
          ],
          "parameterObjects": "",
          "useStrict": true,
          "eventsSheetExpanded": true
        }
      ],
      "parameters": [
        {
          "description": "3D Object ID",
          "name": "Id",
          "supplementaryInformation": "scene3D Object ID",
          "type": "identifier"
        },
        {
          "description": "Original Animation Number",
          "name": "ANumber",
          "type": "expression"
        },
        {
          "description": "Animation Speed Scale (Default: 1)",
          "longDescription": "0 is pause. Negative values play backwards.",
          "name": "Speed",
          "type": "expression"
        },
        {
          "description": "Loop",
          "name": "Loop",
          "supplementaryInformation": "[\"Once\",\"Repeat\",\"PingPong\"]",
          "type": "stringWithSelector"
        },
        {
          "description": "Cross-Fade Duration (in seconds)",
          "name": "Duration",
          "type": "expression"
        }
      ],
      "objectGroups": []
    },
    {
      "fullName": "🎞️Stop 3D Animation",
      "functionType": "Action",
      "group": "3D Object",
      "name": "Stop3DAnimation",
      "sentence": "🎞️Stop 3D Animation (ID: _PARAM1_, Animation: _PARAM2_, Fade: _PARAM3_)",
      "events": [
        {
          "type": "BuiltinCommonInstructions::JsCode",
          "inlineCode": [
            "if (!gdjs.__WithThreeJS.has(\"Renderer\")) {",
            "    console.warn(\"!\");",
            "    return;",
            "}",
            "const Scene = gdjs.__WithThreeJS.get(\"Scene\");",
            "const AnimationActions = gdjs.__WithThreeJS.get(\"AnimationActions\");",
            "const Id = eventsFunctionContext.getArgument(\"Id\");",
            "const ANumber = eventsFunctionContext.getArgument(\"ANumber\");",
            "const Duration = eventsFunctionContext.getArgument(\"Duration\");",
            "//",
            "const Obj = gdjs.__WithThreeJS.get(\"SearchObject\")(Id);",
            "if (!Obj) {",
            "    console.warn(\"3D Object not found: \" + Id);",
            "    return;",
            "}",
            "const Clip = Obj.animations[ANumber];",
            "if (!Clip) {",
            "    console.warn(\"3D Animation not found: \" + ANumber);",
            "    return;",
            "}",
            "//",
            "let Action;",
            "const OBJ_UUID = Obj.uuid;",
            "const Clip_UUID = Clip.uuid;",
            "if (AnimationActions.has(OBJ_UUID)) {",
            "    if (AnimationActions.get(OBJ_UUID).has(Clip_UUID)) {",
            "        const Action = AnimationActions.get(OBJ_UUID).get(Clip_UUID);",
            "        if (Duration === 0) {",
            "            Action.stop();",
            "        } else {",
            "            Action.fadeOut(Duration);  ",
            "        }",
            "    }",
            "}",
            "",
            ""
          ],
          "parameterObjects": "",
          "useStrict": true,
          "eventsSheetExpanded": true
        }
      ],
      "parameters": [
        {
          "description": "3D Object ID",
          "name": "Id",
          "supplementaryInformation": "scene3D Object ID",
          "type": "identifier"
        },
        {
          "description": "Original Animation Number",
          "name": "ANumber",
          "type": "expression"
        },
        {
          "description": "Cross-Fade Duration (in seconds)",
          "name": "Duration",
          "type": "expression"
        }
      ],
      "objectGroups": []
    },
    {
      "fullName": "📝Set number to 3D Object Variable",
      "functionType": "Action",
      "group": "3D Object",
      "name": "SetNumberVariable",
      "sentence": "📝Set number to 3D Object Variable (ID: _PARAM1_, Variable: _PARAM2_, _PARAM3_, _PARAM4_)",
      "events": [
        {
          "type": "BuiltinCommonInstructions::JsCode",
          "inlineCode": [
            "if (!gdjs.__WithThreeJS.has(\"Renderer\")) {",
            "    console.warn(\"!\");",
            "    return;",
            "}",
            "const Scene = gdjs.__WithThreeJS.get(\"Scene\");",
            "const Id = eventsFunctionContext.getArgument(\"Id\");",
            "const VariableName = eventsFunctionContext.getArgument(\"VariableName\");",
            "const Operator = eventsFunctionContext.getArgument(\"Operator\");",
            "const Value = eventsFunctionContext.getArgument(\"Value\");",
            "//",
            "const Obj = gdjs.__WithThreeJS.get(\"SearchObject\")(Id);",
            "if (!Obj) {",
            "    console.warn(\"3D Object not found: \" + Id);",
            "    return;",
            "}",
            "//",
            "if (!Obj.userData.Variable) {",
            "    Obj.userData.Variable = {};",
            "}",
            "if (!Obj.userData.Variable[VariableName]) {",
            "    // false, 0, \"\", undefined ...",
            "    Obj.userData.Variable[VariableName] = 0;",
            "}",
            "if (Operator == \"=\") {",
            "    Obj.userData.Variable[VariableName] = Value;",
            "} else if (Operator == \"+\") {",
            "    Obj.userData.Variable[VariableName] += Value;",
            "} else if (Operator == \"-\") {",
            "    Obj.userData.Variable[VariableName] -= Value;",
            "} else {",
            "    Obj.userData.Variable[VariableName] *= Value;",
            "}",
            "",
            ""
          ],
          "parameterObjects": "",
          "useStrict": true,
          "eventsSheetExpanded": true
        }
      ],
      "parameters": [
        {
          "description": "3D Object ID",
          "name": "Id",
          "supplementaryInformation": "scene3D Object ID",
          "type": "identifier"
        },
        {
          "description": "3D Object Variable Name",
          "name": "VariableName",
          "supplementaryInformation": "scene3D Object Variable Name",
          "type": "identifier"
        },
        {
          "description": "Operator",
          "name": "Operator",
          "supplementaryInformation": "[\"=\",\"+\",\"-\",\"*\"]",
          "type": "stringWithSelector"
        },
        {
          "description": "Value",
          "name": "Value",
          "type": "expression"
        }
      ],
      "objectGroups": []
    },
    {
      "fullName": "📝Set string to 3D Object Variable",
      "functionType": "Action",
      "group": "3D Object",
      "name": "SetStringVariable",
      "sentence": "📝Set string to 3D Object Variable (ID: _PARAM1_, Variable: _PARAM2_, _PARAM3_, _PARAM4_)",
      "events": [
        {
          "type": "BuiltinCommonInstructions::JsCode",
          "inlineCode": [
            "if (!gdjs.__WithThreeJS.has(\"Renderer\")) {",
            "    console.warn(\"!\");",
            "    return;",
            "}",
            "const Scene = gdjs.__WithThreeJS.get(\"Scene\");",
            "const Id = eventsFunctionContext.getArgument(\"Id\");",
            "const VariableName = eventsFunctionContext.getArgument(\"VariableName\");",
            "const Operator = eventsFunctionContext.getArgument(\"Operator\");",
            "const Value = eventsFunctionContext.getArgument(\"Value\");",
            "//",
            "const Obj = gdjs.__WithThreeJS.get(\"SearchObject\")(Id);",
            "if (!Obj) {",
            "    console.warn(\"3D Object not found: \" + Id);",
            "    return;",
            "}",
            "//",
            "if (!Obj.userData.Variable) {",
            "    Obj.userData.Variable = {};",
            "}",
            "if (!Obj.userData.Variable[VariableName]) {",
            "    // false, 0, \"\", undefined ...",
            "    Obj.userData.Variable[VariableName] = \"\";",
            "}",
            "if (Operator == \"=\") {",
            "    Obj.userData.Variable[VariableName] = Value;",
            "} else {",
            "    Obj.userData.Variable[VariableName] += Value;",
            "}",
            "",
            ""
          ],
          "parameterObjects": "",
          "useStrict": true,
          "eventsSheetExpanded": true
        }
      ],
      "parameters": [
        {
          "description": "3D Object ID",
          "name": "Id",
          "supplementaryInformation": "scene3D Object ID",
          "type": "identifier"
        },
        {
          "description": "3D Object Variable Name",
          "name": "VariableName",
          "supplementaryInformation": "scene3D Object Variable Name",
          "type": "identifier"
        },
        {
          "description": "Operator",
          "name": "Operator",
          "supplementaryInformation": "[\"=\",\"+\"]",
          "type": "stringWithSelector"
        },
        {
          "description": "Value",
          "name": "Value",
          "type": "string"
        }
      ],
      "objectGroups": []
    },
    {
      "fullName": "🔜Linearly interpolate 3D Object",
      "functionType": "Action",
      "group": "3D Object",
      "name": "Lerp3DObject",
      "sentence": "🔜Linearly Interpolate 3D Object (ID: _PARAM1_, Target ID: _PARAM2_, Position: _PARAM3_, Rotation: _PARAM4_)",
      "events": [
        {
          "type": "BuiltinCommonInstructions::JsCode",
          "inlineCode": [
            "if (!gdjs.__WithThreeJS.has(\"Renderer\")) {",
            "    console.warn(\"!\");",
            "    return;",
            "}",
            "const Scene = gdjs.__WithThreeJS.get(\"Scene\");",
            "const Id = eventsFunctionContext.getArgument(\"Id\");",
            "const TargetId = eventsFunctionContext.getArgument(\"TargetId\");",
            "const FactorP = eventsFunctionContext.getArgument(\"FactorP\");",
            "const FactorR = eventsFunctionContext.getArgument(\"FactorR\");",
            "//",
            "const Obj = gdjs.__WithThreeJS.get(\"SearchObject\")(Id);",
            "const TargetObj = gdjs.__WithThreeJS.get(\"SearchObject\")(TargetId);",
            "if (!Obj || !TargetObj) {",
            "    console.warn(\"3D Object not found: \" + Id + \" or \" + TargetId);",
            "    return;",
            "}",
            "//",
            "const Parent = Obj.parent;",
            "Scene.attach(Obj);",
            "if (FactorP) {",
            "    const WPos = new THREE.Vector3();",
            "    TargetObj.getWorldPosition(WPos);",
            "    Obj.position.lerp(WPos, FactorP);",
            "}",
            "if (FactorR) {",
            "    const WQua = new THREE.Quaternion();",
            "    TargetObj.getWorldQuaternion(WQua);",
            "    Obj.quaternion.slerp(WQua, FactorR);",
            "}",
            "Parent.attach(Obj);",
            "",
            ""
          ],
          "parameterObjects": "",
          "useStrict": true,
          "eventsSheetExpanded": true
        }
      ],
      "parameters": [
        {
          "description": "3D Object ID",
          "name": "Id",
          "supplementaryInformation": "scene3D Object ID",
          "type": "identifier"
        },
        {
          "description": "Target 3D Object ID",
          "name": "TargetId",
          "supplementaryInformation": "scene3D Object ID",
          "type": "identifier"
        },
        {
          "description": "Position interpolation factor (0 to 1)",
          "longDescription": "Disable with 0",
          "name": "FactorP",
          "type": "expression"
        },
        {
          "description": "Rotation interpolation factor (0 to 1)",
          "longDescription": "Disable with 0",
          "name": "FactorR",
          "type": "expression"
        }
      ],
      "objectGroups": []
    },
    {
      "description": "Adds a suffix to the IDs of the specified 3D object and its children.\nNote that if lights or sounds are included as children, their IDs will also change.",
      "fullName": "🆔Add Suffix To 3D Object ID",
      "functionType": "Action",
      "group": "3D Object",
      "name": "AddSuffixToId",
      "sentence": "🆔Add Suffix To 3D Object ID (ID: _PARAM1_, Suffix: _PARAM2_)",
      "events": [
        {
          "type": "BuiltinCommonInstructions::JsCode",
          "inlineCode": [
            "if (!gdjs.__WithThreeJS.has(\"Renderer\")) {",
            "    console.warn(\"!\");",
            "    return;",
            "}",
            "const Scene = gdjs.__WithThreeJS.get(\"Scene\");",
            "//",
            "const Id = eventsFunctionContext.getArgument(\"Id\");",
            "const Suffix = eventsFunctionContext.getArgument(\"Suffix\");",
            "//",
            "const Obj = gdjs.__WithThreeJS.get(\"SearchObject\")(Id);",
            "if (!Obj) {",
            "    console.warn(\"3D Object not found: \" + Id);",
            "    return;",
            "}",
            "//",
            "Obj.traverse((Child) => {",
            "    // !Obj.isLight && !Obj.isLine && !Obj.isSkinnedMesh && !Obj.isBone",
            "    // Obj.type != \"Audio\"",
            "    if (!Child.isCamera && !Child.isScene && !Child.isBone) {",
            "        if (gdjs.__WithThreeJS.get(\"ObjectList\").has(Child.name)) {",
            "            gdjs.__WithThreeJS.get(\"ObjectList\").delete(Child.name);",
            "        }",
            "        Child.name += Suffix;",
            "    }",
            "});"
          ],
          "parameterObjects": "",
          "useStrict": true,
          "eventsSheetExpanded": true
        }
      ],
      "parameters": [
        {
          "description": "3D Object ID",
          "name": "Id",
          "supplementaryInformation": "scene3D Object ID",
          "type": "identifier"
        },
        {
          "description": "Suffix",
          "name": "Suffix",
          "supplementaryInformation": "scene3D Object ID",
          "type": "string"
        }
      ],
      "objectGroups": []
    },
    {
      "description": "If both \"Cast Shadow\" and \"Receive Shadow\" are enabled, striped patterns are likely to occur in the shadow.",
      "fullName": "👤Set 3D Object Shadow",
      "functionType": "Action",
      "group": "3D Object",
      "name": "Set3DShadow",
      "sentence": "👤Set 3D Object Shadow (ID: _PARAM1_, Cast: _PARAM2_, Receive: _PARAM3_)",
      "events": [
        {
          "type": "BuiltinCommonInstructions::JsCode",
          "inlineCode": [
            "if (!gdjs.__WithThreeJS.has(\"Renderer\")) {",
            "    console.warn(\"!\");",
            "    return;",
            "}",
            "const Scene = gdjs.__WithThreeJS.get(\"Scene\");",
            "//",
            "const Id = eventsFunctionContext.getArgument(\"Id\");",
            "const CastShadow = eventsFunctionContext.getArgument(\"CastShadow\");",
            "const ReceiveShadow = eventsFunctionContext.getArgument(\"ReceiveShadow\");",
            "//",
            "const Obj = gdjs.__WithThreeJS.get(\"SearchObject\")(Id);",
            "if (!Obj) {",
            "    console.warn(\"3D Object not found: \" + Id);",
            "    return;",
            "}",
            "//",
            "Obj.traverse((Child) => {",
            "    if (Child.isMesh) {",
            "        Child.castShadow = CastShadow;",
            "        Child.receiveShadow = ReceiveShadow;",
            "    }",
            "});",
            "",
            ""
          ],
          "parameterObjects": "",
          "useStrict": true,
          "eventsSheetExpanded": true
        }
      ],
      "parameters": [
        {
          "description": "3D Object ID",
          "name": "Id",
          "supplementaryInformation": "scene3D Object ID",
          "type": "identifier"
        },
        {
          "description": "Cast Shadow",
          "name": "CastShadow",
          "supplementaryInformation": "scene3D Object ID",
          "type": "yesorno"
        },
        {
          "description": "Receive Shadow",
          "name": "ReceiveShadow",
          "type": "yesorno"
        }
      ],
      "objectGroups": []
    },
    {
      "description": "Gradually changes the color of the 3D Light.",
      "fullName": "💡Change 3D Light Color",
      "functionType": "Action",
      "group": "3D Light",
      "name": "Change3DLightColor",
      "sentence": "💡Change 3D Light Color (ID: _PARAM1_, Color: _PARAM2_, Duration: _PARAM3_, Space: _PARAM4_)",
      "events": [
        {
          "type": "BuiltinCommonInstructions::JsCode",
          "inlineCode": [
            "if (!gdjs.__WithThreeJS.has(\"Renderer\")) {",
            "    console.warn(\"!\");",
            "    return;",
            "}",
            "//",
            "const LightId = eventsFunctionContext.getArgument(\"LightId\");",
            "const Color = eventsFunctionContext.getArgument(\"Color\") || \"255;255;255\";",
            "const Duration = eventsFunctionContext.getArgument(\"Duration\") || 0;",
            "const ColorSpace = eventsFunctionContext.getArgument(\"ColorSpace\") || \"RGB\";",
            "//",
            "const Obj = gdjs.__WithThreeJS.get(\"SearchObject\")(LightId);",
            "if (!Obj) {",
            "    console.warn(\"3D Light not found: \" + LightId);",
            "    return;",
            "}",
            "if (!Obj.isLight) {",
            "    console.warn(\"Not 3D light: \" + LightId);",
            "    return;",
            "}",
            "//",
            "const RGB = gdjs.rgbOrHexToRGBColor(Color);// Color.split(\";\");",
            "if (Duration === 0) {",
            "    Obj.color.set(`rgb(${RGB[0]}, ${RGB[1]}, ${RGB[2]})`);",
            "} else {",
            "    const FromRGB = Obj.color.clone().convertLinearToSRGB().multiplyScalar(255);",
            "    let FromColor;",
            "    let ToColor;",
            "    let SetValueFunction;",
            "    if (ColorSpace == \"RGB\") {",
            "        FromColor = [Math.round(FromRGB.r), Math.round(FromRGB.g), Math.round(FromRGB.b)];",
            "        ToColor = [RGB[0], RGB[1], RGB[2]];",
            "        SetValueFunction = ([R, G, B]) => {",
            "            Obj.color.set(`rgb(${Math.floor(R)}, ${Math.floor(G)}, ${Math.floor(B)})`);",
            "        };",
            "    } else {",
            "        FromColor = gdjs.evtTools.tween.rgbToHsl(Math.round(FromRGB.r), Math.round(FromRGB.g), Math.round(FromRGB.b));",
            "        ToColor = gdjs.evtTools.tween.rgbToHsl(RGB[0], RGB[1], RGB[2]);",
            "        SetValueFunction = ([Hue, Saturation, Lightness]) => {",
            "            Obj.color.set(`hsl(${Hue}, ${Saturation}%, ${Lightness}%)`);",
            "        };",
            "    }",
            "    gdjs.evtTools.tween.getTweensMap(runtimeScene).addMultiTween(",
            "        `_${LightId}Color`,",
            "        runtimeScene,",
            "        Duration,",
            "        \"linear\",",
            "        gdjs.evtTools.common.lerp,",
            "        FromColor,",
            "        ToColor,",
            "        SetValueFunction,",
            "        null",
            "    );",
            "}",
            "",
            ""
          ],
          "parameterObjects": "",
          "useStrict": true,
          "eventsSheetExpanded": true
        }
      ],
      "parameters": [
        {
          "description": "3D Light ID (3D Object ID)",
          "name": "LightId",
          "supplementaryInformation": "scene3D Object ID",
          "type": "identifier"
        },
        {
          "description": "Color",
          "name": "Color",
          "type": "color"
        },
        {
          "description": "Duration (in seconds)",
          "longDescription": "If the duration is set to 0, the change is immediate.",
          "name": "Duration",
          "type": "expression"
        },
        {
          "description": "Gradient color space",
          "name": "ColorSpace",
          "supplementaryInformation": "[\"RGB\",\"HSL\"]",
          "type": "stringWithSelector"
        }
      ],
      "objectGroups": []
    },
    {
      "description": "Gradually changes the intensity of the 3D Light.",
      "fullName": "💡Change 3D Light Intensity",
      "functionType": "Action",
      "group": "3D Light",
      "name": "Change3DLightIntensity",
      "sentence": "💡Change 3D Light Intensity (ID: _PARAM1_, Intensity: _PARAM2_, Duration: _PARAM3_)",
      "events": [
        {
          "type": "BuiltinCommonInstructions::JsCode",
          "inlineCode": [
            "if (!gdjs.__WithThreeJS.has(\"Renderer\")) {",
            "    console.warn(\"!\");",
            "    return;",
            "}",
            "//",
            "const LightId = eventsFunctionContext.getArgument(\"LightId\");",
            "let Intensity = eventsFunctionContext.getArgument(\"Intensity\");",
            "const Duration = eventsFunctionContext.getArgument(\"Duration\") || 0;",
            "//",
            "const Obj = gdjs.__WithThreeJS.get(\"SearchObject\")(LightId);",
            "if (!Obj) {",
            "    console.warn(\"3D Light not found: \" + LightId);",
            "    return;",
            "}",
            "//",
            "if (Obj.isDirectionalLight) {",
            "    Intensity *= gdjs.__WithThreeJS.get(\"LightIntensityScale\");// Three.js r160",
            "} else if (Obj.isSpotLight) {",
            "    Intensity *= gdjs.__WithThreeJS.get(\"LightIntensityCandela\");// Three.js r160",
            "} else if (Obj.isPointLight) {",
            "    Intensity *= gdjs.__WithThreeJS.get(\"LightIntensityCandela\");// Three.js r160",
            "} else {",
            "    console.warn(\"Not 3D light: \" + LightId);",
            "    return;",
            "}",
            "if (Duration === 0) {",
            "    Obj.intensity = Intensity;",
            "} else {",
            "    gdjs.evtTools.tween.getTweensMap(runtimeScene).addSimpleTween(",
            "        `_${LightId}Intensity`,",
            "        runtimeScene,",
            "        Duration,",
            "        \"linear\",",
            "        gdjs.evtTools.common.lerp,",
            "        Obj.intensity,",
            "        Intensity,",
            "        (V) => Obj.intensity = V,",
            "        null",
            "    );",
            "}",
            "",
            ""
          ],
          "parameterObjects": "",
          "useStrict": true,
          "eventsSheetExpanded": true
        }
      ],
      "parameters": [
        {
          "description": "3D Light ID (3D Object ID)",
          "name": "LightId",
          "supplementaryInformation": "scene3D Object ID",
          "type": "identifier"
        },
        {
          "description": "Intensity (Default: 1)",
          "name": "Intensity",
          "type": "expression"
        },
        {
          "description": "Duration (in seconds)",
          "longDescription": "If the duration is set to 0, the change is immediate.",
          "name": "Duration",
          "type": "expression"
        }
      ],
      "objectGroups": []
    },
    {
      "description": "Gradually changes the color of the 3D Ambient Light.",
      "fullName": "💡Change 3D Ambient Light Color",
      "functionType": "Action",
      "group": "3D Light",
      "name": "Change3DAmbientLightColor",
      "sentence": "💡Change 3D Ambient Light Color (Color: _PARAM1_, Duration: _PARAM2_, Space: _PARAM3_)",
      "events": [
        {
          "type": "BuiltinCommonInstructions::JsCode",
          "inlineCode": [
            "if (!gdjs.__WithThreeJS.has(\"Renderer\")) {",
            "    console.warn(\"!\");",
            "    return;",
            "}",
            "if (!gdjs.__WithThreeJS.has(\"AmbientLight\")) {",
            "    console.warn(\"!\");",
            "    return;",
            "}",
            "const Obj = gdjs.__WithThreeJS.get(\"AmbientLight\");",
            "if (!Obj) {",
            "    console.warn(\"3D Ambient Light not found!\");",
            "    return;",
            "}",
            "//",
            "const Color = eventsFunctionContext.getArgument(\"Color\") || \"255;255;255\";",
            "const Duration = eventsFunctionContext.getArgument(\"Duration\") || 0;",
            "const ColorSpace = eventsFunctionContext.getArgument(\"ColorSpace\") || \"RGB\";",
            "//",
            "const RGB = gdjs.rgbOrHexToRGBColor(Color);// Color.split(\";\");",
            "if (Duration === 0) {",
            "    Obj.color.set(`rgb(${RGB[0]}, ${RGB[1]}, ${RGB[2]})`);",
            "} else {",
            "    const FromRGB = Obj.color.clone().convertLinearToSRGB().multiplyScalar(255);",
            "    let FromColor;",
            "    let ToColor;",
            "    let SetValueFunction;",
            "    if (ColorSpace == \"RGB\") {",
            "        FromColor = [Math.round(FromRGB.r), Math.round(FromRGB.g), Math.round(FromRGB.b)];",
            "        ToColor = [RGB[0], RGB[1], RGB[2]];",
            "        SetValueFunction = ([R, G, B]) => {",
            "            Obj.color.set(`rgb(${Math.floor(R)}, ${Math.floor(G)}, ${Math.floor(B)})`);",
            "        };",
            "    } else {",
            "        FromColor = gdjs.evtTools.tween.rgbToHsl(Math.round(FromRGB.r), Math.round(FromRGB.g), Math.round(FromRGB.b));",
            "        ToColor = gdjs.evtTools.tween.rgbToHsl(RGB[0], RGB[1], RGB[2]);",
            "        SetValueFunction = ([Hue, Saturation, Lightness]) => {",
            "            Obj.color.set(`hsl(${Hue}, ${Saturation}%, ${Lightness}%)`);",
            "        };",
            "    }",
            "    gdjs.evtTools.tween.getTweensMap(runtimeScene).addMultiTween(",
            "        \"_3DAmbientLightColor\",",
            "        runtimeScene,",
            "        Duration,",
            "        \"linear\",",
            "        gdjs.evtTools.common.lerp,",
            "        FromColor,",
            "        ToColor,",
            "        SetValueFunction,",
            "        null",
            "    );",
            "}",
            "",
            ""
          ],
          "parameterObjects": "",
          "useStrict": true,
          "eventsSheetExpanded": true
        }
      ],
      "parameters": [
        {
          "description": "Color",
          "name": "Color",
          "type": "color"
        },
        {
          "description": "Duration (in seconds)",
          "longDescription": "If the duration is set to 0, the change is immediate.",
          "name": "Duration",
          "type": "expression"
        },
        {
          "description": "Gradient color space",
          "name": "ColorSpace",
          "supplementaryInformation": "[\"RGB\",\"HSL\"]",
          "type": "stringWithSelector"
        }
      ],
      "objectGroups": []
    },
    {
      "description": "Gradually changes the color of the 3D Background.",
      "fullName": "🏞️Change 3D Background Color",
      "functionType": "Action",
      "group": "3D Scene",
      "name": "Change3DBackgroundColor",
      "sentence": "🏞️Change 3D Background Color (Color: _PARAM1_, Duration: _PARAM2_, Space: _PARAM3_)",
      "events": [
        {
          "type": "BuiltinCommonInstructions::JsCode",
          "inlineCode": [
            "if (!gdjs.__WithThreeJS.has(\"Renderer\")) {",
            "    console.warn(\"!\");",
            "    return;",
            "}",
            "const Scene = gdjs.__WithThreeJS.get(\"Scene\");",
            "if (Scene.background) {",
            "    if (Scene.background.isTexture) {",
            "        Scene.background.dispose();",
            "        Scene.background = null;",
            "        Scene.background = new THREE.Color(\"rgb(0, 0, 0)\");",
            "    }",
            "} else {",
            "    Scene.background = new THREE.Color(\"rgb(0, 0, 0)\");",
            "}",
            "//",
            "const Color = eventsFunctionContext.getArgument(\"Color\") || \"255;255;255\";",
            "const Duration = eventsFunctionContext.getArgument(\"Duration\") || 0;",
            "const ColorSpace = eventsFunctionContext.getArgument(\"ColorSpace\") || \"RGB\";",
            "//",
            "const RGB = gdjs.rgbOrHexToRGBColor(Color);// Color.split(\";\");",
            "if (Duration === 0) {",
            "    Scene.background.set(`rgb(${RGB[0]}, ${RGB[1]}, ${RGB[2]})`);",
            "} else {",
            "    const FromRGB = Scene.background.clone().convertLinearToSRGB().multiplyScalar(255);",
            "    let FromColor;",
            "    let ToColor;",
            "    let SetValueFunction;",
            "    if (ColorSpace == \"RGB\") {",
            "        FromColor = [Math.round(FromRGB.r), Math.round(FromRGB.g), Math.round(FromRGB.b)];",
            "        ToColor = [RGB[0], RGB[1], RGB[2]];",
            "        SetValueFunction = ([R, G, B]) => {",
            "            Scene.background.set(`rgb(${Math.floor(R)}, ${Math.floor(G)}, ${Math.floor(B)})`);",
            "        };",
            "    } else {",
            "        FromColor = gdjs.evtTools.tween.rgbToHsl(Math.round(FromRGB.r), Math.round(FromRGB.g), Math.round(FromRGB.b));",
            "        ToColor = gdjs.evtTools.tween.rgbToHsl(RGB[0], RGB[1], RGB[2]);",
            "        SetValueFunction = ([Hue, Saturation, Lightness]) => {",
            "            Scene.background.set(`hsl(${Hue}, ${Saturation}%, ${Lightness}%)`);",
            "        };",
            "    }",
            "    gdjs.evtTools.tween.getTweensMap(runtimeScene).addMultiTween(",
            "        \"_3DBackgroundColor\",",
            "        runtimeScene,",
            "        Duration,",
            "        \"linear\",",
            "        gdjs.evtTools.common.lerp,",
            "        FromColor,",
            "        ToColor,",
            "        SetValueFunction,",
            "        null",
            "    );",
            "}",
            "",
            ""
          ],
          "parameterObjects": "",
          "useStrict": true,
          "eventsSheetExpanded": true
        }
      ],
      "parameters": [
        {
          "description": "Background Color",
          "name": "Color",
          "type": "color"
        },
        {
          "description": "Duration (in seconds)",
          "longDescription": "If the duration is set to 0, the change is immediate.",
          "name": "Duration",
          "type": "expression"
        },
        {
          "description": "Gradient color space",
          "name": "ColorSpace",
          "supplementaryInformation": "[\"RGB\",\"HSL\"]",
          "type": "stringWithSelector"
        }
      ],
      "objectGroups": []
    },
    {
      "fullName": "3D Object Position",
      "functionType": "Expression",
      "group": "3D Object",
      "name": "ObjectPosition",
      "sentence": "",
      "events": [
        {
          "type": "BuiltinCommonInstructions::JsCode",
          "inlineCode": [
            "if (!gdjs.__WithThreeJS.has(\"Renderer\")) {",
            "    console.warn(\"!\");",
            "    return;",
            "}",
            "const Scene = gdjs.__WithThreeJS.get(\"Scene\");",
            "const Id = eventsFunctionContext.getArgument(\"Id\");",
            "const Axis = eventsFunctionContext.getArgument(\"Axis\");",
            "//",
            "const Obj = gdjs.__WithThreeJS.get(\"SearchObject\")(Id);",
            "if (!Obj) {",
            "    console.warn(\"3D Object not found: \" + Id);",
            "    return;",
            "}",
            "//",
            "if (Axis == \"X\") {",
            "    eventsFunctionContext.returnValue = Obj.position.x;",
            "} else if (Axis == \"Y\") {",
            "    eventsFunctionContext.returnValue = Obj.position.y;",
            "} else {",
            "    eventsFunctionContext.returnValue = Obj.position.z;",
            "}",
            "",
            ""
          ],
          "parameterObjects": "",
          "useStrict": true,
          "eventsSheetExpanded": true
        }
      ],
      "expressionType": {
        "type": "expression"
      },
      "parameters": [
        {
          "description": "3D Object ID",
          "name": "Id",
          "supplementaryInformation": "scene3D Object ID",
          "type": "identifier"
        },
        {
          "description": "Axis",
          "name": "Axis",
          "supplementaryInformation": "[\"X\",\"Y\",\"Z\"]",
          "type": "stringWithSelector"
        }
      ],
      "objectGroups": []
    },
    {
      "fullName": "3D Object Position On World",
      "functionType": "Expression",
      "group": "3D Object",
      "name": "ObjectPositionOnWorld",
      "sentence": "",
      "events": [
        {
          "type": "BuiltinCommonInstructions::JsCode",
          "inlineCode": [
            "if (!gdjs.__WithThreeJS.has(\"Renderer\")) {",
            "    console.warn(\"!\");",
            "    return;",
            "}",
            "const Scene = gdjs.__WithThreeJS.get(\"Scene\");",
            "const Id = eventsFunctionContext.getArgument(\"Id\");",
            "const Axis = eventsFunctionContext.getArgument(\"Axis\");",
            "//",
            "const Obj = gdjs.__WithThreeJS.get(\"SearchObject\")(Id);",
            "if (!Obj) {",
            "    console.warn(\"3D Object not found: \" + Id);",
            "    return;",
            "}",
            "//",
            "const WorldPosition = new THREE.Vector3();",
            "Obj.getWorldPosition(WorldPosition);",
            "if (Axis == \"X\") {",
            "    eventsFunctionContext.returnValue = WorldPosition.x;",
            "} else if (Axis == \"Y\") {",
            "    eventsFunctionContext.returnValue = WorldPosition.y;",
            "} else {",
            "    eventsFunctionContext.returnValue = WorldPosition.z;",
            "}",
            "",
            ""
          ],
          "parameterObjects": "",
          "useStrict": true,
          "eventsSheetExpanded": true
        }
      ],
      "expressionType": {
        "type": "expression"
      },
      "parameters": [
        {
          "description": "3D Object ID",
          "name": "Id",
          "supplementaryInformation": "scene3D Object ID",
          "type": "identifier"
        },
        {
          "description": "Axis",
          "name": "Axis",
          "supplementaryInformation": "[\"X\",\"Y\",\"Z\"]",
          "type": "stringWithSelector"
        }
      ],
      "objectGroups": []
    },
    {
      "fullName": "3D Object Rotation",
      "functionType": "Expression",
      "group": "3D Object",
      "name": "ObjectRotation",
      "sentence": "",
      "events": [
        {
          "type": "BuiltinCommonInstructions::JsCode",
          "inlineCode": [
            "if (!gdjs.__WithThreeJS.has(\"Renderer\")) {",
            "    console.warn(\"!\");",
            "    return;",
            "}",
            "const Scene = gdjs.__WithThreeJS.get(\"Scene\");",
            "const Id = eventsFunctionContext.getArgument(\"Id\");",
            "const Axis = eventsFunctionContext.getArgument(\"Axis\");",
            "//",
            "const Obj = gdjs.__WithThreeJS.get(\"SearchObject\")(Id);",
            "if (!Obj) {",
            "    console.warn(\"3D Object not found: \" + Id);",
            "    return;",
            "}",
            "//",
            "if (Axis == \"X\") {",
            "    eventsFunctionContext.returnValue = gdjs.toDegrees(Obj.rotation.x);",
            "} else if (Axis == \"Y\") {",
            "    eventsFunctionContext.returnValue = gdjs.toDegrees(Obj.rotation.y);",
            "} else {",
            "    eventsFunctionContext.returnValue = gdjs.toDegrees(Obj.rotation.z);",
            "}",
            "",
            ""
          ],
          "parameterObjects": "",
          "useStrict": true,
          "eventsSheetExpanded": true
        }
      ],
      "expressionType": {
        "type": "expression"
      },
      "parameters": [
        {
          "description": "3D Object ID",
          "name": "Id",
          "supplementaryInformation": "scene3D Object ID",
          "type": "identifier"
        },
        {
          "description": "Axis",
          "name": "Axis",
          "supplementaryInformation": "[\"X\",\"Y\",\"Z\"]",
          "type": "stringWithSelector"
        }
      ],
      "objectGroups": []
    },
    {
      "fullName": "3D Object Rotation On World",
      "functionType": "Expression",
      "group": "3D Object",
      "name": "ObjectRotationOnWorld",
      "sentence": "",
      "events": [
        {
          "type": "BuiltinCommonInstructions::JsCode",
          "inlineCode": [
            "if (!gdjs.__WithThreeJS.has(\"Renderer\")) {",
            "    console.warn(\"!\");",
            "    return;",
            "}",
            "const Scene = gdjs.__WithThreeJS.get(\"Scene\");",
            "const Id = eventsFunctionContext.getArgument(\"Id\");",
            "const Axis = eventsFunctionContext.getArgument(\"Axis\");",
            "//",
            "const Obj = gdjs.__WithThreeJS.get(\"SearchObject\")(Id);",
            "if (!Obj) {",
            "    console.warn(\"3D Object not found: \" + Id);",
            "    return;",
            "}",
            "//",
            "const WorldQuaternion = new THREE.Quaternion();",
            "Obj.getWorldQuaternion(WorldQuaternion);",
            "const Euler = new THREE.Euler();",
            "Euler.setFromQuaternion(WorldQuaternion);",
            "if (Axis == \"X\") {",
            "    eventsFunctionContext.returnValue = gdjs.toDegrees(Euler.x);",
            "} else if (Axis == \"Y\") {",
            "    eventsFunctionContext.returnValue = gdjs.toDegrees(Euler.y);",
            "} else {",
            "    eventsFunctionContext.returnValue = gdjs.toDegrees(Euler.z);",
            "}",
            "",
            ""
          ],
          "parameterObjects": "",
          "useStrict": true,
          "eventsSheetExpanded": true
        }
      ],
      "expressionType": {
        "type": "expression"
      },
      "parameters": [
        {
          "description": "3D Object ID",
          "name": "Id",
          "supplementaryInformation": "scene3D Object ID",
          "type": "identifier"
        },
        {
          "description": "Axis",
          "name": "Axis",
          "supplementaryInformation": "[\"X\",\"Y\",\"Z\"]",
          "type": "stringWithSelector"
        }
      ],
      "objectGroups": []
    },
    {
      "description": "Normalized direction vector of 3D Object.\n(Z axis direction)",
      "fullName": "3D Object Direction",
      "functionType": "Expression",
      "group": "3D Object",
      "name": "ObjectDirection",
      "sentence": "",
      "events": [
        {
          "type": "BuiltinCommonInstructions::JsCode",
          "inlineCode": [
            "if (!gdjs.__WithThreeJS.has(\"Renderer\")) {",
            "    console.warn(\"!\");",
            "    return;",
            "}",
            "const Scene = gdjs.__WithThreeJS.get(\"Scene\");",
            "const Id = eventsFunctionContext.getArgument(\"Id\");",
            "const Axis = eventsFunctionContext.getArgument(\"Axis\");",
            "//",
            "const Obj = gdjs.__WithThreeJS.get(\"SearchObject\")(Id);",
            "if (!Obj) {",
            "    console.warn(\"3D Object not found: \" + Id);",
            "    return;",
            "}",
            "//",
            "const WorldDirection = new THREE.Vector3();",
            "Obj.getWorldDirection(WorldDirection);",
            "//",
            "if (Axis == \"X\") {",
            "    eventsFunctionContext.returnValue = WorldDirection.x;",
            "} else if (Axis == \"Y\") {",
            "    eventsFunctionContext.returnValue = WorldDirection.y;",
            "} else {",
            "    eventsFunctionContext.returnValue = WorldDirection.z;",
            "}",
            "",
            ""
          ],
          "parameterObjects": "",
          "useStrict": true,
          "eventsSheetExpanded": true
        }
      ],
      "expressionType": {
        "type": "expression"
      },
      "parameters": [
        {
          "description": "3D Object ID",
          "name": "Id",
          "supplementaryInformation": "scene3D Object ID",
          "type": "identifier"
        },
        {
          "description": "Axis",
          "name": "Axis",
          "supplementaryInformation": "[\"X\",\"Y\",\"Z\"]",
          "type": "stringWithSelector"
        }
      ],
      "objectGroups": []
    },
    {
      "description": "Returns the opacity of the 3D Object, or the first opacity found among its children.",
      "fullName": "3D Object Opacity",
      "functionType": "Expression",
      "group": "3D Object",
      "name": "ObjectOpacity",
      "sentence": "",
      "events": [
        {
          "type": "BuiltinCommonInstructions::JsCode",
          "inlineCode": [
            "if (!gdjs.__WithThreeJS.has(\"Renderer\")) {",
            "    console.warn(\"!\");",
            "    return;",
            "}",
            "const Scene = gdjs.__WithThreeJS.get(\"Scene\");",
            "const Id = eventsFunctionContext.getArgument(\"Id\");",
            "let Opacity = null;",
            "//",
            "const Obj = gdjs.__WithThreeJS.get(\"SearchObject\")(Id);",
            "if (!Obj) {",
            "    console.warn(\"3D Object not found: \" + Id);",
            "    return;",
            "}",
            "//",
            "Obj.traverse((Child) => {",
            "    if (Opacity === null) {",
            "        if (Child.material) {",
            "            if (Array.isArray(Child.material)) {",
            "                Opacity = Child.material[0].opacity;",
            "            } else {",
            "                Opacity = Child.material.opacity;",
            "            }",
            "        }",
            "    }",
            "});",
            "eventsFunctionContext.returnValue = (Opacity === null)? 1 : Opacity;",
            "",
            ""
          ],
          "parameterObjects": "",
          "useStrict": true,
          "eventsSheetExpanded": true
        }
      ],
      "expressionType": {
        "type": "expression"
      },
      "parameters": [
        {
          "description": "3D Object ID",
          "name": "Id",
          "supplementaryInformation": "scene3D Object ID",
          "type": "identifier"
        }
      ],
      "objectGroups": []
    },
    {
      "fullName": "3D Object Scale",
      "functionType": "Expression",
      "group": "3D Object",
      "name": "ObjectScale",
      "sentence": "",
      "events": [
        {
          "type": "BuiltinCommonInstructions::JsCode",
          "inlineCode": [
            "if (!gdjs.__WithThreeJS.has(\"Renderer\")) {",
            "    console.warn(\"!\");",
            "    return;",
            "}",
            "const Scene = gdjs.__WithThreeJS.get(\"Scene\");",
            "const Id = eventsFunctionContext.getArgument(\"Id\");",
            "const Axis = eventsFunctionContext.getArgument(\"Axis\");",
            "//",
            "const Obj = gdjs.__WithThreeJS.get(\"SearchObject\")(Id);",
            "if (!Obj) {",
            "    console.warn(\"3D Object not found: \" + Id);",
            "    return;",
            "}",
            "//",
            "if (Obj.isSprite) {",
            "    const Texture = Obj.material.map;",
            "    const TextureWidth = Texture.image.width;",
            "    const TextureHeight = Texture.image.height;",
            "    if (Axis == \"Scale X Axis\") {",
            "        eventsFunctionContext.returnValue = Obj.scale.x / TextureWidth;",
            "    } else if (Axis == \"Scale Y Axis\") {",
            "        eventsFunctionContext.returnValue = Obj.scale.y / TextureHeight;",
            "    } else {",
            "        eventsFunctionContext.returnValue = 1;",
            "    }",
            "} else {",
            "    if (Axis == \"Scale X Axis\") {",
            "        eventsFunctionContext.returnValue = Obj.scale.x;",
            "    } else if (Axis == \"Scale Y Axis\") {",
            "        eventsFunctionContext.returnValue = Obj.scale.y;",
            "    } else {",
            "        eventsFunctionContext.returnValue = Obj.scale.z;",
            "    }",
            "}",
            "",
            ""
          ],
          "parameterObjects": "",
          "useStrict": true,
          "eventsSheetExpanded": true
        }
      ],
      "expressionType": {
        "type": "expression"
      },
      "parameters": [
        {
          "description": "3D Object ID",
          "name": "Id",
          "supplementaryInformation": "scene3D Object ID",
          "type": "identifier"
        },
        {
          "description": "Axis",
          "name": "Axis",
          "supplementaryInformation": "[\"Scale X Axis\",\"Scale Y Axis\",\"Scale Z Axis\"]",
          "type": "stringWithSelector"
        }
      ],
      "objectGroups": []
    },
    {
      "fullName": "3D Object Parent",
      "functionType": "StringExpression",
      "group": "3D Object",
      "name": "ObjectParent",
      "sentence": "",
      "events": [
        {
          "type": "BuiltinCommonInstructions::JsCode",
          "inlineCode": [
            "if (!gdjs.__WithThreeJS.has(\"Renderer\")) {",
            "    console.warn(\"!\");",
            "    return;",
            "}",
            "const Scene = gdjs.__WithThreeJS.get(\"Scene\");",
            "const Id = eventsFunctionContext.getArgument(\"Id\");",
            "//",
            "const Obj = gdjs.__WithThreeJS.get(\"SearchObject\")(Id);",
            "if (!Obj) {",
            "    console.warn(\"3D Object not found: \" + Id);",
            "    return;",
            "}",
            "//",
            "eventsFunctionContext.returnValue = Obj.parent.name;",
            ""
          ],
          "parameterObjects": "",
          "useStrict": true,
          "eventsSheetExpanded": true
        }
      ],
      "expressionType": {
        "supplementaryInformation": "scene",
        "type": "string"
      },
      "parameters": [
        {
          "description": "3D Object ID",
          "name": "Id",
          "supplementaryInformation": "scene3D Object ID",
          "type": "identifier"
        }
      ],
      "objectGroups": []
    },
    {
      "fullName": "3D Object Animation Speed Scale",
      "functionType": "Expression",
      "group": "3D Object",
      "name": "ObjectAnimationSpeedScale",
      "sentence": "",
      "events": [
        {
          "type": "BuiltinCommonInstructions::JsCode",
          "inlineCode": [
            "if (!gdjs.__WithThreeJS.has(\"Renderer\")) {",
            "    console.warn(\"!\");",
            "    return;",
            "}",
            "const Scene = gdjs.__WithThreeJS.get(\"Scene\");",
            "const AnimationActions = gdjs.__WithThreeJS.get(\"AnimationActions\");",
            "const Id = eventsFunctionContext.getArgument(\"Id\");",
            "const ANumber = eventsFunctionContext.getArgument(\"ANumber\");",
            "//",
            "const Obj = gdjs.__WithThreeJS.get(\"SearchObject\")(Id);",
            "if (!Obj) {",
            "    console.warn(\"3D Object not found: \" + Id);",
            "    return;",
            "}",
            "const Clip = Obj.animations[ANumber];",
            "if (!Clip) {",
            "    return;",
            "}",
            "//",
            "const OBJ_UUID = Obj.uuid;",
            "const Clip_UUID = Clip.uuid;",
            "if (AnimationActions.has(OBJ_UUID)) {",
            "    if (AnimationActions.get(OBJ_UUID).has(Clip_UUID)) {",
            "        const Action = AnimationActions.get(OBJ_UUID).get(Clip_UUID);",
            "        eventsFunctionContext.returnValue = Action.timeScale;",
            "    }",
            "}",
            "",
            ""
          ],
          "parameterObjects": "",
          "useStrict": true,
          "eventsSheetExpanded": true
        }
      ],
      "expressionType": {
        "supplementaryInformation": "scene",
        "type": "expression"
      },
      "parameters": [
        {
          "description": "3D Object ID",
          "name": "Id",
          "supplementaryInformation": "scene3D Object ID",
          "type": "identifier"
        },
        {
          "description": "Original Animation Number",
          "name": "ANumber",
          "type": "expression"
        }
      ],
      "objectGroups": []
    },
    {
      "fullName": "3D Object Animation Time",
      "functionType": "Expression",
      "group": "3D Object",
      "name": "ObjectAnimationTime",
      "sentence": "",
      "events": [
        {
          "type": "BuiltinCommonInstructions::JsCode",
          "inlineCode": [
            "if (!gdjs.__WithThreeJS.has(\"Renderer\")) {",
            "    console.warn(\"!\");",
            "    return;",
            "}",
            "const Scene = gdjs.__WithThreeJS.get(\"Scene\");",
            "const AnimationActions = gdjs.__WithThreeJS.get(\"AnimationActions\");",
            "const Id = eventsFunctionContext.getArgument(\"Id\");",
            "const ANumber = eventsFunctionContext.getArgument(\"ANumber\");",
            "//",
            "const Obj = gdjs.__WithThreeJS.get(\"SearchObject\")(Id);",
            "if (!Obj) {",
            "    console.warn(\"3D Object not found: \" + Id);",
            "    return;",
            "}",
            "const Clip = Obj.animations[ANumber];",
            "if (!Clip) {",
            "    return;",
            "}",
            "//",
            "const OBJ_UUID = Obj.uuid;",
            "const Clip_UUID = Clip.uuid;",
            "if (AnimationActions.has(OBJ_UUID)) {",
            "    if (AnimationActions.get(OBJ_UUID).has(Clip_UUID)) {",
            "        const Action = AnimationActions.get(OBJ_UUID).get(Clip_UUID);",
            "        eventsFunctionContext.returnValue = Action.time;",
            "    }",
            "}",
            "",
            ""
          ],
          "parameterObjects": "",
          "useStrict": true,
          "eventsSheetExpanded": true
        }
      ],
      "expressionType": {
        "supplementaryInformation": "scene",
        "type": "expression"
      },
      "parameters": [
        {
          "description": "3D Object ID",
          "name": "Id",
          "supplementaryInformation": "scene3D Object ID",
          "type": "identifier"
        },
        {
          "description": "Original Animation Number",
          "name": "ANumber",
          "type": "expression"
        }
      ],
      "objectGroups": []
    },
    {
      "fullName": "3D Object Animation Duration",
      "functionType": "Expression",
      "group": "3D Object",
      "name": "ObjectAnimationDuration",
      "sentence": "",
      "events": [
        {
          "type": "BuiltinCommonInstructions::JsCode",
          "inlineCode": [
            "if (!gdjs.__WithThreeJS.has(\"Renderer\")) {",
            "    console.warn(\"!\");",
            "    return;",
            "}",
            "const Scene = gdjs.__WithThreeJS.get(\"Scene\");",
            "const AnimationActions = gdjs.__WithThreeJS.get(\"AnimationActions\");",
            "const Id = eventsFunctionContext.getArgument(\"Id\");",
            "const ANumber = eventsFunctionContext.getArgument(\"ANumber\");",
            "//",
            "const Obj = gdjs.__WithThreeJS.get(\"SearchObject\")(Id);",
            "if (!Obj) {",
            "    console.warn(\"3D Object not found: \" + Id);",
            "    return;",
            "}",
            "const Clip = Obj.animations[ANumber];",
            "if (!Clip) {",
            "    return;",
            "}",
            "eventsFunctionContext.returnValue = Clip.duration;",
            "",
            ""
          ],
          "parameterObjects": "",
          "useStrict": true,
          "eventsSheetExpanded": true
        }
      ],
      "expressionType": {
        "supplementaryInformation": "scene",
        "type": "expression"
      },
      "parameters": [
        {
          "description": "3D Object ID",
          "name": "Id",
          "supplementaryInformation": "scene3D Object ID",
          "type": "identifier"
        },
        {
          "description": "Original Animation Number",
          "name": "ANumber",
          "type": "expression"
        }
      ],
      "objectGroups": []
    },
    {
      "fullName": "3D Object Number Variable",
      "functionType": "Expression",
      "group": "3D Object",
      "name": "ObjectNumberVariable",
      "sentence": "",
      "events": [
        {
          "type": "BuiltinCommonInstructions::JsCode",
          "inlineCode": [
            "if (!gdjs.__WithThreeJS.has(\"Renderer\")) {",
            "    console.warn(\"!\");",
            "    return;",
            "}",
            "const Scene = gdjs.__WithThreeJS.get(\"Scene\");",
            "const Id = eventsFunctionContext.getArgument(\"Id\");",
            "const VariableName = eventsFunctionContext.getArgument(\"VariableName\");",
            "//",
            "const Obj = gdjs.__WithThreeJS.get(\"SearchObject\")(Id);",
            "if (!Obj) {",
            "    console.warn(\"3D Object not found: \" + Id);",
            "    return;",
            "}",
            "//",
            "if (!Obj.userData.Variable) {",
            "    Obj.userData.Variable = {};",
            "}",
            "if (!Obj.userData.Variable[VariableName]) {",
            "    // false, 0, \"\", undefined ...",
            "    Obj.userData.Variable[VariableName] = 0;",
            "}",
            "eventsFunctionContext.returnValue = Obj.userData.Variable[VariableName];",
            "",
            ""
          ],
          "parameterObjects": "",
          "useStrict": true,
          "eventsSheetExpanded": true
        }
      ],
      "expressionType": {
        "supplementaryInformation": "scene",
        "type": "expression"
      },
      "parameters": [
        {
          "description": "3D Object ID",
          "name": "Id",
          "supplementaryInformation": "scene3D Object ID",
          "type": "identifier"
        },
        {
          "description": "3D Object Variable Name",
          "name": "VariableName",
          "supplementaryInformation": "scene3D Object Variable Name",
          "type": "identifier"
        }
      ],
      "objectGroups": []
    },
    {
      "fullName": "3D Object String Variable",
      "functionType": "StringExpression",
      "group": "3D Object",
      "name": "ObjectStringVariable",
      "sentence": "",
      "events": [
        {
          "type": "BuiltinCommonInstructions::JsCode",
          "inlineCode": [
            "if (!gdjs.__WithThreeJS.has(\"Renderer\")) {",
            "    console.warn(\"!\");",
            "    return;",
            "}",
            "const Scene = gdjs.__WithThreeJS.get(\"Scene\");",
            "const Id = eventsFunctionContext.getArgument(\"Id\");",
            "const VariableName = eventsFunctionContext.getArgument(\"VariableName\");",
            "//",
            "const Obj = gdjs.__WithThreeJS.get(\"SearchObject\")(Id);",
            "if (!Obj) {",
            "    console.warn(\"3D Object not found: \" + Id);",
            "    return;",
            "}",
            "//",
            "if (!Obj.userData.Variable) {",
            "    Obj.userData.Variable = {};",
            "}",
            "if (!Obj.userData.Variable[VariableName]) {",
            "    // false, 0, \"\", undefined ...",
            "    Obj.userData.Variable[VariableName] = \"\";",
            "}",
            "eventsFunctionContext.returnValue = Obj.userData.Variable[VariableName];",
            "",
            ""
          ],
          "parameterObjects": "",
          "useStrict": true,
          "eventsSheetExpanded": true
        }
      ],
      "expressionType": {
        "supplementaryInformation": "scene",
        "type": "string"
      },
      "parameters": [
        {
          "description": "3D Object ID",
          "name": "Id",
          "supplementaryInformation": "scene3D Object ID",
          "type": "identifier"
        },
        {
          "description": "3D Object Variable Name",
          "name": "VariableName",
          "supplementaryInformation": "scene3D Object Variable Name",
          "type": "identifier"
        }
      ],
      "objectGroups": []
    },
    {
      "fullName": "Distance From 3D Object To 3D Object",
      "functionType": "Expression",
      "group": "3D Object",
      "name": "DistanceFrom3DObjectTo3DObject",
      "sentence": "",
      "events": [
        {
          "type": "BuiltinCommonInstructions::JsCode",
          "inlineCode": [
            "if (!gdjs.__WithThreeJS.has(\"Renderer\")) {",
            "    console.warn(\"!\");",
            "    return;",
            "}",
            "const Scene = gdjs.__WithThreeJS.get(\"Scene\");",
            "const Id1 = eventsFunctionContext.getArgument(\"Id1\");",
            "const Id2 = eventsFunctionContext.getArgument(\"Id2\");",
            "//",
            "const Obj1 = gdjs.__WithThreeJS.get(\"SearchObject\")(Id1);",
            "const Obj2 = gdjs.__WithThreeJS.get(\"SearchObject\")(Id2);",
            "if (!Obj1 || !Obj2) {",
            "    console.warn(\"3D Object not found: \" + Id1 + \" or \" + Id2);",
            "    return;",
            "}",
            "//",
            "const WPos1 = new THREE.Vector3();",
            "const WPos2 = new THREE.Vector3();",
            "Obj1.getWorldPosition(WPos1);",
            "Obj2.getWorldPosition(WPos2);",
            "eventsFunctionContext.returnValue = WPos1.distanceTo(WPos2);",
            "",
            ""
          ],
          "parameterObjects": "",
          "useStrict": true,
          "eventsSheetExpanded": true
        }
      ],
      "expressionType": {
        "type": "expression"
      },
      "parameters": [
        {
          "description": "From 3D Object ID",
          "name": "Id1",
          "supplementaryInformation": "scene3D Object ID",
          "type": "identifier"
        },
        {
          "description": "To 3D Object ID",
          "name": "Id2",
          "supplementaryInformation": "scene3D Object ID",
          "type": "identifier"
        }
      ],
      "objectGroups": []
    },
    {
      "fullName": "Bounding Box Collision Result Number",
      "functionType": "Expression",
      "group": "3D Object",
      "name": "BoundingBoxCollisionResultNumber",
      "sentence": "Raycast (From: _PARAM1_, _PARAM2_, _PARAM3_, To: _PARAM4_, _PARAM5_, _PARAM6_)",
      "events": [
        {
          "type": "BuiltinCommonInstructions::JsCode",
          "inlineCode": [
            "if (!gdjs.__WithThreeJS.has(\"Renderer\")) {",
            "    console.warn(\"!\");",
            "    return;",
            "}",
            "if (!gdjs.__WithThreeJS.has(\"BoundingBoxCollisionResult\")) {",
            "    gdjs.__WithThreeJS.set(\"BoundingBoxCollisionResult\", {Hit:false, CenterX:0, CenterY:0, CenterZ:0, SizeX:0, SizeY:0, SizeZ:0, MoveX:0, MoveY:0, MoveZ:0});",
            "}",
            "const BoundingBoxCollisionResult = gdjs.__WithThreeJS.get(\"BoundingBoxCollisionResult\");",
            "const Item = eventsFunctionContext.getArgument(\"Item\");",
            "//",
            "if (Item == \"Center X\") {",
            "    eventsFunctionContext.returnValue = BoundingBoxCollisionResult.CenterX;",
            "} else if (Item == \"Center Y\") {",
            "    eventsFunctionContext.returnValue = BoundingBoxCollisionResult.CenterY;",
            "} else if (Item == \"Center Z\") {",
            "    eventsFunctionContext.returnValue = BoundingBoxCollisionResult.CenterZ;",
            "} else if (Item == \"Size X\") {",
            "    eventsFunctionContext.returnValue = BoundingBoxCollisionResult.SizeX;",
            "} else if (Item == \"Size Y\") {",
            "    eventsFunctionContext.returnValue = BoundingBoxCollisionResult.SizeY;",
            "} else if (Item == \"Size Z\") {",
            "    eventsFunctionContext.returnValue = BoundingBoxCollisionResult.SizeZ;",
            "} else if (Item == \"Move X\") {",
            "    eventsFunctionContext.returnValue = BoundingBoxCollisionResult.MoveX;",
            "} else if (Item == \"Move Y\") {",
            "    eventsFunctionContext.returnValue = BoundingBoxCollisionResult.MoveY;",
            "} else if (Item == \"Move Z\") {",
            "    eventsFunctionContext.returnValue = BoundingBoxCollisionResult.MoveZ;",
            "}",
            "",
            ""
          ],
          "parameterObjects": "",
          "useStrict": true,
          "eventsSheetExpanded": true
        }
      ],
      "expressionType": {
        "type": "expression"
      },
      "parameters": [
        {
          "description": "Item",
          "name": "Item",
          "supplementaryInformation": "[\"Center X\",\"Center Y\",\"Center Z\",\"Size X\",\"Size Y\",\"Size Z\",\"Move X\",\"Move Y\",\"Move Z\"]",
          "type": "stringWithSelector"
        }
      ],
      "objectGroups": []
    },
    {
      "fullName": "💎Check Existence Of 3D Object",
      "functionType": "Condition",
      "group": "3D Object",
      "name": "CheckExistenceOf3DObject",
      "sentence": "💎Check Existence Of 3D Object (ID: _PARAM1_)",
      "events": [
        {
          "type": "BuiltinCommonInstructions::JsCode",
          "inlineCode": [
            "if (!gdjs.__WithThreeJS.has(\"Renderer\")) {",
            "    console.warn(\"!\");",
            "    return;",
            "}",
            "const Scene = gdjs.__WithThreeJS.get(\"Scene\");",
            "const Id = eventsFunctionContext.getArgument(\"Id\");",
            "//",
            "const Obj = gdjs.__WithThreeJS.get(\"SearchObject\")(Id);",
            "if (Obj && Id !== \"\") {",
            "    eventsFunctionContext.returnValue = true;",
            "} else {",
            "    eventsFunctionContext.returnValue = false;",
            "}",
            "",
            ""
          ],
          "parameterObjects": "",
          "useStrict": true,
          "eventsSheetExpanded": true
        }
      ],
      "parameters": [
        {
          "description": "3D Object ID",
          "name": "Id",
          "supplementaryInformation": "scene3D Object ID",
          "type": "identifier"
        }
      ],
      "objectGroups": []
    },
    {
      "description": "Check the visibility of a 3D Object.\nThis condition cannot be tested correctly if the visibility of the 3D object is changed by inheritance.",
      "fullName": "🌗Check Visibility Of 3D Object",
      "functionType": "Condition",
      "group": "3D Object",
      "name": "CheckVisibilityOf3DObject",
      "sentence": "🌗Check Visibility Of 3D Object (ID: _PARAM1_, Visible: _PARAM2_)",
      "events": [
        {
          "type": "BuiltinCommonInstructions::JsCode",
          "inlineCode": [
            "if (!gdjs.__WithThreeJS.has(\"Renderer\")) {",
            "    console.warn(\"!\");",
            "    return;",
            "}",
            "const Scene = gdjs.__WithThreeJS.get(\"Scene\");",
            "const Id = eventsFunctionContext.getArgument(\"Id\");",
            "const Visible = eventsFunctionContext.getArgument(\"Visible\");",
            "//",
            "const Obj = gdjs.__WithThreeJS.get(\"SearchObject\")(Id);",
            "if (!Obj) {",
            "    console.warn(\"3D Object not found: \" + Id);",
            "    return;",
            "}",
            "//",
            "let VisibilityResult = Obj.visible;",
            "if (VisibilityResult) {",
            "    if (Obj.material) {",
            "        if (Array.isArray(Obj.material)) {",
            "            VisibilityResult = Obj.material.every((x) => x.visible === true);",
            "        } else {",
            "            VisibilityResult = Obj.material.visible;",
            "        }",
            "    }",
            "}",
            "eventsFunctionContext.returnValue = VisibilityResult === Visible;",
            "",
            ""
          ],
          "parameterObjects": "",
          "useStrict": true,
          "eventsSheetExpanded": true
        }
      ],
      "parameters": [
        {
          "description": "3D Object ID",
          "name": "Id",
          "supplementaryInformation": "scene3D Object ID",
          "type": "identifier"
        },
        {
          "defaultValue": "yes",
          "description": "Check if the visible is",
          "name": "Visible",
          "optional": true,
          "type": "yesorno"
        }
      ],
      "objectGroups": []
    },
    {
      "description": "Checks for collisions between the Bounding Boxes of two 3D Objects.\nThis condition updates the \"Bounding Box Collision Result\" when it returns True.",
      "fullName": "💥Check Bounding Box Collision",
      "functionType": "Condition",
      "group": "3D Object",
      "name": "CheckBoundingBoxCollision",
      "sentence": "💥Check Bounding Box Collision (ID: _PARAM1_, Unmoved: _PARAM2_)",
      "events": [
        {
          "type": "BuiltinCommonInstructions::JsCode",
          "inlineCode": [
            "if (!gdjs.__WithThreeJS.has(\"Renderer\")) {",
            "    console.warn(\"!\");",
            "    return;",
            "}",
            "const Scene = gdjs.__WithThreeJS.get(\"Scene\");",
            "const Id = eventsFunctionContext.getArgument(\"Id\");",
            "const UnmovedId = eventsFunctionContext.getArgument(\"UnmovedId\");",
            "//",
            "const Obj = gdjs.__WithThreeJS.get(\"SearchObject\")(Id);",
            "const UnmovedObj = gdjs.__WithThreeJS.get(\"SearchObject\")(UnmovedId);",
            "if (!Obj || !UnmovedObj) {",
            "    console.warn(\"3D Object not found: \" + Id + \" or \" + UnmovedId);",
            "    return;",
            "}",
            "//",
            "const BoundingBoxCollisionResult = gdjs.__WithThreeJS.get(\"SetBoundingBoxCollisionResult\")(Obj, UnmovedObj);",
            "eventsFunctionContext.returnValue = BoundingBoxCollisionResult.Hit;",
            "",
            ""
          ],
          "parameterObjects": "",
          "useStrict": true,
          "eventsSheetExpanded": true
        }
      ],
      "parameters": [
        {
          "description": "3D Object ID",
          "name": "Id",
          "supplementaryInformation": "scene3D Object ID",
          "type": "identifier"
        },
        {
          "description": "Unmoved 3D Object ID",
          "name": "UnmovedId",
          "supplementaryInformation": "scene3D Object ID",
          "type": "identifier"
        }
      ],
      "objectGroups": []
    },
    {
      "description": "Checks for collisions between the Oriented Bounding Boxes of two 3D Objects.\nOBB cannot resolve collisions between OBBs or get collision results.",
      "fullName": "💥Check Oriented Bounding Box Collision",
      "functionType": "Condition",
      "group": "3D Object",
      "name": "CheckOrientedBoxCollision",
      "sentence": "💥Check Oriented Bounding Box Collision (ID: _PARAM1_, _PARAM2_)",
      "events": [
        {
          "type": "BuiltinCommonInstructions::JsCode",
          "inlineCode": [
            "if (!gdjs.__WithThreeJS.has(\"Renderer\")) {",
            "    console.warn(\"!\");",
            "    return;",
            "}",
            "const Scene = gdjs.__WithThreeJS.get(\"Scene\");",
            "const Id = eventsFunctionContext.getArgument(\"Id\");",
            "const OtherId = eventsFunctionContext.getArgument(\"OtherId\");",
            "//",
            "const Obj = gdjs.__WithThreeJS.get(\"SearchObject\")(Id);",
            "const OtherObj = gdjs.__WithThreeJS.get(\"SearchObject\")(OtherId);",
            "if (!Obj || !OtherObj) {",
            "    console.warn(\"3D Object not found: \" + Id + \" or \" + OtherId);",
            "    return;",
            "}",
            "// geometryを持たない場合を回避。なぜかSpriteにはgeometryがある",
            "const Geo1 = Obj.geometry;",
            "const Geo2 = OtherObj.geometry;",
            "if (!Geo1 || !Geo2) {",
            "    console.warn(\"Geometry not found: \" + Id + \" or \" + OtherId);",
            "    return;",
            "}",
            "//",
            "const OBB1 = new THREE.OBB().fromBox3(Geo1.boundingBox);",
            "const OBB2 = new THREE.OBB().fromBox3(Geo2.boundingBox);",
            "Obj.updateMatrixWorld(false);//必要?",
            "OtherObj.updateMatrixWorld(false);//必要?",
            "OBB1.applyMatrix4(Obj.matrixWorld);",
            "OBB2.applyMatrix4(OtherObj.matrixWorld);",
            "eventsFunctionContext.returnValue = OBB1.intersectsOBB(OBB2);",
            "",
            ""
          ],
          "parameterObjects": "",
          "useStrict": true,
          "eventsSheetExpanded": true
        }
      ],
      "parameters": [
        {
          "description": "3D Object ID",
          "name": "Id",
          "supplementaryInformation": "scene3D Object ID",
          "type": "identifier"
        },
        {
          "description": "Other 3D Object ID",
          "name": "OtherId",
          "supplementaryInformation": "scene3D Object ID",
          "type": "identifier"
        }
      ],
      "objectGroups": []
    },
    {
      "description": "Check if the 3D Animation is playing.",
      "fullName": "🎞️Check 3D Animation Is Playing",
      "functionType": "Condition",
      "group": "3D Object",
      "name": "Check3DAnimationIsPlaying",
      "sentence": "🎞️Check 3D Animation Is Playing (ID: _PARAM1_, Animation: _PARAM2_)",
      "events": [
        {
          "type": "BuiltinCommonInstructions::JsCode",
          "inlineCode": [
            "if (!gdjs.__WithThreeJS.has(\"Renderer\")) {",
            "    console.warn(\"!\");",
            "    return;",
            "}",
            "const Scene = gdjs.__WithThreeJS.get(\"Scene\");",
            "const AnimationMixer = gdjs.__WithThreeJS.get(\"AnimationMixer\");",
            "const AnimationActions = gdjs.__WithThreeJS.get(\"AnimationActions\");",
            "const Id = eventsFunctionContext.getArgument(\"Id\");",
            "const ANumber = eventsFunctionContext.getArgument(\"ANumber\");",
            "eventsFunctionContext.returnValue = false;",
            "//",
            "const Obj = gdjs.__WithThreeJS.get(\"SearchObject\")(Id);",
            "if (!Obj) {",
            "    console.warn(\"3D Object not found: \" + Id);",
            "    return;",
            "}",
            "const Clip = Obj.animations[ANumber];",
            "if (!Clip) {",
            "    return;",
            "}",
            "//",
            "const OBJ_UUID = Obj.uuid;",
            "const Clip_UUID = Clip.uuid;",
            "if (AnimationActions.has(OBJ_UUID)) {",
            "    if (AnimationActions.get(OBJ_UUID).has(Clip_UUID)) {",
            "        const Action = AnimationActions.get(OBJ_UUID).get(Clip_UUID);",
            "        eventsFunctionContext.returnValue = Action.isRunning();",
            "    }",
            "}",
            "",
            ""
          ],
          "parameterObjects": "",
          "useStrict": true,
          "eventsSheetExpanded": true
        }
      ],
      "parameters": [
        {
          "description": "3D Object ID",
          "name": "Id",
          "supplementaryInformation": "scene3D Object ID",
          "type": "identifier"
        },
        {
          "description": "Original Animation Number",
          "name": "ANumber",
          "supplementaryInformation": "scene3D Object ID",
          "type": "expression"
        }
      ],
      "objectGroups": []
    },
    {
      "description": "Check if the 3D Animation is finished.\nThis condition is valid only for animations with \"Loop\" set to \"Once\".",
      "fullName": "🎞️Check 3D Animation Is Finished",
      "functionType": "Condition",
      "group": "3D Object",
      "name": "Check3DAnimationIsFinished",
      "sentence": "🎞️Check 3D Animation Is Finished (ID: _PARAM1_, Animation: _PARAM2_)",
      "events": [
        {
          "type": "BuiltinCommonInstructions::JsCode",
          "inlineCode": [
            "if (!gdjs.__WithThreeJS.has(\"Renderer\")) {",
            "    console.warn(\"!\");",
            "    return;",
            "}",
            "const Scene = gdjs.__WithThreeJS.get(\"Scene\");",
            "const AnimationMixer = gdjs.__WithThreeJS.get(\"AnimationMixer\");",
            "const AnimationActions = gdjs.__WithThreeJS.get(\"AnimationActions\");",
            "const Id = eventsFunctionContext.getArgument(\"Id\");",
            "const ANumber = eventsFunctionContext.getArgument(\"ANumber\");",
            "eventsFunctionContext.returnValue = false;",
            "//",
            "const Obj = gdjs.__WithThreeJS.get(\"SearchObject\")(Id);",
            "if (!Obj) {",
            "    console.warn(\"3D Object not found: \" + Id);",
            "    return;",
            "}",
            "const Clip = Obj.animations[ANumber];",
            "if (!Clip) {",
            "    return;",
            "}",
            "//",
            "const OBJ_UUID = Obj.uuid;",
            "const Clip_UUID = Clip.uuid;",
            "if (AnimationActions.has(OBJ_UUID)) {",
            "    if (AnimationActions.get(OBJ_UUID).has(Clip_UUID)) {",
            "        const Action = AnimationActions.get(OBJ_UUID).get(Clip_UUID);",
            "        if (Action.loop === THREE.LoopOnce) {",
            "            if (Action.timeScale >= 0) {",
            "                if (Action.time >= Clip.duration) {",
            "                    eventsFunctionContext.returnValue = true;",
            "                }",
            "            } else {",
            "                if (Action.time <= 0) {",
            "                    eventsFunctionContext.returnValue = true;",
            "                }",
            "            }",
            "        }",
            "    }",
            "}",
            "",
            ""
          ],
          "parameterObjects": "",
          "useStrict": true,
          "eventsSheetExpanded": true
        }
      ],
      "parameters": [
        {
          "description": "3D Object ID",
          "name": "Id",
          "supplementaryInformation": "scene3D Object ID",
          "type": "identifier"
        },
        {
          "description": "Original Animation Number",
          "name": "ANumber",
          "supplementaryInformation": "scene3D Object ID",
          "type": "expression"
        }
      ],
      "objectGroups": []
    },
    {
      "description": "Check if the position of the 3D Object is within the field of view of the 3D camera.",
      "fullName": "🎥Check 3D Object Is Within 3D Camera FOV",
      "functionType": "Condition",
      "group": "3D Object",
      "name": "Check3DObjectWithinFOV",
      "sentence": "🎥Check 3D Object Is Within 3D Camera FOV (Camera ID: _PARAM1_, Object ID: _PARAM2_)",
      "events": [
        {
          "type": "BuiltinCommonInstructions::JsCode",
          "inlineCode": [
            "if (!gdjs.__WithThreeJS.has(\"Renderer\")) {",
            "    console.warn(\"!\");",
            "    return;",
            "}",
            "const Scene = gdjs.__WithThreeJS.get(\"Scene\");",
            "const CameraId = eventsFunctionContext.getArgument(\"CameraId\");",
            "const Id = eventsFunctionContext.getArgument(\"Id\");",
            "eventsFunctionContext.returnValue = false;",
            "//",
            "const Obj = gdjs.__WithThreeJS.get(\"SearchObject\")(Id);",
            "if (!Obj) {",
            "    console.warn(\"3D Object not found: \" + Id);",
            "    return;",
            "}",
            "const Camera = gdjs.__WithThreeJS.get(\"GetCamera\")(CameraId);",
            "const Frustum = new THREE.Frustum();",
            "const CloneCamera = Camera.clone();",
            "CloneCamera.rotateZ(gdjs.toRad(180));",
            "Frustum.setFromProjectionMatrix(new THREE.Matrix4().multiplyMatrices(CloneCamera.projectionMatrix, CloneCamera.matrixWorldInverse));",
            "const WPos = new THREE.Vector3();",
            "Obj.getWorldPosition(WPos);",
            "eventsFunctionContext.returnValue = Frustum.containsPoint(WPos);",
            "",
            ""
          ],
          "parameterObjects": "",
          "useStrict": true,
          "eventsSheetExpanded": true
        }
      ],
      "parameters": [
        {
          "description": "3D Camera ID (1 to 4)",
          "name": "CameraId",
          "supplementaryInformation": "scene3D Object ID",
          "type": "expression"
        },
        {
          "description": "3D Object ID",
          "name": "Id",
          "supplementaryInformation": "scene3D Object ID",
          "type": "identifier"
        }
      ],
      "objectGroups": []
    },
    {
      "description": "Play a 3D Positional Sound.",
      "fullName": "Play 3D Sound V1 (Deprecated)",
      "functionType": "Action",
      "group": "3D Sound",
      "name": "Play3DSound",
      "private": true,
      "sentence": "⚠️ Play 3D Sound V1 (Resource: _PARAM1_, Sound ID: _PARAM2_, Parent ID: _PARAM3_, Loop: _PARAM4_, Volume: _PARAM5_, Pitch: _PARAM6_, Distance: _PARAM7_)",
      "events": [
        {
          "type": "BuiltinCommonInstructions::JsCode",
          "inlineCode": [
            "if (!gdjs.__WithThreeJS.has(\"Renderer\")) {",
            "    console.warn(\"!\");",
            "    return;",
            "}",
            "const Scene = gdjs.__WithThreeJS.get(\"Scene\");",
            "const Listener = gdjs.__WithThreeJS.get(\"Listener\");",
            "const ResourceName = eventsFunctionContext.getArgument(\"ResourceName\");",
            "const SoundId = eventsFunctionContext.getArgument(\"SoundId\");",
            "const Id = eventsFunctionContext.getArgument(\"Id\");",
            "const Loop = eventsFunctionContext.getArgument(\"Loop\");",
            "const Volume = eventsFunctionContext.getArgument(\"Volume\") || 1;",
            "const Pitch = eventsFunctionContext.getArgument(\"Pitch\") || 1;",
            "let MaxDistance = eventsFunctionContext.getArgument(\"MaxDistance\") || 1000;",
            "//",
            "const ResourceFileName = gdjs.__WithThreeJS.get(\"GetResourceFileName\")(ResourceName, \"audio\");",
            "MaxDistance = MaxDistance <= 0 ? 0.0001 : MaxDistance;",
            "//",
            "const Obj = gdjs.__WithThreeJS.get(\"SearchObject\")(Id);",
            "if (!Obj) {",
            "    console.warn(\"3D Object not found: \" + Id);",
            "    return;",
            "}",
            "//",
            "let Sound = Obj.getObjectByName(SoundId);",
            "if (!Sound) {",
            "\tSound = new THREE.PositionalAudio(Listener);",
            "\tSound.name = SoundId;",
            "\tObj.add(Sound);",
            "}",
            "Sound.setRefDistance(1);//音量の低下が有効になり始める距離",
            "Sound.setRolloffFactor(1)//音量が減少する速さ",
            "Sound.setDistanceModel(\"linear\");",
            "Sound.setMaxDistance(MaxDistance);//リスナーの間の最大距離",
            "//",
            "Sound.setLoop(Loop);",
            "Sound.setVolume(Volume);",
            "Sound.setPlaybackRate(Pitch);//再生速度",
            "// Sound.setDetune(0);//ピッチ（なぜかエラーになる）",
            "//",
            "const audioLoader = new THREE.AudioLoader();",
            "audioLoader.load(ResourceFileName, function(buffer) {",
            "\tSound.setBuffer(buffer);",
            "\tif (Sound.isPlaying) {",
            "\t\tSound.stop();",
            "\t}",
            "\tSound.play();",
            "});",
            "",
            ""
          ],
          "parameterObjects": "",
          "useStrict": true,
          "eventsSheetExpanded": true
        }
      ],
      "parameters": [
        {
          "description": "GDevelop Resource Name (Audio)",
          "longDescription": "Escape is required. example: \"assets\\\\Sound.wav\" -> \"assets\\\\\\\\Sound.wav\"",
          "name": "ResourceName",
          "type": "string"
        },
        {
          "description": "3D Sound ID",
          "name": "SoundId",
          "supplementaryInformation": "scene3D Sound ID",
          "type": "identifier"
        },
        {
          "description": "Parent 3D Object ID",
          "name": "Id",
          "supplementaryInformation": "scene3D Object ID",
          "type": "identifier"
        },
        {
          "description": "Loop",
          "name": "Loop",
          "type": "yesorno"
        },
        {
          "description": "Volume (Default: 1)",
          "name": "Volume",
          "type": "expression"
        },
        {
          "description": "Pitch (Default: 1)",
          "name": "Pitch",
          "type": "expression"
        },
        {
          "description": "Max Distance (0 or more)",
          "name": "MaxDistance",
          "type": "expression"
        }
      ],
      "objectGroups": []
    },
    {
      "description": "Play a 3D Positional Sound.",
      "fullName": "🔊Play 3D Sound",
      "functionType": "Action",
      "group": "3D Sound",
      "name": "Play3DSoundV2",
      "sentence": "🔊Play 3D Sound (Resource: _PARAM1_, Sound ID: _PARAM2_, Parent ID: _PARAM3_, Loop: _PARAM4_, Volume: _PARAM5_, Pitch: _PARAM6_, Distance: _PARAM7_)",
      "events": [
        {
          "type": "BuiltinCommonInstructions::JsCode",
          "inlineCode": [
            "if (!gdjs.__WithThreeJS.has(\"Renderer\")) {",
            "    console.warn(\"!\");",
            "    return;",
            "}",
            "const Scene = gdjs.__WithThreeJS.get(\"Scene\");",
            "const Listener = gdjs.__WithThreeJS.get(\"Listener\");",
            "const ResourceName = eventsFunctionContext.getArgument(\"ResourceName\");",
            "const SoundId = eventsFunctionContext.getArgument(\"SoundId\");",
            "const Id = eventsFunctionContext.getArgument(\"Id\");",
            "const Loop = eventsFunctionContext.getArgument(\"Loop\");",
            "const Volume = eventsFunctionContext.getArgument(\"Volume\") || 1;",
            "const Pitch = eventsFunctionContext.getArgument(\"Pitch\") || 1;",
            "let MaxDistance = eventsFunctionContext.getArgument(\"MaxDistance\") || 1000;",
            "//",
            "const ResourceFileName = gdjs.__WithThreeJS.get(\"GetResourceFileName\")(ResourceName, \"audio\");",
            "MaxDistance = MaxDistance <= 0 ? 0.0001 : MaxDistance;",
            "//",
            "const Obj = gdjs.__WithThreeJS.get(\"SearchObject\")(Id);",
            "if (!Obj) {",
            "    console.warn(\"3D Object not found: \" + Id);",
            "    return;",
            "}",
            "//",
            "let Sound = Obj.getObjectByName(SoundId);",
            "if (!Sound) {",
            "\tSound = new THREE.PositionalAudio(Listener);",
            "\tSound.name = SoundId;",
            "\tObj.add(Sound);",
            "}",
            "Sound.setRefDistance(1);//音量の低下が有効になり始める距離",
            "Sound.setRolloffFactor(1)//音量が減少する速さ",
            "Sound.setDistanceModel(\"linear\");",
            "Sound.setMaxDistance(MaxDistance);//リスナーの間の最大距離",
            "//",
            "Sound.setLoop(Loop);",
            "Sound.setVolume(Volume);",
            "Sound.setPlaybackRate(Pitch);//再生速度",
            "// Sound.setDetune(0);//ピッチ（なぜかエラーになる）",
            "//",
            "const audioLoader = new THREE.AudioLoader();",
            "audioLoader.load(ResourceFileName, function(buffer) {",
            "\tSound.setBuffer(buffer);",
            "\tif (Sound.isPlaying) {",
            "\t\tSound.stop();",
            "\t}",
            "\tSound.play();",
            "});",
            "",
            ""
          ],
          "parameterObjects": "",
          "useStrict": true,
          "eventsSheetExpanded": true
        }
      ],
      "parameters": [
        {
          "description": "GDevelop Resource Name (Audio)",
          "name": "ResourceName",
          "type": "audioResource"
        },
        {
          "description": "3D Sound ID",
          "name": "SoundId",
          "supplementaryInformation": "scene3D Sound ID",
          "type": "identifier"
        },
        {
          "description": "Parent 3D Object ID",
          "name": "Id",
          "supplementaryInformation": "scene3D Object ID",
          "type": "identifier"
        },
        {
          "description": "Loop",
          "name": "Loop",
          "type": "yesorno"
        },
        {
          "description": "Volume (Default: 1)",
          "name": "Volume",
          "type": "expression"
        },
        {
          "description": "Pitch (Default: 1)",
          "name": "Pitch",
          "type": "expression"
        },
        {
          "description": "Max Distance (0 or more)",
          "name": "MaxDistance",
          "type": "expression"
        }
      ],
      "objectGroups": []
    },
    {
      "description": "Stop a 3D Positional Sound.",
      "fullName": "🔇Stop 3D Sound",
      "functionType": "Action",
      "group": "3D Sound",
      "name": "Stop3DSound",
      "sentence": "🔇Stop 3D Sound (Sound ID: _PARAM1_, Parent ID: _PARAM2_)",
      "events": [
        {
          "type": "BuiltinCommonInstructions::JsCode",
          "inlineCode": [
            "if (!gdjs.__WithThreeJS.has(\"Renderer\")) {",
            "    console.warn(\"!\");",
            "    return;",
            "}",
            "const Scene = gdjs.__WithThreeJS.get(\"Scene\");",
            "const SoundId = eventsFunctionContext.getArgument(\"SoundId\");",
            "const Id = eventsFunctionContext.getArgument(\"Id\");",
            "//",
            "const Obj = gdjs.__WithThreeJS.get(\"SearchObject\")(Id);",
            "if (!Obj) {",
            "    console.warn(\"3D Object not found: \" + Id);",
            "    return;",
            "}",
            "//",
            "const Sound = Obj.getObjectByName(SoundId);",
            "if (!Sound) {",
            "    console.warn(\"3D Sound not found: \" + SoundId);",
            "    return;",
            "}",
            "if (Sound.isPlaying) {",
            "\tSound.stop();",
            "}",
            "",
            ""
          ],
          "parameterObjects": "",
          "useStrict": true,
          "eventsSheetExpanded": true
        }
      ],
      "parameters": [
        {
          "description": "3D Sound ID",
          "name": "SoundId",
          "supplementaryInformation": "scene3D Sound ID",
          "type": "identifier"
        },
        {
          "description": "Parent 3D Object ID",
          "name": "Id",
          "supplementaryInformation": "scene3D Object ID",
          "type": "identifier"
        }
      ],
      "objectGroups": []
    },
    {
      "fullName": "🔊Change Master Volume Of 3D Scene",
      "functionType": "Action",
      "group": "3D Sound",
      "name": "ChangeMasterVolumeOf3DScene",
      "sentence": "🔊Change Master Volume Of 3D Scene (_PARAM1_, Volume: _PARAM2_)",
      "events": [
        {
          "type": "BuiltinCommonInstructions::JsCode",
          "inlineCode": [
            "if (!gdjs.__WithThreeJS.has(\"Renderer\")) {",
            "    console.warn(\"!\");",
            "    return;",
            "}",
            "const Listener = gdjs.__WithThreeJS.get(\"Listener\");",
            "const Operator = eventsFunctionContext.getArgument(\"Operator\");",
            "const Volume = eventsFunctionContext.getArgument(\"Volume\");",
            "//",
            "if (Operator == \"=\") {",
            "    Listener.setMasterVolume(Volume);",
            "} else if (Operator == \"+\") {",
            "    Listener.setMasterVolume(Listener.getMasterVolume() + Volume);",
            "} else if (Operator == \"-\") {",
            "    Listener.setMasterVolume(Listener.getMasterVolume() - Volume);",
            "}",
            "",
            ""
          ],
          "parameterObjects": "",
          "useStrict": true,
          "eventsSheetExpanded": true
        }
      ],
      "parameters": [
        {
          "description": "Operator",
          "name": "Operator",
          "supplementaryInformation": "[\"=\",\"+\",\"-\"]",
          "type": "stringWithSelector"
        },
        {
          "description": "Master Volume (Default: 1)",
          "name": "Volume",
          "type": "expression"
        }
      ],
      "objectGroups": []
    },
    {
      "fullName": "Master Volume Of 3D Scene",
      "functionType": "Expression",
      "group": "3D Sound",
      "name": "MasterVolumeOf3DScene",
      "sentence": "Master Volume of 3D Scene",
      "events": [
        {
          "type": "BuiltinCommonInstructions::JsCode",
          "inlineCode": [
            "if (!gdjs.__WithThreeJS.has(\"Renderer\")) {",
            "    console.warn(\"!\");",
            "    return;",
            "}",
            "const Listener = gdjs.__WithThreeJS.get(\"Listener\");",
            "eventsFunctionContext.returnValue = Listener.getMasterVolume();",
            "",
            ""
          ],
          "parameterObjects": "",
          "useStrict": true,
          "eventsSheetExpanded": true
        }
      ],
      "expressionType": {
        "type": "expression"
      },
      "parameters": [],
      "objectGroups": []
    },
    {
      "description": "Check if the 3D Sound is playing.",
      "fullName": "🔊Check 3D Sound Is Playing",
      "functionType": "Condition",
      "group": "3D Sound",
      "name": "Check3DSoundIsPlaying",
      "sentence": "🔊Check 3D Sound Is Playing (Sound ID: _PARAM1_, Parent ID: _PARAM2_)",
      "events": [
        {
          "type": "BuiltinCommonInstructions::JsCode",
          "inlineCode": [
            "if (!gdjs.__WithThreeJS.has(\"Renderer\")) {",
            "    console.warn(\"!\");",
            "    return;",
            "}",
            "const Scene = gdjs.__WithThreeJS.get(\"Scene\");",
            "const SoundId = eventsFunctionContext.getArgument(\"SoundId\");",
            "const Id = eventsFunctionContext.getArgument(\"Id\");",
            "//",
            "const Obj = gdjs.__WithThreeJS.get(\"SearchObject\")(Id);",
            "if (!Obj) {",
            "    console.warn(\"3D Object not found: \" + Id);",
            "    return;",
            "}",
            "//",
            "const Sound = Obj.getObjectByName(SoundId);",
            "if (!Sound) {",
            "    console.warn(\"3D Sound not found: \" + SoundId);",
            "    return;",
            "}",
            "eventsFunctionContext.returnValue = Sound.isPlaying;",
            "",
            ""
          ],
          "parameterObjects": "",
          "useStrict": true,
          "eventsSheetExpanded": true
        }
      ],
      "parameters": [
        {
          "description": "3D Sound ID",
          "name": "SoundId",
          "supplementaryInformation": "scene3D Sound ID",
          "type": "identifier"
        },
        {
          "description": "Parent 3D Object ID",
          "name": "Id",
          "supplementaryInformation": "scene3D Object ID",
          "type": "identifier"
        }
      ],
      "objectGroups": []
    },
    {
      "fullName": "🛟Create 3D Axes Helper",
      "functionType": "Action",
      "group": "3D Debug",
      "name": "Create3DAxesHelper",
      "sentence": "🛟Create 3D Axes Helper (Parent ID: _PARAM1_, Size: _PARAM2_)",
      "events": [
        {
          "type": "BuiltinCommonInstructions::JsCode",
          "inlineCode": [
            "if (!gdjs.__WithThreeJS.has(\"Renderer\")) {",
            "    console.warn(\"!\");",
            "    return;",
            "}",
            "const Scene = gdjs.__WithThreeJS.get(\"Scene\");",
            "//",
            "const ParentId = eventsFunctionContext.getArgument(\"ParentId\");",
            "const Size = eventsFunctionContext.getArgument(\"Size\");",
            "//",
            "const Parent = gdjs.__WithThreeJS.get(\"SearchObject\")(ParentId);",
            "if (!Parent) {",
            "    console.warn(\"Parent 3D Object not found: \" + ParentId);",
            "    return;",
            "}",
            "//",
            "const AxesHelper = new THREE.AxesHelper(Size);",
            "AxesHelper.name = ParentId + \"_AxesHelper\";",
            "AxesHelper.layers.set(1);",
            "Parent.add(AxesHelper);"
          ],
          "parameterObjects": "",
          "useStrict": true,
          "eventsSheetExpanded": true
        }
      ],
      "parameters": [
        {
          "description": "Parent 3D Object ID",
          "name": "ParentId",
          "supplementaryInformation": "scene3D Object ID",
          "type": "identifier"
        },
        {
          "description": "Size",
          "name": "Size",
          "type": "expression"
        }
      ],
      "objectGroups": []
    },
    {
      "description": "Create or update Helper to graphically display Bounding Box.",
      "fullName": "🛟Update Bounding Box Helper",
      "functionType": "Action",
      "group": "3D Debug",
      "name": "UpdateBoundingBoxHelper",
      "sentence": "🛟Update Bounding Box Helper (ID: _PARAM1_, Color: _PARAM2_)",
      "events": [
        {
          "type": "BuiltinCommonInstructions::JsCode",
          "inlineCode": [
            "if (!gdjs.__WithThreeJS.has(\"Renderer\")) {",
            "    console.warn(\"!\");",
            "    return;",
            "}",
            "const Scene = gdjs.__WithThreeJS.get(\"Scene\");",
            "//",
            "const Id = eventsFunctionContext.getArgument(\"Id\");",
            "const Color = eventsFunctionContext.getArgument(\"Color\") || \"0;0;0\";",
            "const RGB = Color.split(\";\");",
            "//",
            "const Obj = gdjs.__WithThreeJS.get(\"SearchObject\")(Id);",
            "if (!Obj) {",
            "    console.warn(\"3D Object not found: \" + Id);",
            "    return;",
            "}",
            "if (!Obj.geometry) {",
            "    console.warn(\"Geometry not found: \" + Id);",
            "    return;",
            "}",
            "//",
            "// BoxHelper では子まで含んでしまう",
            "let Box3Helper = gdjs.__WithThreeJS.get(\"SearchObject\")(Id + \"_Box3Helper\");",
            "if (Box3Helper) {",
            "    Box3Helper.box.copy(Obj.geometry.boundingBox).applyMatrix4(Obj.matrixWorld);",
            "} else {",
            "    Obj.updateMatrixWorld(true);//シーン開始直後のみ必要だが一応全て最初に実行する",
            "    const Box3 = new THREE.Box3();",
            "    Box3.copy(Obj.geometry.boundingBox).applyMatrix4(Obj.matrixWorld);",
            "    Box3Helper = new THREE.Box3Helper(Box3, `rgb(${RGB[0]}, ${RGB[1]}, ${RGB[2]})`);",
            "    Box3Helper.name = Id + \"_Box3Helper\";",
            "    Box3Helper.layers.set(1);",
            "    Scene.add(Box3Helper);",
            "}",
            "",
            ""
          ],
          "parameterObjects": "",
          "useStrict": true,
          "eventsSheetExpanded": true
        }
      ],
      "parameters": [
        {
          "description": "3D Object ID",
          "name": "Id",
          "supplementaryInformation": "scene3D Object ID",
          "type": "identifier"
        },
        {
          "description": "Color",
          "name": "Color",
          "type": "color"
        }
      ],
      "objectGroups": []
    },
    {
      "fullName": "🛟Output 3D Model Information To Console",
      "functionType": "Action",
      "group": "3D Debug",
      "name": "OutputModelInformationToConsole",
      "sentence": "🛟Output 3D Model Information To Console (3D Model ID: _PARAM1_)",
      "events": [
        {
          "type": "BuiltinCommonInstructions::JsCode",
          "inlineCode": [
            "if (!gdjs.__WithThreeJS.has(\"Renderer\")) {",
            "    console.warn(\"!\");",
            "    return;",
            "}",
            "if (!gdjs.__WithThreeJS.has(\"Models\")) {",
            "    console.warn(\"!\");",
            "    return;",
            "}",
            "const Scene = gdjs.__WithThreeJS.get(\"Scene\");",
            "const Models = gdjs.__WithThreeJS.get(\"Models\");",
            "//",
            "const ModelId = eventsFunctionContext.getArgument(\"ModelId\");",
            "//",
            "if (!Models.has(ModelId)) {",
            "    console.warn(\"3D Model not found: \" + ModelId);",
            "    return;",
            "}",
            "//",
            "console.log(gdjs.__WithThreeJS.get(\"GetModelInfo\")(Models.get(ModelId), \"\", 0));",
            "",
            ""
          ],
          "parameterObjects": "",
          "useStrict": true,
          "eventsSheetExpanded": true
        }
      ],
      "parameters": [
        {
          "description": "3D Model ID",
          "name": "ModelId",
          "supplementaryInformation": "scene3D Model ID",
          "type": "identifier"
        }
      ],
      "objectGroups": []
    },
    {
      "fullName": "🛟Output All IDs To Console",
      "functionType": "Action",
      "group": "3D Debug",
      "name": "OutputAllIdsToConsole",
      "sentence": "🛟Output All IDs To Console (Type: _PARAM1_)",
      "events": [
        {
          "type": "BuiltinCommonInstructions::JsCode",
          "inlineCode": [
            "if (!gdjs.__WithThreeJS.has(\"Renderer\")) {",
            "    console.warn(\"!\");",
            "    return;",
            "}",
            "const Scene = gdjs.__WithThreeJS.get(\"Scene\");",
            "const Type = eventsFunctionContext.getArgument(\"Type\");",
            "let Res = \"\";",
            "//",
            "if (Type == \"3D Object\") {",
            "    Res = gdjs.__WithThreeJS.get(\"GetAllObjectsName\")(Scene, Res, 0);",
            "} else if (Type == \"3D Texture\") {",
            "    if (!gdjs.__WithThreeJS.has(\"Textures\")) {",
            "        console.warn(\"3D Texture not found.\");",
            "        return;",
            "    }",
            "    const Textures = gdjs.__WithThreeJS.get(\"Textures\");",
            "    for (let K of Textures.keys()) {",
            "        Res += \"ID: \" + K + \"\\n\";",
            "    }",
            "} else if (Type == \"3D Model\") {",
            "    if (!gdjs.__WithThreeJS.has(\"Models\")) {",
            "        console.warn(\"3D Model not found.\");",
            "        return;",
            "    }",
            "    const Models = gdjs.__WithThreeJS.get(\"Models\");",
            "    for (let K of Models.keys()) {",
            "        Res += \"ID: \" + K + \"\\n\";",
            "    }",
            "}",
            "//",
            "console.log(Res);",
            "",
            ""
          ],
          "parameterObjects": "",
          "useStrict": true,
          "eventsSheetExpanded": true
        }
      ],
      "parameters": [
        {
          "description": "Type",
          "name": "Type",
          "supplementaryInformation": "[\"3D Object\",\"3D Texture\",\"3D Model\"]",
          "type": "stringWithSelector"
        }
      ],
      "objectGroups": []
    }
  ],
  "eventsBasedBehaviors": [
    {
      "description": "Create 3D Sprite from Sprite object. Moving that Sprite will also move the 3D Sprite.",
      "fullName": "3D Sprite Projection",
      "name": "SpriteProjection",
      "objectType": "Sprite",
      "eventsFunctions": [
        {
          "fullName": "",
          "functionType": "Action",
          "name": "doStepPostEvents",
          "sentence": "",
          "events": [
            {
              "type": "BuiltinCommonInstructions::Standard",
              "conditions": [
                {
                  "type": {
                    "value": "WithThreeJS::SpriteProjection::PropertyFirstFrame"
                  },
                  "parameters": [
                    "Object",
                    "Behavior"
                  ]
                }
              ],
              "actions": [
                {
                  "type": {
                    "value": "WithThreeJS::SpriteProjection::SetPropertyFirstFrame"
                  },
                  "parameters": [
                    "Object",
                    "Behavior",
                    "no"
                  ]
                }
              ],
              "events": [
                {
                  "type": "BuiltinCommonInstructions::JsCode",
                  "inlineCode": [
                    "if (!gdjs.__WithThreeJS.has(\"Renderer\")) {",
                    "    console.warn(\"!\");",
                    "    return;",
                    "}",
                    "if (!gdjs.__WithThreeJS.has(\"Textures\")) {",
                    "    gdjs.__WithThreeJS.set(\"Textures\", new Map());",
                    "}",
                    "const Scene = gdjs.__WithThreeJS.get(\"Scene\");",
                    "let Textures = gdjs.__WithThreeJS.get(\"Textures\");",
                    "//",
                    "const Behavior = objects[0].getBehavior(\"SpriteProjection\");",
                    "const Id = objects[0].name + objects[0].id;",
                    "// const X = objects[0].x;",
                    "// const Y = objects[0].y;",
                    "// const Z = objects[0].zOrder;",
                    "const ProjectionScale = gdjs.__WithThreeJS.get(\"ProjectionScale\");",
                    "// const ViewMode = gdjs.__WithThreeJS.get(\"ViewMode\");",
                    "const AlphaTest = Behavior.AlphaTest();",
                    "const Transparent = AlphaTest !== 0;",
                    "const AntiAliasing = Behavior.AntiAliasing();",
                    "const Depth = Behavior.Depth();",
                    "const CastShadow = Behavior.CastShadow();",
                    "const ReceiveShadow = Behavior.ReceiveShadow();",
                    "// const Blend = THREE.NormalBlending;",
                    "// const Opacity = 1.0;",
                    "//",
                    "//スプライトのすべてのアニメーション画像を取得",
                    "objects[0]._updateIfNotVisible = true;// 非表示でもアニメーション更新を強制",
                    "let AllAnimationSources = [];",
                    "const Animations = objects[0]._animations ? objects[0]._animations : objects[0]._animator._animations;",
                    "for(const V of Animations) {",
                    "    for(const VV of V.directions[0].frames) {",
                    "        AllAnimationSources.push(VV.texture.baseTexture.resource);",
                    "    }",
                    "}",
                    "//その画像がTexturesに登録されているか確認。未登録の場合は作成。",
                    "for(const V of AllAnimationSources) {",
                    "    const TexId = \"_\" + V.url;",
                    "    if (!Textures.has(TexId)) {",
                    "        const T = new THREE.Texture();",
                    "        T.image = V.source;",
                    "        T.wrapS = THREE.MirroredRepeatWrapping;",
                    "        T.wrapT = THREE.MirroredRepeatWrapping;",
                    "        if (!AntiAliasing) {",
                    "            T.magFilter = THREE.NearestFilter;// THREE.LinearFilter",
                    "            T.minFilter = THREE.NearestFilter;// THREE.LinearMipmapLinearFilter",
                    "        }",
                    "        T.colorSpace = THREE.SRGBColorSpace;",
                    "        T.needsUpdate = true;//必須",
                    "        Textures.set(TexId, T);",
                    "        //FlipX",
                    "        const T_FlipX = T.clone();",
                    "        T_FlipX.offset.x = 1;",
                    "        Textures.set(TexId + \"_FlipX\", T_FlipX);",
                    "        //FlipY",
                    "        const T_FlipY = T.clone();",
                    "        T_FlipY.offset.y = 1;",
                    "        Textures.set(TexId + \"_FlipY\", T_FlipY);",
                    "        //FlipXY",
                    "        const T_FlipXY = T.clone();",
                    "        T_FlipXY.offset.x = 1;",
                    "        T_FlipXY.offset.y = 1;",
                    "        Textures.set(TexId + \"_FlipX_FlipY\", T_FlipXY);",
                    "    }",
                    "}",
                    "//",
                    "const TextureId = \"_\" + objects[0].getRendererObject().texture.baseTexture.resource.url;",
                    "Behavior.SetCurrentTextureId(TextureId);",
                    "const Texture = Textures.get(TextureId);",
                    "const TextureWidth = Texture.image.width;",
                    "const TextureHeight = Texture.image.height;",
                    "const Material = new THREE.SpriteMaterial({map:Texture, transparent:Transparent, alphaTest:AlphaTest});// blendingとopacityは2D依存",
                    "const Sprite = new THREE.Sprite(Material);",
                    "// 独自ジオメトリに差し替え（現状ビヘイビアのみ）",
                    "const OriginalGeometry = Sprite.geometry.clone();",
                    "Sprite.geometry = OriginalGeometry;",
                    "Sprite.geometry.computeBoundingBox();",
                    "Sprite.geometry.boundingBox.expandByVector(new THREE.Vector3(0, 0, (Depth * ProjectionScale) / 2));",
                    "Sprite.name = Id;",
                    "Sprite.castShadow = CastShadow;// スプライトは影を投影しないため無意味",
                    "Sprite.receiveShadow = ReceiveShadow;",
                    "Sprite.userData.Use3DProjectionBehavior = true;",
                    "Sprite.scale.set(TextureWidth * ProjectionScale, TextureHeight * ProjectionScale, 1);",
                    "Behavior.SetId(Id);",
                    "Scene.add(Sprite);",
                    "",
                    ""
                  ],
                  "parameterObjects": "Object",
                  "useStrict": true,
                  "eventsSheetExpanded": true
                },
                {
                  "type": "BuiltinCommonInstructions::Standard",
                  "conditions": [
                    {
                      "type": {
                        "value": "WithThreeJS::SpriteProjection::PropertyHide"
                      },
                      "parameters": [
                        "Object",
                        "Behavior"
                      ]
                    }
                  ],
                  "actions": [
                    {
                      "type": {
                        "value": "Cache"
                      },
                      "parameters": [
                        "Object"
                      ]
                    }
                  ]
                }
              ]
            },
            {
              "type": "BuiltinCommonInstructions::JsCode",
              "inlineCode": [
                "if (!gdjs.__WithThreeJS.has(\"Renderer\")) {\r",
                "    console.warn(\"!\");\r",
                "    return;\r",
                "}\r",
                "if (!gdjs.__WithThreeJS.has(\"Textures\")) {\r",
                "    console.warn(\"!\");\r",
                "    return;\r",
                "}\r",
                "const Scene = gdjs.__WithThreeJS.get(\"Scene\");\r",
                "let Textures = gdjs.__WithThreeJS.get(\"Textures\");\r",
                "//\r",
                "const Behavior = objects[0].getBehavior(\"SpriteProjection\");\r",
                "const Id = Behavior.Id();\r",
                "const X = objects[0].getCenterXInScene();\r",
                "const Y = objects[0].getCenterYInScene();\r",
                "const Z = objects[0].zOrder;\r",
                "const ProjectionScale = gdjs.__WithThreeJS.get(\"ProjectionScale\");\r",
                "const ViewMode = gdjs.__WithThreeJS.get(\"ViewMode\");\r",
                "//\r",
                "const Sprite = gdjs.__WithThreeJS.get(\"SearchObject\")(Id);\r",
                "if (!Sprite) {\r",
                "    console.warn(\"3D Object not found: \" + Id);\r",
                "    return;\r",
                "}\r",
                "objects[0]._updateAnimationFrame();//v5.3.198 からのアニメ更新が不規則になる問題への対応\r",
                "let TextureId = \"_\" + objects[0].getRendererObject().texture.baseTexture.resource.url;\r",
                "// Flip\r",
                "if (objects[0].isFlippedX()) {\r",
                "    TextureId += \"_FlipX\";\r",
                "}\r",
                "if (objects[0].isFlippedY()) {\r",
                "    TextureId += \"_FlipY\";\r",
                "}\r",
                "// Animation\r",
                "const Texture = Textures.get(TextureId);\r",
                "if (TextureId !== Behavior.CurrentTextureId()) {\r",
                "    Sprite.material.map = Texture;\r",
                "    Behavior.SetCurrentTextureId(TextureId);\r",
                "}\r",
                "// Blend\r",
                "Sprite.material.blending = gdjs.__WithThreeJS.get(\"Blend2Dto3D\")[objects[0].getBlendMode()];\r",
                "// Opacity\r",
                "const Opacity = objects[0].getOpacity() / 255;\r",
                "if (!Sprite.material.transparent) {\r",
                "    if (Sprite.material.alphaTest !== 0 || Opacity !== 1) {\r",
                "        Sprite.material.transparent = true;\r",
                "        Sprite.material.needsUpdate = true;\r",
                "    }\r",
                "}\r",
                "Sprite.material.opacity = Opacity;\r",
                "// Scale\r",
                "const TextureWidth = Texture.image.width;\r",
                "const TextureHeight = Texture.image.height;\r",
                "Sprite.scale.set(TextureWidth * ProjectionScale * objects[0].getScaleX(), TextureHeight * ProjectionScale * objects[0].getScaleY(), 1);\r",
                "// Move\r",
                "if (ViewMode == \"Top Down\") {\r",
                "    Sprite.position.set(X * ProjectionScale, Z * ProjectionScale, Y * ProjectionScale);\r",
                "} else {\r",
                "    // Side\r",
                "    Sprite.position.set(X * ProjectionScale, -Y * ProjectionScale, Z * ProjectionScale);\r",
                "}\r",
                "\r",
                ""
              ],
              "parameterObjects": "Object",
              "useStrict": true,
              "eventsSheetExpanded": true
            }
          ],
          "parameters": [
            {
              "description": "Object",
              "name": "Object",
              "supplementaryInformation": "Sprite",
              "type": "object"
            },
            {
              "description": "Behavior",
              "name": "Behavior",
              "supplementaryInformation": "WithThreeJS::SpriteProjection",
              "type": "behavior"
            }
          ],
          "objectGroups": []
        },
        {
          "fullName": "",
          "functionType": "Action",
          "name": "onDestroy",
          "sentence": "",
          "events": [
            {
              "type": "BuiltinCommonInstructions::JsCode",
              "inlineCode": [
                "// 生成と同時に削除された場合、3D化されていないので回避\r",
                "// FirstFrame == true のほうが理想的だが取得がめんどくさいので Id を利用。\r",
                "const Behavior = objects[0].getBehavior(\"SpriteProjection\");\r",
                "const Id = Behavior.Id();\r",
                "if (Id === \"\") {\r",
                "    return;\r",
                "}\r",
                "//\r",
                "if (!gdjs.__WithThreeJS.has(\"Renderer\")) {\r",
                "    console.warn(\"!\");\r",
                "    return;\r",
                "}\r",
                "const Scene = gdjs.__WithThreeJS.get(\"Scene\");\r",
                "const Sprite = gdjs.__WithThreeJS.get(\"SearchObject\")(Id);\r",
                "//\r",
                "gdjs.__WithThreeJS.get(\"DisposeChildren\")(Sprite);\r",
                "Sprite.removeFromParent();\r",
                "\r",
                ""
              ],
              "parameterObjects": "Object",
              "useStrict": true,
              "eventsSheetExpanded": true
            }
          ],
          "parameters": [
            {
              "description": "Object",
              "name": "Object",
              "supplementaryInformation": "Sprite",
              "type": "object"
            },
            {
              "description": "Behavior",
              "name": "Behavior",
              "supplementaryInformation": "WithThreeJS::SpriteProjection",
              "type": "behavior"
            }
          ],
          "objectGroups": []
        },
        {
          "fullName": "3D Object ID",
          "functionType": "StringExpression",
          "name": "Id",
          "sentence": "",
          "events": [
            {
              "type": "BuiltinCommonInstructions::Standard",
              "conditions": [],
              "actions": [
                {
                  "type": {
                    "value": "SetReturnString"
                  },
                  "parameters": [
                    "Object.Behavior::PropertyId()"
                  ]
                }
              ]
            }
          ],
          "expressionType": {
            "type": "string"
          },
          "parameters": [
            {
              "description": "Object",
              "name": "Object",
              "supplementaryInformation": "Sprite",
              "type": "object"
            },
            {
              "description": "Behavior",
              "name": "Behavior",
              "supplementaryInformation": "WithThreeJS::SpriteProjection",
              "type": "behavior"
            }
          ],
          "objectGroups": []
        },
        {
          "fullName": "Alpha Channel Test",
          "functionType": "Expression",
          "name": "AlphaTest",
          "sentence": "",
          "events": [
            {
              "type": "BuiltinCommonInstructions::Standard",
              "conditions": [],
              "actions": [
                {
                  "type": {
                    "value": "SetReturnNumber"
                  },
                  "parameters": [
                    "Object.Behavior::PropertyAlphaTest()"
                  ]
                }
              ]
            }
          ],
          "expressionType": {
            "type": "expression"
          },
          "parameters": [
            {
              "description": "Object",
              "name": "Object",
              "supplementaryInformation": "Sprite",
              "type": "object"
            },
            {
              "description": "Behavior",
              "name": "Behavior",
              "supplementaryInformation": "WithThreeJS::SpriteProjection",
              "type": "behavior"
            }
          ],
          "objectGroups": []
        },
        {
          "fullName": "Is Anti-Aliasing",
          "functionType": "Condition",
          "name": "AntiAliasing",
          "private": true,
          "sentence": "Is Anti-Aliasing _PARAM0_",
          "events": [
            {
              "type": "BuiltinCommonInstructions::Standard",
              "conditions": [
                {
                  "type": {
                    "value": "WithThreeJS::SpriteProjection::PropertyAntiAliasing"
                  },
                  "parameters": [
                    "Object",
                    "Behavior"
                  ]
                }
              ],
              "actions": [
                {
                  "type": {
                    "value": "SetReturnBoolean"
                  },
                  "parameters": [
                    "True"
                  ]
                }
              ]
            },
            {
              "type": "BuiltinCommonInstructions::Standard",
              "conditions": [
                {
                  "type": {
                    "inverted": true,
                    "value": "WithThreeJS::SpriteProjection::PropertyAntiAliasing"
                  },
                  "parameters": [
                    "Object",
                    "Behavior"
                  ]
                }
              ],
              "actions": [
                {
                  "type": {
                    "value": "SetReturnBoolean"
                  },
                  "parameters": [
                    "False"
                  ]
                }
              ]
            }
          ],
          "parameters": [
            {
              "description": "Object",
              "name": "Object",
              "supplementaryInformation": "Sprite",
              "type": "object"
            },
            {
              "description": "Behavior",
              "name": "Behavior",
              "supplementaryInformation": "WithThreeJS::SpriteProjection",
              "type": "behavior"
            }
          ],
          "objectGroups": []
        },
        {
          "fullName": "Is Cast Shadow",
          "functionType": "Condition",
          "name": "CastShadow",
          "private": true,
          "sentence": "Is Cast Shadow _PARAM0_",
          "events": [
            {
              "type": "BuiltinCommonInstructions::Standard",
              "conditions": [
                {
                  "type": {
                    "value": "WithThreeJS::SpriteProjection::PropertyCastShadow"
                  },
                  "parameters": [
                    "Object",
                    "Behavior"
                  ]
                }
              ],
              "actions": [
                {
                  "type": {
                    "value": "SetReturnBoolean"
                  },
                  "parameters": [
                    "True"
                  ]
                }
              ]
            },
            {
              "type": "BuiltinCommonInstructions::Standard",
              "conditions": [
                {
                  "type": {
                    "inverted": true,
                    "value": "WithThreeJS::SpriteProjection::PropertyCastShadow"
                  },
                  "parameters": [
                    "Object",
                    "Behavior"
                  ]
                }
              ],
              "actions": [
                {
                  "type": {
                    "value": "SetReturnBoolean"
                  },
                  "parameters": [
                    "False"
                  ]
                }
              ]
            }
          ],
          "parameters": [
            {
              "description": "Object",
              "name": "Object",
              "supplementaryInformation": "Sprite",
              "type": "object"
            },
            {
              "description": "Behavior",
              "name": "Behavior",
              "supplementaryInformation": "WithThreeJS::SpriteProjection",
              "type": "behavior"
            }
          ],
          "objectGroups": []
        },
        {
          "fullName": "Is Receive Shadow",
          "functionType": "Condition",
          "name": "ReceiveShadow",
          "private": true,
          "sentence": "Is Receive Shadow _PARAM0_",
          "events": [
            {
              "type": "BuiltinCommonInstructions::Standard",
              "conditions": [
                {
                  "type": {
                    "value": "WithThreeJS::SpriteProjection::PropertyReceiveShadow"
                  },
                  "parameters": [
                    "Object",
                    "Behavior"
                  ]
                }
              ],
              "actions": [
                {
                  "type": {
                    "value": "SetReturnBoolean"
                  },
                  "parameters": [
                    "True"
                  ]
                }
              ]
            },
            {
              "type": "BuiltinCommonInstructions::Standard",
              "conditions": [
                {
                  "type": {
                    "inverted": true,
                    "value": "WithThreeJS::SpriteProjection::PropertyReceiveShadow"
                  },
                  "parameters": [
                    "Object",
                    "Behavior"
                  ]
                }
              ],
              "actions": [
                {
                  "type": {
                    "value": "SetReturnBoolean"
                  },
                  "parameters": [
                    "False"
                  ]
                }
              ]
            }
          ],
          "parameters": [
            {
              "description": "Object",
              "name": "Object",
              "supplementaryInformation": "Sprite",
              "type": "object"
            },
            {
              "description": "Behavior",
              "name": "Behavior",
              "supplementaryInformation": "WithThreeJS::SpriteProjection",
              "type": "behavior"
            }
          ],
          "objectGroups": []
        },
        {
          "fullName": "Current 3D Texture ID",
          "functionType": "StringExpression",
          "name": "CurrentTextureId",
          "private": true,
          "sentence": "",
          "events": [
            {
              "type": "BuiltinCommonInstructions::Standard",
              "conditions": [],
              "actions": [
                {
                  "type": {
                    "value": "SetReturnString"
                  },
                  "parameters": [
                    "Object.Behavior::PropertyCurrentTextureId()"
                  ]
                }
              ]
            }
          ],
          "expressionType": {
            "type": "string"
          },
          "parameters": [
            {
              "description": "Object",
              "name": "Object",
              "supplementaryInformation": "Sprite",
              "type": "object"
            },
            {
              "description": "Behavior",
              "name": "Behavior",
              "supplementaryInformation": "WithThreeJS::SpriteProjection",
              "type": "behavior"
            }
          ],
          "objectGroups": []
        },
        {
          "fullName": "Depth for Bounding Box Collision",
          "functionType": "Expression",
          "name": "Depth",
          "private": true,
          "sentence": "",
          "events": [
            {
              "type": "BuiltinCommonInstructions::Standard",
              "conditions": [],
              "actions": [
                {
                  "type": {
                    "value": "SetReturnNumber"
                  },
                  "parameters": [
                    "Object.Behavior::PropertyDepth()"
                  ]
                }
              ]
            }
          ],
          "expressionType": {
            "type": "expression"
          },
          "parameters": [
            {
              "description": "Object",
              "name": "Object",
              "supplementaryInformation": "Sprite",
              "type": "object"
            },
            {
              "description": "Behavior",
              "name": "Behavior",
              "supplementaryInformation": "WithThreeJS::SpriteProjection",
              "type": "behavior"
            }
          ],
          "objectGroups": []
        },
        {
          "fullName": "Set 3D Object ID",
          "functionType": "Action",
          "name": "SetId",
          "private": true,
          "sentence": "Set 3D Object ID (_PARAM0_, ID: _PARAM2_)",
          "events": [
            {
              "type": "BuiltinCommonInstructions::Standard",
              "conditions": [],
              "actions": [
                {
                  "type": {
                    "value": "WithThreeJS::SpriteProjection::SetPropertyId"
                  },
                  "parameters": [
                    "Object",
                    "Behavior",
                    "=",
                    "GetArgumentAsString(\"Id\")"
                  ]
                }
              ]
            }
          ],
          "parameters": [
            {
              "description": "Object",
              "name": "Object",
              "supplementaryInformation": "Sprite",
              "type": "object"
            },
            {
              "description": "Behavior",
              "name": "Behavior",
              "supplementaryInformation": "WithThreeJS::SpriteProjection",
              "type": "behavior"
            },
            {
              "description": "3D Object ID",
              "name": "Id",
              "type": "string"
            }
          ],
          "objectGroups": []
        },
        {
          "fullName": "Set Current 3D Texture ID",
          "functionType": "Action",
          "name": "SetCurrentTextureId",
          "private": true,
          "sentence": "Set Current 3D Texture ID (_PARAM0_, ID: _PARAM2_)",
          "events": [
            {
              "type": "BuiltinCommonInstructions::Standard",
              "conditions": [],
              "actions": [
                {
                  "type": {
                    "value": "WithThreeJS::SpriteProjection::SetPropertyCurrentTextureId"
                  },
                  "parameters": [
                    "Object",
                    "Behavior",
                    "=",
                    "GetArgumentAsString(\"Id\")"
                  ]
                }
              ]
            }
          ],
          "parameters": [
            {
              "description": "Object",
              "name": "Object",
              "supplementaryInformation": "Sprite",
              "type": "object"
            },
            {
              "description": "Behavior",
              "name": "Behavior",
              "supplementaryInformation": "WithThreeJS::SpriteProjection",
              "type": "behavior"
            },
            {
              "description": "3D Texture ID",
              "name": "Id",
              "type": "string"
            }
          ],
          "objectGroups": []
        }
      ],
      "propertyDescriptors": [
        {
          "value": "",
          "type": "String",
          "label": "",
          "description": "",
          "group": "",
          "extraInformation": [],
          "hidden": true,
          "name": "Id"
        },
        {
          "value": "true",
          "type": "Boolean",
          "label": "",
          "description": "",
          "group": "",
          "extraInformation": [],
          "hidden": true,
          "name": "FirstFrame"
        },
        {
          "value": "",
          "type": "String",
          "label": "",
          "description": "",
          "group": "",
          "extraInformation": [],
          "hidden": true,
          "name": "CurrentTextureId"
        },
        {
          "value": "true",
          "type": "Boolean",
          "label": "Hide 2D Object",
          "description": "",
          "group": "",
          "extraInformation": [],
          "name": "Hide"
        },
        {
          "value": "0",
          "type": "Number",
          "label": "Alpha Channel Test",
          "description": "Recommended values: 0 or 0.5. Default: 0.",
          "group": "Texture",
          "extraInformation": [],
          "name": "AlphaTest"
        },
        {
          "value": "true",
          "type": "Boolean",
          "label": "Anti-Aliasing",
          "description": "",
          "group": "Texture",
          "extraInformation": [
            "Antialiased",
            "No Antialiasing"
          ],
          "name": "AntiAliasing"
        },
        {
          "value": "0",
          "type": "Number",
          "label": "Depth for Bounding Box Collision",
          "description": "Unit: Pixel",
          "group": "Collision",
          "extraInformation": [],
          "name": "Depth"
        },
        {
          "value": "",
          "type": "Boolean",
          "label": "Cast Shadow",
          "description": "If both \"Cast Shadow\" and \"Receive Shadow\" are enabled, striped patterns are likely to occur in the shadow.",
          "group": "Shadow",
          "extraInformation": [],
          "hidden": true,
          "name": "CastShadow"
        },
        {
          "value": "",
          "type": "Boolean",
          "label": "Receive Shadow",
          "description": "If both \"Cast Shadow\" and \"Receive Shadow\" are enabled, striped patterns are likely to occur in the shadow.",
          "group": "Shadow",
          "extraInformation": [],
          "hidden": true,
          "name": "ReceiveShadow"
        }
      ],
      "sharedPropertyDescriptors": []
    },
    {
      "description": "Create 3D Board (Plane) from Sprite object. Moving that Sprite will also move the 3D Object.",
      "fullName": "3D Board Projection",
      "name": "BoardProjection",
      "objectType": "Sprite",
      "eventsFunctions": [
        {
          "fullName": "",
          "functionType": "Action",
          "name": "doStepPostEvents",
          "sentence": "",
          "events": [
            {
              "type": "BuiltinCommonInstructions::Standard",
              "conditions": [
                {
                  "type": {
                    "value": "WithThreeJS::BoardProjection::PropertyFirstFrame"
                  },
                  "parameters": [
                    "Object",
                    "Behavior"
                  ]
                }
              ],
              "actions": [
                {
                  "type": {
                    "value": "WithThreeJS::BoardProjection::SetPropertyFirstFrame"
                  },
                  "parameters": [
                    "Object",
                    "Behavior",
                    "no"
                  ]
                }
              ],
              "events": [
                {
                  "type": "BuiltinCommonInstructions::JsCode",
                  "inlineCode": [
                    "if (!gdjs.__WithThreeJS.has(\"Renderer\")) {",
                    "    console.warn(\"!\");",
                    "    return;",
                    "}",
                    "if (!gdjs.__WithThreeJS.has(\"Textures\")) {",
                    "    gdjs.__WithThreeJS.set(\"Textures\", new Map());",
                    "}",
                    "const Scene = gdjs.__WithThreeJS.get(\"Scene\");",
                    "let Textures = gdjs.__WithThreeJS.get(\"Textures\");",
                    "//",
                    "const Behavior = objects[0].getBehavior(\"BoardProjection\");",
                    "const Id = objects[0].name + objects[0].id;",
                    "const ProjectionScale = gdjs.__WithThreeJS.get(\"ProjectionScale\");",
                    "// const ViewMode = gdjs.__WithThreeJS.get(\"ViewMode\");",
                    "const AlphaTest = Behavior.AlphaTest();",
                    "const Transparent = AlphaTest !== 0;",
                    "const AntiAliasing = Behavior.AntiAliasing();",
                    "const Depth = Behavior.Depth();",
                    "const CastShadow = Behavior.CastShadow();",
                    "const ReceiveShadow = Behavior.ReceiveShadow();",
                    "//",
                    "//スプライトのすべてのアニメーション画像を取得",
                    "objects[0]._updateIfNotVisible = true;// 非表示でもアニメーション更新を強制",
                    "let AllAnimationSources = [];",
                    "const Animations = objects[0]._animations ? objects[0]._animations : objects[0]._animator._animations;",
                    "for(const V of Animations) {",
                    "    for(const VV of V.directions[0].frames) {",
                    "        AllAnimationSources.push(VV.texture.baseTexture.resource);",
                    "    }",
                    "}",
                    "//その画像がTexturesに登録されているか確認。未登録の場合は作成。(SpriteProjectionと共通の命名規則)",
                    "for(const V of AllAnimationSources) {",
                    "    const TexId = \"_\" + V.url;",
                    "    if (!Textures.has(TexId)) {",
                    "        const T = new THREE.Texture();",
                    "        T.image = V.source;",
                    "        T.wrapS = THREE.MirroredRepeatWrapping;",
                    "        T.wrapT = THREE.MirroredRepeatWrapping;",
                    "        if (!AntiAliasing) {",
                    "            T.magFilter = THREE.NearestFilter;// THREE.LinearFilter",
                    "            T.minFilter = THREE.NearestFilter;// THREE.LinearMipmapLinearFilter",
                    "        }",
                    "        T.colorSpace = THREE.SRGBColorSpace;",
                    "        T.needsUpdate = true;//必須",
                    "        Textures.set(TexId, T);",
                    "        //FlipX",
                    "        const T_FlipX = T.clone();",
                    "        T_FlipX.offset.x = 1;",
                    "        Textures.set(TexId + \"_FlipX\", T_FlipX);",
                    "        //FlipY",
                    "        const T_FlipY = T.clone();",
                    "        T_FlipY.offset.y = 1;",
                    "        Textures.set(TexId + \"_FlipY\", T_FlipY);",
                    "        //FlipXY",
                    "        const T_FlipXY = T.clone();",
                    "        T_FlipXY.offset.x = 1;",
                    "        T_FlipXY.offset.y = 1;",
                    "        Textures.set(TexId + \"_FlipX_FlipY\", T_FlipXY);",
                    "    }",
                    "}",
                    "//",
                    "const TextureId = \"_\" + objects[0].getRendererObject().texture.baseTexture.resource.url;",
                    "Behavior.SetCurrentTextureId(TextureId);",
                    "const Texture = Textures.get(TextureId);",
                    "const TextureWidth = Texture.image.width;",
                    "const TextureHeight = Texture.image.height;",
                    "//const Material = new THREE.MeshBasicMaterial({map:Texture, side:THREE.DoubleSide, transparent:Transparent, alphaTest:AlphaTest});// blendingとopacityは2D依存",
                    "const Material = new THREE.MeshLambertMaterial({map:Texture, side:THREE.DoubleSide, transparent:Transparent, alphaTest:AlphaTest});// blendingとopacityは2D依存",
                    "const Geometry = new THREE.PlaneGeometry(TextureWidth * ProjectionScale, TextureHeight * ProjectionScale, 1, 1);",
                    "Geometry.computeBoundingBox();",
                    "Geometry.boundingBox.expandByVector(new THREE.Vector3(0, 0, (Depth * ProjectionScale) / 2));",
                    "const Obj = new THREE.Mesh(Geometry, Material);",
                    "Obj.name = Id;",
                    "Obj.castShadow = CastShadow;",
                    "Obj.receiveShadow = ReceiveShadow;",
                    "Obj.userData.Use3DProjectionBehavior = true;",
                    "Behavior.SetId(Id);",
                    "Scene.add(Obj);",
                    "",
                    ""
                  ],
                  "parameterObjects": "Object",
                  "useStrict": true,
                  "eventsSheetExpanded": true
                },
                {
                  "type": "BuiltinCommonInstructions::Standard",
                  "conditions": [
                    {
                      "type": {
                        "value": "WithThreeJS::BoardProjection::PropertyHide"
                      },
                      "parameters": [
                        "Object",
                        "Behavior"
                      ]
                    }
                  ],
                  "actions": [
                    {
                      "type": {
                        "value": "Cache"
                      },
                      "parameters": [
                        "Object"
                      ]
                    }
                  ]
                }
              ]
            },
            {
              "type": "BuiltinCommonInstructions::JsCode",
              "inlineCode": [
                "if (!gdjs.__WithThreeJS.has(\"Renderer\")) {\r",
                "    console.warn(\"!\");\r",
                "    return;\r",
                "}\r",
                "if (!gdjs.__WithThreeJS.has(\"Textures\")) {\r",
                "    console.warn(\"!\");\r",
                "    return;\r",
                "}\r",
                "const Scene = gdjs.__WithThreeJS.get(\"Scene\");\r",
                "let Textures = gdjs.__WithThreeJS.get(\"Textures\");\r",
                "//\r",
                "const Behavior = objects[0].getBehavior(\"BoardProjection\");\r",
                "const Id = Behavior.Id();\r",
                "const X = objects[0].getCenterXInScene();\r",
                "const Y = objects[0].getCenterYInScene();\r",
                "const Z = objects[0].zOrder;\r",
                "const ProjectionScale = gdjs.__WithThreeJS.get(\"ProjectionScale\");\r",
                "const ViewMode = gdjs.__WithThreeJS.get(\"ViewMode\");\r",
                "const AngleAxis = Behavior.AngleAxis();\r",
                "const Orientation = Behavior.Orientation();\r",
                "//\r",
                "const Obj = gdjs.__WithThreeJS.get(\"SearchObject\")(Id);\r",
                "if (!Obj) {\r",
                "    console.warn(\"3D Object not found: \" + Id);\r",
                "    return;\r",
                "}\r",
                "objects[0]._updateAnimationFrame();//v5.3.198 からのアニメ更新が不規則になる問題への対応\r",
                "let TextureId = \"_\" + objects[0].getRendererObject().texture.baseTexture.resource.url;\r",
                "// Flip\r",
                "if (objects[0].isFlippedX()) {\r",
                "    TextureId += \"_FlipX\";\r",
                "}\r",
                "if (objects[0].isFlippedY()) {\r",
                "    TextureId += \"_FlipY\";\r",
                "}\r",
                "// Animation\r",
                "const Texture = Textures.get(TextureId);\r",
                "if (TextureId !== Behavior.CurrentTextureId()) {\r",
                "    Obj.material.map = Texture;\r",
                "    Behavior.SetCurrentTextureId(TextureId);\r",
                "}\r",
                "// Blend\r",
                "Obj.material.blending = gdjs.__WithThreeJS.get(\"Blend2Dto3D\")[objects[0].getBlendMode()];\r",
                "// Opacity\r",
                "const Opacity = objects[0].getOpacity() / 255;\r",
                "if (!Obj.material.transparent) {\r",
                "    if (Obj.material.alphaTest !== 0 || Opacity !== 1) {\r",
                "        Obj.material.transparent = true;\r",
                "        Obj.material.needsUpdate = true;\r",
                "    }\r",
                "}\r",
                "Obj.material.opacity = Opacity;\r",
                "// Scale\r",
                "Obj.scale.set(objects[0].getScaleX(), objects[0].getScaleY(), 1);\r",
                "// Rotate\r",
                "const BaseXAngle = (Orientation == \"Horizontal\") ? -90 : 0;\r",
                "const Angle = objects[0].angle * -1;\r",
                "if (AngleAxis == \"X Axis\") {\r",
                "    Obj.rotation.set(gdjs.toRad(BaseXAngle + Angle), gdjs.toRad(0), gdjs.toRad(0));\r",
                "} else if (AngleAxis == \"Y Axis\") {\r",
                "    Obj.rotation.set(gdjs.toRad(BaseXAngle), gdjs.toRad(Angle), gdjs.toRad(0));\r",
                "} else {\r",
                "    Obj.rotation.set(gdjs.toRad(BaseXAngle), gdjs.toRad(0), gdjs.toRad(Angle));\r",
                "}\r",
                "// Move\r",
                "if (ViewMode == \"Top Down\") {\r",
                "    Obj.position.set(X * ProjectionScale, Z * ProjectionScale, Y * ProjectionScale);\r",
                "} else {\r",
                "    // Side\r",
                "    Obj.position.set(X * ProjectionScale, -Y * ProjectionScale, Z * ProjectionScale);\r",
                "}\r",
                "\r",
                ""
              ],
              "parameterObjects": "Object",
              "useStrict": true,
              "eventsSheetExpanded": true
            }
          ],
          "parameters": [
            {
              "description": "Object",
              "name": "Object",
              "supplementaryInformation": "Sprite",
              "type": "object"
            },
            {
              "description": "Behavior",
              "name": "Behavior",
              "supplementaryInformation": "WithThreeJS::BoardProjection",
              "type": "behavior"
            }
          ],
          "objectGroups": []
        },
        {
          "fullName": "",
          "functionType": "Action",
          "name": "onDestroy",
          "sentence": "",
          "events": [
            {
              "type": "BuiltinCommonInstructions::JsCode",
              "inlineCode": [
                "// 生成と同時に削除された場合、3D化されていないので回避\r",
                "// FirstFrame == true のほうが理想的だが取得がめんどくさいので Id を利用。\r",
                "const Behavior = objects[0].getBehavior(\"BoardProjection\");\r",
                "const Id = Behavior.Id();\r",
                "if (Id === \"\") {\r",
                "    return;\r",
                "}\r",
                "//\r",
                "if (!gdjs.__WithThreeJS.has(\"Renderer\")) {\r",
                "    console.warn(\"!\");\r",
                "    return;\r",
                "}\r",
                "const Scene = gdjs.__WithThreeJS.get(\"Scene\");\r",
                "const Sprite = gdjs.__WithThreeJS.get(\"SearchObject\")(Id);\r",
                "//\r",
                "gdjs.__WithThreeJS.get(\"DisposeChildren\")(Sprite);\r",
                "Sprite.removeFromParent();"
              ],
              "parameterObjects": "Object",
              "useStrict": true,
              "eventsSheetExpanded": true
            }
          ],
          "parameters": [
            {
              "description": "Object",
              "name": "Object",
              "supplementaryInformation": "Sprite",
              "type": "object"
            },
            {
              "description": "Behavior",
              "name": "Behavior",
              "supplementaryInformation": "WithThreeJS::BoardProjection",
              "type": "behavior"
            }
          ],
          "objectGroups": []
        },
        {
          "fullName": "3D Object ID",
          "functionType": "StringExpression",
          "name": "Id",
          "sentence": "",
          "events": [
            {
              "type": "BuiltinCommonInstructions::Standard",
              "conditions": [],
              "actions": [
                {
                  "type": {
                    "value": "SetReturnString"
                  },
                  "parameters": [
                    "Object.Behavior::PropertyId()"
                  ]
                }
              ]
            }
          ],
          "expressionType": {
            "type": "string"
          },
          "parameters": [
            {
              "description": "Object",
              "name": "Object",
              "supplementaryInformation": "Sprite",
              "type": "object"
            },
            {
              "description": "Behavior",
              "name": "Behavior",
              "supplementaryInformation": "WithThreeJS::BoardProjection",
              "type": "behavior"
            }
          ],
          "objectGroups": []
        },
        {
          "fullName": "Alpha Channel Test",
          "functionType": "Expression",
          "name": "AlphaTest",
          "sentence": "",
          "events": [
            {
              "type": "BuiltinCommonInstructions::Standard",
              "conditions": [],
              "actions": [
                {
                  "type": {
                    "value": "SetReturnNumber"
                  },
                  "parameters": [
                    "Object.Behavior::PropertyAlphaTest()"
                  ]
                }
              ]
            }
          ],
          "expressionType": {
            "type": "expression"
          },
          "parameters": [
            {
              "description": "Object",
              "name": "Object",
              "supplementaryInformation": "Sprite",
              "type": "object"
            },
            {
              "description": "Behavior",
              "name": "Behavior",
              "supplementaryInformation": "WithThreeJS::BoardProjection",
              "type": "behavior"
            }
          ],
          "objectGroups": []
        },
        {
          "fullName": "Axis linked to 2D Object Angle",
          "functionType": "StringExpression",
          "name": "AngleAxis",
          "sentence": "",
          "events": [
            {
              "type": "BuiltinCommonInstructions::Standard",
              "conditions": [],
              "actions": [
                {
                  "type": {
                    "value": "SetReturnString"
                  },
                  "parameters": [
                    "Object.Behavior::PropertyAngleAxis()"
                  ]
                }
              ]
            }
          ],
          "expressionType": {
            "type": "string"
          },
          "parameters": [
            {
              "description": "Object",
              "name": "Object",
              "supplementaryInformation": "Sprite",
              "type": "object"
            },
            {
              "description": "Behavior",
              "name": "Behavior",
              "supplementaryInformation": "WithThreeJS::BoardProjection",
              "type": "behavior"
            }
          ],
          "objectGroups": []
        },
        {
          "fullName": "Orientation",
          "functionType": "StringExpression",
          "name": "Orientation",
          "sentence": "",
          "events": [
            {
              "type": "BuiltinCommonInstructions::Standard",
              "conditions": [],
              "actions": [
                {
                  "type": {
                    "value": "SetReturnString"
                  },
                  "parameters": [
                    "Object.Behavior::PropertyOrientation()"
                  ]
                }
              ]
            }
          ],
          "expressionType": {
            "type": "string"
          },
          "parameters": [
            {
              "description": "Object",
              "name": "Object",
              "supplementaryInformation": "Sprite",
              "type": "object"
            },
            {
              "description": "Behavior",
              "name": "Behavior",
              "supplementaryInformation": "WithThreeJS::BoardProjection",
              "type": "behavior"
            }
          ],
          "objectGroups": []
        },
        {
          "fullName": "Is Anti-Aliasing",
          "functionType": "Condition",
          "name": "AntiAliasing",
          "private": true,
          "sentence": "Is Anti-Aliasing _PARAM0_",
          "events": [
            {
              "type": "BuiltinCommonInstructions::Standard",
              "conditions": [
                {
                  "type": {
                    "value": "WithThreeJS::BoardProjection::PropertyAntiAliasing"
                  },
                  "parameters": [
                    "Object",
                    "Behavior"
                  ]
                }
              ],
              "actions": [
                {
                  "type": {
                    "value": "SetReturnBoolean"
                  },
                  "parameters": [
                    "True"
                  ]
                }
              ]
            },
            {
              "type": "BuiltinCommonInstructions::Standard",
              "conditions": [
                {
                  "type": {
                    "inverted": true,
                    "value": "WithThreeJS::BoardProjection::PropertyAntiAliasing"
                  },
                  "parameters": [
                    "Object",
                    "Behavior"
                  ]
                }
              ],
              "actions": [
                {
                  "type": {
                    "value": "SetReturnBoolean"
                  },
                  "parameters": [
                    "False"
                  ]
                }
              ]
            }
          ],
          "parameters": [
            {
              "description": "Object",
              "name": "Object",
              "supplementaryInformation": "Sprite",
              "type": "object"
            },
            {
              "description": "Behavior",
              "name": "Behavior",
              "supplementaryInformation": "WithThreeJS::BoardProjection",
              "type": "behavior"
            }
          ],
          "objectGroups": []
        },
        {
          "fullName": "Current 3D Texture ID",
          "functionType": "StringExpression",
          "name": "CurrentTextureId",
          "private": true,
          "sentence": "",
          "events": [
            {
              "type": "BuiltinCommonInstructions::Standard",
              "conditions": [],
              "actions": [
                {
                  "type": {
                    "value": "SetReturnString"
                  },
                  "parameters": [
                    "Object.Behavior::PropertyCurrentTextureId()"
                  ]
                }
              ]
            }
          ],
          "expressionType": {
            "type": "string"
          },
          "parameters": [
            {
              "description": "Object",
              "name": "Object",
              "supplementaryInformation": "Sprite",
              "type": "object"
            },
            {
              "description": "Behavior",
              "name": "Behavior",
              "supplementaryInformation": "WithThreeJS::BoardProjection",
              "type": "behavior"
            }
          ],
          "objectGroups": []
        },
        {
          "fullName": "Depth for Bounding Box Collision",
          "functionType": "Expression",
          "name": "Depth",
          "private": true,
          "sentence": "",
          "events": [
            {
              "type": "BuiltinCommonInstructions::Standard",
              "conditions": [],
              "actions": [
                {
                  "type": {
                    "value": "SetReturnNumber"
                  },
                  "parameters": [
                    "Object.Behavior::PropertyDepth()"
                  ]
                }
              ]
            }
          ],
          "expressionType": {
            "type": "expression"
          },
          "parameters": [
            {
              "description": "Object",
              "name": "Object",
              "supplementaryInformation": "Sprite",
              "type": "object"
            },
            {
              "description": "Behavior",
              "name": "Behavior",
              "supplementaryInformation": "WithThreeJS::BoardProjection",
              "type": "behavior"
            }
          ],
          "objectGroups": []
        },
        {
          "fullName": "Is Cast Shadow",
          "functionType": "Condition",
          "name": "CastShadow",
          "private": true,
          "sentence": "Is Cast Shadow _PARAM0_",
          "events": [
            {
              "type": "BuiltinCommonInstructions::Standard",
              "conditions": [
                {
                  "type": {
                    "value": "WithThreeJS::BoardProjection::PropertyCastShadow"
                  },
                  "parameters": [
                    "Object",
                    "Behavior"
                  ]
                }
              ],
              "actions": [
                {
                  "type": {
                    "value": "SetReturnBoolean"
                  },
                  "parameters": [
                    "True"
                  ]
                }
              ]
            },
            {
              "type": "BuiltinCommonInstructions::Standard",
              "conditions": [
                {
                  "type": {
                    "inverted": true,
                    "value": "WithThreeJS::BoardProjection::PropertyCastShadow"
                  },
                  "parameters": [
                    "Object",
                    "Behavior"
                  ]
                }
              ],
              "actions": [
                {
                  "type": {
                    "value": "SetReturnBoolean"
                  },
                  "parameters": [
                    "False"
                  ]
                }
              ]
            }
          ],
          "parameters": [
            {
              "description": "Object",
              "name": "Object",
              "supplementaryInformation": "Sprite",
              "type": "object"
            },
            {
              "description": "Behavior",
              "name": "Behavior",
              "supplementaryInformation": "WithThreeJS::BoardProjection",
              "type": "behavior"
            }
          ],
          "objectGroups": []
        },
        {
          "fullName": "Is Receive Shadow",
          "functionType": "Condition",
          "name": "ReceiveShadow",
          "private": true,
          "sentence": "Is Receive Shadow _PARAM0_",
          "events": [
            {
              "type": "BuiltinCommonInstructions::Standard",
              "conditions": [
                {
                  "type": {
                    "value": "WithThreeJS::BoardProjection::PropertyReceiveShadow"
                  },
                  "parameters": [
                    "Object",
                    "Behavior"
                  ]
                }
              ],
              "actions": [
                {
                  "type": {
                    "value": "SetReturnBoolean"
                  },
                  "parameters": [
                    "True"
                  ]
                }
              ]
            },
            {
              "type": "BuiltinCommonInstructions::Standard",
              "conditions": [
                {
                  "type": {
                    "inverted": true,
                    "value": "WithThreeJS::BoardProjection::PropertyReceiveShadow"
                  },
                  "parameters": [
                    "Object",
                    "Behavior"
                  ]
                }
              ],
              "actions": [
                {
                  "type": {
                    "value": "SetReturnBoolean"
                  },
                  "parameters": [
                    "False"
                  ]
                }
              ]
            }
          ],
          "parameters": [
            {
              "description": "Object",
              "name": "Object",
              "supplementaryInformation": "Sprite",
              "type": "object"
            },
            {
              "description": "Behavior",
              "name": "Behavior",
              "supplementaryInformation": "WithThreeJS::BoardProjection",
              "type": "behavior"
            }
          ],
          "objectGroups": []
        },
        {
          "fullName": "Set 3D Object ID",
          "functionType": "Action",
          "name": "SetId",
          "private": true,
          "sentence": "Set 3D Object ID (_PARAM0_, ID: _PARAM2_)",
          "events": [
            {
              "type": "BuiltinCommonInstructions::Standard",
              "conditions": [],
              "actions": [
                {
                  "type": {
                    "value": "WithThreeJS::BoardProjection::SetPropertyId"
                  },
                  "parameters": [
                    "Object",
                    "Behavior",
                    "=",
                    "GetArgumentAsString(\"Id\")"
                  ]
                }
              ]
            }
          ],
          "parameters": [
            {
              "description": "Object",
              "name": "Object",
              "supplementaryInformation": "Sprite",
              "type": "object"
            },
            {
              "description": "Behavior",
              "name": "Behavior",
              "supplementaryInformation": "WithThreeJS::BoardProjection",
              "type": "behavior"
            },
            {
              "description": "3D Object ID",
              "name": "Id",
              "type": "string"
            }
          ],
          "objectGroups": []
        },
        {
          "fullName": "Set Current 3D Texture ID",
          "functionType": "Action",
          "name": "SetCurrentTextureId",
          "private": true,
          "sentence": "Set Current 3D Texture ID (_PARAM0_, ID: _PARAM2_)",
          "events": [
            {
              "type": "BuiltinCommonInstructions::Standard",
              "conditions": [],
              "actions": [
                {
                  "type": {
                    "value": "WithThreeJS::BoardProjection::SetPropertyCurrentTextureId"
                  },
                  "parameters": [
                    "Object",
                    "Behavior",
                    "=",
                    "GetArgumentAsString(\"Id\")"
                  ]
                }
              ]
            }
          ],
          "parameters": [
            {
              "description": "Object",
              "name": "Object",
              "supplementaryInformation": "Sprite",
              "type": "object"
            },
            {
              "description": "Behavior",
              "name": "Behavior",
              "supplementaryInformation": "WithThreeJS::BoardProjection",
              "type": "behavior"
            },
            {
              "description": "3D Texture ID",
              "name": "Id",
              "type": "string"
            }
          ],
          "objectGroups": []
        }
      ],
      "propertyDescriptors": [
        {
          "value": "",
          "type": "String",
          "label": "",
          "description": "",
          "group": "",
          "extraInformation": [],
          "hidden": true,
          "name": "Id"
        },
        {
          "value": "true",
          "type": "Boolean",
          "label": "",
          "description": "",
          "group": "",
          "extraInformation": [],
          "hidden": true,
          "name": "FirstFrame"
        },
        {
          "value": "",
          "type": "String",
          "label": "",
          "description": "",
          "group": "",
          "extraInformation": [],
          "hidden": true,
          "name": "CurrentTextureId"
        },
        {
          "value": "true",
          "type": "Boolean",
          "label": "Hide 2D Object",
          "description": "",
          "group": "",
          "extraInformation": [],
          "name": "Hide"
        },
        {
          "value": "0",
          "type": "Number",
          "label": "Alpha Channel Test",
          "description": "Recommended values: 0 or 0.5. Default: 0.",
          "group": "Texture",
          "extraInformation": [],
          "name": "AlphaTest"
        },
        {
          "value": "true",
          "type": "Boolean",
          "label": "Anti-Aliasing",
          "description": "",
          "group": "Texture",
          "extraInformation": [
            "Antialiased",
            "No Antialiasing"
          ],
          "name": "AntiAliasing"
        },
        {
          "value": "Z Axis",
          "type": "Choice",
          "label": "Axis linked to 2D Object Angle",
          "description": "Rotating a 2D object will rotate the 3D object around this axis.",
          "group": "Angle",
          "extraInformation": [
            "X Axis",
            "Y Axis",
            "Z Axis"
          ],
          "name": "AngleAxis"
        },
        {
          "value": "Vertical",
          "type": "Choice",
          "label": "Orientation",
          "description": "For Horizontal, this 3D Object is rotated -90 degrees around the X axis.",
          "group": "Angle",
          "extraInformation": [
            "Vertical",
            "Horizontal"
          ],
          "name": "Orientation"
        },
        {
          "value": "0",
          "type": "Number",
          "label": "Depth for Bounding Box Collision",
          "description": "Unit: Pixel",
          "group": "Collision",
          "extraInformation": [],
          "name": "Depth"
        },
        {
          "value": "",
          "type": "Boolean",
          "label": "Cast Shadow",
          "description": "If both \"Cast Shadow\" and \"Receive Shadow\" are enabled, striped patterns are likely to occur in the shadow.",
          "group": "Shadow",
          "extraInformation": [],
          "name": "CastShadow"
        },
        {
          "value": "",
          "type": "Boolean",
          "label": "Receive Shadow",
          "description": "If both \"Cast Shadow\" and \"Receive Shadow\" are enabled, striped patterns are likely to occur in the shadow.",
          "group": "Shadow",
          "extraInformation": [],
          "name": "ReceiveShadow"
        }
      ],
      "sharedPropertyDescriptors": []
    },
    {
      "description": "Create 3D Plane from Tiled Sprite object. Moving that Tiled Sprite will also move the 3D Object.",
      "fullName": "3D Plane Projection from Tiled Sprite",
      "name": "PlaneProjectionFromTiled",
      "objectType": "TiledSpriteObject::TiledSprite",
      "eventsFunctions": [
        {
          "fullName": "",
          "functionType": "Action",
          "name": "doStepPostEvents",
          "sentence": "",
          "events": [
            {
              "type": "BuiltinCommonInstructions::Standard",
              "conditions": [
                {
                  "type": {
                    "value": "WithThreeJS::PlaneProjectionFromTiled::PropertyFirstFrame"
                  },
                  "parameters": [
                    "Object",
                    "Behavior"
                  ]
                }
              ],
              "actions": [
                {
                  "type": {
                    "value": "WithThreeJS::PlaneProjectionFromTiled::SetPropertyFirstFrame"
                  },
                  "parameters": [
                    "Object",
                    "Behavior",
                    "no"
                  ]
                }
              ],
              "events": [
                {
                  "type": "BuiltinCommonInstructions::JsCode",
                  "inlineCode": [
                    "if (!gdjs.__WithThreeJS.has(\"Renderer\")) {",
                    "    console.warn(\"!\");",
                    "    return;",
                    "}",
                    "if (!gdjs.__WithThreeJS.has(\"Textures\")) {",
                    "    gdjs.__WithThreeJS.set(\"Textures\", new Map());",
                    "}",
                    "const Scene = gdjs.__WithThreeJS.get(\"Scene\");",
                    "let Textures = gdjs.__WithThreeJS.get(\"Textures\");",
                    "//",
                    "const Behavior = objects[0].getBehavior(\"PlaneProjectionFromTiled\");",
                    "const Id = objects[0].name + objects[0].id;",
                    "// const X = objects[0].getCenterXInScene();",
                    "// const Y = objects[0].getCenterYInScene();",
                    "// const Z = objects[0].zOrder;",
                    "const Width = objects[0].getWidth();",
                    "const Height = objects[0].getHeight();",
                    "const ProjectionScale = gdjs.__WithThreeJS.get(\"ProjectionScale\");",
                    "const ViewMode = gdjs.__WithThreeJS.get(\"ViewMode\");",
                    "const AlphaTest = Behavior.AlphaTest();",
                    "const Transparent = AlphaTest !== 0;",
                    "const AntiAliasing = Behavior.AntiAliasing();",
                    "const Depth = Behavior.Depth();",
                    "let Blend = THREE.NormalBlending;",
                    "if (Behavior.Blend() == \"Additive\") {",
                    "    Blend = THREE.AdditiveBlending;",
                    "} else if (Behavior.Blend() == \"Subtractive\") {",
                    "    Blend = THREE.SubtractiveBlending;",
                    "} else if (Behavior.Blend() == \"Multiply\") {",
                    "    Blend = THREE.MultiplyBlending;",
                    "}",
                    "const CastShadow = Behavior.CastShadow();",
                    "const ReceiveShadow = Behavior.ReceiveShadow();",
                    "// const Opacity = 1.0;",
                    "//",
                    "//タイルの画像を取得",
                    "const Resource = objects[0].getRendererObject().texture.baseTexture.resource;",
                    "const TextureWidth = Resource.width;",
                    "const TextureHeight = Resource.height;",
                    "//",
                    "// インスタンスごとのマテリアルとテクスチャ生成",
                    "// Plane は FrontRear のみ",
                    "//リピート数",
                    "const RepeatU = Width / TextureWidth;",
                    "const RepeatV = Height / TextureHeight;",
                    "const TextureId = \"_\" + Id + \"_\" + Resource.url;",
                    "Behavior.SetTextureId(TextureId);",
                    "Behavior.SetOffsetV(1 - (RepeatV % 1));",
                    "//",
                    "const Texture = new THREE.Texture();",
                    "Texture.image = Resource.source;",
                    "Texture.wrapS = THREE.RepeatWrapping;",
                    "Texture.wrapT = THREE.RepeatWrapping;",
                    "if (!AntiAliasing) {",
                    "    Texture.magFilter = THREE.NearestFilter;// THREE.LinearFilter",
                    "    Texture.minFilter = THREE.NearestFilter;// THREE.LinearMipmapLinearFilter",
                    "}",
                    "Texture.repeat.set(RepeatU, RepeatV);",
                    "Texture.colorSpace = THREE.SRGBColorSpace;",
                    "Texture.needsUpdate = true;//必須",
                    "Textures.set(TextureId, Texture);",
                    "//",
                    "// const Material = new THREE.MeshBasicMaterial({map: Texture, side: THREE.DoubleSide, transparent:Transparent, alphaTest:AlphaTest, blending:Blend});",
                    "const Material = new THREE.MeshLambertMaterial({map: Texture, side: THREE.DoubleSide, transparent:Transparent, alphaTest:AlphaTest, blending:Blend});",
                    "const Geometry = new THREE.PlaneGeometry(Width * ProjectionScale, Height * ProjectionScale, 1, 1);",
                    "Geometry.computeBoundingBox();",
                    "Geometry.boundingBox.expandByVector(new THREE.Vector3(0, 0, (Depth * ProjectionScale) / 2));",
                    "const Obj = new THREE.Mesh(Geometry, Material);",
                    "Obj.name = Id;",
                    "Obj.castShadow = CastShadow;",
                    "Obj.receiveShadow = ReceiveShadow;",
                    "Obj.userData.Use3DProjectionBehavior = true;",
                    "Behavior.SetId(Id);",
                    "Scene.add(Obj);",
                    "",
                    ""
                  ],
                  "parameterObjects": "Object",
                  "useStrict": true,
                  "eventsSheetExpanded": true
                },
                {
                  "type": "BuiltinCommonInstructions::Standard",
                  "conditions": [
                    {
                      "type": {
                        "value": "WithThreeJS::PlaneProjectionFromTiled::PropertyHide"
                      },
                      "parameters": [
                        "Object",
                        "Behavior"
                      ]
                    }
                  ],
                  "actions": [
                    {
                      "type": {
                        "value": "Cache"
                      },
                      "parameters": [
                        "Object"
                      ]
                    }
                  ]
                }
              ]
            },
            {
              "type": "BuiltinCommonInstructions::JsCode",
              "inlineCode": [
                "if (!gdjs.__WithThreeJS.has(\"Renderer\")) {\r",
                "    console.warn(\"!\");\r",
                "    return;\r",
                "}\r",
                "if (!gdjs.__WithThreeJS.has(\"Textures\")) {\r",
                "    console.warn(\"!\");\r",
                "    return;\r",
                "}\r",
                "const Scene = gdjs.__WithThreeJS.get(\"Scene\");\r",
                "let Textures = gdjs.__WithThreeJS.get(\"Textures\");\r",
                "//\r",
                "const Behavior = objects[0].getBehavior(\"PlaneProjectionFromTiled\");\r",
                "const Id = Behavior.Id();\r",
                "const X = objects[0].getCenterXInScene();\r",
                "const Y = objects[0].getCenterYInScene();\r",
                "const Z = objects[0].zOrder;\r",
                "const ProjectionScale = gdjs.__WithThreeJS.get(\"ProjectionScale\");\r",
                "const ViewMode = gdjs.__WithThreeJS.get(\"ViewMode\");\r",
                "const Rotate90 = Behavior.Rotate90();\r",
                "//\r",
                "const Obj = gdjs.__WithThreeJS.get(\"SearchObject\")(Id);\r",
                "if (!Obj) {\r",
                "    console.warn(\"3D Object not found: \" + Id);\r",
                "    return;\r",
                "}\r",
                "// Move & Rotate\r",
                "const Angle = objects[0].angle;\r",
                "if (ViewMode == \"Top Down\") {\r",
                "    Obj.position.set(X * ProjectionScale, Z * ProjectionScale, Y * ProjectionScale);\r",
                "    if (Rotate90) {\r",
                "        Obj.rotation.set(gdjs.toRad(0), gdjs.toRad(Angle * -1), gdjs.toRad(0));\r",
                "    } else {\r",
                "        Obj.rotation.set(gdjs.toRad(-90), gdjs.toRad(0), gdjs.toRad(Angle * -1));\r",
                "    }\r",
                "} else {\r",
                "    // Side\r",
                "    Obj.position.set(X * ProjectionScale, -Y * ProjectionScale, Z * ProjectionScale);\r",
                "    if (Rotate90) {\r",
                "        Obj.rotation.set(gdjs.toRad(-90), gdjs.toRad(Angle), gdjs.toRad(0));\r",
                "    } else {\r",
                "        Obj.rotation.set(gdjs.toRad(0), gdjs.toRad(0), gdjs.toRad(Angle * -1));\r",
                "    }\r",
                "}\r",
                "// Opacity\r",
                "const Opacity = objects[0].getOpacity() / 255;\r",
                "if (!Obj.material.transparent) {\r",
                "    if (Obj.material.alphaTest !== 0 || Opacity !== 1) {\r",
                "        Obj.material.transparent = true;\r",
                "        Obj.material.needsUpdate = true;\r",
                "    }\r",
                "}\r",
                "Obj.material.opacity = Opacity;\r",
                "// Offset\r",
                "const Texture = Textures.get(Behavior.TextureId());\r",
                "const TextureWidth = Texture.image.width;\r",
                "const TextureHeight = Texture.image.height;\r",
                "Texture.offset.set(objects[0].getXOffset() / TextureWidth, -(objects[0].getYOffset() / TextureHeight) + Behavior.OffsetV());\r",
                "\r",
                ""
              ],
              "parameterObjects": "Object",
              "useStrict": true,
              "eventsSheetExpanded": true
            }
          ],
          "parameters": [
            {
              "description": "Object",
              "name": "Object",
              "supplementaryInformation": "TiledSpriteObject::TiledSprite",
              "type": "object"
            },
            {
              "description": "Behavior",
              "name": "Behavior",
              "supplementaryInformation": "WithThreeJS::PlaneProjectionFromTiled",
              "type": "behavior"
            }
          ],
          "objectGroups": []
        },
        {
          "fullName": "",
          "functionType": "Action",
          "name": "onDestroy",
          "sentence": "",
          "events": [
            {
              "type": "BuiltinCommonInstructions::JsCode",
              "inlineCode": [
                "// 生成と同時に削除された場合、3D化されていないので回避\r",
                "// FirstFrame == true のほうが理想的だが取得がめんどくさいので Id を利用。\r",
                "const Behavior = objects[0].getBehavior(\"PlaneProjectionFromTiled\");\r",
                "const Id = Behavior.Id();\r",
                "if (Id === \"\") {\r",
                "    return;\r",
                "}\r",
                "//\r",
                "if (!gdjs.__WithThreeJS.has(\"Renderer\")) {\r",
                "    console.warn(\"!\");\r",
                "    return;\r",
                "}\r",
                "if (!gdjs.__WithThreeJS.has(\"Textures\")) {\r",
                "    gdjs.__WithThreeJS.set(\"Textures\", new Map());\r",
                "}\r",
                "const Scene = gdjs.__WithThreeJS.get(\"Scene\");\r",
                "const Textures = gdjs.__WithThreeJS.get(\"Textures\");\r",
                "const Obj = gdjs.__WithThreeJS.get(\"SearchObject\")(Id);\r",
                "if (!Obj) {\r",
                "    console.warn(\"3D Object not found.\");\r",
                "    return;\r",
                "}\r",
                "//\r",
                "const TextureId = Behavior.TextureId();\r",
                "const Texture = Textures.get(TextureId);\r",
                "// インスタンスごとなので全て削除\r",
                "Texture.dispose();\r",
                "Textures.delete(TextureId);\r",
                "gdjs.__WithThreeJS.get(\"DisposeChildren\")(Obj);\r",
                "Obj.removeFromParent();\r",
                "\r",
                ""
              ],
              "parameterObjects": "Object",
              "useStrict": true,
              "eventsSheetExpanded": true
            }
          ],
          "parameters": [
            {
              "description": "Object",
              "name": "Object",
              "supplementaryInformation": "TiledSpriteObject::TiledSprite",
              "type": "object"
            },
            {
              "description": "Behavior",
              "name": "Behavior",
              "supplementaryInformation": "WithThreeJS::PlaneProjectionFromTiled",
              "type": "behavior"
            }
          ],
          "objectGroups": []
        },
        {
          "fullName": "3D Object ID",
          "functionType": "StringExpression",
          "name": "Id",
          "sentence": "",
          "events": [
            {
              "type": "BuiltinCommonInstructions::Standard",
              "conditions": [],
              "actions": [
                {
                  "type": {
                    "value": "SetReturnString"
                  },
                  "parameters": [
                    "Object.Behavior::PropertyId()"
                  ]
                }
              ]
            }
          ],
          "expressionType": {
            "type": "string"
          },
          "parameters": [
            {
              "description": "Object",
              "name": "Object",
              "supplementaryInformation": "TiledSpriteObject::TiledSprite",
              "type": "object"
            },
            {
              "description": "Behavior",
              "name": "Behavior",
              "supplementaryInformation": "WithThreeJS::PlaneProjectionFromTiled",
              "type": "behavior"
            }
          ],
          "objectGroups": []
        },
        {
          "fullName": "Alpha Channel Test",
          "functionType": "Expression",
          "name": "AlphaTest",
          "sentence": "",
          "events": [
            {
              "type": "BuiltinCommonInstructions::Standard",
              "conditions": [],
              "actions": [
                {
                  "type": {
                    "value": "SetReturnNumber"
                  },
                  "parameters": [
                    "Object.Behavior::PropertyAlphaTest()"
                  ]
                }
              ]
            }
          ],
          "expressionType": {
            "type": "expression"
          },
          "parameters": [
            {
              "description": "Object",
              "name": "Object",
              "supplementaryInformation": "TiledSpriteObject::TiledSprite",
              "type": "object"
            },
            {
              "description": "Behavior",
              "name": "Behavior",
              "supplementaryInformation": "WithThreeJS::PlaneProjectionFromTiled",
              "type": "behavior"
            }
          ],
          "objectGroups": []
        },
        {
          "fullName": "Blend Mode",
          "functionType": "StringExpression",
          "name": "Blend",
          "sentence": "",
          "events": [
            {
              "type": "BuiltinCommonInstructions::Standard",
              "conditions": [],
              "actions": [
                {
                  "type": {
                    "value": "SetReturnString"
                  },
                  "parameters": [
                    "Object.Behavior::PropertyBlend()"
                  ]
                }
              ]
            }
          ],
          "expressionType": {
            "type": "string"
          },
          "parameters": [
            {
              "description": "Object",
              "name": "Object",
              "supplementaryInformation": "TiledSpriteObject::TiledSprite",
              "type": "object"
            },
            {
              "description": "Behavior",
              "name": "Behavior",
              "supplementaryInformation": "WithThreeJS::PlaneProjectionFromTiled",
              "type": "behavior"
            }
          ],
          "objectGroups": []
        },
        {
          "fullName": "Is Anti-Aliasing",
          "functionType": "Condition",
          "name": "AntiAliasing",
          "private": true,
          "sentence": "Is Anti-Aliasing _PARAM0_",
          "events": [
            {
              "type": "BuiltinCommonInstructions::Standard",
              "conditions": [
                {
                  "type": {
                    "value": "WithThreeJS::PlaneProjectionFromTiled::PropertyAntiAliasing"
                  },
                  "parameters": [
                    "Object",
                    "Behavior"
                  ]
                }
              ],
              "actions": [
                {
                  "type": {
                    "value": "SetReturnBoolean"
                  },
                  "parameters": [
                    "True"
                  ]
                }
              ]
            },
            {
              "type": "BuiltinCommonInstructions::Standard",
              "conditions": [
                {
                  "type": {
                    "inverted": true,
                    "value": "WithThreeJS::PlaneProjectionFromTiled::PropertyAntiAliasing"
                  },
                  "parameters": [
                    "Object",
                    "Behavior"
                  ]
                }
              ],
              "actions": [
                {
                  "type": {
                    "value": "SetReturnBoolean"
                  },
                  "parameters": [
                    "False"
                  ]
                }
              ]
            }
          ],
          "parameters": [
            {
              "description": "Object",
              "name": "Object",
              "supplementaryInformation": "TiledSpriteObject::TiledSprite",
              "type": "object"
            },
            {
              "description": "Behavior",
              "name": "Behavior",
              "supplementaryInformation": "WithThreeJS::PlaneProjectionFromTiled",
              "type": "behavior"
            }
          ],
          "objectGroups": []
        },
        {
          "fullName": "Is Rotate -90 Degrees",
          "functionType": "Condition",
          "name": "Rotate90",
          "private": true,
          "sentence": "Is Rotate -90 Degrees _PARAM0_",
          "events": [
            {
              "type": "BuiltinCommonInstructions::Standard",
              "conditions": [
                {
                  "type": {
                    "value": "WithThreeJS::PlaneProjectionFromTiled::PropertyRotate90"
                  },
                  "parameters": [
                    "Object",
                    "Behavior"
                  ]
                }
              ],
              "actions": [
                {
                  "type": {
                    "value": "SetReturnBoolean"
                  },
                  "parameters": [
                    "True"
                  ]
                }
              ]
            },
            {
              "type": "BuiltinCommonInstructions::Standard",
              "conditions": [
                {
                  "type": {
                    "inverted": true,
                    "value": "WithThreeJS::PlaneProjectionFromTiled::PropertyRotate90"
                  },
                  "parameters": [
                    "Object",
                    "Behavior"
                  ]
                }
              ],
              "actions": [
                {
                  "type": {
                    "value": "SetReturnBoolean"
                  },
                  "parameters": [
                    "False"
                  ]
                }
              ]
            }
          ],
          "parameters": [
            {
              "description": "Object",
              "name": "Object",
              "supplementaryInformation": "TiledSpriteObject::TiledSprite",
              "type": "object"
            },
            {
              "description": "Behavior",
              "name": "Behavior",
              "supplementaryInformation": "WithThreeJS::PlaneProjectionFromTiled",
              "type": "behavior"
            }
          ],
          "objectGroups": []
        },
        {
          "fullName": "Is Cast Shadow",
          "functionType": "Condition",
          "name": "CastShadow",
          "private": true,
          "sentence": "Is Cast Shadow _PARAM0_",
          "events": [
            {
              "type": "BuiltinCommonInstructions::Standard",
              "conditions": [
                {
                  "type": {
                    "value": "WithThreeJS::PlaneProjectionFromTiled::PropertyCastShadow"
                  },
                  "parameters": [
                    "Object",
                    "Behavior"
                  ]
                }
              ],
              "actions": [
                {
                  "type": {
                    "value": "SetReturnBoolean"
                  },
                  "parameters": [
                    "True"
                  ]
                }
              ]
            },
            {
              "type": "BuiltinCommonInstructions::Standard",
              "conditions": [
                {
                  "type": {
                    "inverted": true,
                    "value": "WithThreeJS::PlaneProjectionFromTiled::PropertyCastShadow"
                  },
                  "parameters": [
                    "Object",
                    "Behavior"
                  ]
                }
              ],
              "actions": [
                {
                  "type": {
                    "value": "SetReturnBoolean"
                  },
                  "parameters": [
                    "False"
                  ]
                }
              ]
            }
          ],
          "parameters": [
            {
              "description": "Object",
              "name": "Object",
              "supplementaryInformation": "TiledSpriteObject::TiledSprite",
              "type": "object"
            },
            {
              "description": "Behavior",
              "name": "Behavior",
              "supplementaryInformation": "WithThreeJS::PlaneProjectionFromTiled",
              "type": "behavior"
            }
          ],
          "objectGroups": []
        },
        {
          "fullName": "Is Receive Shadow",
          "functionType": "Condition",
          "name": "ReceiveShadow",
          "private": true,
          "sentence": "Is Receive Shadow _PARAM0_",
          "events": [
            {
              "type": "BuiltinCommonInstructions::Standard",
              "conditions": [
                {
                  "type": {
                    "value": "WithThreeJS::PlaneProjectionFromTiled::PropertyReceiveShadow"
                  },
                  "parameters": [
                    "Object",
                    "Behavior"
                  ]
                }
              ],
              "actions": [
                {
                  "type": {
                    "value": "SetReturnBoolean"
                  },
                  "parameters": [
                    "True"
                  ]
                }
              ]
            },
            {
              "type": "BuiltinCommonInstructions::Standard",
              "conditions": [
                {
                  "type": {
                    "inverted": true,
                    "value": "WithThreeJS::PlaneProjectionFromTiled::PropertyReceiveShadow"
                  },
                  "parameters": [
                    "Object",
                    "Behavior"
                  ]
                }
              ],
              "actions": [
                {
                  "type": {
                    "value": "SetReturnBoolean"
                  },
                  "parameters": [
                    "False"
                  ]
                }
              ]
            }
          ],
          "parameters": [
            {
              "description": "Object",
              "name": "Object",
              "supplementaryInformation": "TiledSpriteObject::TiledSprite",
              "type": "object"
            },
            {
              "description": "Behavior",
              "name": "Behavior",
              "supplementaryInformation": "WithThreeJS::PlaneProjectionFromTiled",
              "type": "behavior"
            }
          ],
          "objectGroups": []
        },
        {
          "fullName": "3D Texture ID",
          "functionType": "StringExpression",
          "name": "TextureId",
          "private": true,
          "sentence": "",
          "events": [
            {
              "type": "BuiltinCommonInstructions::Standard",
              "conditions": [],
              "actions": [
                {
                  "type": {
                    "value": "SetReturnString"
                  },
                  "parameters": [
                    "Object.Behavior::PropertyTextureId()"
                  ]
                }
              ]
            }
          ],
          "expressionType": {
            "type": "string"
          },
          "parameters": [
            {
              "description": "Object",
              "name": "Object",
              "supplementaryInformation": "TiledSpriteObject::TiledSprite",
              "type": "object"
            },
            {
              "description": "Behavior",
              "name": "Behavior",
              "supplementaryInformation": "WithThreeJS::PlaneProjectionFromTiled",
              "type": "behavior"
            }
          ],
          "objectGroups": []
        },
        {
          "fullName": "Offset V",
          "functionType": "Expression",
          "name": "OffsetV",
          "private": true,
          "sentence": "",
          "events": [
            {
              "type": "BuiltinCommonInstructions::Standard",
              "conditions": [],
              "actions": [
                {
                  "type": {
                    "value": "SetReturnNumber"
                  },
                  "parameters": [
                    "Object.Behavior::PropertyOffsetV()"
                  ]
                }
              ]
            }
          ],
          "expressionType": {
            "type": "expression"
          },
          "parameters": [
            {
              "description": "Object",
              "name": "Object",
              "supplementaryInformation": "TiledSpriteObject::TiledSprite",
              "type": "object"
            },
            {
              "description": "Behavior",
              "name": "Behavior",
              "supplementaryInformation": "WithThreeJS::PlaneProjectionFromTiled",
              "type": "behavior"
            }
          ],
          "objectGroups": []
        },
        {
          "fullName": "Depth for Bounding Box Collision",
          "functionType": "Expression",
          "name": "Depth",
          "private": true,
          "sentence": "",
          "events": [
            {
              "type": "BuiltinCommonInstructions::Standard",
              "conditions": [],
              "actions": [
                {
                  "type": {
                    "value": "SetReturnNumber"
                  },
                  "parameters": [
                    "Object.Behavior::PropertyDepth()"
                  ]
                }
              ]
            }
          ],
          "expressionType": {
            "type": "expression"
          },
          "parameters": [
            {
              "description": "Object",
              "name": "Object",
              "supplementaryInformation": "TiledSpriteObject::TiledSprite",
              "type": "object"
            },
            {
              "description": "Behavior",
              "name": "Behavior",
              "supplementaryInformation": "WithThreeJS::PlaneProjectionFromTiled",
              "type": "behavior"
            }
          ],
          "objectGroups": []
        },
        {
          "fullName": "Set 3D Object ID",
          "functionType": "Action",
          "name": "SetId",
          "private": true,
          "sentence": "Set 3D Object ID (_PARAM0_, ID: _PARAM2_)",
          "events": [
            {
              "type": "BuiltinCommonInstructions::Standard",
              "conditions": [],
              "actions": [
                {
                  "type": {
                    "value": "WithThreeJS::PlaneProjectionFromTiled::SetPropertyId"
                  },
                  "parameters": [
                    "Object",
                    "Behavior",
                    "=",
                    "GetArgumentAsString(\"Id\")"
                  ]
                }
              ]
            }
          ],
          "parameters": [
            {
              "description": "Object",
              "name": "Object",
              "supplementaryInformation": "TiledSpriteObject::TiledSprite",
              "type": "object"
            },
            {
              "description": "Behavior",
              "name": "Behavior",
              "supplementaryInformation": "WithThreeJS::PlaneProjectionFromTiled",
              "type": "behavior"
            },
            {
              "description": "3D Object ID",
              "name": "Id",
              "type": "string"
            }
          ],
          "objectGroups": []
        },
        {
          "fullName": "Set 3D Texture ID",
          "functionType": "Action",
          "name": "SetTextureId",
          "private": true,
          "sentence": "Set 3D Texture ID (_PARAM0_, ID: _PARAM2_)",
          "events": [
            {
              "type": "BuiltinCommonInstructions::Standard",
              "conditions": [],
              "actions": [
                {
                  "type": {
                    "value": "WithThreeJS::PlaneProjectionFromTiled::SetPropertyTextureId"
                  },
                  "parameters": [
                    "Object",
                    "Behavior",
                    "=",
                    "GetArgumentAsString(\"Id\")"
                  ]
                }
              ]
            }
          ],
          "parameters": [
            {
              "description": "Object",
              "name": "Object",
              "supplementaryInformation": "TiledSpriteObject::TiledSprite",
              "type": "object"
            },
            {
              "description": "Behavior",
              "name": "Behavior",
              "supplementaryInformation": "WithThreeJS::PlaneProjectionFromTiled",
              "type": "behavior"
            },
            {
              "description": "3D Texture ID",
              "name": "Id",
              "type": "string"
            }
          ],
          "objectGroups": []
        },
        {
          "fullName": "Set Offset V",
          "functionType": "Action",
          "name": "SetOffsetV",
          "private": true,
          "sentence": "Set Offset V (_PARAM0_, Value: _PARAM2_)",
          "events": [
            {
              "type": "BuiltinCommonInstructions::Standard",
              "conditions": [],
              "actions": [
                {
                  "type": {
                    "value": "WithThreeJS::PlaneProjectionFromTiled::SetPropertyOffsetV"
                  },
                  "parameters": [
                    "Object",
                    "Behavior",
                    "=",
                    "GetArgumentAsNumber(\"Value\")"
                  ]
                }
              ]
            }
          ],
          "parameters": [
            {
              "description": "Object",
              "name": "Object",
              "supplementaryInformation": "TiledSpriteObject::TiledSprite",
              "type": "object"
            },
            {
              "description": "Behavior",
              "name": "Behavior",
              "supplementaryInformation": "WithThreeJS::PlaneProjectionFromTiled",
              "type": "behavior"
            },
            {
              "description": "Offset Value",
              "name": "Value",
              "type": "expression"
            }
          ],
          "objectGroups": []
        }
      ],
      "propertyDescriptors": [
        {
          "value": "",
          "type": "String",
          "label": "",
          "description": "",
          "group": "",
          "extraInformation": [],
          "hidden": true,
          "name": "Id"
        },
        {
          "value": "true",
          "type": "Boolean",
          "label": "",
          "description": "",
          "group": "",
          "extraInformation": [],
          "hidden": true,
          "name": "FirstFrame"
        },
        {
          "value": "true",
          "type": "Boolean",
          "label": "Hide 2D Object",
          "description": "",
          "group": "",
          "extraInformation": [],
          "name": "Hide"
        },
        {
          "value": "0",
          "type": "Number",
          "label": "Alpha Channel Test",
          "description": "Recommended values: 0 or 0.5. Default: 0.",
          "group": "Texture",
          "extraInformation": [],
          "name": "AlphaTest"
        },
        {
          "value": "true",
          "type": "Boolean",
          "label": "Anti-Aliasing",
          "description": "",
          "group": "Texture",
          "extraInformation": [
            "Antialiased",
            "No Antialiasing"
          ],
          "name": "AntiAliasing"
        },
        {
          "value": "Normal",
          "type": "Choice",
          "label": "Blend Mode",
          "description": "",
          "group": "Texture",
          "extraInformation": [
            "Normal",
            "Additive",
            "Subtractive",
            "Multiply"
          ],
          "name": "Blend"
        },
        {
          "value": "",
          "type": "Boolean",
          "label": "Rotate -90 Degrees Around X Axis",
          "description": "If checked, this 3D Object is rotated -90 degrees around the X axis. Note that this makes it less compatible with 2D collisions.",
          "group": "Angle",
          "extraInformation": [],
          "name": "Rotate90"
        },
        {
          "value": "0",
          "type": "Number",
          "label": "Depth for Bounding Box Collision",
          "description": "Unit: Pixel",
          "group": "Collision",
          "extraInformation": [],
          "name": "Depth"
        },
        {
          "value": "",
          "type": "Boolean",
          "label": "Cast Shadow",
          "description": "If both \"Cast Shadow\" and \"Receive Shadow\" are enabled, striped patterns are likely to occur in the shadow.",
          "group": "Shadow",
          "extraInformation": [],
          "name": "CastShadow"
        },
        {
          "value": "",
          "type": "Boolean",
          "label": "Receive Shadow",
          "description": "If both \"Cast Shadow\" and \"Receive Shadow\" are enabled, striped patterns are likely to occur in the shadow.",
          "group": "Shadow",
          "extraInformation": [],
          "name": "ReceiveShadow"
        },
        {
          "value": "",
          "type": "String",
          "label": "",
          "description": "",
          "group": "",
          "extraInformation": [],
          "hidden": true,
          "name": "TextureId"
        },
        {
          "value": "",
          "type": "Number",
          "label": "",
          "description": "",
          "group": "",
          "extraInformation": [],
          "hidden": true,
          "name": "OffsetV"
        }
      ],
      "sharedPropertyDescriptors": []
    },
    {
      "description": "Create 3D Box from Tiled Sprite object. Moving that Tiled Sprite will also move the 3D Object.",
      "fullName": "3D Box Projection from Tiled Sprite",
      "name": "BoxProjectionFromTiled",
      "objectType": "TiledSpriteObject::TiledSprite",
      "eventsFunctions": [
        {
          "fullName": "",
          "functionType": "Action",
          "name": "doStepPostEvents",
          "sentence": "",
          "events": [
            {
              "type": "BuiltinCommonInstructions::Standard",
              "conditions": [
                {
                  "type": {
                    "value": "WithThreeJS::BoxProjectionFromTiled::PropertyFirstFrame"
                  },
                  "parameters": [
                    "Object",
                    "Behavior"
                  ]
                }
              ],
              "actions": [
                {
                  "type": {
                    "value": "WithThreeJS::BoxProjectionFromTiled::SetPropertyFirstFrame"
                  },
                  "parameters": [
                    "Object",
                    "Behavior",
                    "no"
                  ]
                }
              ],
              "events": [
                {
                  "type": "BuiltinCommonInstructions::JsCode",
                  "inlineCode": [
                    "if (!gdjs.__WithThreeJS.has(\"Renderer\")) {",
                    "    console.warn(\"!\");",
                    "    return;",
                    "}",
                    "if (!gdjs.__WithThreeJS.has(\"Textures\")) {",
                    "    gdjs.__WithThreeJS.set(\"Textures\", new Map());",
                    "}",
                    "const Scene = gdjs.__WithThreeJS.get(\"Scene\");",
                    "let Textures = gdjs.__WithThreeJS.get(\"Textures\");",
                    "//",
                    "const Behavior = objects[0].getBehavior(\"BoxProjectionFromTiled\");",
                    "const Id = objects[0].name + objects[0].id;",
                    "// const X = objects[0].getCenterXInScene();",
                    "// const Y = objects[0].getCenterYInScene();",
                    "// const Z = objects[0].zOrder;",
                    "const Width = objects[0].getWidth();",
                    "const Height = objects[0].getHeight();",
                    "const Depth = Behavior.Depth();",
                    "const ProjectionScale = gdjs.__WithThreeJS.get(\"ProjectionScale\");",
                    "const ViewMode = gdjs.__WithThreeJS.get(\"ViewMode\");",
                    "const AlphaTest = Behavior.AlphaTest();",
                    "const Transparent = AlphaTest !== 0;",
                    "const AntiAliasing = Behavior.AntiAliasing();",
                    "let Blend = THREE.NormalBlending;",
                    "if (Behavior.Blend() == \"Additive\") {",
                    "    Blend = THREE.AdditiveBlending;",
                    "} else if (Behavior.Blend() == \"Subtractive\") {",
                    "    Blend = THREE.SubtractiveBlending;",
                    "} else if (Behavior.Blend() == \"Multiply\") {",
                    "    Blend = THREE.MultiplyBlending;",
                    "}",
                    "const CastShadow = Behavior.CastShadow();",
                    "const ReceiveShadow = Behavior.ReceiveShadow();",
                    "// const Opacity = 1.0;",
                    "//",
                    "//タイルの画像を取得",
                    "const Resource = objects[0].getRendererObject().texture.baseTexture.resource;",
                    "const TextureWidth = Resource.width;",
                    "const TextureHeight = Resource.height;",
                    "//",
                    "// インスタンスごとのマテリアルとテクスチャ生成",
                    "// FrontRear のみの1パターンか LeftRight, TopBottom, FrontRear の3パターン",
                    "// FrontRear は必須",
                    "let FRRepeatU, FRRepeatV;",
                    "if (ViewMode == \"Top Down\") {",
                    "    FRRepeatU = Width / TextureWidth;",
                    "    FRRepeatV = Depth / TextureHeight;",
                    "} else {",
                    "    // Side",
                    "    FRRepeatU = Width / TextureWidth;",
                    "    FRRepeatV = Height / TextureHeight;",
                    "}",
                    "const FRTextureId = \"_\" + Id + \"_\" + Resource.url + \"_FR\";",
                    "Behavior.SetFRTextureId(FRTextureId);",
                    "Behavior.SetFROffsetV(1 - (FRRepeatV % 1));",
                    "//",
                    "const FRTexture = new THREE.Texture();",
                    "FRTexture.image = Resource.source;",
                    "FRTexture.wrapS = THREE.RepeatWrapping;",
                    "FRTexture.wrapT = THREE.RepeatWrapping;",
                    "if (!AntiAliasing) {",
                    "    FRTexture.magFilter = THREE.NearestFilter;// THREE.LinearFilter",
                    "    FRTexture.minFilter = THREE.NearestFilter;// THREE.LinearMipmapLinearFilter",
                    "}",
                    "FRTexture.repeat.set(FRRepeatU, FRRepeatV);",
                    "FRTexture.colorSpace = THREE.SRGBColorSpace;",
                    "FRTexture.needsUpdate = true;//必須",
                    "Textures.set(FRTextureId, FRTexture);",
                    "// const FRMaterial = new THREE.MeshBasicMaterial({map: FRTexture, transparent:Transparent, alphaTest:AlphaTest, blending:Blend});",
                    "const FRMaterial = new THREE.MeshLambertMaterial({map: FRTexture, transparent:Transparent, alphaTest:AlphaTest, blending:Blend});",
                    "//",
                    "// 正方形なら1パターン、違うなら3パターン（2パターンはありえない）",
                    "const IsCube = (Width == Height && Width == Depth);",
                    "Behavior.SetIsCube(IsCube);",
                    "// 必要なら残りのパターンを生成して Material 設定",
                    "let Material;",
                    "if (IsCube) {",
                    "    Material = FRMaterial;",
                    "} else {",
                    "    // LeftRight",
                    "    let LRRepeatU, LRRepeatV;",
                    "    if (ViewMode == \"Top Down\") {",
                    "        LRRepeatU = Height / TextureWidth;",
                    "        LRRepeatV = Depth / TextureHeight;",
                    "    } else {",
                    "        // Side",
                    "        LRRepeatU = Depth / TextureWidth;",
                    "        LRRepeatV = Height / TextureHeight;",
                    "    }",
                    "    const LRTextureId = \"_\" + Id + \"_\" + Resource.url + \"_LR\";",
                    "    Behavior.SetLRTextureId(LRTextureId);",
                    "    Behavior.SetLROffsetV(1 - (LRRepeatV % 1));",
                    "    //",
                    "    const LRTexture = FRTexture.clone();",
                    "    LRTexture.repeat.set(LRRepeatU, LRRepeatV);",
                    "    LRTexture.colorSpace = THREE.SRGBColorSpace;",
                    "    LRTexture.needsUpdate = true;//必須",
                    "    Textures.set(LRTextureId, LRTexture);",
                    "    // const LRMaterial = new THREE.MeshBasicMaterial({map: LRTexture, transparent:Transparent, alphaTest:AlphaTest, blending:Blend});",
                    "    const LRMaterial = new THREE.MeshLambertMaterial({map: LRTexture, transparent:Transparent, alphaTest:AlphaTest, blending:Blend});",
                    "    //",
                    "    // TopBottom",
                    "    let TBRepeatU, TBRepeatV;",
                    "    if (ViewMode == \"Top Down\") {",
                    "        TBRepeatU = Width / TextureWidth;",
                    "        TBRepeatV = Height / TextureHeight;",
                    "    } else {",
                    "        // Side",
                    "        TBRepeatU = Width / TextureWidth;",
                    "        TBRepeatV = Depth / TextureHeight;",
                    "    }",
                    "    const TBTextureId = \"_\" + Id + \"_\" + Resource.url + \"_TB\";",
                    "    Behavior.SetTBTextureId(TBTextureId);",
                    "    Behavior.SetTBOffsetV(1 - (TBRepeatV % 1));",
                    "    //",
                    "    const TBTexture = FRTexture.clone();",
                    "    TBTexture.repeat.set(TBRepeatU, TBRepeatV);",
                    "    TBTexture.colorSpace = THREE.SRGBColorSpace;",
                    "    TBTexture.needsUpdate = true;//必須",
                    "    Textures.set(TBTextureId, TBTexture);",
                    "    // const TBMaterial = new THREE.MeshBasicMaterial({map: TBTexture, transparent:Transparent, alphaTest:AlphaTest, blending:Blend});",
                    "    const TBMaterial = new THREE.MeshLambertMaterial({map: TBTexture, transparent:Transparent, alphaTest:AlphaTest, blending:Blend});",
                    "    //",
                    "    Material = [LRMaterial, LRMaterial, TBMaterial, TBMaterial, FRMaterial, FRMaterial];",
                    "}",
                    "//",
                    "let Geometry;",
                    "if (ViewMode == \"Top Down\") {",
                    "    Geometry = new THREE.BoxGeometry(Width * ProjectionScale, Depth * ProjectionScale, Height * ProjectionScale);",
                    "} else {",
                    "    // Side",
                    "    Geometry = new THREE.BoxGeometry(Width * ProjectionScale, Height * ProjectionScale, Depth * ProjectionScale);",
                    "}",
                    "Geometry.computeBoundingBox();",
                    "const Obj = new THREE.Mesh(Geometry, Material);",
                    "Obj.name = Id;",
                    "Obj.castShadow = CastShadow;",
                    "Obj.receiveShadow = ReceiveShadow;",
                    "Obj.userData.Use3DProjectionBehavior = true;",
                    "Behavior.SetId(Id);",
                    "Scene.add(Obj);",
                    "",
                    ""
                  ],
                  "parameterObjects": "Object",
                  "useStrict": true,
                  "eventsSheetExpanded": true
                },
                {
                  "type": "BuiltinCommonInstructions::Standard",
                  "conditions": [
                    {
                      "type": {
                        "value": "WithThreeJS::BoxProjectionFromTiled::PropertyHide"
                      },
                      "parameters": [
                        "Object",
                        "Behavior"
                      ]
                    }
                  ],
                  "actions": [
                    {
                      "type": {
                        "value": "Cache"
                      },
                      "parameters": [
                        "Object"
                      ]
                    }
                  ]
                }
              ]
            },
            {
              "type": "BuiltinCommonInstructions::JsCode",
              "inlineCode": [
                "if (!gdjs.__WithThreeJS.has(\"Renderer\")) {\r",
                "    console.warn(\"!\");\r",
                "    return;\r",
                "}\r",
                "if (!gdjs.__WithThreeJS.has(\"Textures\")) {\r",
                "    console.warn(\"!\");\r",
                "    return;\r",
                "}\r",
                "const Scene = gdjs.__WithThreeJS.get(\"Scene\");\r",
                "let Textures = gdjs.__WithThreeJS.get(\"Textures\");\r",
                "//\r",
                "const Behavior = objects[0].getBehavior(\"BoxProjectionFromTiled\");\r",
                "const Id = Behavior.Id();\r",
                "const X = objects[0].getCenterXInScene();\r",
                "const Y = objects[0].getCenterYInScene();\r",
                "const Z = objects[0].zOrder;\r",
                "const ProjectionScale = gdjs.__WithThreeJS.get(\"ProjectionScale\");//Behavior.ProjectionScale();\r",
                "const ViewMode = gdjs.__WithThreeJS.get(\"ViewMode\");//Behavior.ViewMode();\r",
                "const IsCube = Behavior.IsCube();\r",
                "//\r",
                "const Obj = gdjs.__WithThreeJS.get(\"SearchObject\")(Id);\r",
                "if (!Obj) {\r",
                "    console.warn(\"3D Object not found: \" + Id);\r",
                "    return;\r",
                "}\r",
                "// Move & Rotate\r",
                "const Angle = objects[0].angle;\r",
                "if (ViewMode == \"Top Down\") {\r",
                "    Obj.position.set(X * ProjectionScale, Z * ProjectionScale, Y * ProjectionScale);\r",
                "    Obj.rotation.set(gdjs.toRad(0), gdjs.toRad(Angle * -1), gdjs.toRad(0));\r",
                "} else if (ViewMode == \"Side\") {\r",
                "    Obj.position.set(X * ProjectionScale, -Y * ProjectionScale, Z * ProjectionScale);\r",
                "    Obj.rotation.set(gdjs.toRad(0), gdjs.toRad(0), gdjs.toRad(Angle * -1));\r",
                "} else {\r",
                "    Obj.position.set(X * ProjectionScale, Y * ProjectionScale, Z * ProjectionScale);\r",
                "    Obj.rotation.set(gdjs.toRad(-90), gdjs.toRad(Angle * -1), gdjs.toRad(0));\r",
                "}\r",
                "// Opacity\r",
                "const Opacity = objects[0].getOpacity() / 255;\r",
                "if (Array.isArray(Obj.material)) {\r",
                "    for (let i = 0; i < Obj.material.length; i++) {\r",
                "        if (!Obj.material[i].transparent) {\r",
                "            if (Obj.material[i].alphaTest !== 0 || Opacity !== 1) {\r",
                "                Obj.material[i].transparent = true;\r",
                "                Obj.material[i].needsUpdate = true;\r",
                "            }\r",
                "        }\r",
                "        Obj.material[i].opacity = Opacity;\r",
                "    }\r",
                "} else {\r",
                "    if (!Obj.material.transparent) {\r",
                "        if (Obj.material.alphaTest !== 0 || Opacity !== 1) {\r",
                "            Obj.material.transparent = true;\r",
                "            Obj.material.needsUpdate = true;\r",
                "        }\r",
                "    }\r",
                "    Obj.material.opacity = Opacity;\r",
                "}\r",
                "// Offset\r",
                "const FRTexture = Textures.get(Behavior.FRTextureId());\r",
                "const TextureWidth = FRTexture.image.width;\r",
                "const TextureHeight = FRTexture.image.height;\r",
                "FRTexture.offset.set(objects[0].getXOffset() / TextureWidth, -(objects[0].getYOffset() / TextureHeight) + Behavior.FROffsetV());\r",
                "if (!IsCube) {\r",
                "    const LRTexture = Textures.get(Behavior.LRTextureId());\r",
                "    const TBTexture = Textures.get(Behavior.TBTextureId());\r",
                "    LRTexture.offset.set(objects[0].getXOffset() / TextureWidth, -(objects[0].getYOffset() / TextureHeight) + Behavior.LROffsetV());\r",
                "    TBTexture.offset.set(objects[0].getXOffset() / TextureWidth, -(objects[0].getYOffset() / TextureHeight) + Behavior.TBOffsetV());\r",
                "}\r",
                "\r",
                "\r",
                ""
              ],
              "parameterObjects": "Object",
              "useStrict": true,
              "eventsSheetExpanded": true
            }
          ],
          "parameters": [
            {
              "description": "Object",
              "name": "Object",
              "supplementaryInformation": "TiledSpriteObject::TiledSprite",
              "type": "object"
            },
            {
              "description": "Behavior",
              "name": "Behavior",
              "supplementaryInformation": "WithThreeJS::BoxProjectionFromTiled",
              "type": "behavior"
            }
          ],
          "objectGroups": []
        },
        {
          "fullName": "",
          "functionType": "Action",
          "name": "onDestroy",
          "sentence": "",
          "events": [
            {
              "type": "BuiltinCommonInstructions::JsCode",
              "inlineCode": [
                "// 生成と同時に削除された場合、3D化されていないので回避\r",
                "// FirstFrame == true のほうが理想的だが取得がめんどくさいので Id を利用。\r",
                "const Behavior = objects[0].getBehavior(\"BoxProjectionFromTiled\");\r",
                "const Id = Behavior.Id();\r",
                "if (Id === \"\") {\r",
                "    return;\r",
                "}\r",
                "//\r",
                "if (!gdjs.__WithThreeJS.has(\"Renderer\")) {\r",
                "    console.warn(\"!\");\r",
                "    return;\r",
                "}\r",
                "if (!gdjs.__WithThreeJS.has(\"Textures\")) {\r",
                "    gdjs.__WithThreeJS.set(\"Textures\", new Map());\r",
                "}\r",
                "const Scene = gdjs.__WithThreeJS.get(\"Scene\");\r",
                "const Textures = gdjs.__WithThreeJS.get(\"Textures\");\r",
                "const Obj = gdjs.__WithThreeJS.get(\"SearchObject\")(Id);\r",
                "if (!Obj) {\r",
                "    console.warn(\"3D Object not found.\");\r",
                "    return;\r",
                "}\r",
                "//\r",
                "const IsCube = Behavior.IsCube();\r",
                "const FRTextureId = Behavior.FRTextureId();\r",
                "const FRTexture = Textures.get(FRTextureId);\r",
                "// インスタンスごとなので全て削除\r",
                "FRTexture.dispose();\r",
                "Textures.delete(FRTextureId);\r",
                "if (!IsCube) {\r",
                "    const LRTextureId = Behavior.LRTextureId();\r",
                "    const TBTextureId = Behavior.TBTextureId();\r",
                "    const LRTexture = Textures.get(LRTextureId);\r",
                "    const TBTexture = Textures.get(TBTextureId);\r",
                "    LRTexture.dispose();\r",
                "    TBTexture.dispose();\r",
                "    Textures.delete(LRTextureId);\r",
                "    Textures.delete(TBTextureId);\r",
                "}\r",
                "//\r",
                "gdjs.__WithThreeJS.get(\"DisposeChildren\")(Obj);\r",
                "Obj.removeFromParent();\r",
                "\r",
                ""
              ],
              "parameterObjects": "Object",
              "useStrict": true,
              "eventsSheetExpanded": true
            }
          ],
          "parameters": [
            {
              "description": "Object",
              "name": "Object",
              "supplementaryInformation": "TiledSpriteObject::TiledSprite",
              "type": "object"
            },
            {
              "description": "Behavior",
              "name": "Behavior",
              "supplementaryInformation": "WithThreeJS::BoxProjectionFromTiled",
              "type": "behavior"
            }
          ],
          "objectGroups": []
        },
        {
          "fullName": "3D Object ID",
          "functionType": "StringExpression",
          "name": "Id",
          "sentence": "",
          "events": [
            {
              "type": "BuiltinCommonInstructions::Standard",
              "conditions": [],
              "actions": [
                {
                  "type": {
                    "value": "SetReturnString"
                  },
                  "parameters": [
                    "Object.Behavior::PropertyId()"
                  ]
                }
              ]
            }
          ],
          "expressionType": {
            "type": "string"
          },
          "parameters": [
            {
              "description": "Object",
              "name": "Object",
              "supplementaryInformation": "TiledSpriteObject::TiledSprite",
              "type": "object"
            },
            {
              "description": "Behavior",
              "name": "Behavior",
              "supplementaryInformation": "WithThreeJS::BoxProjectionFromTiled",
              "type": "behavior"
            }
          ],
          "objectGroups": []
        },
        {
          "fullName": "Depth",
          "functionType": "Expression",
          "name": "Depth",
          "sentence": "",
          "events": [
            {
              "type": "BuiltinCommonInstructions::Standard",
              "conditions": [],
              "actions": [
                {
                  "type": {
                    "value": "SetReturnNumber"
                  },
                  "parameters": [
                    "Object.Behavior::PropertyDepth()"
                  ]
                }
              ]
            }
          ],
          "expressionType": {
            "type": "expression"
          },
          "parameters": [
            {
              "description": "Object",
              "name": "Object",
              "supplementaryInformation": "TiledSpriteObject::TiledSprite",
              "type": "object"
            },
            {
              "description": "Behavior",
              "name": "Behavior",
              "supplementaryInformation": "WithThreeJS::BoxProjectionFromTiled",
              "type": "behavior"
            }
          ],
          "objectGroups": []
        },
        {
          "fullName": "Alpha Channel Test",
          "functionType": "Expression",
          "name": "AlphaTest",
          "sentence": "",
          "events": [
            {
              "type": "BuiltinCommonInstructions::Standard",
              "conditions": [],
              "actions": [
                {
                  "type": {
                    "value": "SetReturnNumber"
                  },
                  "parameters": [
                    "Object.Behavior::PropertyAlphaTest()"
                  ]
                }
              ]
            }
          ],
          "expressionType": {
            "type": "expression"
          },
          "parameters": [
            {
              "description": "Object",
              "name": "Object",
              "supplementaryInformation": "TiledSpriteObject::TiledSprite",
              "type": "object"
            },
            {
              "description": "Behavior",
              "name": "Behavior",
              "supplementaryInformation": "WithThreeJS::BoxProjectionFromTiled",
              "type": "behavior"
            }
          ],
          "objectGroups": []
        },
        {
          "fullName": "Blend Mode",
          "functionType": "StringExpression",
          "name": "Blend",
          "sentence": "",
          "events": [
            {
              "type": "BuiltinCommonInstructions::Standard",
              "conditions": [],
              "actions": [
                {
                  "type": {
                    "value": "SetReturnString"
                  },
                  "parameters": [
                    "Object.Behavior::PropertyBlend()"
                  ]
                }
              ]
            }
          ],
          "expressionType": {
            "type": "string"
          },
          "parameters": [
            {
              "description": "Object",
              "name": "Object",
              "supplementaryInformation": "TiledSpriteObject::TiledSprite",
              "type": "object"
            },
            {
              "description": "Behavior",
              "name": "Behavior",
              "supplementaryInformation": "WithThreeJS::BoxProjectionFromTiled",
              "type": "behavior"
            }
          ],
          "objectGroups": []
        },
        {
          "fullName": "Is Anti-Aliasing",
          "functionType": "Condition",
          "name": "AntiAliasing",
          "private": true,
          "sentence": "Is Anti-Aliasing _PARAM0_",
          "events": [
            {
              "type": "BuiltinCommonInstructions::Standard",
              "conditions": [
                {
                  "type": {
                    "value": "WithThreeJS::BoxProjectionFromTiled::PropertyAntiAliasing"
                  },
                  "parameters": [
                    "Object",
                    "Behavior"
                  ]
                }
              ],
              "actions": [
                {
                  "type": {
                    "value": "SetReturnBoolean"
                  },
                  "parameters": [
                    "True"
                  ]
                }
              ]
            },
            {
              "type": "BuiltinCommonInstructions::Standard",
              "conditions": [
                {
                  "type": {
                    "inverted": true,
                    "value": "WithThreeJS::BoxProjectionFromTiled::PropertyAntiAliasing"
                  },
                  "parameters": [
                    "Object",
                    "Behavior"
                  ]
                }
              ],
              "actions": [
                {
                  "type": {
                    "value": "SetReturnBoolean"
                  },
                  "parameters": [
                    "False"
                  ]
                }
              ]
            }
          ],
          "parameters": [
            {
              "description": "Object",
              "name": "Object",
              "supplementaryInformation": "TiledSpriteObject::TiledSprite",
              "type": "object"
            },
            {
              "description": "Behavior",
              "name": "Behavior",
              "supplementaryInformation": "WithThreeJS::BoxProjectionFromTiled",
              "type": "behavior"
            }
          ],
          "objectGroups": []
        },
        {
          "fullName": "Is Cube",
          "functionType": "Condition",
          "name": "IsCube",
          "private": true,
          "sentence": "Is Cube _PARAM0_",
          "events": [
            {
              "type": "BuiltinCommonInstructions::Standard",
              "conditions": [
                {
                  "type": {
                    "value": "WithThreeJS::BoxProjectionFromTiled::PropertyIsCube"
                  },
                  "parameters": [
                    "Object",
                    "Behavior"
                  ]
                }
              ],
              "actions": [
                {
                  "type": {
                    "value": "SetReturnBoolean"
                  },
                  "parameters": [
                    "True"
                  ]
                }
              ]
            },
            {
              "type": "BuiltinCommonInstructions::Standard",
              "conditions": [
                {
                  "type": {
                    "inverted": true,
                    "value": "WithThreeJS::BoxProjectionFromTiled::PropertyIsCube"
                  },
                  "parameters": [
                    "Object",
                    "Behavior"
                  ]
                }
              ],
              "actions": [
                {
                  "type": {
                    "value": "SetReturnBoolean"
                  },
                  "parameters": [
                    "False"
                  ]
                }
              ]
            }
          ],
          "parameters": [
            {
              "description": "Object",
              "name": "Object",
              "supplementaryInformation": "TiledSpriteObject::TiledSprite",
              "type": "object"
            },
            {
              "description": "Behavior",
              "name": "Behavior",
              "supplementaryInformation": "WithThreeJS::BoxProjectionFromTiled",
              "type": "behavior"
            }
          ],
          "objectGroups": []
        },
        {
          "fullName": "Is Cast Shadow",
          "functionType": "Condition",
          "name": "CastShadow",
          "private": true,
          "sentence": "Is Cast Shadow _PARAM0_",
          "events": [
            {
              "type": "BuiltinCommonInstructions::Standard",
              "conditions": [
                {
                  "type": {
                    "value": "WithThreeJS::BoxProjectionFromTiled::PropertyCastShadow"
                  },
                  "parameters": [
                    "Object",
                    "Behavior"
                  ]
                }
              ],
              "actions": [
                {
                  "type": {
                    "value": "SetReturnBoolean"
                  },
                  "parameters": [
                    "True"
                  ]
                }
              ]
            },
            {
              "type": "BuiltinCommonInstructions::Standard",
              "conditions": [
                {
                  "type": {
                    "inverted": true,
                    "value": "WithThreeJS::BoxProjectionFromTiled::PropertyCastShadow"
                  },
                  "parameters": [
                    "Object",
                    "Behavior"
                  ]
                }
              ],
              "actions": [
                {
                  "type": {
                    "value": "SetReturnBoolean"
                  },
                  "parameters": [
                    "False"
                  ]
                }
              ]
            }
          ],
          "parameters": [
            {
              "description": "Object",
              "name": "Object",
              "supplementaryInformation": "TiledSpriteObject::TiledSprite",
              "type": "object"
            },
            {
              "description": "Behavior",
              "name": "Behavior",
              "supplementaryInformation": "WithThreeJS::BoxProjectionFromTiled",
              "type": "behavior"
            }
          ],
          "objectGroups": []
        },
        {
          "fullName": "Is Receive Shadow",
          "functionType": "Condition",
          "name": "ReceiveShadow",
          "private": true,
          "sentence": "Is Receive Shadow _PARAM0_",
          "events": [
            {
              "type": "BuiltinCommonInstructions::Standard",
              "conditions": [
                {
                  "type": {
                    "value": "WithThreeJS::BoxProjectionFromTiled::PropertyReceiveShadow"
                  },
                  "parameters": [
                    "Object",
                    "Behavior"
                  ]
                }
              ],
              "actions": [
                {
                  "type": {
                    "value": "SetReturnBoolean"
                  },
                  "parameters": [
                    "True"
                  ]
                }
              ]
            },
            {
              "type": "BuiltinCommonInstructions::Standard",
              "conditions": [
                {
                  "type": {
                    "inverted": true,
                    "value": "WithThreeJS::BoxProjectionFromTiled::PropertyReceiveShadow"
                  },
                  "parameters": [
                    "Object",
                    "Behavior"
                  ]
                }
              ],
              "actions": [
                {
                  "type": {
                    "value": "SetReturnBoolean"
                  },
                  "parameters": [
                    "False"
                  ]
                }
              ]
            }
          ],
          "parameters": [
            {
              "description": "Object",
              "name": "Object",
              "supplementaryInformation": "TiledSpriteObject::TiledSprite",
              "type": "object"
            },
            {
              "description": "Behavior",
              "name": "Behavior",
              "supplementaryInformation": "WithThreeJS::BoxProjectionFromTiled",
              "type": "behavior"
            }
          ],
          "objectGroups": []
        },
        {
          "fullName": "TopBottom 3D Texture ID",
          "functionType": "StringExpression",
          "name": "TBTextureId",
          "private": true,
          "sentence": "",
          "events": [
            {
              "type": "BuiltinCommonInstructions::Standard",
              "conditions": [],
              "actions": [
                {
                  "type": {
                    "value": "SetReturnString"
                  },
                  "parameters": [
                    "Object.Behavior::PropertyTBTextureId()"
                  ]
                }
              ]
            }
          ],
          "expressionType": {
            "type": "string"
          },
          "parameters": [
            {
              "description": "Object",
              "name": "Object",
              "supplementaryInformation": "TiledSpriteObject::TiledSprite",
              "type": "object"
            },
            {
              "description": "Behavior",
              "name": "Behavior",
              "supplementaryInformation": "WithThreeJS::BoxProjectionFromTiled",
              "type": "behavior"
            }
          ],
          "objectGroups": []
        },
        {
          "fullName": "LeftRight 3D Texture ID",
          "functionType": "StringExpression",
          "name": "LRTextureId",
          "private": true,
          "sentence": "",
          "events": [
            {
              "type": "BuiltinCommonInstructions::Standard",
              "conditions": [],
              "actions": [
                {
                  "type": {
                    "value": "SetReturnString"
                  },
                  "parameters": [
                    "Object.Behavior::PropertyLRTextureId()"
                  ]
                }
              ]
            }
          ],
          "expressionType": {
            "type": "string"
          },
          "parameters": [
            {
              "description": "Object",
              "name": "Object",
              "supplementaryInformation": "TiledSpriteObject::TiledSprite",
              "type": "object"
            },
            {
              "description": "Behavior",
              "name": "Behavior",
              "supplementaryInformation": "WithThreeJS::BoxProjectionFromTiled",
              "type": "behavior"
            }
          ],
          "objectGroups": []
        },
        {
          "fullName": "FrontRear 3D Texture ID",
          "functionType": "StringExpression",
          "name": "FRTextureId",
          "private": true,
          "sentence": "",
          "events": [
            {
              "type": "BuiltinCommonInstructions::Standard",
              "conditions": [],
              "actions": [
                {
                  "type": {
                    "value": "SetReturnString"
                  },
                  "parameters": [
                    "Object.Behavior::PropertyFRTextureId()"
                  ]
                }
              ]
            }
          ],
          "expressionType": {
            "type": "string"
          },
          "parameters": [
            {
              "description": "Object",
              "name": "Object",
              "supplementaryInformation": "TiledSpriteObject::TiledSprite",
              "type": "object"
            },
            {
              "description": "Behavior",
              "name": "Behavior",
              "supplementaryInformation": "WithThreeJS::BoxProjectionFromTiled",
              "type": "behavior"
            }
          ],
          "objectGroups": []
        },
        {
          "fullName": "TopBottom Offset V",
          "functionType": "Expression",
          "name": "TBOffsetV",
          "private": true,
          "sentence": "",
          "events": [
            {
              "type": "BuiltinCommonInstructions::Standard",
              "conditions": [],
              "actions": [
                {
                  "type": {
                    "value": "SetReturnNumber"
                  },
                  "parameters": [
                    "Object.Behavior::PropertyTBOffsetV()"
                  ]
                }
              ]
            }
          ],
          "expressionType": {
            "type": "expression"
          },
          "parameters": [
            {
              "description": "Object",
              "name": "Object",
              "supplementaryInformation": "TiledSpriteObject::TiledSprite",
              "type": "object"
            },
            {
              "description": "Behavior",
              "name": "Behavior",
              "supplementaryInformation": "WithThreeJS::BoxProjectionFromTiled",
              "type": "behavior"
            }
          ],
          "objectGroups": []
        },
        {
          "fullName": "LeftRight Offset V",
          "functionType": "Expression",
          "name": "LROffsetV",
          "private": true,
          "sentence": "",
          "events": [
            {
              "type": "BuiltinCommonInstructions::Standard",
              "conditions": [],
              "actions": [
                {
                  "type": {
                    "value": "SetReturnNumber"
                  },
                  "parameters": [
                    "Object.Behavior::PropertyLROffsetV()"
                  ]
                }
              ]
            }
          ],
          "expressionType": {
            "type": "expression"
          },
          "parameters": [
            {
              "description": "Object",
              "name": "Object",
              "supplementaryInformation": "TiledSpriteObject::TiledSprite",
              "type": "object"
            },
            {
              "description": "Behavior",
              "name": "Behavior",
              "supplementaryInformation": "WithThreeJS::BoxProjectionFromTiled",
              "type": "behavior"
            }
          ],
          "objectGroups": []
        },
        {
          "fullName": "FrontRear Offset V",
          "functionType": "Expression",
          "name": "FROffsetV",
          "private": true,
          "sentence": "",
          "events": [
            {
              "type": "BuiltinCommonInstructions::Standard",
              "conditions": [],
              "actions": [
                {
                  "type": {
                    "value": "SetReturnNumber"
                  },
                  "parameters": [
                    "Object.Behavior::PropertyFROffsetV()"
                  ]
                }
              ]
            }
          ],
          "expressionType": {
            "type": "expression"
          },
          "parameters": [
            {
              "description": "Object",
              "name": "Object",
              "supplementaryInformation": "TiledSpriteObject::TiledSprite",
              "type": "object"
            },
            {
              "description": "Behavior",
              "name": "Behavior",
              "supplementaryInformation": "WithThreeJS::BoxProjectionFromTiled",
              "type": "behavior"
            }
          ],
          "objectGroups": []
        },
        {
          "fullName": "Set 3D Object ID",
          "functionType": "Action",
          "name": "SetId",
          "private": true,
          "sentence": "Set 3D Object ID (_PARAM0_, ID: _PARAM2_)",
          "events": [
            {
              "type": "BuiltinCommonInstructions::Standard",
              "conditions": [],
              "actions": [
                {
                  "type": {
                    "value": "WithThreeJS::BoxProjectionFromTiled::SetPropertyId"
                  },
                  "parameters": [
                    "Object",
                    "Behavior",
                    "=",
                    "GetArgumentAsString(\"Id\")"
                  ]
                }
              ]
            }
          ],
          "parameters": [
            {
              "description": "Object",
              "name": "Object",
              "supplementaryInformation": "TiledSpriteObject::TiledSprite",
              "type": "object"
            },
            {
              "description": "Behavior",
              "name": "Behavior",
              "supplementaryInformation": "WithThreeJS::BoxProjectionFromTiled",
              "type": "behavior"
            },
            {
              "description": "3D Object ID",
              "name": "Id",
              "type": "string"
            }
          ],
          "objectGroups": []
        },
        {
          "fullName": "Set Is Cube",
          "functionType": "Action",
          "name": "SetIsCube",
          "private": true,
          "sentence": "Set Is Cube (_PARAM0_ Cube: _PARAM2_)",
          "events": [
            {
              "type": "BuiltinCommonInstructions::Standard",
              "conditions": [
                {
                  "type": {
                    "value": "GetArgumentAsBoolean"
                  },
                  "parameters": [
                    "\"Cube\""
                  ]
                }
              ],
              "actions": [
                {
                  "type": {
                    "value": "WithThreeJS::BoxProjectionFromTiled::SetPropertyIsCube"
                  },
                  "parameters": [
                    "Object",
                    "Behavior",
                    "yes"
                  ]
                }
              ]
            },
            {
              "type": "BuiltinCommonInstructions::Standard",
              "conditions": [
                {
                  "type": {
                    "inverted": true,
                    "value": "GetArgumentAsBoolean"
                  },
                  "parameters": [
                    "\"Cube\""
                  ]
                }
              ],
              "actions": [
                {
                  "type": {
                    "value": "WithThreeJS::BoxProjectionFromTiled::SetPropertyIsCube"
                  },
                  "parameters": [
                    "Object",
                    "Behavior",
                    "no"
                  ]
                }
              ]
            }
          ],
          "parameters": [
            {
              "description": "Object",
              "name": "Object",
              "supplementaryInformation": "TiledSpriteObject::TiledSprite",
              "type": "object"
            },
            {
              "description": "Behavior",
              "name": "Behavior",
              "supplementaryInformation": "WithThreeJS::BoxProjectionFromTiled",
              "type": "behavior"
            },
            {
              "description": "Cube",
              "name": "Cube",
              "type": "trueorfalse"
            }
          ],
          "objectGroups": []
        },
        {
          "fullName": "Set TopBottom 3D Texture ID",
          "functionType": "Action",
          "name": "SetTBTextureId",
          "private": true,
          "sentence": "Set TopBottom 3D Texture ID (_PARAM0_, ID: _PARAM2_)",
          "events": [
            {
              "type": "BuiltinCommonInstructions::Standard",
              "conditions": [],
              "actions": [
                {
                  "type": {
                    "value": "WithThreeJS::BoxProjectionFromTiled::SetPropertyTBTextureId"
                  },
                  "parameters": [
                    "Object",
                    "Behavior",
                    "=",
                    "GetArgumentAsString(\"Id\")"
                  ]
                }
              ]
            }
          ],
          "parameters": [
            {
              "description": "Object",
              "name": "Object",
              "supplementaryInformation": "TiledSpriteObject::TiledSprite",
              "type": "object"
            },
            {
              "description": "Behavior",
              "name": "Behavior",
              "supplementaryInformation": "WithThreeJS::BoxProjectionFromTiled",
              "type": "behavior"
            },
            {
              "description": "3D Texture ID",
              "name": "Id",
              "type": "string"
            }
          ],
          "objectGroups": []
        },
        {
          "fullName": "Set LeftRight 3D Texture ID",
          "functionType": "Action",
          "name": "SetLRTextureId",
          "private": true,
          "sentence": "Set LeftRight 3D Texture ID (_PARAM0_, ID: _PARAM2_)",
          "events": [
            {
              "type": "BuiltinCommonInstructions::Standard",
              "conditions": [],
              "actions": [
                {
                  "type": {
                    "value": "WithThreeJS::BoxProjectionFromTiled::SetPropertyLRTextureId"
                  },
                  "parameters": [
                    "Object",
                    "Behavior",
                    "=",
                    "GetArgumentAsString(\"Id\")"
                  ]
                }
              ]
            }
          ],
          "parameters": [
            {
              "description": "Object",
              "name": "Object",
              "supplementaryInformation": "TiledSpriteObject::TiledSprite",
              "type": "object"
            },
            {
              "description": "Behavior",
              "name": "Behavior",
              "supplementaryInformation": "WithThreeJS::BoxProjectionFromTiled",
              "type": "behavior"
            },
            {
              "description": "3D Texture ID",
              "name": "Id",
              "type": "string"
            }
          ],
          "objectGroups": []
        },
        {
          "fullName": "Set FrontRear 3D Texture ID",
          "functionType": "Action",
          "name": "SetFRTextureId",
          "private": true,
          "sentence": "Set FrontRear 3D Texture ID (_PARAM0_, ID: _PARAM2_)",
          "events": [
            {
              "type": "BuiltinCommonInstructions::Standard",
              "conditions": [],
              "actions": [
                {
                  "type": {
                    "value": "WithThreeJS::BoxProjectionFromTiled::SetPropertyFRTextureId"
                  },
                  "parameters": [
                    "Object",
                    "Behavior",
                    "=",
                    "GetArgumentAsString(\"Id\")"
                  ]
                }
              ]
            }
          ],
          "parameters": [
            {
              "description": "Object",
              "name": "Object",
              "supplementaryInformation": "TiledSpriteObject::TiledSprite",
              "type": "object"
            },
            {
              "description": "Behavior",
              "name": "Behavior",
              "supplementaryInformation": "WithThreeJS::BoxProjectionFromTiled",
              "type": "behavior"
            },
            {
              "description": "3D Texture ID",
              "name": "Id",
              "type": "string"
            }
          ],
          "objectGroups": []
        },
        {
          "fullName": "Set TopBottom Offset V",
          "functionType": "Action",
          "name": "SetTBOffsetV",
          "private": true,
          "sentence": "Set TopBottom Offset V (_PARAM0_, Value: _PARAM2_)",
          "events": [
            {
              "type": "BuiltinCommonInstructions::Standard",
              "conditions": [],
              "actions": [
                {
                  "type": {
                    "value": "WithThreeJS::BoxProjectionFromTiled::SetPropertyTBOffsetV"
                  },
                  "parameters": [
                    "Object",
                    "Behavior",
                    "=",
                    "GetArgumentAsNumber(\"Value\")"
                  ]
                }
              ]
            }
          ],
          "parameters": [
            {
              "description": "Object",
              "name": "Object",
              "supplementaryInformation": "TiledSpriteObject::TiledSprite",
              "type": "object"
            },
            {
              "description": "Behavior",
              "name": "Behavior",
              "supplementaryInformation": "WithThreeJS::BoxProjectionFromTiled",
              "type": "behavior"
            },
            {
              "description": "Offset Value",
              "name": "Value",
              "type": "expression"
            }
          ],
          "objectGroups": []
        },
        {
          "fullName": "Set LeftRight Offset V",
          "functionType": "Action",
          "name": "SetLROffsetV",
          "private": true,
          "sentence": "Set LeftRight Offset V (_PARAM0_, Value: _PARAM2_)",
          "events": [
            {
              "type": "BuiltinCommonInstructions::Standard",
              "conditions": [],
              "actions": [
                {
                  "type": {
                    "value": "WithThreeJS::BoxProjectionFromTiled::SetPropertyLROffsetV"
                  },
                  "parameters": [
                    "Object",
                    "Behavior",
                    "=",
                    "GetArgumentAsNumber(\"Value\")"
                  ]
                }
              ]
            }
          ],
          "parameters": [
            {
              "description": "Object",
              "name": "Object",
              "supplementaryInformation": "TiledSpriteObject::TiledSprite",
              "type": "object"
            },
            {
              "description": "Behavior",
              "name": "Behavior",
              "supplementaryInformation": "WithThreeJS::BoxProjectionFromTiled",
              "type": "behavior"
            },
            {
              "description": "Offset Value",
              "name": "Value",
              "type": "expression"
            }
          ],
          "objectGroups": []
        },
        {
          "fullName": "Set FrontRear Offset V",
          "functionType": "Action",
          "name": "SetFROffsetV",
          "private": true,
          "sentence": "Set FrontRear Offset V (_PARAM0_, Value: _PARAM2_)",
          "events": [
            {
              "type": "BuiltinCommonInstructions::Standard",
              "conditions": [],
              "actions": [
                {
                  "type": {
                    "value": "WithThreeJS::BoxProjectionFromTiled::SetPropertyFROffsetV"
                  },
                  "parameters": [
                    "Object",
                    "Behavior",
                    "=",
                    "GetArgumentAsNumber(\"Value\")"
                  ]
                }
              ]
            }
          ],
          "parameters": [
            {
              "description": "Object",
              "name": "Object",
              "supplementaryInformation": "TiledSpriteObject::TiledSprite",
              "type": "object"
            },
            {
              "description": "Behavior",
              "name": "Behavior",
              "supplementaryInformation": "WithThreeJS::BoxProjectionFromTiled",
              "type": "behavior"
            },
            {
              "description": "Offset Value",
              "name": "Value",
              "type": "expression"
            }
          ],
          "objectGroups": []
        }
      ],
      "propertyDescriptors": [
        {
          "value": "",
          "type": "String",
          "label": "",
          "description": "",
          "group": "",
          "extraInformation": [],
          "hidden": true,
          "name": "Id"
        },
        {
          "value": "true",
          "type": "Boolean",
          "label": "",
          "description": "",
          "group": "",
          "extraInformation": [],
          "hidden": true,
          "name": "FirstFrame"
        },
        {
          "value": "true",
          "type": "Boolean",
          "label": "Hide 2D Object",
          "description": "",
          "group": "",
          "extraInformation": [],
          "name": "Hide"
        },
        {
          "value": "0",
          "type": "Number",
          "label": "Alpha Channel Test",
          "description": "Recommended values: 0 or 0.5. Default: 0.",
          "group": "Texture",
          "extraInformation": [],
          "name": "AlphaTest"
        },
        {
          "value": "true",
          "type": "Boolean",
          "label": "Anti-Aliasing",
          "description": "",
          "group": "Texture",
          "extraInformation": [
            "Antialiased",
            "No Antialiasing"
          ],
          "name": "AntiAliasing"
        },
        {
          "value": "1",
          "type": "Number",
          "label": "Depth",
          "description": "Unit: Pixel",
          "group": "",
          "extraInformation": [],
          "name": "Depth"
        },
        {
          "value": "",
          "type": "Boolean",
          "label": "",
          "description": "",
          "group": "",
          "extraInformation": [],
          "hidden": true,
          "name": "IsCube"
        },
        {
          "value": "",
          "type": "String",
          "label": "",
          "description": "",
          "group": "",
          "extraInformation": [],
          "hidden": true,
          "name": "TBTextureId"
        },
        {
          "value": "",
          "type": "String",
          "label": "",
          "description": "",
          "group": "",
          "extraInformation": [],
          "hidden": true,
          "name": "LRTextureId"
        },
        {
          "value": "",
          "type": "String",
          "label": "",
          "description": "",
          "group": "",
          "extraInformation": [],
          "hidden": true,
          "name": "FRTextureId"
        },
        {
          "value": "0",
          "type": "Number",
          "label": "",
          "description": "",
          "group": "",
          "extraInformation": [],
          "hidden": true,
          "name": "TBOffsetV"
        },
        {
          "value": "",
          "type": "Number",
          "label": "",
          "description": "",
          "group": "",
          "extraInformation": [],
          "hidden": true,
          "name": "LROffsetV"
        },
        {
          "value": "",
          "type": "Number",
          "label": "",
          "description": "",
          "group": "",
          "extraInformation": [],
          "hidden": true,
          "name": "FROffsetV"
        },
        {
          "value": "Normal",
          "type": "Choice",
          "label": "Blend Mode",
          "description": "",
          "group": "Texture",
          "extraInformation": [
            "Normal",
            "Additive",
            "Subtractive",
            "Multiply"
          ],
          "name": "Blend"
        },
        {
          "value": "",
          "type": "Boolean",
          "label": "Cast Shadow",
          "description": "If both \"Cast Shadow\" and \"Receive Shadow\" are enabled, striped patterns are likely to occur in the shadow.",
          "group": "Shadow",
          "extraInformation": [],
          "name": "CastShadow"
        },
        {
          "value": "",
          "type": "Boolean",
          "label": "Receive Shadow",
          "description": "If both \"Cast Shadow\" and \"Receive Shadow\" are enabled, striped patterns are likely to occur in the shadow.",
          "group": "Shadow",
          "extraInformation": [],
          "name": "ReceiveShadow"
        }
      ],
      "sharedPropertyDescriptors": []
    },
    {
      "description": "Link a Sprite object and  a 3D Camera.",
      "fullName": "Linked 3D Camera",
      "name": "LinkedCamera",
      "objectType": "Sprite",
      "eventsFunctions": [
        {
          "fullName": "",
          "functionType": "Action",
          "name": "doStepPostEvents",
          "sentence": "",
          "events": [
            {
              "type": "BuiltinCommonInstructions::JsCode",
              "inlineCode": [
                "if (!gdjs.__WithThreeJS.has(\"Renderer\")) {",
                "    console.warn(\"!\");",
                "    return;",
                "}",
                "const Behavior = objects[0].getBehavior(\"LinkedCamera\");",
                "const Id = Behavior.Id();",
                "const Camera = gdjs.__WithThreeJS.get(\"GetCamera\")(Id);",
                "const Fov = Behavior.Fov();",
                "const ProjectionScale = gdjs.__WithThreeJS.get(\"ProjectionScale\");",
                "const ViewMode = gdjs.__WithThreeJS.get(\"ViewMode\");",
                "const LinkAngle = Behavior.LinkAngle();",
                "const Hide = Behavior.Hide();",
                "const X = objects[0].getCenterXInScene();",
                "const Y = objects[0].getCenterYInScene();",
                "const Z = objects[0].zOrder;",
                "//",
                "if (ViewMode == \"Top Down\") {",
                "    Camera.position.set(X * ProjectionScale, Z * ProjectionScale, Y * ProjectionScale);",
                "} else {",
                "    // Side",
                "    Camera.position.set(X * ProjectionScale, -Y * ProjectionScale, Z * ProjectionScale);",
                "}",
                "//",
                "if (LinkAngle) {",
                "    const Angle = objects[0].angle;",
                "    if (ViewMode == \"Top Down\") {",
                "        Camera.rotation.set(gdjs.toRad(0), gdjs.toRad(Angle * -1 - 90), gdjs.toRad(0));",
                "    } else {",
                "        // Side",
                "        Camera.rotation.set(gdjs.toRad(-Angle), gdjs.toRad(-90), gdjs.toRad(0), \"YXZ\");",
                "    }",
                "}",
                "//",
                "if (Camera.fov != Fov) {",
                "    Camera.fov = Fov;",
                "    Camera.updateProjectionMatrix();",
                "}",
                "//",
                "objects[0].hide(Hide);",
                "",
                ""
              ],
              "parameterObjects": "Object",
              "useStrict": true,
              "eventsSheetExpanded": true
            }
          ],
          "parameters": [
            {
              "description": "Object",
              "name": "Object",
              "supplementaryInformation": "Sprite",
              "type": "object"
            },
            {
              "description": "Behavior",
              "name": "Behavior",
              "supplementaryInformation": "WithThreeJS::LinkedCamera",
              "type": "behavior"
            }
          ],
          "objectGroups": []
        },
        {
          "fullName": "3D Camera ID",
          "functionType": "Expression",
          "name": "Id",
          "sentence": "",
          "events": [
            {
              "type": "BuiltinCommonInstructions::Standard",
              "conditions": [],
              "actions": [
                {
                  "type": {
                    "value": "SetReturnNumber"
                  },
                  "parameters": [
                    "Object.Behavior::PropertyId()"
                  ]
                }
              ]
            }
          ],
          "expressionType": {
            "type": "expression"
          },
          "parameters": [
            {
              "description": "Object",
              "name": "Object",
              "supplementaryInformation": "Sprite",
              "type": "object"
            },
            {
              "description": "Behavior",
              "name": "Behavior",
              "supplementaryInformation": "WithThreeJS::LinkedCamera",
              "type": "behavior"
            }
          ],
          "objectGroups": []
        },
        {
          "fullName": "Field Of View",
          "functionType": "Expression",
          "name": "Fov",
          "sentence": "",
          "events": [
            {
              "type": "BuiltinCommonInstructions::Standard",
              "conditions": [],
              "actions": [
                {
                  "type": {
                    "value": "SetReturnNumber"
                  },
                  "parameters": [
                    "Object.Behavior::PropertyFov()"
                  ]
                }
              ]
            }
          ],
          "expressionType": {
            "type": "expression"
          },
          "parameters": [
            {
              "description": "Object",
              "name": "Object",
              "supplementaryInformation": "Sprite",
              "type": "object"
            },
            {
              "description": "Behavior",
              "name": "Behavior",
              "supplementaryInformation": "WithThreeJS::LinkedCamera",
              "type": "behavior"
            }
          ],
          "objectGroups": []
        },
        {
          "fullName": "Is LinkAngle",
          "functionType": "Condition",
          "name": "LinkAngle",
          "private": true,
          "sentence": "Is Link Angle _PARAM0_",
          "events": [
            {
              "type": "BuiltinCommonInstructions::Standard",
              "conditions": [
                {
                  "type": {
                    "value": "WithThreeJS::LinkedCamera::PropertyLinkAngle"
                  },
                  "parameters": [
                    "Object",
                    "Behavior"
                  ]
                }
              ],
              "actions": [
                {
                  "type": {
                    "value": "SetReturnBoolean"
                  },
                  "parameters": [
                    "True"
                  ]
                }
              ]
            },
            {
              "type": "BuiltinCommonInstructions::Standard",
              "conditions": [
                {
                  "type": {
                    "inverted": true,
                    "value": "WithThreeJS::LinkedCamera::PropertyLinkAngle"
                  },
                  "parameters": [
                    "Object",
                    "Behavior"
                  ]
                }
              ],
              "actions": [
                {
                  "type": {
                    "value": "SetReturnBoolean"
                  },
                  "parameters": [
                    "False"
                  ]
                }
              ]
            }
          ],
          "parameters": [
            {
              "description": "Object",
              "name": "Object",
              "supplementaryInformation": "Sprite",
              "type": "object"
            },
            {
              "description": "Behavior",
              "name": "Behavior",
              "supplementaryInformation": "WithThreeJS::LinkedCamera",
              "type": "behavior"
            }
          ],
          "objectGroups": []
        },
        {
          "fullName": "Is Hide",
          "functionType": "Condition",
          "name": "Hide",
          "private": true,
          "sentence": "Is Hide _PARAM0_",
          "events": [
            {
              "type": "BuiltinCommonInstructions::Standard",
              "conditions": [
                {
                  "type": {
                    "value": "WithThreeJS::LinkedCamera::PropertyHide"
                  },
                  "parameters": [
                    "Object",
                    "Behavior"
                  ]
                }
              ],
              "actions": [
                {
                  "type": {
                    "value": "SetReturnBoolean"
                  },
                  "parameters": [
                    "True"
                  ]
                }
              ]
            },
            {
              "type": "BuiltinCommonInstructions::Standard",
              "conditions": [
                {
                  "type": {
                    "inverted": true,
                    "value": "WithThreeJS::LinkedCamera::PropertyHide"
                  },
                  "parameters": [
                    "Object",
                    "Behavior"
                  ]
                }
              ],
              "actions": [
                {
                  "type": {
                    "value": "SetReturnBoolean"
                  },
                  "parameters": [
                    "False"
                  ]
                }
              ]
            }
          ],
          "parameters": [
            {
              "description": "Object",
              "name": "Object",
              "supplementaryInformation": "Sprite",
              "type": "object"
            },
            {
              "description": "Behavior",
              "name": "Behavior",
              "supplementaryInformation": "WithThreeJS::LinkedCamera",
              "type": "behavior"
            }
          ],
          "objectGroups": []
        }
      ],
      "propertyDescriptors": [
        {
          "value": "1",
          "type": "Number",
          "label": "3D Camera ID (1 to 4)",
          "description": "Enter a number from 1 to 4. Up to four 3D Cameras can be installed. Use the \"Setup Multiple 3D Cameras\" action to switch 3D Cameras.",
          "group": "",
          "extraInformation": [],
          "name": "Id"
        },
        {
          "value": "50",
          "type": "Number",
          "label": "Field Of View",
          "description": "Default: 50",
          "group": "",
          "extraInformation": [],
          "name": "Fov"
        },
        {
          "value": "true",
          "type": "Boolean",
          "label": "Link Angle",
          "description": "Top Down: 2D Angle -> 3D Y axis or Side: 2D Angle -> 3D X axis",
          "group": "",
          "extraInformation": [],
          "name": "LinkAngle"
        },
        {
          "value": "true",
          "type": "Boolean",
          "label": "Hide 2D Object",
          "description": "",
          "group": "",
          "extraInformation": [],
          "name": "Hide"
        }
      ],
      "sharedPropertyDescriptors": []
    },
    {
      "description": "⚠️ 3D Lights are highly loaded.\nLink a Sprite object and  a 3D Light.",
      "fullName": "Linked 3D Light",
      "name": "LinkedLight",
      "objectType": "Sprite",
      "eventsFunctions": [
        {
          "fullName": "",
          "functionType": "Action",
          "name": "doStepPostEvents",
          "sentence": "",
          "events": [
            {
              "type": "BuiltinCommonInstructions::Standard",
              "conditions": [
                {
                  "type": {
                    "value": "WithThreeJS::LinkedLight::PropertyFirstFrame"
                  },
                  "parameters": [
                    "Object",
                    "Behavior"
                  ]
                }
              ],
              "actions": [
                {
                  "type": {
                    "value": "WithThreeJS::LinkedLight::SetPropertyFirstFrame"
                  },
                  "parameters": [
                    "Object",
                    "Behavior",
                    "no"
                  ]
                }
              ],
              "events": [
                {
                  "type": "BuiltinCommonInstructions::JsCode",
                  "inlineCode": [
                    "if (!gdjs.__WithThreeJS.has(\"Renderer\")) {",
                    "    console.warn(\"!\");",
                    "    return;",
                    "}",
                    "const Scene = gdjs.__WithThreeJS.get(\"Scene\");",
                    "const Renderer = gdjs.__WithThreeJS.get(\"Renderer\");",
                    "//",
                    "const Behavior = objects[0].getBehavior(eventsFunctionContext.getBehaviorName(\"Behavior\"));",
                    "const Id = objects[0].name + objects[0].id;",
                    "//",
                    "const LightType = Behavior._getType();",
                    "const Color = Behavior._getColor() || \"255;255;255\";",
                    "let Intensity = Behavior._getIntensity();",
                    "const Distance = Behavior._getDistance();",
                    "const Decay = 2;",
                    "const SpotAngle = Behavior._getSpotAngle();",
                    "const SpotPenumbra = Behavior._getSpotPenumbra();",
                    "const CastShadow = Behavior._getCastShadow();",
                    "const ShadowMapSize = gdjs.__WithThreeJS.get(\"ShadowMapSizeStringToValue\")[Behavior._getShadowMapSize()];",
                    "const ShadowRange = Behavior._getShadowRange();",
                    "const ShadowBias = Behavior._getShadowDepthBias();",
                    "const ShadowNormalBias = Behavior._getShadowNormalBias();",
                    "const LightHelper = Behavior._getLightHelper();",
                    "const ShadowHelper = Behavior._getShadowHelper();",
                    "//",
                    "const RGB = Color.split(\";\");",
                    "let Light;",
                    "if (LightType == \"Directional Light\") {",
                    "    Intensity *= gdjs.__WithThreeJS.get(\"LightIntensityScale\");// Three.js r160",
                    "    Light = new THREE.DirectionalLight(`rgb(${RGB[0]}, ${RGB[1]}, ${RGB[2]})`, Intensity);",
                    "    const Target = new THREE.Group();",
                    "    Target.translateZ(-128);",
                    "    Light.add(Target);",
                    "    Light.target = Target;",
                    "    //",
                    "    Light.shadow.camera.top = ShadowRange / 2;",
                    "    Light.shadow.camera.right = ShadowRange / 2;",
                    "    Light.shadow.camera.bottom = -ShadowRange / 2;",
                    "    Light.shadow.camera.left = -ShadowRange / 2;",
                    "    Light.shadow.camera.near = 0.5;// default",
                    "    Light.shadow.camera.far = ShadowRange;",
                    "    //",
                    "    if (LightHelper) {",
                    "        const DirectionalLightHelper = new THREE.DirectionalLightHelper(Light, 128);",
                    "        DirectionalLightHelper.name = Id + \"_DirectionalLightHelper\";",
                    "        Scene.add(DirectionalLightHelper);",
                    "    }",
                    "} else if (LightType == \"Spot Light\") {",
                    "    Intensity *= gdjs.__WithThreeJS.get(\"LightIntensityCandela\");// Three.js r160",
                    "    Light = new THREE.SpotLight(`rgb(${RGB[0]}, ${RGB[1]}, ${RGB[2]})`, Intensity, Distance, gdjs.toRad(SpotAngle), SpotPenumbra, Decay);",
                    "    const Target = new THREE.Group();",
                    "    Target.translateZ(-1);",
                    "    Light.add(Target);",
                    "    Light.target = Target;",
                    "    //",
                    "    Light.shadow.camera.near = 0.5;// default",
                    "    Light.shadow.camera.far = ShadowRange;",
                    "    Light.shadow.focus = 1; // default",
                    "    //",
                    "    if (LightHelper) {",
                    "        const SpotLightHelper = new THREE.SpotLightHelper(Light);",
                    "        SpotLightHelper.name = Id + \"_SpotLightHelper\";",
                    "        Scene.add(SpotLightHelper);",
                    "    }",
                    "} else {",
                    "    // Point",
                    "    Intensity *= gdjs.__WithThreeJS.get(\"LightIntensityCandela\");// Three.js r160",
                    "    Light = new THREE.PointLight(`rgb(${RGB[0]}, ${RGB[1]}, ${RGB[2]})`, Intensity, Distance, Decay);",
                    "    //",
                    "    Light.shadow.camera.near = 0.5;// default",
                    "    Light.shadow.camera.far = ShadowRange;",
                    "    //",
                    "    if (LightHelper) {",
                    "        const PointLightHelper = new THREE.PointLightHelper(Light, 16);",
                    "        PointLightHelper.name = Id + \"_PointLightHelper\";",
                    "        Scene.add(PointLightHelper);",
                    "    }",
                    "}",
                    "Renderer.shadowMap.enabled = Renderer.shadowMap.enabled ? true : CastShadow;",
                    "Light.castShadow = CastShadow;",
                    "Light.shadow.mapSize.width = ShadowMapSize;",
                    "Light.shadow.mapSize.height = ShadowMapSize;",
                    "Light.shadow.bias = ShadowBias;",
                    "Light.shadow.normalBias = ShadowNormalBias;",
                    "Light.shadow.updateMatrices(Light);// 必須",
                    "Light.shadow.camera.updateProjectionMatrix();",
                    "//",
                    "Light.name = Id;",
                    "Behavior._setId(Id);",
                    "Light.userData.Use3DProjectionBehavior = true;",
                    "Scene.add(Light);",
                    "//",
                    "if (ShadowHelper && CastShadow) {",
                    "    let CameraHelper;",
                    "    if (LightType != \"Point Light\") {",
                    "        CameraHelper = new THREE.CameraHelper(Light.shadow.camera);",
                    "        Scene.add(CameraHelper);",
                    "    } else {",
                    "        const Geometry = new THREE.IcosahedronGeometry(Light.shadow.camera.far, 2); ",
                    "        const Material = new THREE.MeshBasicMaterial( {color: 0xffaa00, wireframe: true} );",
                    "        CameraHelper = new THREE.Mesh(Geometry, Material);",
                    "        Light.add(CameraHelper);",
                    "    }",
                    "    CameraHelper.name = Id + \"_CameraHelper\";",
                    "}",
                    "",
                    ""
                  ],
                  "parameterObjects": "Object",
                  "useStrict": true,
                  "eventsSheetExpanded": true
                },
                {
                  "type": "BuiltinCommonInstructions::Standard",
                  "conditions": [
                    {
                      "type": {
                        "value": "WithThreeJS::LinkedLight::PropertyHide"
                      },
                      "parameters": [
                        "Object",
                        "Behavior"
                      ]
                    }
                  ],
                  "actions": [
                    {
                      "type": {
                        "value": "Cache"
                      },
                      "parameters": [
                        "Object"
                      ]
                    }
                  ]
                }
              ]
            },
            {
              "type": "BuiltinCommonInstructions::JsCode",
              "inlineCode": [
                "if (!gdjs.__WithThreeJS.has(\"Renderer\")) {\r",
                "    console.warn(\"!\");\r",
                "    return;\r",
                "}\r",
                "const Scene = gdjs.__WithThreeJS.get(\"Scene\");\r",
                "//\r",
                "const Behavior = objects[0].getBehavior(eventsFunctionContext.getBehaviorName(\"Behavior\"));\r",
                "const Id = Behavior.Id();\r",
                "const Tilt = Behavior.Tilt();\r",
                "const X = objects[0].getCenterXInScene();\r",
                "const Y = objects[0].getCenterYInScene();\r",
                "const Z = objects[0].zOrder;\r",
                "const ProjectionScale = gdjs.__WithThreeJS.get(\"ProjectionScale\");\r",
                "const ViewMode = gdjs.__WithThreeJS.get(\"ViewMode\");\r",
                "//\r",
                "const Obj = gdjs.__WithThreeJS.get(\"SearchObject\")(Id);\r",
                "if (!Obj) {\r",
                "    console.warn(\"3D Object not found: \" + Id);\r",
                "    return;\r",
                "}\r",
                "// Move & Rotate\r",
                "const Angle = objects[0].angle;\r",
                "if (ViewMode == \"Top Down\") {\r",
                "    Obj.position.set(X * ProjectionScale, Z * ProjectionScale, Y * ProjectionScale);\r",
                "    Obj.rotation.set(gdjs.toRad(0), gdjs.toRad((Angle + 90) * -1), gdjs.toRad(0));\r",
                "    Obj.rotateX(gdjs.toRad(Tilt));\r",
                "} else {\r",
                "    // Side\r",
                "    Obj.position.set(X * ProjectionScale, -Y * ProjectionScale, Z * ProjectionScale);\r",
                "    Obj.rotation.set(0, gdjs.toRad(-90), gdjs.toRad(0));\r",
                "    Obj.rotateY(gdjs.toRad(Tilt));\r",
                "    Obj.rotateX(gdjs.toRad(Angle * -1));\r",
                "}\r",
                "\r",
                ""
              ],
              "parameterObjects": "Object",
              "useStrict": true,
              "eventsSheetExpanded": true
            }
          ],
          "parameters": [
            {
              "description": "Object",
              "name": "Object",
              "supplementaryInformation": "Sprite",
              "type": "object"
            },
            {
              "description": "Behavior",
              "name": "Behavior",
              "supplementaryInformation": "WithThreeJS::LinkedLight",
              "type": "behavior"
            }
          ],
          "objectGroups": []
        },
        {
          "fullName": "",
          "functionType": "Action",
          "name": "onDestroy",
          "sentence": "",
          "events": [
            {
              "type": "BuiltinCommonInstructions::JsCode",
              "inlineCode": [
                "// 生成と同時に削除された場合、3D化されていないので回避\r",
                "// FirstFrame == true のほうが理想的だが取得がめんどくさいので Id を利用。\r",
                "const Behavior = objects[0].getBehavior(eventsFunctionContext.getBehaviorName(\"Behavior\"));\r",
                "const Id = Behavior.Id();\r",
                "if (Id === \"\") {\r",
                "    return;\r",
                "}\r",
                "//\r",
                "if (!gdjs.__WithThreeJS.has(\"Renderer\")) {\r",
                "    console.warn(\"!\");\r",
                "    return;\r",
                "}\r",
                "const Scene = gdjs.__WithThreeJS.get(\"Scene\");\r",
                "const Obj = gdjs.__WithThreeJS.get(\"SearchObject\")(Id);\r",
                "const CastShadow = Behavior._getCastShadow();\r",
                "//\r",
                "gdjs.__WithThreeJS.get(\"DisposeChildren\")(Obj);\r",
                "Obj.removeFromParent();\r",
                "\r",
                ""
              ],
              "parameterObjects": "Object",
              "useStrict": true,
              "eventsSheetExpanded": true
            }
          ],
          "parameters": [
            {
              "description": "Object",
              "name": "Object",
              "supplementaryInformation": "Sprite",
              "type": "object"
            },
            {
              "description": "Behavior",
              "name": "Behavior",
              "supplementaryInformation": "WithThreeJS::LinkedLight",
              "type": "behavior"
            }
          ],
          "objectGroups": []
        },
        {
          "fullName": "3D Object ID",
          "functionType": "StringExpression",
          "name": "Id",
          "sentence": "",
          "events": [
            {
              "type": "BuiltinCommonInstructions::Standard",
              "conditions": [],
              "actions": [
                {
                  "type": {
                    "value": "SetReturnString"
                  },
                  "parameters": [
                    "Object.Behavior::PropertyId()"
                  ]
                }
              ]
            }
          ],
          "expressionType": {
            "type": "string"
          },
          "parameters": [
            {
              "description": "Object",
              "name": "Object",
              "supplementaryInformation": "Sprite",
              "type": "object"
            },
            {
              "description": "Behavior",
              "name": "Behavior",
              "supplementaryInformation": "WithThreeJS::LinkedLight",
              "type": "behavior"
            }
          ],
          "objectGroups": []
        },
        {
          "fullName": "Type",
          "functionType": "StringExpression",
          "name": "Type",
          "sentence": "",
          "events": [
            {
              "type": "BuiltinCommonInstructions::Standard",
              "conditions": [],
              "actions": [
                {
                  "type": {
                    "value": "SetReturnString"
                  },
                  "parameters": [
                    "Object.Behavior::PropertyType()"
                  ]
                }
              ]
            }
          ],
          "expressionType": {
            "type": "stringWithSelector"
          },
          "parameters": [
            {
              "description": "Object",
              "name": "Object",
              "supplementaryInformation": "Sprite",
              "type": "object"
            },
            {
              "description": "Behavior",
              "name": "Behavior",
              "supplementaryInformation": "WithThreeJS::LinkedLight",
              "type": "behavior"
            }
          ],
          "objectGroups": []
        },
        {
          "fullName": "Tilt",
          "functionType": "Expression",
          "name": "Tilt",
          "sentence": "",
          "events": [
            {
              "type": "BuiltinCommonInstructions::Standard",
              "conditions": [],
              "actions": [
                {
                  "type": {
                    "value": "SetReturnNumber"
                  },
                  "parameters": [
                    "Object.Behavior::PropertyTilt()"
                  ]
                }
              ]
            }
          ],
          "expressionType": {
            "type": "expression"
          },
          "parameters": [
            {
              "description": "Object",
              "name": "Object",
              "supplementaryInformation": "Sprite",
              "type": "object"
            },
            {
              "description": "Behavior",
              "name": "Behavior",
              "supplementaryInformation": "WithThreeJS::LinkedLight",
              "type": "behavior"
            }
          ],
          "objectGroups": []
        },
        {
          "fullName": "Set Tilt",
          "functionType": "Action",
          "name": "SetTilt",
          "private": true,
          "sentence": "Set Tilt (_PARAM0_, Value: _PARAM2_)",
          "events": [
            {
              "type": "BuiltinCommonInstructions::Standard",
              "conditions": [],
              "actions": [
                {
                  "type": {
                    "value": "WithThreeJS::LinkedLight::SetPropertyTilt"
                  },
                  "parameters": [
                    "Object",
                    "Behavior",
                    "=",
                    "GetArgumentAsNumber(\"Value\")"
                  ]
                }
              ]
            }
          ],
          "parameters": [
            {
              "description": "Object",
              "name": "Object",
              "supplementaryInformation": "Sprite",
              "type": "object"
            },
            {
              "description": "Behavior",
              "name": "Behavior",
              "supplementaryInformation": "WithThreeJS::LinkedLight",
              "type": "behavior"
            },
            {
              "description": "Tilt Value (Recommended: -90 to 90)",
              "name": "Value",
              "type": "expression"
            }
          ],
          "objectGroups": []
        }
      ],
      "propertyDescriptors": [
        {
          "value": "",
          "type": "String",
          "label": "",
          "description": "",
          "group": "",
          "extraInformation": [],
          "hidden": true,
          "name": "Id"
        },
        {
          "value": "true",
          "type": "Boolean",
          "label": "",
          "description": "",
          "group": "",
          "extraInformation": [],
          "hidden": true,
          "name": "FirstFrame"
        },
        {
          "value": "true",
          "type": "Boolean",
          "label": "Hide 2D Object",
          "description": "",
          "group": "",
          "extraInformation": [],
          "name": "Hide"
        },
        {
          "value": "Directional Light",
          "type": "Choice",
          "label": "Type",
          "description": "",
          "group": "",
          "extraInformation": [
            "Directional Light",
            "Point Light",
            "Spot Light"
          ],
          "name": "Type"
        },
        {
          "value": "255;255;255",
          "type": "Color",
          "label": "Color",
          "description": "",
          "group": "",
          "extraInformation": [],
          "name": "Color"
        },
        {
          "value": "1",
          "type": "Number",
          "label": "Intensity (Default: 1)",
          "description": "",
          "group": "",
          "extraInformation": [],
          "name": "Intensity"
        },
        {
          "value": "0",
          "type": "Number",
          "label": "Distance (Default: 0)",
          "description": "For Point and Spot Lights. 0 is no limit.",
          "group": "",
          "extraInformation": [],
          "name": "Distance"
        },
        {
          "value": "45",
          "type": "Number",
          "label": "Spot Angle (0 to 180)",
          "description": "For Spot Lights. The narrower the angle, the better the shadow quality. If it is a multiple of 90, the shadow will not be cast correctly.",
          "group": "",
          "extraInformation": [],
          "name": "SpotAngle"
        },
        {
          "value": "0.5",
          "type": "Number",
          "label": "Spot Penumbra (0 to 1)",
          "description": "For Spot Lights.",
          "group": "",
          "extraInformation": [],
          "name": "SpotPenumbra"
        },
        {
          "value": "0",
          "type": "Number",
          "label": "Tilt (Recommended: -90 to 90)",
          "description": "",
          "group": "",
          "extraInformation": [],
          "name": "Tilt"
        },
        {
          "value": "",
          "type": "Boolean",
          "label": "Cast Shadow",
          "description": "⚠️ This is expensive and requires tweaking to get shadows looking right.",
          "group": "Shadow",
          "extraInformation": [],
          "name": "CastShadow"
        },
        {
          "value": "512px",
          "type": "Choice",
          "label": "Shadow Map Size",
          "description": "The larger the map, the better the shadow quality, but the greater the load.",
          "group": "Shadow",
          "extraInformation": [
            "128px",
            "256px",
            "512px",
            "1024px",
            "2048px"
          ],
          "name": "ShadowMapSize"
        },
        {
          "value": "256",
          "type": "Number",
          "label": "Range to Draw Shadows",
          "description": "The smaller the range, the better the shadow quality. For Point and Spot Lights, this value is valid only if the Distance is 0.",
          "group": "Shadow",
          "extraInformation": [],
          "name": "ShadowRange"
        },
        {
          "value": "0.002",
          "type": "Number",
          "label": "Shadow Depth Bias (Default: 0.002)",
          "description": "It is mainly effective for filling gaps between objects and shadows. Reference value: [Directional Light: 0.002] [Point Light: 0.001] [Spot Light: 0.00001]",
          "group": "Shadow Bias",
          "extraInformation": [],
          "name": "ShadowDepthBias"
        },
        {
          "value": "2",
          "type": "Number",
          "label": "Shadow Normal Bias (Default: 2)",
          "description": "It is mainly effective in reducing striped patterns. Reference value: [Directional Light: 2] [Point Light: 1] [Spot Light: 1]",
          "group": "Shadow Bias",
          "extraInformation": [],
          "name": "ShadowNormalBias"
        },
        {
          "value": "",
          "type": "Boolean",
          "label": "Light Helper",
          "description": "",
          "group": "Helper",
          "extraInformation": [],
          "name": "LightHelper"
        },
        {
          "value": "",
          "type": "Boolean",
          "label": "Shadow Range Helper",
          "description": "",
          "group": "Helper",
          "extraInformation": [],
          "name": "ShadowHelper"
        }
      ],
      "sharedPropertyDescriptors": []
    }
  ],
  "eventsBasedObjects": [
    {
      "areaMaxX": 64,
      "areaMaxY": 64,
      "areaMaxZ": 64,
      "areaMinX": 0,
      "areaMinY": 0,
      "areaMinZ": 0,
      "defaultName": "My3DBox",
      "description": "This 3D Box can have different textures on 6 faces.\n⚠️ This object is high load.",
      "fullName": "3D Box",
      "is3D": true,
      "isUsingLegacyInstancesRenderer": true,
      "name": "Box3D",
      "eventsFunctions": [
        {
          "fullName": "",
          "functionType": "Action",
          "name": "onCreated",
          "sentence": "",
          "events": [
            {
              "type": "BuiltinCommonInstructions::Standard",
              "conditions": [],
              "actions": [
                {
                  "type": {
                    "value": "Create"
                  },
                  "parameters": [
                    "",
                    "Front",
                    "0",
                    "0",
                    "\"\""
                  ]
                }
              ]
            },
            {
              "type": "BuiltinCommonInstructions::Standard",
              "conditions": [
                {
                  "type": {
                    "value": "WithThreeJS::Box3D::PropertyHide"
                  },
                  "parameters": [
                    "Object"
                  ]
                }
              ],
              "actions": [
                {
                  "type": {
                    "value": "Cache"
                  },
                  "parameters": [
                    "Object"
                  ]
                }
              ]
            }
          ],
          "parameters": [
            {
              "description": "Object",
              "name": "Object",
              "supplementaryInformation": "WithThreeJS::Box3D",
              "type": "object"
            }
          ],
          "objectGroups": []
        },
        {
          "fullName": "",
          "functionType": "Action",
          "name": "doStepPostEvents",
          "sentence": "",
          "events": [
            {
              "type": "BuiltinCommonInstructions::JsCode",
              "inlineCode": [
                "const Obj2D = objects[0];\r",
                "if (!gdjs.__WithThreeJS.has(\"Renderer\") || !gdjs.__WithThreeJS.get(\"SceneIsReady\")) {\r",
                "    // 【!】PostEventなのにシーンイベントよりも早く処理が実行される問題がある。\r",
                "    // console.warn(\"! (3D Box Object)\");\r",
                "    return;\r",
                "}\r",
                "const Scene = gdjs.__WithThreeJS.get(\"Scene\");\r",
                "//\r",
                "if (Obj2D._getFirstFrame()) {\r",
                "    Obj2D._setFirstFrame(false);\r",
                "    //\r",
                "    if (!gdjs.__WithThreeJS.has(\"Textures\")) {\r",
                "        gdjs.__WithThreeJS.set(\"Textures\", new Map());\r",
                "    }\r",
                "    const Textures = gdjs.__WithThreeJS.get(\"Textures\");\r",
                "    //\r",
                "    const Id = Obj2D.name + Obj2D.id;\r",
                "    const Width = Obj2D.getWidth();\r",
                "    const Height = Obj2D.getHeight();\r",
                "    const Depth = Obj2D._getDepth();\r",
                "    const ProjectionScale = gdjs.__WithThreeJS.get(\"ProjectionScale\");\r",
                "    const ViewMode = gdjs.__WithThreeJS.get(\"ViewMode\");\r",
                "    const AlphaTest = Obj2D._getAlphaTest();\r",
                "    const Transparent = AlphaTest !== 0;\r",
                "    const AntiAliasing = Obj2D._getAntiAliasing();\r",
                "    let Blend = THREE.NormalBlending;\r",
                "    if (Obj2D._getBlend() == \"Additive\") {\r",
                "        Blend = THREE.AdditiveBlending;\r",
                "    } else if (Obj2D._getBlend() == \"Subtractive\") {\r",
                "        Blend = THREE.SubtractiveBlending;\r",
                "    } else if (Obj2D._getBlend() == \"Multiply\") {\r",
                "        Blend = THREE.MultiplyBlending;\r",
                "    }\r",
                "    const CastShadow = Obj2D._getCastShadow();\r",
                "    const ReceiveShadow = Obj2D._getReceiveShadow();\r",
                "    //\r",
                "    const Items = Obj2D._instanceContainer._objects.items;\r",
                "    const ResourceNameTop = Items.Top.texture;\r",
                "    const ResourceNameBottom = Items.Bottom.texture;\r",
                "    const ResourceNameFront = Items.Front.texture;\r",
                "    const ResourceNameBack = Items.Back.texture;\r",
                "    const ResourceNameLeft = Items.Left.texture;\r",
                "    const ResourceNameRight = Items.Right.texture;\r",
                "    if (ResourceNameTop == \"\" || ResourceNameBottom == \"\" || ResourceNameFront == \"\" || ResourceNameBack == \"\" || ResourceNameLeft == \"\" || ResourceNameRight == \"\") {\r",
                "        console.warn(\"Some faces have no image.\");\r",
                "        return;\r",
                "    }\r",
                "    const ResourceTop = runtimeScene.getGame().getImageManager().getPIXITexture(ResourceNameTop).baseTexture.resource;\r",
                "    const ResourceBottom = runtimeScene.getGame().getImageManager().getPIXITexture(ResourceNameBottom).baseTexture.resource;\r",
                "    const ResourceFront = runtimeScene.getGame().getImageManager().getPIXITexture(ResourceNameFront).baseTexture.resource;\r",
                "    const ResourceBack = runtimeScene.getGame().getImageManager().getPIXITexture(ResourceNameBack).baseTexture.resource;\r",
                "    const ResourceLeft = runtimeScene.getGame().getImageManager().getPIXITexture(ResourceNameLeft).baseTexture.resource;\r",
                "    const ResourceRight = runtimeScene.getGame().getImageManager().getPIXITexture(ResourceNameRight).baseTexture.resource;\r",
                "    //\r",
                "    Obj2D._setTextureIdTop(\"_\" + Id + \"_\" + ResourceTop.url + \"_Top\");\r",
                "    Obj2D._setTextureIdBottom(\"_\" + Id + \"_\" + ResourceBottom.url + \"_Bottom\");\r",
                "    Obj2D._setTextureIdFront(\"_\" + Id + \"_\" + ResourceFront.url + \"_Front\");\r",
                "    Obj2D._setTextureIdBack(\"_\" + Id + \"_\" + ResourceBack.url + \"_Back\");\r",
                "    Obj2D._setTextureIdLeft(\"_\" + Id + \"_\" + ResourceLeft.url + \"_Left\");\r",
                "    Obj2D._setTextureIdRight(\"_\" + Id + \"_\" + ResourceRight.url + \"_Right\");\r",
                "    //\r",
                "    let RepeatTopU, RepeatTopV;\r",
                "    let RepeatBottomU, RepeatBottomV;\r",
                "    let RepeatFrontU, RepeatFrontV;\r",
                "    let RepeatBackU, RepeatBackV;\r",
                "    let RepeatLeftU, RepeatLeftV;\r",
                "    let RepeatRightU, RepeatRightV;\r",
                "    if (ViewMode == \"Top Down\") {\r",
                "        RepeatTopU = Width / ResourceTop.width;\r",
                "        RepeatTopV = Height / ResourceTop.height;\r",
                "        RepeatBottomU = Width / ResourceBottom.width;\r",
                "        RepeatBottomV = Height / ResourceBottom.height;\r",
                "        //\r",
                "        RepeatFrontU = Width / ResourceFront.width;\r",
                "        RepeatFrontV = Depth / ResourceFront.height;\r",
                "        RepeatBackU = Width / ResourceBack.width;\r",
                "        RepeatBackV = Depth / ResourceBack.height;\r",
                "        //\r",
                "        RepeatLeftU = Height / ResourceLeft.width;\r",
                "        RepeatLeftV = Depth / ResourceLeft.height;\r",
                "        RepeatRightU = Height / ResourceRight.width;\r",
                "        RepeatRightV = Depth / ResourceRight.height;\r",
                "    } else {\r",
                "        // Side\r",
                "        RepeatTopU = Width / ResourceTop.width;\r",
                "        RepeatTopV = Depth / ResourceTop.height;\r",
                "        RepeatBottomU = Width / ResourceBottom.width;\r",
                "        RepeatBottomV = Depth / ResourceBottom.height;\r",
                "        //\r",
                "        RepeatFrontU = Width / ResourceFront.width;\r",
                "        RepeatFrontV = Height / ResourceFront.height;\r",
                "        RepeatBackU = Width / ResourceBack.width;\r",
                "        RepeatBackV = Height / ResourceBack.height;\r",
                "        //\r",
                "        RepeatLeftU = Depth / ResourceLeft.width;\r",
                "        RepeatLeftV = Height / ResourceLeft.height;\r",
                "        RepeatRightU = Depth / ResourceRight.width;\r",
                "        RepeatRightV = Height / ResourceRight.height;\r",
                "    }\r",
                "    // Offset\r",
                "    Obj2D._setTopOffsetV(1 - (RepeatTopV % 1));\r",
                "    Obj2D._setBottomOffsetV(1 - (RepeatBottomV % 1));\r",
                "    Obj2D._setFrontOffsetV(1 - (RepeatFrontV % 1));\r",
                "    Obj2D._setBackOffsetV(1 - (RepeatBackV % 1));\r",
                "    Obj2D._setLeftOffsetV(1 - (RepeatLeftV % 1));\r",
                "    Obj2D._setRightOffsetV(1 - (RepeatRightV % 1));\r",
                "    //\r",
                "    const TextureTop = new THREE.Texture();\r",
                "    TextureTop.image = ResourceTop.source;\r",
                "    TextureTop.wrapS = THREE.RepeatWrapping;\r",
                "    TextureTop.wrapT = THREE.RepeatWrapping;\r",
                "    if (!AntiAliasing) {\r",
                "        TextureTop.magFilter = THREE.NearestFilter;// THREE.LinearFilter\r",
                "        TextureTop.minFilter = THREE.NearestFilter;// THREE.LinearMipmapLinearFilter\r",
                "    }\r",
                "    TextureTop.repeat.set(RepeatTopU, RepeatTopV);\r",
                "    TextureTop.offset.set(0, Obj2D._getTopOffsetV());\r",
                "    TextureTop.colorSpace = THREE.SRGBColorSpace;\r",
                "    TextureTop.needsUpdate = true;//必須\r",
                "    Textures.set(Obj2D._getTextureIdTop(), TextureTop);\r",
                "    //\r",
                "    const TextureBottom = new THREE.Texture();\r",
                "    TextureBottom.image = ResourceBottom.source;\r",
                "    TextureBottom.wrapS = THREE.RepeatWrapping;\r",
                "    TextureBottom.wrapT = THREE.RepeatWrapping;\r",
                "    if (!AntiAliasing) {\r",
                "        TextureBottom.magFilter = THREE.NearestFilter;// THREE.LinearFilter\r",
                "        TextureBottom.minFilter = THREE.NearestFilter;// THREE.LinearMipmapLinearFilter\r",
                "    }\r",
                "    TextureBottom.repeat.set(RepeatBottomU, RepeatBottomV);\r",
                "    TextureBottom.offset.set(0, Obj2D._getBottomOffsetV());\r",
                "    TextureBottom.colorSpace = THREE.SRGBColorSpace;\r",
                "    TextureBottom.needsUpdate = true;//必須\r",
                "    Textures.set(Obj2D._getTextureIdBottom(), TextureBottom);\r",
                "    //\r",
                "    const TextureFront = new THREE.Texture();\r",
                "    TextureFront.image = ResourceFront.source;\r",
                "    TextureFront.wrapS = THREE.RepeatWrapping;\r",
                "    TextureFront.wrapT = THREE.RepeatWrapping;\r",
                "    if (!AntiAliasing) {\r",
                "        TextureFront.magFilter = THREE.NearestFilter;// THREE.LinearFilter\r",
                "        TextureFront.minFilter = THREE.NearestFilter;// THREE.LinearMipmapLinearFilter\r",
                "    }\r",
                "    TextureFront.repeat.set(RepeatFrontU, RepeatFrontV);\r",
                "    TextureFront.offset.set(0, Obj2D._getFrontOffsetV());\r",
                "    TextureFront.colorSpace = THREE.SRGBColorSpace;\r",
                "    TextureFront.needsUpdate = true;//必須\r",
                "    Textures.set(Obj2D._getTextureIdFront(), TextureFront);\r",
                "    //\r",
                "    const TextureBack = new THREE.Texture();\r",
                "    TextureBack.image = ResourceBack.source;\r",
                "    TextureBack.wrapS = THREE.RepeatWrapping;\r",
                "    TextureBack.wrapT = THREE.RepeatWrapping;\r",
                "    if (!AntiAliasing) {\r",
                "        TextureBack.magFilter = THREE.NearestFilter;// THREE.LinearFilter\r",
                "        TextureBack.minFilter = THREE.NearestFilter;// THREE.LinearMipmapLinearFilter\r",
                "    }\r",
                "    TextureBack.repeat.set(RepeatBackU, RepeatBackV);\r",
                "    TextureBack.offset.set(0, Obj2D._getBackOffsetV());\r",
                "    TextureBack.colorSpace = THREE.SRGBColorSpace;\r",
                "    TextureBack.needsUpdate = true;//必須\r",
                "    Textures.set(Obj2D._getTextureIdBack(), TextureBack);\r",
                "    //\r",
                "    const TextureLeft = new THREE.Texture();\r",
                "    TextureLeft.image = ResourceLeft.source;\r",
                "    TextureLeft.wrapS = THREE.RepeatWrapping;\r",
                "    TextureLeft.wrapT = THREE.RepeatWrapping;\r",
                "    if (!AntiAliasing) {\r",
                "        TextureLeft.magFilter = THREE.NearestFilter;// THREE.LinearFilter\r",
                "        TextureLeft.minFilter = THREE.NearestFilter;// THREE.LinearMipmapLinearFilter\r",
                "    }\r",
                "    TextureLeft.repeat.set(RepeatLeftU, RepeatLeftV);\r",
                "    TextureLeft.offset.set(0, Obj2D._getLeftOffsetV());\r",
                "    TextureLeft.colorSpace = THREE.SRGBColorSpace;\r",
                "    TextureLeft.needsUpdate = true;//必須\r",
                "    Textures.set(Obj2D._getTextureIdLeft(), TextureLeft);\r",
                "    //\r",
                "    const TextureRight = new THREE.Texture();\r",
                "    TextureRight.image = ResourceRight.source;\r",
                "    TextureRight.wrapS = THREE.RepeatWrapping;\r",
                "    TextureRight.wrapT = THREE.RepeatWrapping;\r",
                "    if (!AntiAliasing) {\r",
                "        TextureRight.magFilter = THREE.NearestFilter;// THREE.LinearFilter\r",
                "        TextureRight.minFilter = THREE.NearestFilter;// THREE.LinearMipmapLinearFilter\r",
                "    }\r",
                "    TextureRight.repeat.set(RepeatRightU, RepeatRightV);\r",
                "    TextureRight.offset.set(0, Obj2D._getRightOffsetV());\r",
                "    TextureRight.colorSpace = THREE.SRGBColorSpace;\r",
                "    TextureRight.needsUpdate = true;//必須\r",
                "    Textures.set(Obj2D._getTextureIdRight(), TextureRight);\r",
                "    //\r",
                "    // const MaterialTop = new THREE.MeshBasicMaterial({map: TextureTop, transparent:Transparent, alphaTest:AlphaTest, blending:Blend});\r",
                "    // const MaterialBottom = new THREE.MeshBasicMaterial({map: TextureBottom, transparent:Transparent, alphaTest:AlphaTest, blending:Blend});\r",
                "    // const MaterialFront = new THREE.MeshBasicMaterial({map: TextureFront, transparent:Transparent, alphaTest:AlphaTest, blending:Blend});\r",
                "    // const MaterialBack = new THREE.MeshBasicMaterial({map: TextureBack, transparent:Transparent, alphaTest:AlphaTest, blending:Blend});\r",
                "    // const MaterialLeft = new THREE.MeshBasicMaterial({map: TextureLeft, transparent:Transparent, alphaTest:AlphaTest, blending:Blend});\r",
                "    // const MaterialRight = new THREE.MeshBasicMaterial({map: TextureRight, transparent:Transparent, alphaTest:AlphaTest, blending:Blend});\r",
                "    const MaterialTop = new THREE.MeshLambertMaterial({map: TextureTop, transparent:Transparent, alphaTest:AlphaTest, blending:Blend});\r",
                "    const MaterialBottom = new THREE.MeshLambertMaterial({map: TextureBottom, transparent:Transparent, alphaTest:AlphaTest, blending:Blend});\r",
                "    const MaterialFront = new THREE.MeshLambertMaterial({map: TextureFront, transparent:Transparent, alphaTest:AlphaTest, blending:Blend});\r",
                "    const MaterialBack = new THREE.MeshLambertMaterial({map: TextureBack, transparent:Transparent, alphaTest:AlphaTest, blending:Blend});\r",
                "    const MaterialLeft = new THREE.MeshLambertMaterial({map: TextureLeft, transparent:Transparent, alphaTest:AlphaTest, blending:Blend});\r",
                "    const MaterialRight = new THREE.MeshLambertMaterial({map: TextureRight, transparent:Transparent, alphaTest:AlphaTest, blending:Blend});\r",
                "    //\r",
                "    const Material = [MaterialLeft, MaterialRight, MaterialTop, MaterialBottom, MaterialFront, MaterialBack];\r",
                "    let Geometry;\r",
                "    if (ViewMode == \"Top Down\") {\r",
                "        Geometry = new THREE.BoxGeometry(Width * ProjectionScale, Depth * ProjectionScale, Height * ProjectionScale);\r",
                "    } else {\r",
                "        // Side\r",
                "        Geometry = new THREE.BoxGeometry(Width * ProjectionScale, Height * ProjectionScale, Depth * ProjectionScale);\r",
                "    }\r",
                "    Geometry.computeBoundingBox();\r",
                "    const Obj3D = new THREE.Mesh(Geometry, Material);\r",
                "    Obj3D.name = Id;\r",
                "    Obj3D.castShadow = CastShadow;\r",
                "    Obj3D.receiveShadow = ReceiveShadow;\r",
                "    Obj3D.userData.Use3DProjectionBehavior = true;\r",
                "    Obj2D._setId(Id);\r",
                "    Scene.add(Obj3D);\r",
                "}\r",
                "// ====================================\r",
                "const Id = Obj2D._getId();\r",
                "const X = Obj2D.getCenterXInScene();\r",
                "const Y = Obj2D.getCenterYInScene();\r",
                "const Z = Obj2D.zOrder;\r",
                "const Angle = Obj2D.angle;\r",
                "const Opacity = Obj2D.getOpacity() / 255;\r",
                "const ProjectionScale = gdjs.__WithThreeJS.get(\"ProjectionScale\");\r",
                "const ViewMode = gdjs.__WithThreeJS.get(\"ViewMode\");\r",
                "//\r",
                "const Obj3D = gdjs.__WithThreeJS.get(\"SearchObject\")(Id);\r",
                "if (!Obj3D) {\r",
                "    console.warn(\"3D Object not found: \" + Id);\r",
                "    return;\r",
                "}\r",
                "// Move & Rotate\r",
                "if (ViewMode == \"Top Down\") {\r",
                "    Obj3D.position.set(X * ProjectionScale, Z * ProjectionScale, Y * ProjectionScale);\r",
                "    Obj3D.rotation.set(gdjs.toRad(0), gdjs.toRad(Angle * -1), gdjs.toRad(0));\r",
                "} else {\r",
                "    // Side\r",
                "    Obj3D.position.set(X * ProjectionScale, -Y * ProjectionScale, Z * ProjectionScale);\r",
                "    Obj3D.rotation.set(gdjs.toRad(0), gdjs.toRad(0), gdjs.toRad(Angle * -1));\r",
                "}\r",
                "// Opacity\r",
                "for (let i = 0; i < Obj3D.material.length; i++) {\r",
                "    if (!Obj3D.material[i].transparent) {\r",
                "        if (Obj3D.material[i].alphaTest !== 0 || Opacity !== 1) {\r",
                "            Obj3D.material[i].transparent = true;\r",
                "            Obj3D.material[i].needsUpdate = true;\r",
                "        }\r",
                "    }\r",
                "    Obj3D.material[i].opacity = Opacity;\r",
                "}\r",
                "\r",
                ""
              ],
              "parameterObjects": "Object",
              "useStrict": true,
              "eventsSheetExpanded": true
            }
          ],
          "parameters": [
            {
              "description": "Object",
              "name": "Object",
              "supplementaryInformation": "WithThreeJS::Box3D",
              "type": "object"
            }
          ],
          "objectGroups": []
        },
        {
          "fullName": "",
          "functionType": "Action",
          "name": "onDestroy",
          "sentence": "",
          "events": [
            {
              "type": "BuiltinCommonInstructions::JsCode",
              "inlineCode": [
                "// 生成と同時に削除された場合、3D化されていないので回避\r",
                "const Obj2D = objects[0];\r",
                "if (Obj2D._getFirstFrame()) {\r",
                "    return;\r",
                "}\r",
                "//\r",
                "if (!gdjs.__WithThreeJS.has(\"Renderer\")) {\r",
                "    console.warn(\"!\");\r",
                "    return;\r",
                "}\r",
                "const Scene = gdjs.__WithThreeJS.get(\"Scene\");\r",
                "const Textures = gdjs.__WithThreeJS.get(\"Textures\");\r",
                "const Id = Obj2D._getId();\r",
                "const Obj3D = gdjs.__WithThreeJS.get(\"SearchObject\")(Id);\r",
                "if (!Obj3D) {\r",
                "    console.warn(\"3D Object not found.\");\r",
                "    return;\r",
                "}\r",
                "// Texture dispose\r",
                "Textures.get(Obj2D._getTextureIdTop()).dispose();\r",
                "Textures.delete(Obj2D._getTextureIdTop());\r",
                "Textures.get(Obj2D._getTextureIdBottom()).dispose();\r",
                "Textures.delete(Obj2D._getTextureIdBottom());\r",
                "Textures.get(Obj2D._getTextureIdFront()).dispose();\r",
                "Textures.delete(Obj2D._getTextureIdFront());\r",
                "Textures.get(Obj2D._getTextureIdBack()).dispose();\r",
                "Textures.delete(Obj2D._getTextureIdBack());\r",
                "Textures.get(Obj2D._getTextureIdLeft()).dispose();\r",
                "Textures.delete(Obj2D._getTextureIdLeft());\r",
                "Textures.get(Obj2D._getTextureIdRight()).dispose();\r",
                "Textures.delete(Obj2D._getTextureIdRight());\r",
                "// material dispose インスタンスごとなので全て削除してOK\r",
                "gdjs.__WithThreeJS.get(\"DisposeChildren\")(Obj3D);\r",
                "//\r",
                "Obj3D.removeFromParent();\r",
                "\r",
                ""
              ],
              "parameterObjects": "Object",
              "useStrict": true,
              "eventsSheetExpanded": true
            }
          ],
          "parameters": [
            {
              "description": "Object",
              "name": "Object",
              "supplementaryInformation": "WithThreeJS::Box3D",
              "type": "object"
            }
          ],
          "objectGroups": []
        },
        {
          "fullName": "3D Object ID",
          "functionType": "StringExpression",
          "name": "Id",
          "sentence": "",
          "events": [
            {
              "type": "BuiltinCommonInstructions::JsCode",
              "inlineCode": "eventsFunctionContext.returnValue = objects[0]._getId();",
              "parameterObjects": "Object",
              "useStrict": true,
              "eventsSheetExpanded": false
            }
          ],
          "expressionType": {
            "type": "string"
          },
          "parameters": [
            {
              "description": "Object",
              "name": "Object",
              "supplementaryInformation": "WithThreeJS::Box3D",
              "type": "object"
            }
          ],
          "objectGroups": []
        },
        {
          "fullName": "Depth",
          "functionType": "Expression",
          "name": "Depth",
          "sentence": "",
          "events": [
            {
              "type": "BuiltinCommonInstructions::JsCode",
              "inlineCode": "eventsFunctionContext.returnValue = objects[0]._getDepth();",
              "parameterObjects": "Object",
              "useStrict": true,
              "eventsSheetExpanded": false
            }
          ],
          "expressionType": {
            "type": "expression"
          },
          "parameters": [
            {
              "description": "Object",
              "name": "Object",
              "supplementaryInformation": "WithThreeJS::Box3D",
              "type": "object"
            }
          ],
          "objectGroups": []
        }
      ],
      "propertyDescriptors": [
        {
          "value": "",
          "type": "String",
          "label": "",
          "description": "",
          "group": "",
          "extraInformation": [],
          "hidden": true,
          "name": "Id"
        },
        {
          "value": "true",
          "type": "Boolean",
          "label": "",
          "description": "",
          "group": "",
          "extraInformation": [],
          "hidden": true,
          "name": "FirstFrame"
        },
        {
          "value": "true",
          "type": "Boolean",
          "label": "Hide 2D Object",
          "description": "",
          "group": "",
          "extraInformation": [],
          "name": "Hide"
        },
        {
          "value": "0",
          "type": "Number",
          "label": "Alpha Channel Test",
          "description": "Recommended values: 0 or 0.5. Default: 0.",
          "group": "Texture",
          "extraInformation": [],
          "name": "AlphaTest"
        },
        {
          "value": "true",
          "type": "Boolean",
          "label": "Anti-Aliasing",
          "description": "",
          "group": "Texture",
          "extraInformation": [],
          "name": "AntiAliasing"
        },
        {
          "value": "1",
          "type": "Number",
          "unit": "Pixel",
          "label": "Depth",
          "description": "Unit: Pixel",
          "group": "",
          "extraInformation": [],
          "name": "Depth"
        },
        {
          "value": "Normal",
          "type": "Choice",
          "label": "Blend Mode",
          "description": "",
          "group": "Texture",
          "extraInformation": [
            "Normal",
            "Additive",
            "Subtractive",
            "Multiply"
          ],
          "name": "Blend"
        },
        {
          "value": "0",
          "type": "Number",
          "label": "",
          "description": "",
          "group": "",
          "extraInformation": [],
          "hidden": true,
          "name": "TopOffsetV"
        },
        {
          "value": "0",
          "type": "Number",
          "label": "",
          "description": "",
          "group": "",
          "extraInformation": [],
          "hidden": true,
          "name": "BottomOffsetV"
        },
        {
          "value": "0",
          "type": "Number",
          "label": "",
          "description": "",
          "group": "",
          "extraInformation": [],
          "hidden": true,
          "name": "FrontOffsetV"
        },
        {
          "value": "0",
          "type": "Number",
          "label": "",
          "description": "",
          "group": "",
          "extraInformation": [],
          "hidden": true,
          "name": "BackOffsetV"
        },
        {
          "value": "0",
          "type": "Number",
          "label": "",
          "description": "",
          "group": "",
          "extraInformation": [],
          "hidden": true,
          "name": "LeftOffsetV"
        },
        {
          "value": "0",
          "type": "Number",
          "label": "",
          "description": "",
          "group": "",
          "extraInformation": [],
          "hidden": true,
          "name": "RightOffsetV"
        },
        {
          "value": "",
          "type": "String",
          "label": "",
          "description": "",
          "group": "",
          "extraInformation": [],
          "hidden": true,
          "name": "TextureIdTop"
        },
        {
          "value": "",
          "type": "String",
          "label": "",
          "description": "",
          "group": "",
          "extraInformation": [],
          "hidden": true,
          "name": "TextureIdBottom"
        },
        {
          "value": "",
          "type": "String",
          "label": "",
          "description": "",
          "group": "",
          "extraInformation": [],
          "hidden": true,
          "name": "TextureIdFront"
        },
        {
          "value": "",
          "type": "String",
          "label": "",
          "description": "",
          "group": "",
          "extraInformation": [],
          "hidden": true,
          "name": "TextureIdBack"
        },
        {
          "value": "",
          "type": "String",
          "label": "",
          "description": "",
          "group": "",
          "extraInformation": [],
          "hidden": true,
          "name": "TextureIdLeft"
        },
        {
          "value": "",
          "type": "String",
          "label": "",
          "description": "",
          "group": "",
          "extraInformation": [],
          "hidden": true,
          "name": "TextureIdRight"
        },
        {
          "value": "",
          "type": "Boolean",
          "label": "Cast Shadow",
          "description": "",
          "group": "Shadow",
          "extraInformation": [],
          "name": "CastShadow"
        },
        {
          "value": "",
          "type": "Boolean",
          "label": "Receive Shadow",
          "description": "",
          "group": "Shadow",
          "extraInformation": [],
          "name": "ReceiveShadow"
        }
      ],
      "objects": [
        {
          "assetStoreId": "",
          "height": 32,
          "name": "Top",
          "texture": "",
          "type": "TiledSpriteObject::TiledSprite",
          "width": 32,
          "variables": [],
          "effects": [],
          "behaviors": []
        },
        {
          "assetStoreId": "",
          "height": 32,
          "name": "Bottom",
          "texture": "",
          "type": "TiledSpriteObject::TiledSprite",
          "width": 32,
          "variables": [],
          "effects": [],
          "behaviors": []
        },
        {
          "assetStoreId": "",
          "height": 32,
          "name": "Front",
          "texture": "",
          "type": "TiledSpriteObject::TiledSprite",
          "width": 32,
          "variables": [],
          "effects": [],
          "behaviors": []
        },
        {
          "assetStoreId": "",
          "height": 32,
          "name": "Back",
          "texture": "",
          "type": "TiledSpriteObject::TiledSprite",
          "width": 32,
          "variables": [],
          "effects": [],
          "behaviors": []
        },
        {
          "assetStoreId": "",
          "height": 32,
          "name": "Left",
          "texture": "",
          "type": "TiledSpriteObject::TiledSprite",
          "width": 32,
          "variables": [],
          "effects": [],
          "behaviors": []
        },
        {
          "assetStoreId": "",
          "height": 32,
          "name": "Right",
          "texture": "",
          "type": "TiledSpriteObject::TiledSprite",
          "width": 32,
          "variables": [],
          "effects": [],
          "behaviors": []
        }
      ],
      "objectsFolderStructure": {
        "folderName": "__ROOT",
        "children": [
          {
            "objectName": "Top"
          },
          {
            "objectName": "Bottom"
          },
          {
            "objectName": "Front"
          },
          {
            "objectName": "Back"
          },
          {
            "objectName": "Left"
          },
          {
            "objectName": "Right"
          }
        ]
      },
      "objectsGroups": [],
      "layers": [
        {
          "ambientLightColorB": 200,
          "ambientLightColorG": 200,
          "ambientLightColorR": 200,
          "camera3DFarPlaneDistance": 10000,
          "camera3DFieldOfView": 45,
          "camera3DNearPlaneDistance": 3,
          "cameraType": "",
          "followBaseLayerCamera": false,
          "isLightingLayer": false,
          "isLocked": false,
          "name": "",
          "renderingType": "",
          "visibility": true,
          "cameras": [
            {
              "defaultSize": true,
              "defaultViewport": true,
              "height": 0,
              "viewportBottom": 1,
              "viewportLeft": 0,
              "viewportRight": 1,
              "viewportTop": 0,
              "width": 0
            }
          ],
          "effects": []
        }
      ],
      "instances": []
    },
    {
      "areaMaxX": 64,
      "areaMaxY": 64,
      "areaMaxZ": 64,
      "areaMinX": 0,
      "areaMinY": 0,
      "areaMinZ": 0,
      "defaultName": "Enable_WithThreeJS",
      "description": "Adding this object to your project will enable WithThreeJS in all scenes.\nThere is no need to place this in the scene.",
      "fullName": "Enable WithThreeJS",
      "is3D": true,
      "isUsingLegacyInstancesRenderer": true,
      "name": "EnableWithThreeJS",
      "eventsFunctions": [],
      "propertyDescriptors": [],
      "objects": [],
      "objectsFolderStructure": {
        "folderName": "__ROOT"
      },
      "objectsGroups": [],
      "layers": [
        {
          "ambientLightColorB": 200,
          "ambientLightColorG": 200,
          "ambientLightColorR": 200,
          "camera3DFarPlaneDistance": 10000,
          "camera3DFieldOfView": 45,
          "camera3DNearPlaneDistance": 3,
          "cameraType": "",
          "followBaseLayerCamera": false,
          "isLightingLayer": false,
          "isLocked": false,
          "name": "",
          "renderingType": "",
          "visibility": true,
          "cameras": [
            {
              "defaultSize": true,
              "defaultViewport": true,
              "height": 0,
              "viewportBottom": 1,
              "viewportLeft": 0,
              "viewportRight": 1,
              "viewportTop": 0,
              "width": 0
            }
          ],
          "effects": []
        }
      ],
      "instances": []
    }
  ]
}