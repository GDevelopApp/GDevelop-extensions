{
  "author": "",
  "category": "Movement",
  "extensionNamespace": "",
  "fullName": "Navigation mesh pathfinding (experimental)",
  "helpPath": "",
  "iconUrl": "data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0idXRmLTgiPz4NCjwhLS0gR2VuZXJhdG9yOiBBZG9iZSBJbGx1c3RyYXRvciAyMy4wLjMsIFNWRyBFeHBvcnQgUGx1Zy1JbiAuIFNWRyBWZXJzaW9uOiA2LjAwIEJ1aWxkIDApICAtLT4NCjxzdmcgdmVyc2lvbj0iMS4xIiBpZD0iSWNvbnMiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgeG1sbnM6eGxpbms9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmsiIHg9IjBweCIgeT0iMHB4Ig0KCSB2aWV3Qm94PSIwIDAgMzIgMzIiIHN0eWxlPSJlbmFibGUtYmFja2dyb3VuZDpuZXcgMCAwIDMyIDMyOyIgeG1sOnNwYWNlPSJwcmVzZXJ2ZSI+DQo8c3R5bGUgdHlwZT0idGV4dC9jc3MiPg0KCS5zdDB7ZmlsbDpub25lO3N0cm9rZTojMDAwMDAwO3N0cm9rZS13aWR0aDoyO3N0cm9rZS1saW5lY2FwOnJvdW5kO3N0cm9rZS1saW5lam9pbjpyb3VuZDtzdHJva2UtbWl0ZXJsaW1pdDoxMDt9DQo8L3N0eWxlPg0KPHBvbHlsaW5lIGNsYXNzPSJzdDAiIHBvaW50cz0iMTcsMjYgNSwyNiA1LDQgMjcsNCAyNywyNiAyNSwyNiAiLz4NCjxwb2x5bGluZSBjbGFzcz0ic3QwIiBwb2ludHM9IjUsMTkgMTYsOCAyNywxOSAiLz4NCjxsaW5lIGNsYXNzPSJzdDAiIHgxPSIxMiIgeTE9IjQiIHgyPSIxOSIgeTI9IjExIi8+DQo8bGluZSBjbGFzcz0ic3QwIiB4MT0iMjIiIHkxPSI0IiB4Mj0iMjIiIHkyPSIxNCIvPg0KPHBhdGggY2xhc3M9InN0MCIgZD0iTTIwLjUsMTcuNWMtMS45LTEuOS01LjEtMS45LTcsMGMtMS45LDEuOS0xLjksNS4xLDAsN2MxLjQsMS41LDMuNiwxLjgsNS40LDEuMWMwLjYtMC4yLDEuMi0wLjYsMS42LTEuMQ0KCUMyMi40LDIyLjYsMjIuNCwxOS41LDIwLjUsMTcuNXoiLz4NCjxwYXRoIGNsYXNzPSJzdDAiIGQ9Ik0yMS41LDIzbDMuOSwzLjZjMC44LDAuOCwwLjgsMiwwLDIuOGwwLDBjLTAuOCwwLjgtMiwwLjgtMi44LDBsLTMuNS0zLjUiLz4NCjwvc3ZnPg0K",
  "name": "NavMeshPathfinding",
  "previewIconUrl": "https://resources.gdevelop-app.com/assets/Icons/Line Hero Pack/Master/SVG/Maps and Navigation/Maps and Navigation_map_find_search.svg",
  "shortDescription": "Pathfinding allows to compute an efficient path for objects, avoiding obstacles on the way.",
  "version": "0.1.0",
  "description": "Compare to the built-in pathfinding behavior, this one aims to:\n- better respect obstacle shapes\n- find pathes faster if obstacles don't move\n",
  "tags": [
    "navmesh",
    "pathfinding"
  ],
  "authorIds": [
    "IWykYNRvhCZBN3vEgKEbBPOR3Oc2"
  ],
  "dependencies": [],
  "eventsFunctions": [
    {
      "description": "Define JavaScript classes.",
      "fullName": "Define JavaScript classes",
      "functionType": "Action",
      "name": "DefineJavaScript",
      "private": true,
      "sentence": "Define JavaScript classes",
      "events": [
        {
          "type": "BuiltinCommonInstructions::Standard",
          "conditions": [
            {
              "type": {
                "value": "GlobalVariableAsBoolean"
              },
              "parameters": [
                "__NavMeshPathfinding_ClassesDefined",
                ""
              ]
            }
          ],
          "actions": [
            {
              "type": {
                "value": "SetGlobalVariableAsBoolean"
              },
              "parameters": [
                "__NavMeshPathfinding_ClassesDefined",
                "True"
              ]
            }
          ],
          "events": [
            {
              "type": "BuiltinCommonInstructions::JsCode",
              "inlineCode": "\n// This code has been built from https://github.com/D8H/NavMesh-GDevelop-Extension\n// If you need to make any modification, please open a PR on github.\n\nvar extendStatics = function(d, b) {\n    extendStatics = Object.setPrototypeOf ||\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n        function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\n    return extendStatics(d, b);\n};\n\nfunction __extends(d, b) {\n    if (typeof b !== \"function\" && b !== null)\n        throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\n    extendStatics(d, b);\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n}\n\n/**\n * Stripped down version of Phaser's Vector2 with just the functionality needed for navmeshes.\n *\n * @export\n * @class Vector2\n */\nvar Vector2 = /** @class */ (function () {\n    function Vector2(x, y) {\n        if (x === void 0) { x = 0; }\n        if (y === void 0) { y = 0; }\n        this.x = x;\n        this.y = y;\n    }\n    Vector2.prototype.equals = function (v) {\n        return this.x === v.x && this.y === v.y;\n    };\n    Vector2.prototype.angle = function (v) {\n        return Math.atan2(v.y - this.y, v.x - this.x);\n    };\n    Vector2.prototype.distance = function (v) {\n        var dx = v.x - this.x;\n        var dy = v.y - this.y;\n        return Math.sqrt(dx * dx + dy * dy);\n    };\n    Vector2.prototype.add = function (v) {\n        this.x += v.x;\n        this.y += v.y;\n    };\n    Vector2.prototype.subtract = function (v) {\n        this.x -= v.x;\n        this.y -= v.y;\n    };\n    Vector2.prototype.clone = function () {\n        return new Vector2(this.x, this.y);\n    };\n    return Vector2;\n}());\n\nvar GridNode = /** @class */ (function () {\n    function GridNode(weight) {\n        this.h = 0;\n        this.g = 0;\n        this.f = 0;\n        this.closed = false;\n        this.visited = false;\n        this.parent = null;\n        this.weight = weight;\n    }\n    GridNode.prototype.isWall = function () {\n        return this.weight === 0;\n    };\n    GridNode.prototype.clean = function () {\n        this.f = 0;\n        this.g = 0;\n        this.h = 0;\n        this.visited = false;\n        this.closed = false;\n        this.parent = null;\n    };\n    return GridNode;\n}());\n\n/**\n * A class that represents a navigable polygon with a navmesh. It is built on top of a\n * {@link Polygon}. It implements the properties and fields that javascript-astar needs - weight,\n * toString, isWall and getCost. See GPS test from astar repo for structure:\n * https://github.com/bgrins/javascript-astar/blob/master/test/tests.js\n */\nvar NavPoly = /** @class */ (function (_super) {\n    __extends(NavPoly, _super);\n    /**\n     * Creates an instance of NavPoly.\n     */\n    function NavPoly(id, polygon) {\n        var _this = _super.call(this, 1) || this;\n        _this.id = id;\n        _this.polygon = polygon;\n        _this.edges = polygon.edges;\n        _this.neighbors = [];\n        _this.portals = [];\n        _this.centroid = _this.calculateCentroid();\n        _this.boundingRadius = _this.calculateRadius();\n        return _this;\n    }\n    /**\n     * Returns an array of points that form the polygon.\n     */\n    NavPoly.prototype.getPoints = function () {\n        return this.polygon.points;\n    };\n    /**\n     * Check if the given point-like object is within the polygon.\n     */\n    NavPoly.prototype.contains = function (point) {\n        // Phaser's polygon check doesn't handle when a point is on one of the edges of the line. Note:\n        // check numerical stability here. It would also be good to optimize this for different shapes.\n        return this.polygon.contains(point.x, point.y) || this.isPointOnEdge(point);\n    };\n    /**\n     * Only rectangles are supported, so this calculation works, but this is not actually the centroid\n     * calculation for a polygon. This is just the average of the vertices - proper centroid of a\n     * polygon factors in the area.\n     */\n    NavPoly.prototype.calculateCentroid = function () {\n        var centroid = new Vector2(0, 0);\n        var length = this.polygon.points.length;\n        this.polygon.points.forEach(function (p) { return centroid.add(p); });\n        centroid.x /= length;\n        centroid.y /= length;\n        return centroid;\n    };\n    /**\n     * Calculate the radius of a circle that circumscribes the polygon.\n     */\n    NavPoly.prototype.calculateRadius = function () {\n        var boundingRadius = 0;\n        for (var _i = 0, _a = this.polygon.points; _i < _a.length; _i++) {\n            var point = _a[_i];\n            var d = this.centroid.distance(point);\n            if (d > boundingRadius)\n                boundingRadius = d;\n        }\n        return boundingRadius;\n    };\n    /**\n     * Check if the given point-like object is on one of the edges of the polygon.\n     */\n    NavPoly.prototype.isPointOnEdge = function (_a) {\n        var x = _a.x, y = _a.y;\n        for (var _i = 0, _b = this.edges; _i < _b.length; _i++) {\n            var edge = _b[_i];\n            if (edge.pointOnSegment(x, y))\n                return true;\n        }\n        return false;\n    };\n    NavPoly.prototype.destroy = function () {\n        this.neighbors = [];\n        this.portals = [];\n    };\n    // === jsastar methods ===\n    NavPoly.prototype.toString = function () {\n        return \"NavPoly(id: \" + this.id + \" at: \" + this.centroid + \")\";\n    };\n    NavPoly.prototype.isWall = function () {\n        return false;\n    };\n    NavPoly.prototype.centroidDistance = function (navPolygon) {\n        return this.centroid.distance(navPolygon.centroid);\n    };\n    NavPoly.prototype.getCost = function (navPolygon) {\n        //TODO the cost method should not be in the Node\n        return this.centroidDistance(navPolygon);\n    };\n    return NavPoly;\n}(GridNode));\n\n/**\n * A graph memory structure\n */\nvar Graph = /** @class */ (function () {\n    /**\n     * A graph memory structure\n     * @param {Array} gridIn 2D array of input weights\n     * @param {Object} [options]\n     * @param {bool} [options.diagonal] Specifies whether diagonal moves are allowed\n     */\n    function Graph(nodes, options) {\n        this.dirtyNodes = [];\n        options = options || {};\n        this.nodes = nodes;\n        this.diagonal = !!options.diagonal;\n        this.init();\n    }\n    Graph.prototype.init = function () {\n        this.dirtyNodes = [];\n        for (var i = 0; i < this.nodes.length; i++) {\n            this.nodes[i].clean();\n        }\n    };\n    Graph.prototype.cleanDirty = function () {\n        for (var i = 0; i < this.dirtyNodes.length; i++) {\n            this.dirtyNodes[i].clean();\n        }\n        this.dirtyNodes = [];\n    };\n    Graph.prototype.markDirty = function (node) {\n        this.dirtyNodes.push(node);\n    };\n    return Graph;\n}());\n\n/**\n * Graph for javascript-astar. It implements the functionality for astar. See GPS test from astar\n * repo for structure: https://github.com/bgrins/javascript-astar/blob/master/test/tests.js\n *\n * @class NavGraph\n * @private\n */\nvar NavGraph = /** @class */ (function (_super) {\n    __extends(NavGraph, _super);\n    function NavGraph(navPolygons) {\n        var _this = _super.call(this, navPolygons) || this;\n        _this.nodes = navPolygons;\n        _this.init();\n        return _this;\n    }\n    NavGraph.prototype.neighbors = function (navPolygon) {\n        return navPolygon.neighbors;\n    };\n    NavGraph.prototype.navHeuristic = function (navPolygon1, navPolygon2) {\n        return navPolygon1.centroidDistance(navPolygon2);\n    };\n    NavGraph.prototype.destroy = function () {\n        this.cleanDirty();\n        this.nodes = [];\n    };\n    return NavGraph;\n}(Graph));\n\n/**\n * Calculate the distance squared between two points. This is an optimization to a square root when\n * you just need to compare relative distances without needing to know the specific distance.\n * @param a\n * @param b\n */\nfunction distanceSquared(a, b) {\n    var dx = b.x - a.x;\n    var dy = b.y - a.y;\n    return dx * dx + dy * dy;\n}\n/**\n * Project a point onto a line segment.\n * JS Source: http://stackoverflow.com/questions/849211/shortest-distance-between-a-point-and-a-line-segment\n * @param point\n * @param line\n */\nfunction projectPointToEdge(point, line) {\n    var a = line.start;\n    var b = line.end;\n    // Consider the parametric equation for the edge's line, p = a + t (b - a). We want to find\n    // where our point lies on the line by solving for t:\n    //  t = [(p-a) . (b-a)] / |b-a|^2\n    var l2 = distanceSquared(a, b);\n    var t = ((point.x - a.x) * (b.x - a.x) + (point.y - a.y) * (b.y - a.y)) / l2;\n    // We clamp t from [0,1] to handle points outside the segment vw.\n    t = clamp(t, 0, 1);\n    // Project onto the segment\n    var p = new Vector2(a.x + t * (b.x - a.x), a.y + t * (b.y - a.y));\n    return p;\n}\n/**\n * Twice the area of the triangle formed by a, b and c.\n */\nfunction triarea2(a, b, c) {\n    var ax = b.x - a.x;\n    var ay = b.y - a.y;\n    var bx = c.x - a.x;\n    var by = c.y - a.y;\n    return bx * ay - ax * by;\n}\n/**\n * Clamp the given value between min and max.\n */\nfunction clamp(value, min, max) {\n    if (value < min)\n        value = min;\n    if (value > max)\n        value = max;\n    return value;\n}\n/**\n * Check if two values are within a small margin of one another.\n */\nfunction almostEqual(value1, value2, errorMargin) {\n    if (errorMargin === void 0) { errorMargin = 0.0001; }\n    if (Math.abs(value1 - value2) <= errorMargin)\n        return true;\n    else\n        return false;\n}\n/**\n * Find the smallest angle difference between two angles\n * https://gist.github.com/Aaronduino/4068b058f8dbc34b4d3a9eedc8b2cbe0\n */\nfunction angleDifference(x, y) {\n    var a = x - y;\n    var i = a + Math.PI;\n    var j = Math.PI * 2;\n    a = i - Math.floor(i / j) * j; // (a+180) % 360; this ensures the correct sign\n    a -= Math.PI;\n    return a;\n}\n/**\n * Check if two lines are collinear (within a small error margin).\n */\nfunction areCollinear(line1, line2, errorMargin) {\n    if (errorMargin === void 0) { errorMargin = 0.0001; }\n    // Figure out if the two lines are equal by looking at the area of the triangle formed\n    // by their points\n    var area1 = triarea2(line1.start, line1.end, line2.start);\n    var area2 = triarea2(line1.start, line1.end, line2.end);\n    if (almostEqual(area1, 0, errorMargin) && almostEqual(area2, 0, errorMargin)) {\n        return true;\n    }\n    else\n        return false;\n}\n\n// Mostly sourced from PatrolJS at the moment. TODO: come back and reimplement this as an incomplete\n/**\n * @private\n */\nvar Channel = /** @class */ (function () {\n    function Channel() {\n        this.portals = [];\n        this.path = [];\n    }\n    Channel.prototype.push = function (p1, p2) {\n        if (p2 === undefined)\n            p2 = p1;\n        this.portals.push({\n            left: p1,\n            right: p2,\n        });\n    };\n    Channel.prototype.stringPull = function () {\n        var portals = this.portals;\n        var pts = [];\n        // Init scan state\n        var apexIndex = 0;\n        var leftIndex = 0;\n        var rightIndex = 0;\n        var portalApex = portals[0].left;\n        var portalLeft = portals[0].left;\n        var portalRight = portals[0].right;\n        // Add start point.\n        pts.push(portalApex);\n        for (var i = 1; i < portals.length; i++) {\n            // Find the next portal vertices\n            var left = portals[i].left;\n            var right = portals[i].right;\n            // Update right vertex.\n            if (triarea2(portalApex, portalRight, right) <= 0.0) {\n                if (portalApex.equals(portalRight) || triarea2(portalApex, portalLeft, right) > 0.0) {\n                    // Tighten the funnel.\n                    portalRight = right;\n                    rightIndex = i;\n                }\n                else {\n                    // Right vertex just crossed over the left vertex, so the left vertex should\n                    // now be part of the path.\n                    pts.push(portalLeft);\n                    // Restart scan from portal left point.\n                    // Make current left the new apex.\n                    portalApex = portalLeft;\n                    apexIndex = leftIndex;\n                    // Reset portal\n                    portalLeft = portalApex;\n                    portalRight = portalApex;\n                    leftIndex = apexIndex;\n                    rightIndex = apexIndex;\n                    // Restart scan\n                    i = apexIndex;\n                    continue;\n                }\n            }\n            // Update left vertex.\n            if (triarea2(portalApex, portalLeft, left) >= 0.0) {\n                if (portalApex.equals(portalLeft) || triarea2(portalApex, portalRight, left) < 0.0) {\n                    // Tighten the funnel.\n                    portalLeft = left;\n                    leftIndex = i;\n                }\n                else {\n                    // Left vertex just crossed over the right vertex, so the right vertex should\n                    // now be part of the path\n                    pts.push(portalRight);\n                    // Restart scan from portal right point.\n                    // Make current right the new apex.\n                    portalApex = portalRight;\n                    apexIndex = rightIndex;\n                    // Reset portal\n                    portalLeft = portalApex;\n                    portalRight = portalApex;\n                    leftIndex = apexIndex;\n                    rightIndex = apexIndex;\n                    // Restart scan\n                    i = apexIndex;\n                    continue;\n                }\n            }\n        }\n        if (pts.length === 0 || !pts[pts.length - 1].equals(portals[portals.length - 1].left)) {\n            // Append last point to path.\n            pts.push(portals[portals.length - 1].left);\n        }\n        this.path = pts;\n        return pts;\n    };\n    return Channel;\n}());\n\n/**\n * Stripped down version of Phaser's Line with just the functionality needed for navmeshes.\n *\n * @export\n * @class Line\n */\nvar Line = /** @class */ (function () {\n    function Line(x1, y1, x2, y2) {\n        this.start = new Vector2(x1, y1);\n        this.end = new Vector2(x2, y2);\n        this.left = Math.min(x1, x2);\n        this.right = Math.max(x1, x2);\n        this.top = Math.min(y1, y2);\n        this.bottom = Math.max(y1, y2);\n    }\n    Line.prototype.pointOnSegment = function (x, y) {\n        return (x >= this.left &&\n            x <= this.right &&\n            y >= this.top &&\n            y <= this.bottom &&\n            this.pointOnLine(x, y));\n    };\n    Line.prototype.pointOnLine = function (x, y) {\n        // Compare slope of line start -> xy to line start -> line end\n        return (x - this.left) * (this.bottom - this.top) === (this.right - this.left) * (y - this.top);\n    };\n    return Line;\n}());\n\n/**\n * Stripped down version of Phaser's Polygon with just the functionality needed for navmeshes.\n *\n * @export\n * @class Polygon\n */\nvar Polygon = /** @class */ (function () {\n    function Polygon(points, closed) {\n        if (closed === void 0) { closed = true; }\n        this.isClosed = closed;\n        this.points = points;\n        this.edges = [];\n        for (var i = 1; i < points.length; i++) {\n            var p1 = points[i - 1];\n            var p2 = points[i];\n            this.edges.push(new Line(p1.x, p1.y, p2.x, p2.y));\n        }\n        if (this.isClosed) {\n            var first = points[0];\n            var last = points[points.length - 1];\n            this.edges.push(new Line(first.x, first.y, last.x, last.y));\n        }\n    }\n    Polygon.prototype.contains = function (x, y) {\n        var inside = false;\n        for (var i = -1, j = this.points.length - 1; ++i < this.points.length; j = i) {\n            var ix = this.points[i].x;\n            var iy = this.points[i].y;\n            var jx = this.points[j].x;\n            var jy = this.points[j].y;\n            if (((iy <= y && y < jy) || (jy <= y && y < iy)) &&\n                x < ((jx - ix) * (y - iy)) / (jy - iy) + ix) {\n                inside = !inside;\n            }\n        }\n        return inside;\n    };\n    return Polygon;\n}());\n\nvar BinaryHeap = /** @class */ (function () {\n    function BinaryHeap(scoreFunction) {\n        this.content = new Array();\n        this.scoreFunction = scoreFunction;\n    }\n    BinaryHeap.prototype.push = function (element) {\n        // Add the new element to the end of the array.\n        this.content.push(element);\n        // Allow it to sink down.\n        this.sinkDown(this.content.length - 1);\n    };\n    BinaryHeap.prototype.pop = function () {\n        // Store the first element so we can return it later.\n        var result = this.content[0];\n        // Get the element at the end of the array.\n        var end = this.content.pop();\n        if (!end)\n            return;\n        // If there are any elements left, put the end element at the\n        // start, and let it bubble up.\n        if (this.content.length > 0) {\n            this.content[0] = end;\n            this.bubbleUp(0);\n        }\n        return result;\n    };\n    BinaryHeap.prototype.remove = function (node) {\n        var i = this.content.indexOf(node);\n        // When it is found, the process seen in 'pop' is repeated\n        // to fill up the hole.\n        var end = this.content.pop();\n        if (!end)\n            return;\n        if (i !== this.content.length - 1) {\n            this.content[i] = end;\n            if (this.scoreFunction(end) < this.scoreFunction(node)) {\n                this.sinkDown(i);\n            }\n            else {\n                this.bubbleUp(i);\n            }\n        }\n    };\n    BinaryHeap.prototype.size = function () {\n        return this.content.length;\n    };\n    BinaryHeap.prototype.rescoreElement = function (node) {\n        this.sinkDown(this.content.indexOf(node));\n    };\n    BinaryHeap.prototype.sinkDown = function (n) {\n        // Fetch the element that has to be sunk.\n        var element = this.content[n];\n        // When at 0, an element can not sink any further.\n        while (n > 0) {\n            // Compute the parent element's index, and fetch it.\n            var parentN = ((n + 1) >> 1) - 1;\n            var parent = this.content[parentN];\n            // Swap the elements if the parent is greater.\n            if (this.scoreFunction(element) < this.scoreFunction(parent)) {\n                this.content[parentN] = element;\n                this.content[n] = parent;\n                // Update 'n' to continue at the new position.\n                n = parentN;\n            }\n            // Found a parent that is less, no need to sink any further.\n            else {\n                break;\n            }\n        }\n    };\n    BinaryHeap.prototype.bubbleUp = function (n) {\n        // Look up the target element and its score.\n        var length = this.content.length;\n        var element = this.content[n];\n        var elemScore = this.scoreFunction(element);\n        while (true) {\n            // Compute the indices of the child elements.\n            var child2N = (n + 1) << 1;\n            var child1N = child2N - 1;\n            // This is used to store the new position of the element, if any.\n            var swap = null;\n            var child1Score = 0;\n            // If the first child exists (is inside the array)...\n            if (child1N < length) {\n                // Look it up and compute its score.\n                var child1 = this.content[child1N];\n                child1Score = this.scoreFunction(child1);\n                // If the score is less than our element's, we need to swap.\n                if (child1Score < elemScore) {\n                    swap = child1N;\n                }\n            }\n            // Do the same checks for the other child.\n            if (child2N < length) {\n                var child2 = this.content[child2N];\n                var child2Score = this.scoreFunction(child2);\n                if (child2Score < (swap === null ? elemScore : child1Score)) {\n                    swap = child2N;\n                }\n            }\n            // If the element needs to be moved, swap it, and continue.\n            if (swap !== null) {\n                this.content[n] = this.content[swap];\n                this.content[swap] = element;\n                n = swap;\n            }\n            // Otherwise, we are done.\n            else {\n                break;\n            }\n        }\n    };\n    return BinaryHeap;\n}());\n\n// The following implementation of the A* algorithm is from:\nvar AStar = /** @class */ (function () {\n    function AStar() {\n    }\n    /**\n     * Perform an A* Search on a graph given a start and end node.\n     * @param {Graph} graph\n     * @param {GridNode} start\n     * @param {GridNode} end\n     * @param {Object} [options]\n     * @param {bool} [options.closest] Specifies whether to return the\n     path to the closest node if the target is unreachable.\n    * @param {Function} [options.heuristic] Heuristic function (see\n    *          astar.heuristics).\n    */\n    AStar.prototype.search = function (graph, start, end, \n    // See list of heuristics: http://theory.stanford.edu/~amitp/GameProgramming/Heuristics.html\n    heuristic, closest) {\n        if (closest === void 0) { closest = false; }\n        graph.cleanDirty();\n        var openHeap = this.getHeap();\n        var closestNode = start; // set the start node to be the closest if required\n        start.h = heuristic(start, end);\n        graph.markDirty(start);\n        openHeap.push(start);\n        while (openHeap.size() > 0) {\n            // Grab the lowest f(x) to process next.  Heap keeps this sorted for us.\n            var currentNode = openHeap.pop();\n            // never happen\n            if (!currentNode)\n                return [];\n            // End case -- result has been found, return the traced path.\n            if (currentNode === end) {\n                return this.pathTo(currentNode);\n            }\n            // Normal case -- move currentNode from open to closed, process each of its neighbors.\n            currentNode.closed = true;\n            // Find all neighbors for the current node.\n            var neighbors = graph.neighbors(currentNode);\n            for (var i = 0, il = neighbors.length; i < il; ++i) {\n                var neighbor = neighbors[i];\n                if (neighbor.closed || neighbor.isWall()) {\n                    // Not a valid node to process, skip to next neighbor.\n                    continue;\n                }\n                // The g score is the shortest distance from start to current node.\n                // We need to check if the path we have arrived at this neighbor is the shortest one we have seen yet.\n                var gScore = currentNode.g + neighbor.getCost(currentNode);\n                var beenVisited = neighbor.visited;\n                if (!beenVisited || gScore < neighbor.g) {\n                    // Found an optimal (so far) path to this node.  Take score for node to see how good it is.\n                    neighbor.visited = true;\n                    neighbor.parent = currentNode;\n                    neighbor.h = neighbor.h || heuristic(neighbor, end);\n                    neighbor.g = gScore;\n                    neighbor.f = neighbor.g + neighbor.h;\n                    graph.markDirty(neighbor);\n                    if (closest) {\n                        // If the neighbor is closer than the current closestNode or if it's equally close but has\n                        // a cheaper path than the current closest node then it becomes the closest node\n                        if (neighbor.h < closestNode.h ||\n                            (neighbor.h === closestNode.h && neighbor.g < closestNode.g)) {\n                            closestNode = neighbor;\n                        }\n                    }\n                    if (!beenVisited) {\n                        // Pushing to heap will put it in proper place based on the 'f' value.\n                        openHeap.push(neighbor);\n                    }\n                    else {\n                        // Already seen the node, but since it has been rescored we need to reorder it in the heap\n                        openHeap.rescoreElement(neighbor);\n                    }\n                }\n            }\n        }\n        if (closest) {\n            return this.pathTo(closestNode);\n        }\n        // No result was found - empty array signifies failure to find path.\n        return [];\n    };\n    AStar.prototype.pathTo = function (node) {\n        var curr = node;\n        var path = new Array();\n        while (curr.parent) {\n            path.unshift(curr);\n            curr = curr.parent;\n        }\n        return path;\n    };\n    AStar.prototype.getHeap = function () {\n        return new BinaryHeap(function (node) {\n            return node.f;\n        });\n    };\n    return AStar;\n}());\n\n/**\n * The `NavMesh` class is the workhorse that represents a navigation mesh built from a series of\n * polygons. Once built, the mesh can be asked for a path from one point to another point. Some\n * internal terminology usage:\n * - neighbor: a polygon that shares part of an edge with another polygon\n * - portal: when two neighbor's have edges that overlap, the portal is the overlapping line segment\n * - channel: the path of polygons from starting point to end point\n * - pull the string: run the funnel algorithm on the channel so that the path hugs the edges of the\n *   channel. Equivalent to having a string snaking through a hallway and then pulling it taut.\n */\nvar NavMesh = /** @class */ (function () {\n    /**\n     * @param meshPolygonPoints Array where each element is an array of point-like objects that\n     * defines a polygon.\n     * @param meshShrinkAmount The amount (in pixels) that the navmesh has been shrunk around\n     * obstacles (a.k.a the amount obstacles have been expanded).\n     */\n    function NavMesh(meshPolygonPoints, meshShrinkAmount) {\n        if (meshShrinkAmount === void 0) { meshShrinkAmount = 0; }\n        this.meshShrinkAmount = meshShrinkAmount;\n        // Convert the PolyPoints[] into NavPoly instances.\n        this.navPolygons = meshPolygonPoints.map(function (polyPoints, i) { return new NavPoly(i, new Polygon(polyPoints)); });\n        this.calculateNeighbors();\n        // Astar graph of connections between polygons\n        this.graph = new NavGraph(this.navPolygons);\n    }\n    /**\n     * Get the NavPolys that are in this navmesh.\n     */\n    NavMesh.prototype.getPolygons = function () {\n        return this.navPolygons;\n    };\n    /**\n     * Cleanup method to remove references.\n     */\n    NavMesh.prototype.destroy = function () {\n        this.graph.destroy();\n        for (var _i = 0, _a = this.navPolygons; _i < _a.length; _i++) {\n            var poly = _a[_i];\n            poly.destroy();\n        }\n        this.navPolygons = [];\n    };\n    /**\n     * Find if the given point is within any of the polygons in the mesh.\n     * @param point\n     */\n    NavMesh.prototype.isPointInMesh = function (point) {\n        return this.navPolygons.some(function (navPoly) { return navPoly.contains(point); });\n    };\n    /**\n     * Find the closest point in the mesh to the given point. If the point is already in the mesh,\n     * this will give you that point. If the point is outside of the mesh, this will attempt to\n     * project this point into the mesh (up to the given maxAllowableDist). This returns an object\n     * with:\n     * - distance - from the given point to the mesh\n     * - polygon - the one the point is closest to, or null\n     * - point - the point inside the mesh, or null\n     * @param point\n     * @param maxAllowableDist\n     */\n    NavMesh.prototype.findClosestMeshPoint = function (point, maxAllowableDist) {\n        if (maxAllowableDist === void 0) { maxAllowableDist = Number.POSITIVE_INFINITY; }\n        var minDistance = maxAllowableDist;\n        var closestPoly = null;\n        var pointOnClosestPoly = null;\n        for (var _i = 0, _a = this.navPolygons; _i < _a.length; _i++) {\n            var navPoly = _a[_i];\n            // If we are inside a poly, we've got the closest.\n            if (navPoly.contains(point)) {\n                minDistance = 0;\n                closestPoly = navPoly;\n                pointOnClosestPoly = point;\n                break;\n            }\n            // Is the poly close enough to warrant a more accurate check? Point is definitely outside of\n            // the polygon. Distance - Radius is the smallest possible distance to an edge of the poly.\n            // This will underestimate distance, but that's perfectly fine.\n            var r = navPoly.boundingRadius;\n            var d = navPoly.centroid.distance(point);\n            if (d - r < minDistance) {\n                var result = this.projectPointToPolygon(point, navPoly);\n                if (result.distance < minDistance) {\n                    minDistance = result.distance;\n                    closestPoly = navPoly;\n                    pointOnClosestPoly = result.point;\n                }\n            }\n        }\n        return { distance: minDistance, polygon: closestPoly, point: pointOnClosestPoly };\n    };\n    /**\n     * Find a path from the start point to the end point using this nav mesh.\n     * @param startPoint A point-like object in the form {x, y}\n     * @param endPoint A point-like object in the form {x, y}\n     * @returns An array of points if a path is found, or null if no path\n     */\n    NavMesh.prototype.findPath = function (startPoint, endPoint) {\n        var startPoly = null;\n        var endPoly = null;\n        var startDistance = Number.MAX_VALUE;\n        var endDistance = Number.MAX_VALUE;\n        var d, r;\n        var startVector = new Vector2(startPoint.x, startPoint.y);\n        var endVector = new Vector2(endPoint.x, endPoint.y);\n        // Find the closest poly for the starting and ending point\n        for (var _i = 0, _a = this.navPolygons; _i < _a.length; _i++) {\n            var navPoly = _a[_i];\n            r = navPoly.boundingRadius;\n            // Start\n            d = navPoly.centroid.distance(startVector);\n            if (d <= startDistance && d <= r && navPoly.contains(startVector)) {\n                startPoly = navPoly;\n                startDistance = d;\n            }\n            // End\n            d = navPoly.centroid.distance(endVector);\n            if (d <= endDistance && d <= r && navPoly.contains(endVector)) {\n                endPoly = navPoly;\n                endDistance = d;\n            }\n        }\n        // If the end point wasn't inside a polygon, run a more liberal check that allows a point\n        // to be within meshShrinkAmount radius of a polygon\n        if (!endPoly && this.meshShrinkAmount > 0) {\n            for (var _b = 0, _c = this.navPolygons; _b < _c.length; _b++) {\n                var navPoly = _c[_b];\n                r = navPoly.boundingRadius + this.meshShrinkAmount;\n                d = navPoly.centroid.distance(endVector);\n                if (d <= r) {\n                    var distance = this.projectPointToPolygon(endVector, navPoly).distance;\n                    if (distance <= this.meshShrinkAmount && distance < endDistance) {\n                        endPoly = navPoly;\n                        endDistance = distance;\n                    }\n                }\n            }\n        }\n        // No matching polygons locations for the end, so no path found\n        // because start point is valid normally, check end point first\n        if (!endPoly)\n            return null;\n        // Same check as above, but for the start point\n        if (!startPoly && this.meshShrinkAmount > 0) {\n            for (var _d = 0, _e = this.navPolygons; _d < _e.length; _d++) {\n                var navPoly = _e[_d];\n                // Check if point is within bounding circle to avoid extra projection calculations\n                r = navPoly.boundingRadius + this.meshShrinkAmount;\n                d = navPoly.centroid.distance(startVector);\n                if (d <= r) {\n                    // Check if projected point is within range of a polygon and is closer than the\n                    // previous point\n                    var distance = this.projectPointToPolygon(startVector, navPoly).distance;\n                    if (distance <= this.meshShrinkAmount && distance < startDistance) {\n                        startPoly = navPoly;\n                        startDistance = distance;\n                    }\n                }\n            }\n        }\n        // No matching polygons locations for the start, so no path found\n        if (!startPoly)\n            return null;\n        // If the start and end polygons are the same, return a direct path\n        if (startPoly === endPoly)\n            return [startVector, endVector];\n        // Search!\n        var astarPath = new AStar().search(this.graph, startPoly, endPoly, this.graph.navHeuristic);\n        // While the start and end polygons may be valid, no path between them\n        if (astarPath.length === 0)\n            return null;\n        // jsastar drops the first point from the path, but the funnel algorithm needs it\n        astarPath.unshift(startPoly);\n        // We have a path, so now time for the funnel algorithm\n        var channel = new Channel();\n        channel.push(startVector);\n        for (var i = 0; i < astarPath.length - 1; i++) {\n            var navPolygon = astarPath[i];\n            var nextNavPolygon = astarPath[i + 1];\n            // Find the portal\n            var portal = null;\n            for (var i_1 = 0; i_1 < navPolygon.neighbors.length; i_1++) {\n                if (navPolygon.neighbors[i_1].id === nextNavPolygon.id) {\n                    portal = navPolygon.portals[i_1];\n                }\n            }\n            if (!portal)\n                throw new Error(\"Path was supposed to be found, but portal is missing!\");\n            // Push the portal vertices into the channel\n            channel.push(portal.start, portal.end);\n        }\n        channel.push(endVector);\n        // Pull a string along the channel to run the funnel\n        channel.stringPull();\n        // Clone path, excluding duplicates\n        var lastPoint = null;\n        var phaserPath = new Array();\n        for (var _f = 0, _g = channel.path; _f < _g.length; _f++) {\n            var p = _g[_f];\n            var newPoint = p.clone();\n            if (!lastPoint || !newPoint.equals(lastPoint))\n                phaserPath.push(newPoint);\n            lastPoint = newPoint;\n        }\n        return phaserPath;\n    };\n    NavMesh.prototype.calculateNeighbors = function () {\n        // Fill out the neighbor information for each navpoly\n        for (var i = 0; i < this.navPolygons.length; i++) {\n            var navPoly = this.navPolygons[i];\n            for (var j = i + 1; j < this.navPolygons.length; j++) {\n                var otherNavPoly = this.navPolygons[j];\n                // Check if the other navpoly is within range to touch\n                var d = navPoly.centroid.distance(otherNavPoly.centroid);\n                if (d > navPoly.boundingRadius + otherNavPoly.boundingRadius)\n                    continue;\n                // The are in range, so check each edge pairing\n                for (var _i = 0, _a = navPoly.edges; _i < _a.length; _i++) {\n                    var edge = _a[_i];\n                    for (var _b = 0, _c = otherNavPoly.edges; _b < _c.length; _b++) {\n                        var otherEdge = _c[_b];\n                        // If edges aren't collinear, not an option for connecting navpolys\n                        if (!areCollinear(edge, otherEdge))\n                            continue;\n                        // If they are collinear, check if they overlap\n                        var overlap = this.getSegmentOverlap(edge, otherEdge);\n                        if (!overlap)\n                            continue;\n                        // Connections are symmetric!\n                        navPoly.neighbors.push(otherNavPoly);\n                        otherNavPoly.neighbors.push(navPoly);\n                        // Calculate the portal between the two polygons - this needs to be in\n                        // counter-clockwise order, relative to each polygon\n                        var p1 = overlap[0], p2 = overlap[1];\n                        var edgeStartAngle = navPoly.centroid.angle(edge.start);\n                        var a1 = navPoly.centroid.angle(overlap[0]);\n                        var a2 = navPoly.centroid.angle(overlap[1]);\n                        var d1 = angleDifference(edgeStartAngle, a1);\n                        var d2 = angleDifference(edgeStartAngle, a2);\n                        if (d1 < d2) {\n                            navPoly.portals.push(new Line(p1.x, p1.y, p2.x, p2.y));\n                        }\n                        else {\n                            navPoly.portals.push(new Line(p2.x, p2.y, p1.x, p1.y));\n                        }\n                        edgeStartAngle = otherNavPoly.centroid.angle(otherEdge.start);\n                        a1 = otherNavPoly.centroid.angle(overlap[0]);\n                        a2 = otherNavPoly.centroid.angle(overlap[1]);\n                        d1 = angleDifference(edgeStartAngle, a1);\n                        d2 = angleDifference(edgeStartAngle, a2);\n                        if (d1 < d2) {\n                            otherNavPoly.portals.push(new Line(p1.x, p1.y, p2.x, p2.y));\n                        }\n                        else {\n                            otherNavPoly.portals.push(new Line(p2.x, p2.y, p1.x, p1.y));\n                        }\n                        // Two convex polygons shouldn't be connected more than once! (Unless\n                        // there are unnecessary vertices...)\n                    }\n                }\n            }\n        }\n    };\n    // Check two collinear line segments to see if they overlap by sorting the points.\n    // Algorithm source: http://stackoverflow.com/a/17152247\n    NavMesh.prototype.getSegmentOverlap = function (line1, line2) {\n        var points = [\n            { line: line1, point: line1.start },\n            { line: line1, point: line1.end },\n            { line: line2, point: line2.start },\n            { line: line2, point: line2.end },\n        ];\n        points.sort(function (a, b) {\n            if (a.point.x < b.point.x)\n                return -1;\n            else if (a.point.x > b.point.x)\n                return 1;\n            else {\n                if (a.point.y < b.point.y)\n                    return -1;\n                else if (a.point.y > b.point.y)\n                    return 1;\n                else\n                    return 0;\n            }\n        });\n        // If the first two points in the array come from the same line, no overlap\n        var noOverlap = points[0].line === points[1].line;\n        // If the two middle points in the array are the same coordinates, then there is a\n        // single point of overlap.\n        var singlePointOverlap = points[1].point.equals(points[2].point);\n        if (noOverlap || singlePointOverlap)\n            return null;\n        else\n            return [points[1].point, points[2].point];\n    };\n    /**\n     * Project a point onto a polygon in the shortest distance possible.\n     *\n     * @param {Phaser.Point} point The point to project\n     * @param {NavPoly} navPoly The navigation polygon to test against\n     * @returns {{point: Phaser.Point, distance: number}}\n     */\n    NavMesh.prototype.projectPointToPolygon = function (point, navPoly) {\n        var closestProjection = null;\n        var closestDistance = Number.MAX_VALUE;\n        for (var _i = 0, _a = navPoly.edges; _i < _a.length; _i++) {\n            var edge = _a[_i];\n            var projectedPoint = projectPointToEdge(point, edge);\n            var d = point.distance(projectedPoint);\n            if (closestProjection === null || d < closestDistance) {\n                closestDistance = d;\n                closestProjection = projectedPoint;\n            }\n        }\n        return { point: closestProjection, distance: closestDistance };\n    };\n    return NavMesh;\n}());\n\n/**\n * This implementation is strongly inspired from CritterAI class \"Geometry\".\n */\nvar Geometry = /** @class */ (function () {\n    function Geometry() {\n    }\n    /**\n     * Returns TRUE if line segment AB intersects with line segment CD in any\n     * manner. Either collinear or at a single point.\n     * @param ax The x-value for point (ax, ay) in line segment AB.\n     * @param ay The y-value for point (ax, ay) in line segment AB.\n     * @param bx The x-value for point (bx, by) in line segment AB.\n     * @param by The y-value for point (bx, by) in line segment AB.\n     * @param cx The x-value for point (cx, cy) in line segment CD.\n     * @param cy The y-value for point (cx, cy) in line segment CD.\n     * @param dx The x-value for point (dx, dy) in line segment CD.\n     * @param dy The y-value for point (dx, dy) in line segment CD.\n     * @return TRUE if line segment AB intersects with line segment CD in any\n     * manner.\n     */\n    Geometry.segmentsIntersect = function (ax, ay, bx, by, cx, cy, dx, dy) {\n        // This is modified 2D line-line intersection/segment-segment\n        // intersection test.\n        var deltaABx = bx - ax;\n        var deltaABy = by - ay;\n        var deltaCAx = ax - cx;\n        var deltaCAy = ay - cy;\n        var deltaCDx = dx - cx;\n        var deltaCDy = dy - cy;\n        var numerator = deltaCAy * deltaCDx - deltaCAx * deltaCDy;\n        var denominator = deltaABx * deltaCDy - deltaABy * deltaCDx;\n        // Perform early exit tests.\n        if (denominator === 0 && numerator !== 0) {\n            // If numerator is zero, then the lines are colinear.\n            // Since it isn't, then the lines must be parallel.\n            return false;\n        }\n        // Lines intersect. But do the segments intersect?\n        // Forcing float division on both of these via casting of the\n        // denominator.\n        var factorAB = numerator / denominator;\n        var factorCD = (deltaCAy * deltaABx - deltaCAx * deltaABy) / denominator;\n        // Determine the type of intersection\n        if (factorAB >= 0.0 &&\n            factorAB <= 1.0 &&\n            factorCD >= 0.0 &&\n            factorCD <= 1.0) {\n            return true; // The two segments intersect.\n        }\n        // The lines intersect, but segments to not.\n        return false;\n    };\n    /**\n     * Returns the distance squared from the point to the line segment.\n     *\n     * Behavior is undefined if the the closest distance is outside the\n     * line segment.\n     *\n     * @param px The x-value of point (px, py).\n     * @param py The y-value of point (px, py)\n     * @param ax The x-value of the line segment's vertex A.\n     * @param ay The y-value of the line segment's vertex A.\n     * @param bx The x-value of the line segment's vertex B.\n     * @param by The y-value of the line segment's vertex B.\n     * @return The distance squared from the point (px, py) to line segment AB.\n     */\n    Geometry.getPointSegmentDistanceSq = function (px, py, ax, ay, bx, by) {\n        // Reference: http://local.wasp.uwa.edu.au/~pbourke/geometry/pointline/\n        //\n        // The goal of the algorithm is to find the point on line segment AB\n        // that is closest to P and then calculate the distance between P\n        // and that point.\n        var deltaABx = bx - ax;\n        var deltaABy = by - ay;\n        var deltaAPx = px - ax;\n        var deltaAPy = py - ay;\n        var segmentABLengthSq = deltaABx * deltaABx + deltaABy * deltaABy;\n        if (segmentABLengthSq === 0) {\n            // AB is not a line segment. So just return\n            // distanceSq from P to A\n            return deltaAPx * deltaAPx + deltaAPy * deltaAPy;\n        }\n        var u = (deltaAPx * deltaABx + deltaAPy * deltaABy) / segmentABLengthSq;\n        if (u < 0) {\n            // Closest point on line AB is outside outside segment AB and\n            // closer to A. So return distanceSq from P to A.\n            return deltaAPx * deltaAPx + deltaAPy * deltaAPy;\n        }\n        else if (u > 1) {\n            // Closest point on line AB is outside segment AB and closer to B.\n            // So return distanceSq from P to B.\n            return (px - bx) * (px - bx) + (py - by) * (py - by);\n        }\n        // Closest point on lineAB is inside segment AB. So find the exact\n        // point on AB and calculate the distanceSq from it to P.\n        // The calculation in parenthesis is the location of the point on\n        // the line segment.\n        var deltaX = ax + u * deltaABx - px;\n        var deltaY = ay + u * deltaABy - py;\n        return deltaX * deltaX + deltaY * deltaY;\n    };\n    return Geometry;\n}());\n\n/**\n * A cell that holds data needed by the 1st steps of the NavMesh generation.\n */\nvar RasterizationCell = /** @class */ (function () {\n    function RasterizationCell(x, y) {\n        /**\n         * 0 means there is an obstacle in the cell.\n         * See {@link RegionGenerator}\n         */\n        this.distanceToObstacle = Number.MAX_VALUE;\n        this.regionID = RasterizationCell.NULL_REGION_ID;\n        this.distanceToRegionCore = 0;\n        /**\n         * If a cell is connected to one or more external regions then the\n         *  flag will be a 4 bit value where connections are recorded as\n         *  follows:\n         *  - bit1 = neighbor0\n         *  - bit2 = neighbor1\n         *  - bit3 = neighbor2\n         *  - bit4 = neighbor3\n         *  With the meaning of the bits as follows:\n         *  - 0 = neighbor in same region.\n         *  - 1 = neighbor not in same region (neighbor may be the obstacle\n         *    region or a real region).\n         *\n         * See {@link ContourBuilder}\n         */\n        this.contourFlags = 0;\n        this.x = x;\n        this.y = y;\n        this.clear();\n    }\n    RasterizationCell.prototype.clear = function () {\n        this.distanceToObstacle = Number.MAX_VALUE;\n        this.regionID = RasterizationCell.NULL_REGION_ID;\n        this.distanceToRegionCore = 0;\n        this.contourFlags = 0;\n    };\n    /** A cell that has not been assigned to any region yet */\n    RasterizationCell.NULL_REGION_ID = 0;\n    /**\n     * A cell that contains an obstacle.\n     *\n     * The value is the same as NULL_REGION_ID because the cells that are\n     * not assigned to any region at the end of the flooding algorithm are\n     * the obstacle cells.\n     */\n    RasterizationCell.OBSTACLE_REGION_ID = 0;\n    return RasterizationCell;\n}());\n\nvar RasterizationGrid = /** @class */ (function () {\n    function RasterizationGrid(left, top, right, bottom, cellWidth, cellHeight) {\n        this.regionCount = 0;\n        this.cellWidth = cellWidth;\n        this.cellHeight = cellHeight;\n        this.originX = left - cellWidth;\n        this.originY = top - cellHeight;\n        var dimX = 2 + Math.ceil((right - left) / cellWidth);\n        var dimY = 2 + Math.ceil((bottom - top) / cellHeight);\n        this.cells = [];\n        for (var y = 0; y < dimY; y++) {\n            this.cells[y] = [];\n            for (var x = 0; x < dimX; x++) {\n                this.cells[y][x] = new RasterizationCell(x, y);\n            }\n        }\n    }\n    RasterizationGrid.prototype.clear = function () {\n        for (var _i = 0, _a = this.cells; _i < _a.length; _i++) {\n            var row = _a[_i];\n            for (var _b = 0, row_1 = row; _b < row_1.length; _b++) {\n                var cell = row_1[_b];\n                cell.clear();\n            }\n        }\n        this.regionCount = 0;\n    };\n    /**\n     *\n     * @param position the position on the scene\n     * @param gridPosition the position on the grid\n     * @returns the position on the grid\n     */\n    RasterizationGrid.prototype.convertToGridBasis = function (position, gridPosition) {\n        gridPosition.x = (position.x - this.originX) / this.cellWidth;\n        gridPosition.y = (position.y - this.originY) / this.cellHeight;\n        return gridPosition;\n    };\n    /**\n     *\n     * @param gridPosition the position on the grid\n     * @param position the position on the scene\n     * @returns the position on the scene\n     */\n    RasterizationGrid.prototype.convertFromGridBasis = function (gridPosition, position) {\n        position.x = gridPosition.x * this.cellWidth + this.originX;\n        position.y = gridPosition.y * this.cellHeight + this.originY;\n        return position;\n    };\n    RasterizationGrid.prototype.get = function (x, y) {\n        return this.cells[y][x];\n    };\n    RasterizationGrid.prototype.getNeighbor = function (cell, direction) {\n        var delta = RasterizationGrid.neighbor8Deltas[direction];\n        return this.cells[cell.y + delta.y][cell.x + delta.x];\n    };\n    RasterizationGrid.prototype.dimY = function () {\n        return this.cells.length;\n    };\n    RasterizationGrid.prototype.dimX = function () {\n        var firstColumn = this.cells[0];\n        return firstColumn ? firstColumn.length : 0;\n    };\n    RasterizationGrid.prototype.obstacleDistanceMax = function () {\n        var max = 0;\n        for (var _i = 0, _a = this.cells; _i < _a.length; _i++) {\n            var cellRow = _a[_i];\n            for (var _b = 0, cellRow_1 = cellRow; _b < cellRow_1.length; _b++) {\n                var cell = cellRow_1[_b];\n                if (cell.distanceToObstacle > max) {\n                    max = cell.distanceToObstacle;\n                }\n            }\n        }\n        return max;\n    };\n    RasterizationGrid.neighbor4Deltas = [\n        { x: -1, y: 0 },\n        { x: 0, y: 1 },\n        { x: 1, y: 0 },\n        { x: 0, y: -1 },\n    ];\n    RasterizationGrid.neighbor8Deltas = [\n        { x: -1, y: 0 },\n        { x: 0, y: 1 },\n        { x: 1, y: 0 },\n        { x: 0, y: -1 },\n        { x: 1, y: 1 },\n        { x: -1, y: 1 },\n        { x: -1, y: -1 },\n        { x: 1, y: -1 },\n    ];\n    return RasterizationGrid;\n}());\n\n/**\n * Builds a set of contours from the region information contained in\n * {@link RasterizationCell}. It does this by locating and \"walking\" the edges.\n *\n * This implementation is strongly inspired from CritterAI class \"ContourSetBuilder\".\n * http://www.critterai.org/projects/nmgen_study/contourgen.html\n */\nvar ContourBuilder = /** @class */ (function () {\n    function ContourBuilder() {\n        // These are working lists whose content changes with each iteration\n        // of the up coming loop. They represent the detailed and simple\n        // contour vertices.\n        // Initial sizing is arbitrary.\n        this.workingRawVertices = new Array(256);\n        this.workingSimplifiedVertices = new Array(64);\n    }\n    /**\n     * Generates a contour set from the provided {@link RasterizationGrid}\n     *\n     * The provided field is expected to contain region information.\n     * Behavior is undefined if the provided field is malformed or incomplete.\n     *\n     * This operation overwrites the flag fields for all cells in the\n     * provided field. So the flags must be saved and restored if they are\n     * important.\n     *\n     * @param grid A fully generated field.\n     * @param threshold The maximum distance (in cells) the edge of the contour\n     * may deviate from the source geometry when the rastered obstacles are\n     * vectorized.\n     *\n     * Setting it to:\n     * - 1 ensure that an aliased edge won't be split to more edges.\n     * - more that 1 will reduce the number of edges but the obstacles edges\n     *   will be followed with less accuracy.\n     * - less that 1 might be more accurate but it may try to follow the\n     *   aliasing and be a lot less accurate.\n     *\n     * Values under 1 can be useful in specific cases:\n     * - when edges are horizontal or vertical, there is no aliasing so value\n     *   near 0 can do better results.\n     * - when edges are 45° multiples, aliased vertex won't be farther than\n     *   sqrt(2)/2 so values over 0.71 should give good results but not\n     *   necessarily better than 1.\n     *\n     * @return The contours generated from the field.\n     */\n    ContourBuilder.prototype.buildContours = function (grid, threshold) {\n        var contours = new Array(grid.regionCount);\n        contours.length = 0;\n        var contoursByRegion = new Array(grid.regionCount);\n        var discardedContours = 0;\n        //  Set the flags on all cells in non-obstacle regions to indicate which\n        //  edges are connected to external regions.\n        //\n        //  Reference: Neighbor search and nomenclature.\n        //  http://www.critterai.org/projects/nmgen_study/heightfields.html#nsearch\n        //\n        //  If a cell has no connections to external regions or is\n        //  completely surrounded by other regions (a single cell island),\n        //  its flag will be zero.\n        //\n        //  If a cell is connected to one or more external regions then the\n        //  flag will be a 4 bit value where connections are recorded as\n        //  follows:\n        //      bit1 = neighbor0\n        //      bit2 = neighbor1\n        //      bit3 = neighbor2\n        //      bit4 = neighbor3\n        //  With the meaning of the bits as follows:\n        //      0 = neighbor in same region.\n        //      1 = neighbor not in same region (neighbor may be the obstacle\n        //      region or a real region).\n        for (var y = 1; y < grid.dimY() - 1; y++) {\n            for (var x = 1; x < grid.dimX() - 1; x++) {\n                var cell = grid.get(x, y);\n                // Note:  This algorithm first sets the flag bits such that\n                // 1 = \"neighbor is in the same region\". At the end it inverts\n                // the bits so flags are as expected.\n                // Default to \"not connected to any external region\".\n                cell.contourFlags = 0;\n                if (cell.regionID === RasterizationCell.OBSTACLE_REGION_ID)\n                    // Don't care about cells in the obstacle region.\n                    continue;\n                for (var direction = 0; direction < RasterizationGrid.neighbor4Deltas.length; direction++) {\n                    var delta = RasterizationGrid.neighbor4Deltas[direction];\n                    var neighbor = grid.get(cell.x + delta.x, cell.y + delta.y);\n                    if (cell.regionID === neighbor.regionID) {\n                        // Neighbor is in same region as this cell.\n                        // Set the bit for this neighbor to 1 (Will be inverted later).\n                        cell.contourFlags |= 1 << direction;\n                    }\n                }\n                // Invert the bits so a bit value of 1 indicates neighbor NOT in\n                // same region.\n                cell.contourFlags ^= 0xf;\n                if (cell.contourFlags === 0xf) {\n                    // This is an island cell (All neighbors are from other regions)\n                    // Get rid of flags.\n                    cell.contourFlags = 0;\n                    console.warn(\"Discarded contour: Island cell. Can't form  a contour. Region: \" +\n                        cell.regionID);\n                    discardedContours++;\n                }\n            }\n        }\n        // Loop through all cells looking for cells on the edge of a region.\n        //\n        // At this point, only cells with flags != 0 are edge cells that\n        // are part of a region contour.\n        //\n        // The process of building a contour will clear the flags on all cells\n        // that make up the contour to ensure they are only processed once.\n        for (var y = 1; y < grid.dimY() - 1; y++) {\n            for (var x = 1; x < grid.dimX() - 1; x++) {\n                var cell = grid.get(x, y);\n                if (cell.regionID === RasterizationCell.OBSTACLE_REGION_ID ||\n                    cell.contourFlags === 0) {\n                    // cell is either: Part of the obstacle region, does not\n                    // represent an edge cell, or was already processed during\n                    // an earlier iteration.\n                    continue;\n                }\n                this.workingRawVertices.length = 0;\n                this.workingSimplifiedVertices.length = 0;\n                // The cell is part of an unprocessed region's contour.\n                // Locate a direction of the cell's edge which points toward\n                // another region (there is at least one).\n                var startDirection = 0;\n                while ((cell.contourFlags & (1 << startDirection)) === 0) {\n                    startDirection++;\n                }\n                // We now have a cell that is part of a contour and a direction\n                // that points to a different region (obstacle or real).\n                // Build the contour.\n                this.buildRawContours(grid, cell, startDirection, this.workingRawVertices);\n                // Perform post processing on the contour in order to\n                // create the final, simplified contour.\n                this.generateSimplifiedContour(cell.regionID, this.workingRawVertices, this.workingSimplifiedVertices, threshold);\n                // The CritterAI implementation filters polygons with less than\n                // 3 vertices, but they are needed to filter vertices in the middle\n                // (not on an obstacle region border).\n                var contour = Array.from(this.workingSimplifiedVertices);\n                contours.push(contour);\n                contoursByRegion[cell.regionID] = contour;\n            }\n        }\n        if (contours.length + discardedContours !== grid.regionCount - 1) {\n            // The only valid state is one contour per region.\n            //\n            // The only time this should occur is if an invalid contour\n            // was formed or if a region resulted in multiple\n            // contours (bad region data).\n            //\n            // IMPORTANT: While a mismatch may not be a fatal error,\n            // it should be addressed since it can result in odd,\n            // hard to spot anomalies later in the pipeline.\n            //\n            // A known cause is if a region fully encompasses another\n            // region. In such a case, two contours will be formed.\n            // The normal outer contour and an inner contour.\n            // The CleanNullRegionBorders algorithm protects\n            // against internal encompassed obstacle regions.\n            console.error(\"Contour generation failed: Detected contours does\" +\n                \" not match the number of regions. Regions: \" +\n                (grid.regionCount - 1) +\n                \", Detected contours: \" +\n                (contours.length + discardedContours) +\n                \" (Actual: \" +\n                contours.length +\n                \", Discarded: \" +\n                discardedContours +\n                \")\");\n            // The CritterAI implementation has more detailed logs.\n            // They can be interesting for debugging.\n        }\n        this.filterNonObstacleVertices(contours, contoursByRegion);\n        return contours;\n    };\n    /**\n     * Search vertices that are not shared with the obstacle region and\n     * remove them.\n     *\n     * Some contours will have no vertex left.\n     *\n     * @param contours\n     * @param contoursByRegion Some regions may have been discarded\n     * so contours index can't be used.\n     */\n    ContourBuilder.prototype.filterNonObstacleVertices = function (contours, contoursByRegion) {\n        // This was not part of the CritterAI implementation.\n        // The removed vertex is merged on the nearest of the edges other extremity\n        // that is on an obstacle border.\n        var commonVertexContours = new Array(5);\n        var commonVertexIndexes = new Array(5);\n        // Each pass only filter vertex that have an edge other extremity on an obstacle.\n        // Vertex depth (in number of edges to reach an obstacle) is reduces by\n        // at least one by each pass.\n        var movedAnyVertex = false;\n        do {\n            movedAnyVertex = false;\n            for (var _i = 0, contours_1 = contours; _i < contours_1.length; _i++) {\n                var contour = contours_1[_i];\n                for (var vertexIndex = 0; vertexIndex < contour.length; vertexIndex++) {\n                    var vertex = contour[vertexIndex];\n                    var nextVertex = contour[(vertexIndex + 1) % contour.length];\n                    if (vertex.region !== RasterizationCell.OBSTACLE_REGION_ID &&\n                        nextVertex.region !== RasterizationCell.OBSTACLE_REGION_ID) {\n                        // This is a vertex in the middle. It must be removed.\n                        // Search the contours around the vertex.\n                        //\n                        // Typically a contour point to its neighbor and it form a cycle.\n                        //\n                        //   \\ C /\n                        //    \\ /\n                        //  A  |  B\n                        //     |\n                        //\n                        // C -> B -> A -> C\n                        //\n                        // There can be more than 3 contours even if it's rare.\n                        commonVertexContours.length = 0;\n                        commonVertexIndexes.length = 0;\n                        commonVertexContours.push(contour);\n                        commonVertexIndexes.push(vertexIndex);\n                        var errorFound = false;\n                        var commonVertex = vertex;\n                        do {\n                            var neighborContour = contoursByRegion[commonVertex.region];\n                            if (!neighborContour) {\n                                errorFound = true;\n                                if (commonVertex.region !== RasterizationCell.OBSTACLE_REGION_ID) {\n                                    console.warn(\"contour already discarded: \" + commonVertex.region);\n                                }\n                                break;\n                            }\n                            var foundVertex = false;\n                            for (var neighborVertexIndex = 0; neighborVertexIndex < neighborContour.length; neighborVertexIndex++) {\n                                var neighborVertex = neighborContour[neighborVertexIndex];\n                                if (neighborVertex.x === commonVertex.x &&\n                                    neighborVertex.y === commonVertex.y) {\n                                    commonVertexContours.push(neighborContour);\n                                    commonVertexIndexes.push(neighborVertexIndex);\n                                    commonVertex = neighborVertex;\n                                    foundVertex = true;\n                                    break;\n                                }\n                            }\n                            if (!foundVertex) {\n                                errorFound = true;\n                                console.error(\"Can't find a common vertex with a neighbor contour. There is probably a superposition.\");\n                                break;\n                            }\n                        } while (commonVertex !== vertex);\n                        if (errorFound) {\n                            continue;\n                        }\n                        if (commonVertexContours.length < 3) {\n                            console.error(\"The vertex is shared by only \" + commonVertexContours.length + \" regions.\");\n                        }\n                        var shorterEdgeContourIndex = -1;\n                        var edgeLengthMin = Number.MAX_VALUE;\n                        for (var index = 0; index < commonVertexContours.length; index++) {\n                            var vertexContour = commonVertexContours[index];\n                            var vertexIndex_1 = commonVertexIndexes[index];\n                            var previousVertex = vertexContour[(vertexIndex_1 - 1 + vertexContour.length) %\n                                vertexContour.length];\n                            if (previousVertex.region === RasterizationCell.OBSTACLE_REGION_ID) {\n                                var deltaX = previousVertex.x - vertex.x;\n                                var deltaY = previousVertex.y - vertex.y;\n                                var lengthSq = deltaX * deltaX + deltaY * deltaY;\n                                if (lengthSq < edgeLengthMin) {\n                                    edgeLengthMin = lengthSq;\n                                    shorterEdgeContourIndex = index;\n                                }\n                            }\n                        }\n                        if (shorterEdgeContourIndex === -1) {\n                            // A vertex has no neighbor on an obstacle.\n                            // It will be solved in next iterations.\n                            continue;\n                        }\n                        // Merge the vertex on the other extremity of the smallest of the 3 edges.\n                        //\n                        //   \\ C /\n                        //    \\ /\n                        //  A  |  B\n                        //     |\n                        //\n                        // - the shortest edge is between A and B\n                        // - the Y will become a V\n                        // - vertices are store clockwise\n                        // - there can be more than one C (it's rare)\n                        // This is B\n                        var shorterEdgeContour = commonVertexContours[shorterEdgeContourIndex];\n                        var shorterEdgeVertexIndex = commonVertexIndexes[shorterEdgeContourIndex];\n                        var shorterEdgeExtremityVertex = shorterEdgeContour[(shorterEdgeVertexIndex - 1 + shorterEdgeContour.length) %\n                            shorterEdgeContour.length];\n                        // This is A\n                        var shorterEdgeOtherContourIndex = (shorterEdgeContourIndex + 1) % commonVertexContours.length;\n                        var shorterEdgeOtherContour = commonVertexContours[shorterEdgeOtherContourIndex];\n                        var shorterEdgeOtherVertexIndex = commonVertexIndexes[shorterEdgeOtherContourIndex];\n                        for (var index = 0; index < commonVertexContours.length; index++) {\n                            if (index === shorterEdgeContourIndex ||\n                                index === shorterEdgeOtherContourIndex) {\n                                continue;\n                            }\n                            // These are C\n                            var commonVertexContour = commonVertexContours[index];\n                            var commonVertexIndex = commonVertexIndexes[index];\n                            // Move the vertex to an obstacle border\n                            var movedVertex = commonVertexContour[commonVertexIndex];\n                            movedVertex.x = shorterEdgeExtremityVertex.x;\n                            movedVertex.y = shorterEdgeExtremityVertex.y;\n                            movedVertex.region = RasterizationCell.NULL_REGION_ID;\n                        }\n                        // There is no more border between A and B,\n                        // update the region from B to C.\n                        shorterEdgeOtherContour[(shorterEdgeOtherVertexIndex + 1) % shorterEdgeOtherContour.length].region =\n                            shorterEdgeOtherContour[shorterEdgeOtherVertexIndex].region;\n                        // Remove in A and B the vertex that's been move in C.\n                        shorterEdgeContour.splice(shorterEdgeVertexIndex, 1);\n                        shorterEdgeOtherContour.splice(shorterEdgeOtherVertexIndex, 1);\n                        movedAnyVertex = true;\n                    }\n                }\n            }\n        } while (movedAnyVertex);\n        // Clean the polygons from identical vertices.\n        //\n        // This can happen with 2 vertices regions.\n        // 2 edges are superposed and there extremity is the same.\n        // One is move over the other.\n        // I could observe this with a region between 2 regions\n        // where one of one of these 2 regions were also encompassed.\n        // A bit like a rainbow, 2 big regions: the land, the sky\n        // and 2 regions for the colors.\n        //\n        // The vertex can't be removed during the process because\n        // they hold data used by other merging.\n        //\n        // Some contour will have no vertex left.\n        // It more efficient to let the next step ignore them.\n        for (var _a = 0, contours_2 = contours; _a < contours_2.length; _a++) {\n            var contour = contours_2[_a];\n            for (var vertexIndex = 0; vertexIndex < contour.length; vertexIndex++) {\n                var vertex = contour[vertexIndex];\n                var nextVertexIndex = (vertexIndex + 1) % contour.length;\n                var nextVertex = contour[nextVertexIndex];\n                if (vertex.x === nextVertex.x && vertex.y === nextVertex.y) {\n                    contour.splice(nextVertexIndex, 1);\n                    vertexIndex--;\n                }\n            }\n        }\n    };\n    /**\n     * Walk around the edge of this cell's region gathering vertices that\n     * represent the corners of each cell on the sides that are external facing.\n     *\n     * There will be two or three vertices for each edge cell:\n     * Two for cells that don't represent a change in edge direction. Three\n     * for cells that represent a change in edge direction.\n     *\n     * The output array will contain vertices ordered as follows:\n     * (x, y, z, regionID) where regionID is the region (obstacle or real) that\n     * this vertex is considered to be connected to.\n     *\n     * WARNING: Only run this operation on cells that are already known\n     * to be on a region edge. The direction must also be pointing to a\n     * valid edge. Otherwise behavior will be undefined.\n     *\n     * @param grid the grid of cells\n     * @param startCell A cell that is known to be on the edge of a region\n     * (part of a region contour).\n     * @param startDirection The direction of the edge of the cell that is\n     * known to point\n     * across the region edge.\n     * @param outContourVertices The list of vertices that represent the edge\n     * of the region.\n     */\n    ContourBuilder.prototype.buildRawContours = function (grid, startCell, startDirection, outContourVertices) {\n        // Flaw in Algorithm:\n        //\n        // This method of contour generation can result in an inappropriate\n        // impassable seam between two adjacent regions in the following case:\n        //\n        // 1. One region connects to another region on two sides in an\n        // uninterrupted manner (visualize one region wrapping in an L\n        // shape around the corner of another).\n        // 2. At the corner shared by the two regions, a change in height\n        // occurs.\n        //\n        // In this case, the two regions should share a corner vertex\n        // (an obtuse corner vertex for one region and an acute corner\n        // vertex for the other region).\n        //\n        // In reality, though this algorithm will select the same (x, z)\n        // coordinates for each region's corner vertex, the vertex heights\n        // may differ, eventually resulting in an impassable seam.\n        // It is a bit hard to describe the stepping portion of this algorithm.\n        // One way to visualize it is to think of a robot sitting on the\n        // floor facing a known wall. It then does the following to skirt\n        // the wall:\n        // 1. If there is a wall in front of it, turn clockwise in 90 degrees\n        //    increments until it finds the wall is gone.\n        // 2. Move forward one step.\n        // 3. Turn counter-clockwise by 90 degrees.\n        // 4. Repeat from step 1 until it finds itself at its original\n        //    location facing its original direction.\n        //\n        // See also: http://www.critterai.org/projects/nmgen_study/contourgen.html#robotwalk\n        var cell = startCell;\n        var direction = startDirection;\n        var loopCount = 0;\n        do {\n            // Note: The design of this loop is such that the cell variable\n            // will always reference an edge cell from the same region as\n            // the start cell.\n            if ((cell.contourFlags & (1 << direction)) !== 0) {\n                // The current direction is pointing toward an edge.\n                // Get this edge's vertex.\n                var delta = ContourBuilder.leftVertexOfFacingCellBorderDeltas[direction];\n                var neighbor = grid.get(cell.x + RasterizationGrid.neighbor4Deltas[direction].x, cell.y + RasterizationGrid.neighbor4Deltas[direction].y);\n                outContourVertices.push({\n                    x: cell.x + delta.x,\n                    y: cell.y + delta.y,\n                    region: neighbor.regionID,\n                });\n                // Remove the flag for this edge. We never need to consider\n                // it again since we have a vertex for this edge.\n                cell.contourFlags &= ~(1 << direction);\n                // Rotate in clockwise direction.\n                direction = (direction + 1) & 0x3;\n            }\n            else {\n                // The current direction does not point to an edge. So it\n                // must point to a neighbor cell in the same region as the\n                // current cell. Move to the neighbor and swing the search\n                // direction back one increment (counterclockwise).\n                // By moving the direction back one increment we guarantee we\n                // don't miss any edges.\n                var neighbor = grid.get(cell.x + RasterizationGrid.neighbor4Deltas[direction].x, cell.y + RasterizationGrid.neighbor4Deltas[direction].y);\n                cell = neighbor;\n                direction = (direction + 3) & 0x3; // Rotate counterclockwise.\n            }\n            // The loop limit is arbitrary. It exists only to guarantee that\n            // bad input data doesn't result in an infinite loop.\n            // The only down side of this loop limit is that it limits the\n            // number of detectable edge vertices (the longer the region edge\n            // and the higher the number of \"turns\" in a region's edge, the less\n            // edge vertices can be detected for that region).\n        } while (!(cell === startCell && direction === startDirection) &&\n            ++loopCount < 65535);\n        return outContourVertices;\n    };\n    /**\n     * Takes a group of vertices that represent a region contour and changes\n     * it in the following manner:\n     * - For any edges that connect to non-obstacle regions, remove all\n     * vertices except the start and end vertices for that edge (this\n     * smooths the edges between non-obstacle regions into a straight line).\n     * - Runs an algorithm's against the contour to follow the edge more closely.\n     *\n     * @param regionID The region the contour was derived from.\n     * @param sourceVertices  The source vertices that represent the complex\n     * contour.\n     * @param outVertices The simplified contour vertices.\n     * @param threshold The maximum distance the edge of the contour may deviate\n     * from the source geometry.\n     */\n    ContourBuilder.prototype.generateSimplifiedContour = function (regionID, sourceVertices, outVertices, threshold) {\n        var noConnections = true;\n        for (var _i = 0, sourceVertices_1 = sourceVertices; _i < sourceVertices_1.length; _i++) {\n            var sourceVertex = sourceVertices_1[_i];\n            if (sourceVertex.region !== RasterizationCell.OBSTACLE_REGION_ID) {\n                noConnections = false;\n                break;\n            }\n        }\n        // Seed the simplified contour with the mandatory edges\n        // (At least one edge).\n        if (noConnections) {\n            // This contour represents an island region surrounded only by the\n            // obstacle region. Seed the simplified contour with the source's\n            // lower left (ll) and upper right (ur) vertices.\n            var lowerLeftX = sourceVertices[0].x;\n            var lowerLeftY = sourceVertices[0].y;\n            var lowerLeftIndex = 0;\n            var upperRightX = sourceVertices[0].x;\n            var upperRightY = sourceVertices[0].y;\n            var upperRightIndex = 0;\n            for (var index = 0; index < sourceVertices.length; index++) {\n                var sourceVertex = sourceVertices[index];\n                var x = sourceVertex.x;\n                var y = sourceVertex.y;\n                if (x < lowerLeftX || (x === lowerLeftX && y < lowerLeftY)) {\n                    lowerLeftX = x;\n                    lowerLeftY = y;\n                    lowerLeftIndex = index;\n                }\n                if (x >= upperRightX || (x === upperRightX && y > upperRightY)) {\n                    upperRightX = x;\n                    upperRightY = y;\n                    upperRightIndex = index;\n                }\n            }\n            // The region attribute is used to store an index locally in this function.\n            // TODO Maybe there is a way to do this cleanly and keep no memory footprint.\n            // Seed the simplified contour with this edge.\n            outVertices.push({\n                x: lowerLeftX,\n                y: lowerLeftY,\n                region: lowerLeftIndex,\n            });\n            outVertices.push({\n                x: upperRightX,\n                y: upperRightY,\n                region: upperRightIndex,\n            });\n        }\n        else {\n            // The contour shares edges with other non-obstacle regions.\n            // Seed the simplified contour with a new vertex for every\n            // location where the region connection changes. These are\n            // vertices that are important because they represent portals\n            // to other regions.\n            for (var index = 0; index < sourceVertices.length; index++) {\n                var sourceVert = sourceVertices[index];\n                if (sourceVert.region !==\n                    sourceVertices[(index + 1) % sourceVertices.length].region) {\n                    // The current vertex has a different region than the\n                    // next vertex. So there is a change in vertex region.\n                    outVertices.push({\n                        x: sourceVert.x,\n                        y: sourceVert.y,\n                        region: index,\n                    });\n                }\n            }\n        }\n        this.matchObstacleRegionEdges(sourceVertices, outVertices, threshold);\n        if (outVertices.length < 2) {\n            // It will be ignored by the triangulation.\n            // It should be rare enough not to handle it now.\n            console.warn(\"A region is encompassed in another region. It will be ignored.\");\n        }\n        // There can be polygons with only 2 vertices when a region is between\n        // 2 non-obstacles regions. It's still a useful information to filter\n        // vertices in the middle (not on an obstacle region border).\n        // In this case, the CritterAI implementation adds a 3rd point to avoid\n        // invisible polygons, but it makes it difficult to filter it later.\n        // Replace the index pointers in the output list with region IDs.\n        for (var _a = 0, outVertices_1 = outVertices; _a < outVertices_1.length; _a++) {\n            var outVertex = outVertices_1[_a];\n            outVertex.region = sourceVertices[outVertex.region].region;\n        }\n    };\n    /**\n     * Applies an algorithm to contours which results in obstacle-region edges\n     * following the original detail source geometry edge more closely.\n     * http://www.critterai.org/projects/nmgen_study/contourgen.html#nulledgesimple\n     *\n     * Adds vertices from the source list to the result list such that\n     * if any obstacle region vertices are compared against the result list,\n     * none of the vertices will be further from the obstacle region edges than\n     * the allowed threshold.\n     *\n     * Only obstacle-region edges are operated on. All other edges are\n     * ignored.\n     *\n     * The result vertices is expected to be seeded with at least two\n     * source vertices.\n     *\n     * @param sourceVertices\n     * @param inoutResultVertices\n     * @param threshold The maximum distance the edge of the contour may deviate\n     * from the source geometry.\n     */\n    ContourBuilder.prototype.matchObstacleRegionEdges = function (sourceVertices, inoutResultVertices, threshold) {\n        // This implementation is strongly inspired from CritterAI class \"MatchNullRegionEdges\".\n        // Loop through all edges in this contour.\n        //\n        // NOTE: The simplifiedVertCount in the loop condition\n        // increases over iterations. That is what keeps the loop going beyond\n        // the initial vertex count.\n        var resultIndexA = 0;\n        while (resultIndexA < inoutResultVertices.length) {\n            var resultIndexB = (resultIndexA + 1) % inoutResultVertices.length;\n            // The line segment's beginning vertex.\n            var ax = inoutResultVertices[resultIndexA].x;\n            var az = inoutResultVertices[resultIndexA].y;\n            var sourceIndexA = inoutResultVertices[resultIndexA].region;\n            // The line segment's ending vertex.\n            var bx = inoutResultVertices[resultIndexB].x;\n            var bz = inoutResultVertices[resultIndexB].y;\n            var sourceIndexB = inoutResultVertices[resultIndexB].region;\n            // The source index of the next vertex to test (the vertex just\n            // after the current vertex in the source vertex list).\n            var testedSourceIndex = (sourceIndexA + 1) % sourceVertices.length;\n            var maxDeviation = 0;\n            // Default to no index. No new vert to add.\n            var toInsertSourceIndex = -1;\n            if (sourceVertices[testedSourceIndex].region ===\n                RasterizationCell.OBSTACLE_REGION_ID) {\n                // This test vertex is part of a obstacle region edge.\n                // Loop through the source vertices until the end vertex\n                // is found, searching for the vertex that is farthest from\n                // the line segment formed by the begin/end vertices.\n                //\n                // Visualizations:\n                // http://www.critterai.org/projects/nmgen_study/contourgen.html#nulledgesimple\n                while (testedSourceIndex !== sourceIndexB) {\n                    var deviation = Geometry.getPointSegmentDistanceSq(sourceVertices[testedSourceIndex].x, sourceVertices[testedSourceIndex].y, ax, az, bx, bz);\n                    if (deviation > maxDeviation) {\n                        // A new maximum deviation was detected.\n                        maxDeviation = deviation;\n                        toInsertSourceIndex = testedSourceIndex;\n                    }\n                    // Move to the next vertex.\n                    testedSourceIndex = (testedSourceIndex + 1) % sourceVertices.length;\n                }\n            }\n            if (toInsertSourceIndex !== -1 && maxDeviation > threshold * threshold) {\n                // A vertex was found that is further than allowed from the\n                // current edge. Add this vertex to the contour.\n                inoutResultVertices.splice(resultIndexA + 1, 0, {\n                    x: sourceVertices[toInsertSourceIndex].x,\n                    y: sourceVertices[toInsertSourceIndex].y,\n                    region: toInsertSourceIndex,\n                });\n                // Not incrementing the vertex since we need to test the edge\n                // formed by vertA  and this this new vertex on the next\n                // iteration of the loop.\n            }\n            // This edge segment does not need to be altered. Move to\n            // the next vertex.\n            else\n                resultIndexA++;\n        }\n    };\n    ContourBuilder.leftVertexOfFacingCellBorderDeltas = [\n        { x: 0, y: 1 },\n        { x: 1, y: 1 },\n        { x: 1, y: 0 },\n        { x: 0, y: 0 },\n    ];\n    return ContourBuilder;\n}());\n\n/**\n * Builds convex polygons from the provided polygons.\n *\n * This implementation is strongly inspired from CritterAI class \"PolyMeshFieldBuilder\".\n * http://www.critterai.org/projects/nmgen_study/polygen.html\n */\nvar ConvexPolygonGenerator = /** @class */ (function () {\n    function ConvexPolygonGenerator() {\n    }\n    /**\n     * Builds convex polygons from the provided polygons.\n     * @param concavePolygons The content is manipulated during the operation\n     * and it will be left in an undefined state at the end of\n     * the operation.\n     * @param maxVerticesPerPolygon cap the vertex number in return polygons.\n     * @return convex polygons.\n     */\n    ConvexPolygonGenerator.prototype.splitToConvexPolygons = function (concavePolygons, maxVerticesPerPolygon) {\n        // The maximum possible number of polygons assuming that all will\n        // be triangles.\n        var maxPossiblePolygons = 0;\n        // The maximum vertices found in a single contour.\n        var maxVerticesPerContour = 0;\n        for (var _i = 0, concavePolygons_1 = concavePolygons; _i < concavePolygons_1.length; _i++) {\n            var contour = concavePolygons_1[_i];\n            var count = contour.length;\n            maxPossiblePolygons += count - 2;\n            maxVerticesPerContour = Math.max(maxVerticesPerContour, count);\n        }\n        // Each list is initialized to a size that will minimize resizing.\n        var convexPolygons = new Array(maxPossiblePolygons);\n        convexPolygons.length = 0;\n        // Various working variables.\n        // (Values are meaningless outside of the iteration)\n        var workingContourFlags = new Array(maxVerticesPerContour);\n        workingContourFlags.length = 0;\n        var workingPolygons = new Array(maxVerticesPerContour + 1);\n        workingPolygons.length = 0;\n        var workingMergeInfo = {\n            lengthSq: -1,\n            polygonAVertexIndex: -1,\n            polygonBVertexIndex: -1,\n        };\n        var workingMergedPolygon = new Array(maxVerticesPerPolygon);\n        workingMergedPolygon.length = 0;\n        var _loop_1 = function (contour) {\n            if (contour.length < 3) {\n                return \"continue\";\n            }\n            // Initialize the working polygon array.\n            workingPolygons.length = 0;\n            // Triangulate the contour.\n            var foundAnyTriangle = false;\n            this_1.triangulate(contour, workingContourFlags, function (p1, p2, p3) {\n                var workingPolygon = new Array(maxVerticesPerPolygon);\n                workingPolygon.length = 0;\n                workingPolygon.push(p1);\n                workingPolygon.push(p2);\n                workingPolygon.push(p3);\n                workingPolygons.push(workingPolygon);\n                foundAnyTriangle = true;\n            });\n            if (!foundAnyTriangle) {\n                /*\n                    * Failure of the triangulation.\n                    * This is known to occur if the source polygon is\n                    * self-intersecting or the source region contains internal\n                    * holes. In both cases, the problem is likely due to bad\n                    * region formation.\n                    */\n                console.error(\"Polygon generation failure: Could not triangulate contour.\");\n                console.error(\"contour:\" +\n                    contour.map(function (point) { return point.x + \" \" + point.y; }).join(\" ; \"));\n                return \"continue\";\n            }\n            if (maxVerticesPerPolygon > 3) {\n                // Merging of triangles into larger polygons is permitted.\n                // Continue until no polygons can be found to merge.\n                // http://www.critterai.org/nmgen_polygen#mergepolys\n                while (true) {\n                    var longestMergeEdge = -1;\n                    var bestPolygonA = [];\n                    var polygonAVertexIndex = -1; // Start of the shared edge.\n                    var bestPolygonB = [];\n                    var polygonBVertexIndex = -1; // Start of the shared edge.\n                    var bestPolygonBIndex = -1;\n                    // Loop through all but the last polygon looking for the\n                    // best polygons to merge in this iteration.\n                    for (var indexA = 0; indexA < workingPolygons.length - 1; indexA++) {\n                        var polygonA = workingPolygons[indexA];\n                        for (var indexB = indexA + 1; indexB < workingPolygons.length; indexB++) {\n                            var polygonB = workingPolygons[indexB];\n                            // Can polyB merge with polyA?\n                            this_1.getPolyMergeInfo(polygonA, polygonB, maxVerticesPerPolygon, workingMergeInfo);\n                            if (workingMergeInfo.lengthSq > longestMergeEdge) {\n                                // polyB has the longest shared edge with\n                                // polyA found so far. Save the merge\n                                // information.\n                                longestMergeEdge = workingMergeInfo.lengthSq;\n                                bestPolygonA = polygonA;\n                                polygonAVertexIndex = workingMergeInfo.polygonAVertexIndex;\n                                bestPolygonB = polygonB;\n                                polygonBVertexIndex = workingMergeInfo.polygonBVertexIndex;\n                                bestPolygonBIndex = indexB;\n                            }\n                        }\n                    }\n                    if (longestMergeEdge <= 0)\n                        // No valid merges found during this iteration.\n                        break;\n                    // Found polygons to merge. Perform the merge.\n                    /*\n                        * Fill the mergedPoly array.\n                        * Start the vertex at the end of polygon A's shared edge.\n                        * Add all vertices until looping back to the vertex just\n                        * before the start of the shared edge. Repeat for\n                        * polygon B.\n                        *\n                        * Duplicate vertices are avoided, while ensuring we get\n                        * all vertices, since each loop  drops the vertex that\n                        * starts its polygon's shared edge and:\n                        *\n                        * PolyAStartVert == PolyBEndVert and\n                        * PolyAEndVert == PolyBStartVert.\n                        */\n                    var vertCountA = bestPolygonA.length;\n                    var vertCountB = bestPolygonB.length;\n                    workingMergedPolygon.length = 0;\n                    for (var i = 0; i < vertCountA - 1; i++)\n                        workingMergedPolygon.push(bestPolygonA[(polygonAVertexIndex + 1 + i) % vertCountA]);\n                    for (var i = 0; i < vertCountB - 1; i++)\n                        workingMergedPolygon.push(bestPolygonB[(polygonBVertexIndex + 1 + i) % vertCountB]);\n                    // Copy the merged polygon over the top of polygon A.\n                    bestPolygonA.length = 0;\n                    Array.prototype.push.apply(bestPolygonA, workingMergedPolygon);\n                    // Remove polygon B\n                    workingPolygons.splice(bestPolygonBIndex, 1);\n                }\n            }\n            // Polygon creation for this contour is complete.\n            // Add polygons to the global polygon array\n            Array.prototype.push.apply(convexPolygons, workingPolygons);\n        };\n        var this_1 = this;\n        // Split every concave polygon into convex polygons.\n        for (var _a = 0, concavePolygons_2 = concavePolygons; _a < concavePolygons_2.length; _a++) {\n            var contour = concavePolygons_2[_a];\n            _loop_1(contour);\n        }\n        // The original implementation builds polygon adjacency information.\n        // but the library for the pathfinding already does it.\n        return convexPolygons;\n    };\n    /**\n     * Checks two polygons to see if they can be merged. If a merge is\n     * allowed, provides data via the outResult argument (see {@link PolyMergeResult}).\n     *\n     * @param polygonA The polygon A\n     * @param polygonB The polygon B\n     * @param maxVerticesPerPolygon cap the vertex number in return polygons.\n     * @param outResult contains merge information.\n     */\n    ConvexPolygonGenerator.prototype.getPolyMergeInfo = function (polygonA, polygonB, maxVerticesPerPolygon, outResult) {\n        outResult.lengthSq = -1; // Default to invalid merge\n        outResult.polygonAVertexIndex = -1;\n        outResult.polygonBVertexIndex = -1;\n        var vertexCountA = polygonA.length;\n        var vertexCountB = polygonB.length;\n        // If the merged polygon would would have to many vertices, do not\n        // merge. Subtracting two since to take into account the effect of\n        // a merge.\n        if (vertexCountA + vertexCountB - 2 > maxVerticesPerPolygon)\n            return;\n        // Check if the polygons share an edge.\n        for (var indexA = 0; indexA < vertexCountA; indexA++) {\n            // Get the vertex indices for the polygonA edge\n            var vertexA = polygonA[indexA];\n            var nextVertexA = polygonA[(indexA + 1) % vertexCountA];\n            // Search polygonB for matches.\n            for (var indexB = 0; indexB < vertexCountB; indexB++) {\n                // Get the vertex indices for the polygonB edge.\n                var vertexB = polygonB[indexB];\n                var nextVertexB = polygonB[(indexB + 1) % vertexCountB];\n                // === can be used because vertices comme from the same concave polygon.\n                if (vertexA === nextVertexB && nextVertexA === vertexB) {\n                    // The vertex indices for this edge are the same and\n                    // sequenced in opposite order. So the edge is shared.\n                    outResult.polygonAVertexIndex = indexA;\n                    outResult.polygonBVertexIndex = indexB;\n                }\n            }\n        }\n        if (outResult.polygonAVertexIndex === -1)\n            // No common edge, cannot merge.\n            return;\n        // Check to see if the merged polygon would be convex.\n        //\n        // Gets the vertices near the section where the merge would occur.\n        // Do they form a concave section?  If so, the merge is invalid.\n        //\n        // Note that the following algorithm is only valid for clockwise\n        // wrapped convex polygons.\n        var sharedVertMinus = polygonA[(outResult.polygonAVertexIndex - 1 + vertexCountA) % vertexCountA];\n        var sharedVert = polygonA[outResult.polygonAVertexIndex];\n        var sharedVertPlus = polygonB[(outResult.polygonBVertexIndex + 2) % vertexCountB];\n        if (!ConvexPolygonGenerator.isLeft(sharedVert.x, sharedVert.y, sharedVertMinus.x, sharedVertMinus.y, sharedVertPlus.x, sharedVertPlus.y)) {\n            // The shared vertex (center) is not to the left of segment\n            // vertMinus->vertPlus. For a clockwise wrapped polygon, this\n            // indicates a concave section. Merged polygon would be concave.\n            // Invalid merge.\n            return;\n        }\n        sharedVertMinus =\n            polygonB[(outResult.polygonBVertexIndex - 1 + vertexCountB) % vertexCountB];\n        sharedVert = polygonB[outResult.polygonBVertexIndex];\n        sharedVertPlus =\n            polygonA[(outResult.polygonAVertexIndex + 2) % vertexCountA];\n        if (!ConvexPolygonGenerator.isLeft(sharedVert.x, sharedVert.y, sharedVertMinus.x, sharedVertMinus.y, sharedVertPlus.x, sharedVertPlus.y)) {\n            // The shared vertex (center) is not to the left of segment\n            // vertMinus->vertPlus. For a clockwise wrapped polygon, this\n            // indicates a concave section. Merged polygon would be concave.\n            // Invalid merge.\n            return;\n        }\n        // Get the vertex indices that form the shared edge.\n        sharedVertMinus = polygonA[outResult.polygonAVertexIndex];\n        sharedVert = polygonA[(outResult.polygonAVertexIndex + 1) % vertexCountA];\n        // Store the lengthSq of the shared edge.\n        var deltaX = sharedVertMinus.x - sharedVert.x;\n        var deltaZ = sharedVertMinus.y - sharedVert.y;\n        outResult.lengthSq = deltaX * deltaX + deltaZ * deltaZ;\n    };\n    /**\n     * Attempts to triangulate a polygon.\n     *\n     * @param vertices the polygon to be triangulate.\n     * The content is manipulated during the operation\n     * and it will be left in an undefined state at the end of\n     * the operation.\n     * @param vertexFlags only used internally\n     * @param outTriangles is called for each triangle derived\n     * from the original polygon.\n     * @return The number of triangles generated. Or, if triangulation\n     * failed, a negative number.\n     */\n    ConvexPolygonGenerator.prototype.triangulate = function (vertices, vertexFlags, outTriangles) {\n        // Terminology, concepts and such:\n        //\n        // This algorithm loops around the edges of a polygon looking for\n        // new internal edges to add that will partition the polygon into a\n        // new valid triangle internal to the starting polygon. During each\n        // iteration the shortest potential new edge is selected to form that\n        // iteration's new triangle.\n        //\n        // Triangles will only be formed if a single new edge will create\n        // a triangle. Two new edges will never be added during a single\n        // iteration. This means that the triangulated portions of the\n        // original polygon will only contain triangles and the only\n        // non-triangle polygon will exist in the untriangulated portion\n        // of the original polygon.\n        //\n        // \"Partition edge\" refers to a potential new edge that will form a\n        // new valid triangle.\n        //\n        // \"Center\" vertex refers to the vertex in a potential new triangle\n        // which, if the triangle is formed, will be external to the\n        // remaining untriangulated portion of the polygon. Since it\n        // is now external to the polygon, it can't be used to form any\n        // new triangles.\n        //\n        // Some documentation refers to \"iPlus2\" even though the variable is\n        // not in scope or does not exist for that section of code. For\n        // documentation purposes, iPlus2 refers to the 2nd vertex after the\n        // primary vertex.\n        // E.g.: i, iPlus1, and iPlus2.\n        //\n        // Visualizations: http://www.critterai.org/projects/nmgen_study/polygen.html#triangulation\n        // Loop through all vertices, flagging all indices that represent\n        // a center vertex of a valid new triangle.\n        vertexFlags.length = vertices.length;\n        for (var i = 0; i < vertices.length; i++) {\n            var iPlus1 = (i + 1) % vertices.length;\n            var iPlus2 = (i + 2) % vertices.length;\n            // A triangle formed by i, iPlus1, and iPlus2 will result\n            // in a valid internal triangle.\n            // Flag the center vertex (iPlus1) to indicate a valid triangle\n            // location.\n            vertexFlags[iPlus1] = ConvexPolygonGenerator.isValidPartition(i, iPlus2, vertices);\n        }\n        // Loop through the vertices creating triangles. When there is only a\n        // single triangle left,  the operation is complete.\n        //\n        // When a valid triangle is formed, remove its center vertex. So for\n        // each loop, a single vertex will be removed.\n        //\n        // At the start of each iteration the indices list is in the following\n        // state:\n        // - Represents a simple polygon representing the un-triangulated\n        //   portion of the original polygon.\n        // - All valid center vertices are flagged.\n        while (vertices.length > 3) {\n            // Find the shortest new valid edge.\n            // NOTE: i and iPlus1 are defined in two different scopes in\n            // this section. So be careful.\n            // Loop through all indices in the remaining polygon.\n            var minLengthSq = Number.MAX_VALUE;\n            var minLengthSqVertexIndex = -1;\n            for (var i_1 = 0; i_1 < vertices.length; i_1++) {\n                if (vertexFlags[(i_1 + 1) % vertices.length]) {\n                    // Indices i, iPlus1, and iPlus2 are known to form a\n                    // valid triangle.\n                    var vert = vertices[i_1];\n                    var vertPlus2 = vertices[(i_1 + 2) % vertices.length];\n                    // Determine the length of the partition edge.\n                    // (i -> iPlus2)\n                    var deltaX = vertPlus2.x - vert.x;\n                    var deltaY = vertPlus2.y - vert.y;\n                    var lengthSq = deltaX * deltaX + deltaY * deltaY;\n                    if (lengthSq < minLengthSq) {\n                        minLengthSq = lengthSq;\n                        minLengthSqVertexIndex = i_1;\n                    }\n                }\n            }\n            if (minLengthSqVertexIndex === -1)\n                // Could not find a new triangle. Triangulation failed.\n                // This happens if there are three or more vertices\n                // left, but none of them are flagged as being a\n                // potential center vertex.\n                return;\n            var i = minLengthSqVertexIndex;\n            var iPlus1 = (i + 1) % vertices.length;\n            // Add the new triangle to the output.\n            outTriangles(vertices[i], vertices[iPlus1], vertices[(i + 2) % vertices.length]);\n            // iPlus1, the \"center\" vert in the new triangle, is now external\n            // to the untriangulated portion of the polygon. Remove it from\n            // the vertices list since it cannot be a member of any new\n            // triangles.\n            vertices.splice(iPlus1, 1);\n            vertexFlags.splice(iPlus1, 1);\n            if (iPlus1 === 0 || iPlus1 >= vertices.length) {\n                // The vertex removal has invalidated iPlus1 and/or i. So\n                // force a wrap, fixing the indices so they reference the\n                // correct indices again. This only occurs when the new\n                // triangle is formed across the wrap location of the polygon.\n                // Case 1: i = 14, iPlus1 = 15, iPlus2 = 0\n                // Case 2: i = 15, iPlus1 = 0, iPlus2 = 1;\n                i = vertices.length - 1;\n                iPlus1 = 0;\n            }\n            // At this point i and iPlus1 refer to the two indices from a\n            // successful triangulation that will be part of another new\n            // triangle. We now need to re-check these indices to see if they\n            // can now be the center index in a potential new partition.\n            vertexFlags[i] = ConvexPolygonGenerator.isValidPartition((i - 1 + vertices.length) % vertices.length, iPlus1, vertices);\n            vertexFlags[iPlus1] = ConvexPolygonGenerator.isValidPartition(i, (i + 2) % vertices.length, vertices);\n        }\n        // Only 3 vertices remain.\n        // Add their triangle to the output list.\n        outTriangles(vertices[0], vertices[1], vertices[2]);\n    };\n    /**\n     * Check if the line segment formed by vertex A and vertex B will\n     * form a valid partition of the polygon.\n     *\n     * I.e. the line segment AB is internal to the polygon and will not\n     * cross existing line segments.\n     *\n     * Assumptions:\n     * - The vertices arguments define a valid simple polygon\n     * with vertices wrapped clockwise.\n     * - indexA != indexB\n     *\n     * Behavior is undefined if the arguments to not meet these\n     * assumptions\n     *\n     * @param indexA the index of the vertex that will form the segment AB.\n     * @param indexB the index of the vertex that will form the segment AB.\n     * @param vertices a polygon wrapped clockwise.\n     * @return true if the line segment formed by vertex A and vertex B will\n     * form a valid partition of the polygon.\n     */\n    ConvexPolygonGenerator.isValidPartition = function (indexA, indexB, vertices) {\n        //  First check whether the segment AB lies within the internal\n        //  angle formed at A (this is the faster check).\n        //  If it does, then perform the more costly check.\n        return (ConvexPolygonGenerator.liesWithinInternalAngle(indexA, indexB, vertices) &&\n            !ConvexPolygonGenerator.hasIllegalEdgeIntersection(indexA, indexB, vertices));\n    };\n    /**\n     * Check if vertex B lies within the internal angle of the polygon\n     * at vertex A.\n     *\n     * Vertex B does not have to be within the polygon border. It just has\n     * be be within the area encompassed by the internal angle formed at\n     * vertex A.\n     *\n     * This operation is a fast way of determining whether a line segment\n     * can possibly form a valid polygon partition. If this test returns\n     * FALSE, then more expensive checks can be skipped.\n     *\n     * Visualizations: http://www.critterai.org/projects/nmgen_study/polygen.html#anglecheck\n     *\n     * Special case:\n     * FALSE is returned if vertex B lies directly on either of the rays\n     * cast from vertex A along its associated polygon edges. So the test\n     * on vertex B is exclusive of the polygon edges.\n     *\n     * Assumptions:\n     * - The vertices and indices arguments define a valid simple polygon\n     * with vertices wrapped clockwise.\n     * -indexA != indexB\n     *\n     * Behavior is undefined if the arguments to not meet these\n     * assumptions\n     *\n     * @param indexA the index of the vertex that will form the segment AB.\n     * @param indexB the index of the vertex that will form the segment AB.\n     * @param vertices a polygon wrapped clockwise.\n     * @return true if vertex B lies within the internal angle of\n     * the polygon at vertex A.\n     */\n    ConvexPolygonGenerator.liesWithinInternalAngle = function (indexA, indexB, vertices) {\n        // Get pointers to the main vertices being tested.\n        var vertexA = vertices[indexA];\n        var vertexB = vertices[indexB];\n        // Get pointers to the vertices just before and just after vertA.\n        var vertexAMinus = vertices[(indexA - 1 + vertices.length) % vertices.length];\n        var vertexAPlus = vertices[(indexA + 1) % vertices.length];\n        // First, find which of the two angles formed by the line segments\n        //  AMinus->A->APlus is internal to (pointing towards) the polygon.\n        // Then test to see if B lies within the area formed by that angle.\n        // TRUE if A is left of or on line AMinus->APlus\n        if (ConvexPolygonGenerator.isLeftOrCollinear(vertexA.x, vertexA.y, vertexAMinus.x, vertexAMinus.y, vertexAPlus.x, vertexAPlus.y))\n            // The angle internal to the polygon is <= 180 degrees\n            // (non-reflex angle).\n            // Test to see if B lies within this angle.\n            return (ConvexPolygonGenerator.isLeft(\n            // TRUE if B is left of line A->AMinus\n            vertexB.x, vertexB.y, vertexA.x, vertexA.y, vertexAMinus.x, vertexAMinus.y) &&\n                // TRUE if B is right of line A->APlus\n                ConvexPolygonGenerator.isRight(vertexB.x, vertexB.y, vertexA.x, vertexA.y, vertexAPlus.x, vertexAPlus.y));\n        // The angle internal to the polygon is > 180 degrees (reflex angle).\n        // Test to see if B lies within the external (<= 180 degree) angle and\n        // flip the result. (If B lies within the external angle, it can't\n        // lie within the internal angle)\n        return !(\n        // TRUE if B is left of or on line A->APlus\n        (ConvexPolygonGenerator.isLeftOrCollinear(vertexB.x, vertexB.y, vertexA.x, vertexA.y, vertexAPlus.x, vertexAPlus.y) &&\n            // TRUE if B is right of or on line A->AMinus\n            ConvexPolygonGenerator.isRightOrCollinear(vertexB.x, vertexB.y, vertexA.x, vertexA.y, vertexAMinus.x, vertexAMinus.y)));\n    };\n    /**\n     * Check if the line segment AB intersects any edges not already\n     * connected to one of the two vertices.\n     *\n     * Assumptions:\n     * - The vertices and indices arguments define a valid simple polygon\n     * with vertices wrapped clockwise.\n     * - indexA != indexB\n     *\n     * Behavior is undefined if the arguments to not meet these\n     * assumptions\n     *\n     * @param indexA the index of the vertex that will form the segment AB.\n     * @param indexB the index of the vertex that will form the segment AB.\n     * @param vertices a polygon wrapped clockwise.\n     * @return true if the line segment AB intersects any edges not already\n     * connected to one of the two vertices.\n     */\n    ConvexPolygonGenerator.hasIllegalEdgeIntersection = function (indexA, indexB, vertices) {\n        // Get pointers to the primary vertices being tested.\n        var vertexA = vertices[indexA];\n        var vertexB = vertices[indexB];\n        // Loop through the polygon edges.\n        for (var edgeBeginIndex = 0; edgeBeginIndex < vertices.length; edgeBeginIndex++) {\n            var edgeEndIndex = (edgeBeginIndex + 1) % vertices.length;\n            if (edgeBeginIndex === indexA ||\n                edgeBeginIndex === indexB ||\n                edgeEndIndex === indexA ||\n                edgeEndIndex === indexB) {\n                continue;\n            }\n            // Neither of the test indices are endpoints of this edge.\n            // Get this edge's vertices.\n            var edgeBegin = vertices[edgeBeginIndex];\n            var edgeEnd = vertices[edgeEndIndex];\n            if ((edgeBegin.x === vertexA.x && edgeBegin.y === vertexA.y) ||\n                (edgeBegin.x === vertexB.x && edgeBegin.y === vertexB.y) ||\n                (edgeEnd.x === vertexA.x && edgeEnd.y === vertexA.y) ||\n                (edgeEnd.x === vertexB.x && edgeEnd.y === vertexB.y)) {\n                // One of the test vertices is co-located\n                // with one of the endpoints of this edge (this is a\n                // test of the actual position of the vertices rather than\n                // simply the index check performed earlier).\n                // Skip this edge.\n                continue;\n            }\n            // This edge is not connected to either of the test vertices.\n            // If line segment AB intersects  with this edge, then the\n            // intersection is illegal.\n            // I.e. New edges cannot cross existing edges.\n            if (Geometry.segmentsIntersect(vertexA.x, vertexA.y, vertexB.x, vertexB.y, edgeBegin.x, edgeBegin.y, edgeEnd.x, edgeEnd.y)) {\n                return true;\n            }\n        }\n        return false;\n    };\n    /**\n     * Check if point P is to the left of line AB when looking\n     * from A to B.\n     * @param px The x-value of the point to test.\n     * @param py The y-value of the point to test.\n     * @param ax The x-value of the point (ax, ay) that is point A on line AB.\n     * @param ay The y-value of the point (ax, ay) that is point A on line AB.\n     * @param bx The x-value of the point (bx, by) that is point B on line AB.\n     * @param by The y-value of the point (bx, by) that is point B on line AB.\n     * @return TRUE if point P is to the left of line AB when looking\n     * from A to B.\n     */\n    ConvexPolygonGenerator.isLeft = function (px, py, ax, ay, bx, by) {\n        return ConvexPolygonGenerator.getSignedAreaX2(ax, ay, px, py, bx, by) < 0;\n    };\n    /**\n     * Check if point P is to the left of line AB when looking\n     * from A to B or is collinear with line AB.\n     * @param px The x-value of the point to test.\n     * @param py The y-value of the point to test.\n     * @param ax The x-value of the point (ax, ay) that is point A on line AB.\n     * @param ay The y-value of the point (ax, ay) that is point A on line AB.\n     * @param bx The x-value of the point (bx, by) that is point B on line AB.\n     * @param by The y-value of the point (bx, by) that is point B on line AB.\n     * @return TRUE if point P is to the left of line AB when looking\n     * from A to B, or is collinear with line AB.\n     */\n    ConvexPolygonGenerator.isLeftOrCollinear = function (px, py, ax, ay, bx, by) {\n        return ConvexPolygonGenerator.getSignedAreaX2(ax, ay, px, py, bx, by) <= 0;\n    };\n    /**\n     * Check if point P is to the right of line AB when looking\n     * from A to B.\n     * @param px The x-value of the point to test.\n     * @param py The y-value of the point to test.\n     * @param ax The x-value of the point (ax, ay) that is point A on line AB.\n     * @param ay The y-value of the point (ax, ay) that is point A on line AB.\n     * @param bx The x-value of the point (bx, by) that is point B on line AB.\n     * @param by The y-value of the point (bx, by) that is point B on line AB.\n     * @return TRUE if point P is to the right of line AB when looking\n     * from A to B.\n     */\n    ConvexPolygonGenerator.isRight = function (px, py, ax, ay, bx, by) {\n        return ConvexPolygonGenerator.getSignedAreaX2(ax, ay, px, py, bx, by) > 0;\n    };\n    /**\n     * Check if point P is to the right of or on line AB when looking\n     * from A to B.\n     * @param px The x-value of the point to test.\n     * @param py The y-value of the point to test.\n     * @param ax The x-value of the point (ax, ay) that is point A on line AB.\n     * @param ay The y-value of the point (ax, ay) that is point A on line AB.\n     * @param bx The x-value of the point (bx, by) that is point B on line AB.\n     * @param by The y-value of the point (bx, by) that is point B on line AB.\n     * @return TRUE if point P is to the right of or on line AB when looking\n     * from A to B.\n     */\n    ConvexPolygonGenerator.isRightOrCollinear = function (px, py, ax, ay, bx, by) {\n        return ConvexPolygonGenerator.getSignedAreaX2(ax, ay, px, py, bx, by) >= 0;\n    };\n    /**\n     * The absolute value of the returned value is two times the area of the\n     * triangle defined by points (A, B, C).\n     *\n     * A positive value indicates:\n     * - Counterclockwise wrapping of the points.\n     * - Point B lies to the right of line AC, looking from A to C.\n     *\n     * A negative value indicates:\n     * - Clockwise wrapping of the points.<\n     * - Point B lies to the left of line AC, looking from A to C.\n     *\n     * A value of zero indicates that all points are collinear or\n     * represent the same point.\n     *\n     * This is a fast operation.\n     *\n     * @param ax The x-value for point (ax, ay) for vertex A of the triangle.\n     * @param ay The y-value for point (ax, ay) for vertex A of the triangle.\n     * @param bx The x-value for point (bx, by) for vertex B of the triangle.\n     * @param by The y-value for point (bx, by) for vertex B of the triangle.\n     * @param cx The x-value for point (cx, cy) for vertex C of the triangle.\n     * @param cy The y-value for point (cx, cy) for vertex C of the triangle.\n     * @return The signed value of two times the area of the triangle defined\n     * by the points (A, B, C).\n     */\n    ConvexPolygonGenerator.getSignedAreaX2 = function (ax, ay, bx, by, cx, cy) {\n        // References:\n        // http://softsurfer.com/Archive/algorithm_0101/algorithm_0101.htm#Modern%20Triangles\n        // http://mathworld.wolfram.com/TriangleArea.html (Search for \"signed\")\n        return (bx - ax) * (cy - ay) - (cx - ax) * (by - ay);\n    };\n    return ConvexPolygonGenerator;\n}());\n\nvar GridCoordinateConverter = /** @class */ (function () {\n    function GridCoordinateConverter() {\n    }\n    /**\n     *\n     * @param gridPosition the position on the grid\n     * @param position the position on the scene\n     * @param scaleY for isometry\n     * @returns the position on the scene\n     */\n    GridCoordinateConverter.prototype.convertFromGridBasis = function (grid, polygons) {\n        // point can be shared so them must be copied to be scaled.\n        return polygons.map(function (polygon) {\n            return polygon.map(function (point) { return grid.convertFromGridBasis(point, { x: 0, y: 0 }); });\n        });\n    };\n    return GridCoordinateConverter;\n}());\n\n/**\n * It rasterizes obstacles on a grid.\n *\n * It flags cells as obstacle to be used by {@link RegionGenerator}.\n */\nvar ObstacleRasterizer = /** @class */ (function () {\n    function ObstacleRasterizer() {\n        this.workingNodes = new Array(8);\n        this.gridBasisIterable = new GridBasisIterable();\n    }\n    /**\n     * Rasterize obstacles on a grid.\n     * @param grid\n     * @param obstacles\n     */\n    ObstacleRasterizer.prototype.rasterizeObstacles = function (grid, obstacles) {\n        var obstaclesItr = obstacles[Symbol.iterator]();\n        for (var next = obstaclesItr.next(); !next.done; next = obstaclesItr.next()) {\n            var obstacle = next.value;\n            this.gridBasisIterable.set(grid, obstacle);\n            var vertices = this.gridBasisIterable;\n            var minX = Number.MAX_VALUE;\n            var maxX = -Number.MAX_VALUE;\n            var minY = Number.MAX_VALUE;\n            var maxY = -Number.MAX_VALUE;\n            var verticesItr = vertices[Symbol.iterator]();\n            for (var next_1 = verticesItr.next(); !next_1.done; next_1 = verticesItr.next()) {\n                var vertex = next_1.value;\n                minX = Math.min(minX, vertex.x);\n                maxX = Math.max(maxX, vertex.x);\n                minY = Math.min(minY, vertex.y);\n                maxY = Math.max(maxY, vertex.y);\n            }\n            minX = Math.max(Math.floor(minX), 0);\n            maxX = Math.min(Math.ceil(maxX), grid.dimX());\n            minY = Math.max(Math.floor(minY), 0);\n            maxY = Math.min(Math.ceil(maxY), grid.dimY());\n            this.fillPolygon(vertices, minX, maxX, minY, maxY, function (x, y) { return (grid.get(x, y).distanceToObstacle = 0); });\n        }\n    };\n    ObstacleRasterizer.prototype.fillPolygon = function (vertices, minX, maxX, minY, maxY, fill) {\n        // The following implementation of the scan-line polygon fill algorithm\n        // is strongly inspired from:\n        // https://alienryderflex.com/polygon_fill/\n        // The original implementation was under this license:\n        // public-domain code by Darel Rex Finley, 2007\n        // This implementation differ with the following:\n        // - it handles float vertices\n        //   so it focus on pixels center\n        // - it is conservative to thin vertical or horizontal polygons\n        var fillAnyPixels = false;\n        this.scanY(vertices, minX, maxX, minY, maxY, function (pixelY, minX, maxX) {\n            for (var pixelX = minX; pixelX < maxX; pixelX++) {\n                fillAnyPixels = true;\n                fill(pixelX, pixelY);\n            }\n        });\n        if (fillAnyPixels) {\n            return;\n        }\n        this.scanY(vertices, minX, maxX, minY, maxY, function (pixelY, minX, maxX) {\n            // conserve thin (less than one cell large) horizontal polygons\n            if (minX === maxX) {\n                fill(minX, pixelY);\n            }\n        });\n        this.scanX(vertices, minX, maxX, minY, maxY, function (pixelX, minY, maxY) {\n            for (var pixelY = minY; pixelY < maxY; pixelY++) {\n                fill(pixelX, pixelY);\n            }\n            // conserve thin (less than one cell large) vertical polygons\n            if (minY === maxY) {\n                fill(pixelX, minY);\n            }\n        });\n    };\n    ObstacleRasterizer.prototype.scanY = function (vertices, minX, maxX, minY, maxY, checkAndFillY) {\n        var workingNodes = this.workingNodes;\n        //  Loop through the rows of the image.\n        for (var pixelY = minY; pixelY < maxY; pixelY++) {\n            var pixelCenterY = pixelY + 0.5;\n            //  Build a list of nodes.\n            workingNodes.length = 0;\n            //let j = vertices.length - 1;\n            var verticesItr = vertices[Symbol.iterator]();\n            var next = verticesItr.next();\n            var vertex = next.value;\n            // The iterator always return the same instance.\n            // It must be copied to be save for later.\n            var firstVertexX = vertex.x;\n            var firstVertexY = vertex.y;\n            while (!next.done) {\n                var previousVertexX = vertex.x;\n                var previousVertexY = vertex.y;\n                next = verticesItr.next();\n                if (next.done) {\n                    vertex.x = firstVertexX;\n                    vertex.y = firstVertexY;\n                }\n                else {\n                    vertex = next.value;\n                }\n                if ((vertex.y <= pixelCenterY && pixelCenterY < previousVertexY) ||\n                    (previousVertexY < pixelCenterY && pixelCenterY <= vertex.y)) {\n                    workingNodes.push(Math.round(vertex.x +\n                        ((pixelCenterY - vertex.y) / (previousVertexY - vertex.y)) *\n                            (previousVertexX - vertex.x)));\n                }\n            }\n            //  Sort the nodes, via a simple “Bubble” sort.\n            {\n                var i = 0;\n                while (i < workingNodes.length - 1) {\n                    if (workingNodes[i] > workingNodes[i + 1]) {\n                        var swap = workingNodes[i];\n                        workingNodes[i] = workingNodes[i + 1];\n                        workingNodes[i + 1] = swap;\n                        if (i > 0)\n                            i--;\n                    }\n                    else {\n                        i++;\n                    }\n                }\n            }\n            //  Fill the pixels between node pairs.\n            for (var i = 0; i < workingNodes.length; i += 2) {\n                if (workingNodes[i] >= maxX) {\n                    break;\n                }\n                if (workingNodes[i + 1] <= minX) {\n                    continue;\n                }\n                if (workingNodes[i] < minX) {\n                    workingNodes[i] = minX;\n                }\n                if (workingNodes[i + 1] > maxX) {\n                    workingNodes[i + 1] = maxX;\n                }\n                checkAndFillY(pixelY, workingNodes[i], workingNodes[i + 1]);\n            }\n        }\n    };\n    ObstacleRasterizer.prototype.scanX = function (vertices, minX, maxX, minY, maxY, checkAndFillX) {\n        var workingNodes = this.workingNodes;\n        //  Loop through the columns of the image.\n        for (var pixelX = minX; pixelX < maxX; pixelX++) {\n            var pixelCenterX = pixelX + 0.5;\n            //  Build a list of nodes.\n            workingNodes.length = 0;\n            var verticesItr = vertices[Symbol.iterator]();\n            var next = verticesItr.next();\n            var vertex = next.value;\n            // The iterator always return the same instance.\n            // It must be copied to be save for later.\n            var firstVertexX = vertex.x;\n            var firstVertexY = vertex.y;\n            while (!next.done) {\n                var previousVertexX = vertex.x;\n                var previousVertexY = vertex.y;\n                next = verticesItr.next();\n                if (next.done) {\n                    vertex.x = firstVertexX;\n                    vertex.y = firstVertexY;\n                }\n                else {\n                    vertex = next.value;\n                }\n                if ((vertex.x < pixelCenterX && pixelCenterX < previousVertexX) ||\n                    (previousVertexX < pixelCenterX && pixelCenterX < vertex.x)) {\n                    workingNodes.push(Math.round(vertex.y +\n                        ((pixelCenterX - vertex.x) / (previousVertexX - vertex.x)) *\n                            (previousVertexY - vertex.y)));\n                }\n            }\n            //  Sort the nodes, via a simple “Bubble” sort.\n            {\n                var i = 0;\n                while (i < workingNodes.length - 1) {\n                    if (workingNodes[i] > workingNodes[i + 1]) {\n                        var swap = workingNodes[i];\n                        workingNodes[i] = workingNodes[i + 1];\n                        workingNodes[i + 1] = swap;\n                        if (i > 0)\n                            i--;\n                    }\n                    else {\n                        i++;\n                    }\n                }\n            }\n            //  Fill the pixels between node pairs.\n            for (var i = 0; i < workingNodes.length; i += 2) {\n                if (workingNodes[i] >= maxY) {\n                    break;\n                }\n                if (workingNodes[i + 1] <= minY) {\n                    continue;\n                }\n                if (workingNodes[i] < minY) {\n                    workingNodes[i] = minY;\n                }\n                if (workingNodes[i + 1] > maxY) {\n                    workingNodes[i + 1] = maxY;\n                }\n                checkAndFillX(pixelX, workingNodes[i], workingNodes[i + 1]);\n            }\n        }\n    };\n    return ObstacleRasterizer;\n}());\n/**\n * Iterable that converts coordinates to the grid.\n *\n * This is an allocation free iterable\n * that can only do one iteration at a time.\n */\nvar GridBasisIterable = /** @class */ (function () {\n    function GridBasisIterable() {\n        this.grid = null;\n        this.sceneVertices = [];\n        this.verticesItr = this.sceneVertices[Symbol.iterator]();\n        this.result = {\n            value: { x: 0, y: 0 },\n            done: false,\n        };\n    }\n    GridBasisIterable.prototype.set = function (grid, sceneVertices) {\n        this.grid = grid;\n        this.sceneVertices = sceneVertices;\n    };\n    GridBasisIterable.prototype[Symbol.iterator] = function () {\n        this.verticesItr = this.sceneVertices[Symbol.iterator]();\n        return this;\n    };\n    GridBasisIterable.prototype.next = function () {\n        var next = this.verticesItr.next();\n        if (next.done) {\n            return next;\n        }\n        this.grid.convertToGridBasis(next.value, this.result.value);\n        return this.result;\n    };\n    return GridBasisIterable;\n}());\n\n/**\n * Build cohesive regions from the non-obstacle space. It uses the data\n * from the obstacles rasterization {@link ObstacleRasterizer}.\n *\n * This implementation is strongly inspired from CritterAI class \"OpenHeightfieldBuilder\".\n *\n * Introduction to Height Fields: http://www.critterai.org/projects/nmgen_study/heightfields.html\n *\n * Region Generation: http://www.critterai.org/projects/nmgen_study/regiongen.html\n */\nvar RegionGenerator = /** @class */ (function () {\n    function RegionGenerator() {\n        this.obstacleRegionBordersCleaner = new ObstacleRegionBordersCleaner();\n        this.floodedCells = new Array(1024);\n        this.workingStack = new Array(1024);\n    }\n    //TODO implement the smoothing pass on the distance field?\n    /**\n     * Groups cells into cohesive regions using an watershed based algorithm.\n     *\n     * This operation depends on neighbor and distance field information.\n     * So {@link RegionGenerator.generateDistanceField} operations must be\n     * run before this operation.\n     *\n     * @param grid A field with cell distance information fully generated.\n     * @param obstacleCellPadding a padding in cells to apply around the\n     * obstacles.\n     */\n    RegionGenerator.prototype.generateRegions = function (grid, obstacleCellPadding) {\n        // Watershed Algorithm\n        //\n        // Reference: http://en.wikipedia.org/wiki/Watershed_%28algorithm%29\n        // A good visualization:\n        // http://artis.imag.fr/Publications/2003/HDS03/ (PDF)\n        //\n        // Summary:\n        //\n        // This algorithm utilizes the cell.distanceToObstacle value, which\n        // is generated by the generateDistanceField() operation.\n        //\n        // Using the watershed analogy, the cells which are furthest from\n        // a border (highest distance to border) represent the lowest points\n        // in the watershed. A border cell represents the highest possible\n        // water level.\n        //\n        // The main loop iterates, starting at the lowest point in the\n        // watershed, then incrementing with each loop until the highest\n        // allowed water level is reached. This slowly \"floods\" the cells\n        // starting at the lowest points.\n        //\n        // During each iteration of the loop, cells that are below the\n        // current water level are located and an attempt is made to either\n        // add them to exiting regions or create new regions from them.\n        //\n        // During the region expansion phase, if a newly flooded cell\n        // borders on an existing region, it is usually added to the region.\n        //\n        // Any newly flooded cell that survives the region expansion phase\n        // is used as a seed for a new region.\n        //\n        // At the end of the main loop, a final region expansion is\n        // performed which should catch any stray cells that escaped region\n        // assignment during the main loop.\n        // Represents the minimum distance to an obstacle that is considered\n        // traversable. I.e. Can't traverse cells closer than this distance\n        // to a border. This provides a way of artificially capping the\n        // height to which watershed flooding can occur.\n        // I.e. Don't let the algorithm flood all the way to the actual border.\n        //\n        // We add the minimum border distance to take into account the\n        // blurring algorithm which can result in a border cell having a\n        // border distance > 0.\n        var distanceMin = obstacleCellPadding * 2;\n        // TODO: EVAL: Figure out why this iteration limit is needed\n        // (todo from the CritterAI sources).\n        var expandIterations = 4 + distanceMin * 2;\n        // Zero is reserved for the obstacle-region. So initializing to 1.\n        var nextRegionID = 1;\n        var floodedCells = this.floodedCells;\n        // Search until the current distance reaches the minimum allowed\n        // distance.\n        //\n        // Note: This loop will not necessarily complete all region\n        // assignments. This is OK since a final region assignment step\n        // occurs after the loop iteration is complete.\n        for (\n        // This value represents the current distance from the border which\n        // is to be searched. The search starts at the maximum distance then\n        // moves toward zero (toward borders).\n        //\n        // This number will always be divisible by 2.\n        var distance = grid.obstacleDistanceMax() & ~1; distance > distanceMin; distance = Math.max(distance - 2, 0)) {\n            // Find all cells that are at or below the current \"water level\"\n            // and are not already assigned to a region. Add these cells to\n            // the flooded cell list for processing.\n            floodedCells.length = 0;\n            for (var y = 1; y < grid.dimY() - 1; y++) {\n                for (var x = 1; x < grid.dimX() - 1; x++) {\n                    var cell = grid.get(x, y);\n                    if (cell.regionID === RasterizationCell.NULL_REGION_ID &&\n                        cell.distanceToObstacle >= distance) {\n                        // The cell is not already assigned a region and is\n                        // below the current \"water level\". So the cell can be\n                        // considered for region assignment.\n                        floodedCells.push(cell);\n                    }\n                }\n            }\n            if (nextRegionID > 1) {\n                // At least one region has already been created, so first\n                // try to  put the newly flooded cells into existing regions.\n                if (distance > 0) {\n                    this.expandRegions(grid, floodedCells, expandIterations);\n                }\n                else {\n                    this.expandRegions(grid, floodedCells, -1);\n                }\n            }\n            // Create new regions for all cells that could not be added to\n            // existing regions.\n            for (var _i = 0, floodedCells_1 = floodedCells; _i < floodedCells_1.length; _i++) {\n                var floodedCell = floodedCells_1[_i];\n                if (!floodedCell ||\n                    floodedCell.regionID !== RasterizationCell.NULL_REGION_ID) {\n                    // This cell was assigned to a newly created region\n                    // during an earlier iteration of this loop.\n                    // So it can be skipped.\n                    continue;\n                }\n                // Fill to slightly more than the current \"water level\".\n                // This improves efficiency of the algorithm.\n                // And it is necessary with the conservative expansion to ensure that\n                // more than one cell is added initially to a new regions otherwise\n                // no cell could be added to it later because of the conservative\n                // constraint.\n                var fillTo = Math.max(distance - 2, distanceMin + 1, 1);\n                if (this.floodNewRegion(grid, floodedCell, fillTo, nextRegionID)) {\n                    nextRegionID++;\n                }\n            }\n        }\n        // Find all cells that haven't been assigned regions by the main loop\n        // (up to the minimum distance).\n        floodedCells.length = 0;\n        for (var y = 1; y < grid.dimY() - 1; y++) {\n            for (var x = 1; x < grid.dimX() - 1; x++) {\n                var cell = grid.get(x, y);\n                if (cell.distanceToObstacle > distanceMin &&\n                    cell.regionID === RasterizationCell.NULL_REGION_ID) {\n                    // Not a border or obstacle region cell. Should be in a region.\n                    floodedCells.push(cell);\n                }\n            }\n        }\n        // Perform a final expansion of existing regions.\n        // Allow more iterations than normal for this last expansion.\n        if (distanceMin > 0) {\n            this.expandRegions(grid, floodedCells, expandIterations * 8);\n        }\n        else {\n            this.expandRegions(grid, floodedCells, -1);\n        }\n        grid.regionCount = nextRegionID;\n        this.obstacleRegionBordersCleaner.fixObstacleRegion(grid);\n        //TODO Also port FilterOutSmallRegions?\n        // The algorithm to remove vertices in the middle (added at the end of\n        // ContourBuilder.buildContours) may already filter them and contour are\n        // faster to process than cells.\n    };\n    /**\n     * Attempts to find the most appropriate regions to attach cells to.\n     *\n     * Any cells successfully attached to a region will have their list\n     * entry set to null. So any non-null entries in the list will be cells\n     * for which a region could not be determined.\n     *\n     * @param grid\n     * @param inoutCells As input, the list of cells available for formation\n     * of new regions. As output, the cells that could not be assigned\n     * to new regions.\n     * @param maxIterations If set to -1, will iterate through completion.\n     */\n    RegionGenerator.prototype.expandRegions = function (grid, inoutCells, iterationMax) {\n        if (inoutCells.length === 0)\n            return;\n        var skipped = 0;\n        for (var iteration = 0; (iteration < iterationMax || iterationMax === -1) &&\n            // All cells have either been processed or could not be\n            // processed during the last cycle.\n            skipped < inoutCells.length; iteration++) {\n            // The number of cells in the working list that have been\n            // successfully processed or could not be processed successfully\n            // for some reason.\n            // This value controls when iteration ends.\n            skipped = 0;\n            for (var index = 0; index < inoutCells.length; index++) {\n                var cell = inoutCells[index];\n                if (cell === null) {\n                    // The cell originally at this index location has\n                    // already been successfully assigned a region. Nothing\n                    // else to do with it.\n                    skipped++;\n                    continue;\n                }\n                // Default to unassigned.\n                var cellRegion = RasterizationCell.NULL_REGION_ID;\n                var regionCenterDist = Number.MAX_VALUE;\n                for (var _i = 0, _a = RasterizationGrid.neighbor4Deltas; _i < _a.length; _i++) {\n                    var delta = _a[_i];\n                    var neighbor = grid.get(cell.x + delta.x, cell.y + delta.y);\n                    if (neighbor.regionID !== RasterizationCell.NULL_REGION_ID) {\n                        if (neighbor.distanceToRegionCore + 2 < regionCenterDist) {\n                            // This neighbor is closer to its region core\n                            // than previously detected neighbors.\n                            // Conservative expansion constraint:\n                            // Check to ensure that this neighbor has\n                            // at least two other neighbors in its region.\n                            // This makes sure that adding this cell to\n                            // this neighbor's  region will not result\n                            // in a single width line of cells.\n                            var sameRegionCount = 0;\n                            for (var neighborDirection = 0; neighborDirection < 4; neighborDirection++) {\n                                var nnCell = grid.getNeighbor(neighbor, neighborDirection);\n                                // There is a diagonal-neighbor\n                                if (nnCell.regionID === neighbor.regionID) {\n                                    // This neighbor has a neighbor in\n                                    // the same region.\n                                    sameRegionCount++;\n                                }\n                            }\n                            if (sameRegionCount > 1) {\n                                cellRegion = neighbor.regionID;\n                                regionCenterDist = neighbor.distanceToRegionCore + 2;\n                            }\n                        }\n                    }\n                }\n                if (cellRegion !== RasterizationCell.NULL_REGION_ID) {\n                    // Found a suitable region for this cell to belong to.\n                    // Mark this index as having been processed.\n                    inoutCells[index] = null;\n                    cell.regionID = cellRegion;\n                    cell.distanceToRegionCore = regionCenterDist;\n                }\n                else {\n                    // Could not find an existing region for this cell.\n                    skipped++;\n                }\n            }\n        }\n    };\n    /**\n     * Creates a new region surrounding a cell, adding neighbor cells to the\n     * new region as appropriate.\n     *\n     * The new region creation will fail if the root cell is on the\n     * border of an existing region.\n     *\n     * All cells added to the new region as part of this process become\n     * \"core\" cells with a distance to region core of zero.\n     *\n     * @param grid\n     * @param rootCell The cell used to seed the new region.\n     * @param fillToDist The watershed distance to flood to.\n     * @param regionID The region ID to use for the new region\n     * (if creation is successful).\n     * @return true if a new region was created.\n     */\n    RegionGenerator.prototype.floodNewRegion = function (grid, rootCell, fillToDist, regionID) {\n        var workingStack = this.workingStack;\n        workingStack.length = 0;\n        workingStack.push(rootCell);\n        rootCell.regionID = regionID;\n        rootCell.distanceToRegionCore = 0;\n        var regionSize = 0;\n        var cell;\n        while ((cell = workingStack.pop())) {\n            // Check regions of neighbor cells.\n            //\n            // If any neighbor is found to have a region assigned, then\n            // the current cell can't be in the new region\n            // (want standard flooding algorithm to handle deciding which\n            // region this cell should go in).\n            //\n            // Up to 8 neighbors are checked.\n            //\n            // Neighbor searches:\n            // http://www.critterai.org/projects/nmgen_study/heightfields.html#nsearch\n            var isOnRegionBorder = false;\n            for (var _i = 0, _a = RasterizationGrid.neighbor8Deltas; _i < _a.length; _i++) {\n                var delta = _a[_i];\n                var neighbor = grid.get(cell.x + delta.x, cell.y + delta.y);\n                isOnRegionBorder =\n                    neighbor.regionID !== RasterizationCell.NULL_REGION_ID &&\n                        neighbor.regionID !== regionID;\n                if (isOnRegionBorder)\n                    break;\n            }\n            if (isOnRegionBorder) {\n                cell.regionID = RasterizationCell.NULL_REGION_ID;\n                continue;\n            }\n            regionSize++;\n            // If got this far, we know the current cell is part of the new\n            // region. Now check its neighbors to see if they should be\n            // assigned to this new region.\n            for (var _b = 0, _c = RasterizationGrid.neighbor4Deltas; _b < _c.length; _b++) {\n                var delta = _c[_b];\n                var neighbor = grid.get(cell.x + delta.x, cell.y + delta.y);\n                if (neighbor.distanceToObstacle >= fillToDist &&\n                    neighbor.regionID === RasterizationCell.NULL_REGION_ID) {\n                    neighbor.regionID = regionID;\n                    neighbor.distanceToRegionCore = 0;\n                    workingStack.push(neighbor);\n                }\n            }\n        }\n        return regionSize > 0;\n    };\n    /**\n     * Generates distance field information.\n     * The {@link RasterizationCell.distanceToObstacle} information is generated\n     * for all cells in the field.\n     *\n     * All distance values are relative and do not represent explicit\n     * distance values (such as grid unit distance). The algorithm which is\n     * used results in an approximation only. It is not exhaustive.\n     *\n     * The data generated by this operation is required by\n     * {@link RegionGenerator.generateRegions}.\n     *\n     * @param grid A field with cells obstacle information already generated.\n     */\n    RegionGenerator.prototype.generateDistanceField = function (grid) {\n        // close borders\n        for (var x = 0; x < grid.dimX(); x++) {\n            var leftCell = grid.get(x, 0);\n            leftCell.distanceToObstacle = 0;\n            var rightCell = grid.get(x, grid.dimY() - 1);\n            rightCell.distanceToObstacle = 0;\n        }\n        for (var y = 1; y < grid.dimY() - 1; y++) {\n            var topCell = grid.get(0, y);\n            topCell.distanceToObstacle = 0;\n            var bottomCell = grid.get(grid.dimX() - 1, y);\n            bottomCell.distanceToObstacle = 0;\n        }\n        // The next two phases basically check the neighbors of a cell and\n        // set the cell's distance field to be slightly greater than the\n        // neighbor with the lowest border distance. Distance is increased\n        // slightly more for diagonal-neighbors than for axis-neighbors.\n        // 1st pass\n        // During this pass, the following neighbors are checked:\n        // (-1, 0) (-1, -1) (0, -1) (1, -1)\n        for (var y = 1; y < grid.dimY() - 1; y++) {\n            for (var x = 1; x < grid.dimX() - 1; x++) {\n                var cell = grid.get(x, y);\n                for (var _i = 0, _a = RegionGenerator.firstPassDeltas; _i < _a.length; _i++) {\n                    var delta = _a[_i];\n                    var distanceByNeighbor = grid.get(x + delta.x, y + delta.y).distanceToObstacle +\n                        delta.distance;\n                    if (cell.distanceToObstacle > distanceByNeighbor) {\n                        cell.distanceToObstacle = distanceByNeighbor;\n                    }\n                }\n            }\n        }\n        // 2nd pass\n        // During this pass, the following neighbors are checked:\n        //   (1, 0) (1, 1) (0, 1) (-1, 1)\n        //\n        // Besides checking different neighbors, this pass performs its\n        // grid search in reverse order.\n        for (var y = grid.dimY() - 2; y >= 1; y--) {\n            for (var x = grid.dimX() - 2; x >= 1; x--) {\n                var cell = grid.get(x, y);\n                for (var _b = 0, _c = RegionGenerator.secondPassDeltas; _b < _c.length; _b++) {\n                    var delta = _c[_b];\n                    var distanceByNeighbor = grid.get(x + delta.x, y + delta.y).distanceToObstacle +\n                        delta.distance;\n                    if (cell.distanceToObstacle > distanceByNeighbor) {\n                        cell.distanceToObstacle = distanceByNeighbor;\n                    }\n                }\n            }\n        }\n    };\n    RegionGenerator.firstPassDeltas = [\n        { x: -1, y: 0, distance: 2 },\n        { x: -1, y: -1, distance: 3 },\n        { x: 0, y: -1, distance: 2 },\n        { x: 1, y: -1, distance: 3 },\n    ];\n    RegionGenerator.secondPassDeltas = [\n        { x: 1, y: 0, distance: 2 },\n        { x: 1, y: 1, distance: 3 },\n        { x: 0, y: 1, distance: 2 },\n        { x: -1, y: 1, distance: 3 },\n    ];\n    return RegionGenerator;\n}());\n/**\n * Implements three algorithms that clean up issues that can\n * develop around obstacle region boarders.\n *\n * - Detect and fix encompassed obstacle regions:\n *\n * If a obstacle region is found that is fully encompassed by a single\n * region, then the region will be split into two regions at the\n * obstacle region border.\n *\n * - Detect and fix \"short wrapping\" of obstacle regions:\n *\n * Regions can sometimes wrap slightly around the corner of a obstacle region\n * in a manner that eventually results in the formation of self-intersecting\n * polygons.\n *\n * Example: Before the algorithm is applied:\n * http://www.critterai.org/projects/nmgen_study/media/images/ohfg_08_cornerwrapbefore.jpg\"\n *\n * Example: After the algorithm is applied:\n * http://www.critterai.org/projects/nmgen_study/media/images/ohfg_09_cornerwrapafter.jpg\n *\n * - Detect and fix incomplete obstacle region connections:\n *\n * If a region touches obstacle region only diagonally, then contour detection\n * algorithms may not properly detect the obstacle region connection. This can\n * adversely effect other algorithms in the pipeline.\n *\n * Example: Before algorithm is applied:\n *\n *     b b a a a a\n *     b b a a a a\n *     a a x x x x\n *     a a x x x x\n *\n * Example: After algorithm is applied:\n *\n *     b b a a a a\n *     b b b a a a <-- Cell transferred to region B.\n *     a a x x x x\n *     a a x x x x\n *\n *\n * Region Generation: http://www.critterai.org/projects/nmgen_study/regiongen.html\n */\nvar ObstacleRegionBordersCleaner = /** @class */ (function () {\n    function ObstacleRegionBordersCleaner() {\n        this.workingUpLeftOpenCells = new Array(512);\n        this.workingDownRightOpenCells = new Array(512);\n        this.workingOpenCells = new Array(512);\n    }\n    /**\n     * This operation utilizes {@link RasterizationCell.contourFlags}. It\n     * expects the value to be zero on entry, and re-zero's the value\n     * on exit.\n     *\n     * @param grid a grid with fully built regions.\n     */\n    ObstacleRegionBordersCleaner.prototype.fixObstacleRegion = function (grid) {\n        var workingUpLeftOpenCells = this.workingUpLeftOpenCells;\n        workingUpLeftOpenCells.length = 0;\n        var workingDownRightOpenCells = this.workingDownRightOpenCells;\n        workingDownRightOpenCells.length = 0;\n        var workingOpenCells = this.workingOpenCells;\n        workingOpenCells.length = 0;\n        var extremeCells = [\n            null,\n            null,\n        ];\n        var nextRegionID = grid.regionCount;\n        // Iterate over the cells, trying to find obstacle region borders.\n        for (var y = 1; y < grid.dimY() - 1; y++) {\n            for (var x = 1; x < grid.dimX() - 1; x++) {\n                var cell = grid.get(x, y);\n                if (cell.contourFlags !== 0)\n                    // Cell was processed in a previous iteration.\n                    // Ignore it.\n                    continue;\n                cell.contourFlags = 1;\n                var workingCell = null;\n                var edgeDirection = -1;\n                if (cell.regionID !== RasterizationCell.OBSTACLE_REGION_ID) {\n                    // Not interested in this cell.\n                    continue;\n                }\n                // This is a obstacle region cell. See if it\n                // connects to a cell in a non-obstacle region.\n                edgeDirection = this.getNonNullBorderDirection(grid, cell);\n                if (edgeDirection === -1)\n                    // This cell is not a border cell. Ignore it.\n                    continue;\n                // This is a border cell. Step into the non-null\n                // region and swing the direction around 180 degrees.\n                workingCell = grid.getNeighbor(cell, edgeDirection);\n                edgeDirection = (edgeDirection + 2) & 0x3;\n                // Process the obstacle region contour. Detect and fix\n                // local issues. Determine if the region is\n                // fully encompassed by a single non-obstacle region.\n                var isEncompassedNullRegion = this.processNullRegion(grid, workingCell, edgeDirection, extremeCells);\n                if (isEncompassedNullRegion) {\n                    // This cell is part of a group of obstacle region cells\n                    // that is encompassed within a single non-obstacle region.\n                    // This is not permitted. Need to fix it.\n                    this.partialFloodRegion(grid, extremeCells[0], extremeCells[1], nextRegionID);\n                    nextRegionID++;\n                }\n            }\n        }\n        grid.regionCount = nextRegionID;\n        // Clear all flags.\n        for (var y = 1; y < grid.dimY() - 1; y++) {\n            for (var x = 1; x < grid.dimX() - 1; x++) {\n                var cell = grid.get(x, y);\n                cell.contourFlags = 0;\n            }\n        }\n    };\n    /**\n     * Partially flood a region away from the specified direction.\n     *\n     * {@link RasterizationCell.contourFlags}\n     * is set to zero for all flooded cells.\n     *\n     * @param grid\n     * @param startCell The cell to start the flood from.\n     * @param borderDirection  The hard border for flooding. No\n     * cells in this direction from the startCell will be flooded.\n     * @param newRegionID The region id to assign the flooded\n     * cells to.\n     */\n    ObstacleRegionBordersCleaner.prototype.partialFloodRegion = function (grid, upLeftCell, downRightCell, newRegionID) {\n        var upLeftOpenCells = this.workingUpLeftOpenCells;\n        var downRightOpenCells = this.workingDownRightOpenCells;\n        var workingOpenCells = this.workingOpenCells;\n        // The implementation differs from CritterAI to avoid non-contiguous\n        // sections. Instead of brushing in one direction, it floods from\n        // 2 extremities of the encompassed obstacle region.\n        var regionID = upLeftCell.regionID;\n        if (regionID === newRegionID) {\n            // avoid infinity loop\n            console.error(\"Can't create a new region with an ID that already exist.\");\n            return;\n        }\n        // The 1st flooding set a new the regionID\n        upLeftCell.regionID = newRegionID;\n        upLeftCell.distanceToRegionCore = 0; // This information is lost.\n        upLeftOpenCells.length = 0;\n        upLeftOpenCells.push(upLeftCell);\n        // The 2nd flooding keep the regionID and mark the cell as visited.\n        downRightCell.contourFlags = 2;\n        downRightCell.distanceToRegionCore = 0; // This information is lost.\n        downRightOpenCells.length = 0;\n        downRightOpenCells.push(downRightCell);\n        var swap;\n        workingOpenCells.length = 0;\n        while (upLeftOpenCells.length !== 0 || downRightOpenCells.length !== 0) {\n            for (var _i = 0, upLeftOpenCells_1 = upLeftOpenCells; _i < upLeftOpenCells_1.length; _i++) {\n                var cell = upLeftOpenCells_1[_i];\n                for (var direction = 0; direction < 4; direction++) {\n                    var neighbor = grid.getNeighbor(cell, direction);\n                    if (neighbor.regionID !== regionID || neighbor.contourFlags === 2) {\n                        continue;\n                    }\n                    // Transfer the neighbor to the new region.\n                    neighbor.regionID = newRegionID;\n                    neighbor.distanceToRegionCore = 0; // This information is lost.\n                    workingOpenCells.push(neighbor);\n                }\n            }\n            // This allows to flood the nearest cells first without needing lifo queue.\n            // But a queue would take less memory.\n            swap = upLeftOpenCells;\n            upLeftOpenCells = workingOpenCells;\n            workingOpenCells = swap;\n            workingOpenCells.length = 0;\n            for (var _a = 0, downRightOpenCells_1 = downRightOpenCells; _a < downRightOpenCells_1.length; _a++) {\n                var cell = downRightOpenCells_1[_a];\n                for (var direction = 0; direction < 4; direction++) {\n                    var neighbor = grid.getNeighbor(cell, direction);\n                    if (neighbor.regionID !== regionID || neighbor.contourFlags === 2) {\n                        continue;\n                    }\n                    // Keep the neighbor to the current region.\n                    neighbor.contourFlags = 2;\n                    neighbor.distanceToRegionCore = 0; // This information is lost.\n                    workingOpenCells.push(neighbor);\n                }\n            }\n            swap = downRightOpenCells;\n            downRightOpenCells = workingOpenCells;\n            workingOpenCells = swap;\n            workingOpenCells.length = 0;\n        }\n    };\n    /**\n     * Detects and fixes bad cell configurations in the vicinity of a\n     * obstacle region contour (See class description for details).\n     * @param grid\n     * @param startCell A cell in a non-obstacle region that borders a null\n     * region.\n     * @param startDirection The direction of the obstacle region border.\n     * @return TRUE if the start cell's region completely encompasses\n     * the obstacle region.\n     */\n    ObstacleRegionBordersCleaner.prototype.processNullRegion = function (grid, startCell, startDirection, extremeCells) {\n        // This algorithm traverses the contour. As it does so, it detects\n        // and fixes various known dangerous cell configurations.\n        //\n        // Traversing the contour:  A good way to  visualize it is to think\n        // of a robot sitting on the floor facing  a known wall. It then\n        // does the following to skirt the wall:\n        // 1. If there is a wall in front of it, turn clockwise in 90 degrees\n        //    increments until it finds the wall is gone.\n        // 2. Move forward one step.\n        // 3. Turn counter-clockwise by 90 degrees.\n        // 4. Repeat from step 1 until it finds itself at its original\n        //    location facing its original direction.\n        //\n        // See also: http://www.critterai.org/projects/nmgen_study/regiongen.html#robotwalk\n        //\n        // As the traversal occurs, the number of acute (90 degree) and\n        // obtuse (270 degree) corners are monitored. If a complete contour is\n        // detected and (obtuse corners > acute corners), then the null\n        // region is inside the contour. Otherwise the obstacle region is\n        // outside the contour, which we don't care about.\n        var borderRegionID = startCell.regionID;\n        // Prepare for loop.\n        var cell = startCell;\n        var neighbor = null;\n        var direction = startDirection;\n        var upLeftCell = cell;\n        var downRightCell = cell;\n        // Initialize monitoring variables.\n        var loopCount = 0;\n        var acuteCornerCount = 0;\n        var obtuseCornerCount = 0;\n        var stepsWithoutBorder = 0;\n        var borderSeenLastLoop = false;\n        var isBorder = true; // Initial value doesn't matter.\n        // Assume a single region is connected to the obstacle region\n        // until proven otherwise.\n        var hasSingleConnection = true;\n        // The loop limit exists for the sole reason of preventing\n        // an infinite loop in case of bad input data.\n        // It is set to a very high value because there is no way of\n        // definitively determining a safe smaller value. Setting\n        // the value too low can result in rescanning a contour\n        // multiple times, killing performance.\n        while (++loopCount < 1 << 30) {\n            // Get the cell across the border.\n            neighbor = grid.getNeighbor(cell, direction);\n            // Detect which type of edge this direction points across.\n            if (neighbor === null) {\n                // It points across a obstacle region border edge.\n                isBorder = true;\n            }\n            else {\n                // We never need to perform contour detection\n                // on this cell again. So mark it as processed.\n                neighbor.contourFlags = 1;\n                if (neighbor.regionID === RasterizationCell.OBSTACLE_REGION_ID) {\n                    // It points across a obstacle region border edge.\n                    isBorder = true;\n                }\n                else {\n                    // This isn't a obstacle region border.\n                    isBorder = false;\n                    if (neighbor.regionID !== borderRegionID)\n                        // It points across a border to a non-obstacle region.\n                        // This means the current contour can't\n                        // represent a fully encompassed obstacle region.\n                        hasSingleConnection = false;\n                }\n            }\n            // Process the border.\n            if (isBorder) {\n                // It is a border edge.\n                if (borderSeenLastLoop) {\n                    // A border was detected during the last loop as well.\n                    // Two detections in a row indicates we passed an acute\n                    // (inner) corner.\n                    //\n                    //     a x\n                    //     x x\n                    acuteCornerCount++;\n                }\n                else if (stepsWithoutBorder > 1) {\n                    // We have moved at least two cells before detecting\n                    // a border. This indicates we passed an obtuse\n                    // (outer) corner.\n                    //\n                    //     a a\n                    //     a x\n                    obtuseCornerCount++;\n                    stepsWithoutBorder = 0;\n                    // Detect and fix cell configuration issue around this\n                    // corner.\n                    if (this.processOuterCorner(grid, cell, direction))\n                        // A change was made and it resulted in the\n                        // corner area having multiple region connections.\n                        hasSingleConnection = false;\n                }\n                direction = (direction + 1) & 0x3; // Rotate in clockwise direction.\n                borderSeenLastLoop = true;\n                stepsWithoutBorder = 0;\n            }\n            else {\n                // Not a obstacle region border.\n                // Move to the neighbor and swing the search direction back\n                // one increment (counterclockwise). By moving the direction\n                // back one increment we guarantee we don't miss any edges.\n                cell = neighbor;\n                direction = (direction + 3) & 0x3; // Rotate counterclockwise direction.\n                borderSeenLastLoop = false;\n                stepsWithoutBorder++;\n                if (cell.x < upLeftCell.x ||\n                    (cell.x === upLeftCell.x && cell.y < upLeftCell.y)) {\n                    upLeftCell = cell;\n                }\n                if (cell.x > downRightCell.x ||\n                    (cell.x === downRightCell.x && cell.y > downRightCell.y)) {\n                    downRightCell = cell;\n                }\n            }\n            if (startCell === cell && startDirection === direction) {\n                extremeCells[0] = upLeftCell;\n                extremeCells[1] = downRightCell;\n                // Have returned to the original cell and direction.\n                // The search is complete.\n                // Is the obstacle region inside the contour?\n                return hasSingleConnection && obtuseCornerCount > acuteCornerCount;\n            }\n        }\n        // If got here then the obstacle region boarder is too large to be fully\n        // explored. So it can't be encompassed.\n        return false;\n    };\n    /**\n     * Detects and fixes cell configuration issues in the vicinity\n     * of obtuse (outer) obstacle region corners.\n     * @param grid\n     * @param referenceCell The cell in a non-obstacle region that is\n     * just past the outer corner.\n     * @param borderDirection The direction of the obstacle region border.\n     * @return TRUE if more than one region connects to the obstacle region\n     * in the vicinity of the corner (this may or may not be due to\n     * a change made by this operation).\n     */\n    ObstacleRegionBordersCleaner.prototype.processOuterCorner = function (grid, referenceCell, borderDirection) {\n        var hasMultiRegions = false;\n        // Get the previous two cells along the border.\n        var backOne = grid.getNeighbor(referenceCell, (borderDirection + 3) & 0x3);\n        var backTwo = grid.getNeighbor(backOne, borderDirection);\n        var testCell;\n        if (backOne.regionID !== referenceCell.regionID &&\n            // This differ from the CritterAI implementation.\n            // To filter vertices in the middle, this must be avoided too:\n            //     a x\n            //     b c\n            backTwo.regionID !== backOne.regionID) {\n            // Dangerous corner configuration.\n            //\n            //     a x\n            //     b a\n            //\n            // Need to change to one of the following configurations:\n            //\n            //     b x        a x\n            //     b a        b b\n            //\n            // Reason: During contour detection this type of configuration can\n            // result in the region connection being detected as a\n            // region-region portal, when it is not. The region connection\n            // is actually interrupted by the obstacle region.\n            //\n            // This configuration has been demonstrated to result in\n            // two regions being improperly merged to encompass an\n            // internal obstacle region.\n            //\n            // Example:\n            //\n            //     a a x x x a\n            //     a a x x a a\n            //     b b a a a a\n            //     b b a a a a\n            //\n            // During contour and connection detection for region b, at no\n            // point will the obstacle region be detected. It will appear\n            // as if a clean a-b portal exists.\n            //\n            // An investigation into fixing this issue via updates to the\n            // watershed or contour detection algorithms did not turn\n            // up a better way of resolving this issue.\n            hasMultiRegions = true;\n            // Determine how many connections backTwo has to backOne's region.\n            testCell = grid.getNeighbor(backOne, (borderDirection + 3) & 0x3);\n            var backTwoConnections = 0;\n            if (testCell.regionID === backOne.regionID) {\n                backTwoConnections++;\n                testCell = grid.getNeighbor(testCell, borderDirection);\n                if (testCell.regionID === backOne.regionID)\n                    backTwoConnections++;\n            }\n            // Determine how many connections the reference cell has\n            // to backOne's region.\n            var referenceConnections = 0;\n            testCell = grid.getNeighbor(backOne, (borderDirection + 2) & 0x3);\n            if (testCell.regionID === backOne.regionID) {\n                referenceConnections++;\n                testCell = grid.getNeighbor(testCell, (borderDirection + 2) & 0x3);\n                if (testCell.regionID === backOne.regionID)\n                    backTwoConnections++;\n            }\n            // Change the region of the cell that has the most connections\n            // to the target region.\n            if (referenceConnections > backTwoConnections)\n                referenceCell.regionID = backOne.regionID;\n            else\n                backTwo.regionID = backOne.regionID;\n        }\n        else if (backOne.regionID === referenceCell.regionID &&\n            backTwo.regionID === referenceCell.regionID) {\n            // Potential dangerous short wrap.\n            //\n            //  a x\n            //  a a\n            //\n            //  Example of actual problem configuration:\n            //\n            //  b b x x\n            //  b a x x <- Short wrap.\n            //  b a a a\n            //\n            //  In the above case, the short wrap around the corner of the\n            //  obstacle region has been demonstrated to cause self-intersecting\n            //  polygons during polygon formation.\n            //\n            //  This algorithm detects whether or not one (and only one)\n            //  of the axis neighbors of the corner should be re-assigned to\n            //  a more appropriate region.\n            //\n            //  In the above example, the following configuration is more\n            //  appropriate:\n            //\n            //  b b x x\n            //  b b x x <- Change to this row.\n            //  b a a a\n            // Check to see if backTwo should be in a different region.\n            var selectedRegion = this.selectedRegionID(grid, backTwo, (borderDirection + 1) & 0x3, (borderDirection + 2) & 0x3);\n            if (selectedRegion === backTwo.regionID) {\n                // backTwo should not be re-assigned. How about\n                // the reference cell?\n                selectedRegion = this.selectedRegionID(grid, referenceCell, borderDirection, (borderDirection + 3) & 0x3);\n                if (selectedRegion !== referenceCell.regionID) {\n                    // The reference cell should be reassigned\n                    // to a new region.\n                    referenceCell.regionID = selectedRegion;\n                    hasMultiRegions = true;\n                }\n            }\n            else {\n                // backTwo should be re-assigned to a new region.\n                backTwo.regionID = selectedRegion;\n                hasMultiRegions = true;\n            }\n        }\n        else\n            hasMultiRegions = true;\n        // No dangerous configurations detected. But definitely\n        // has a change in regions at the corner. We know this\n        // because one of the previous checks looked for a single\n        // region for all wrap cells.\n        return hasMultiRegions;\n    };\n    /**\n     * Checks the cell to see if it should be reassigned to a new region.\n     *\n     * @param grid\n     * @param referenceCell A cell on one side of an obstacle region contour's\n     * outer corner. It is expected that the all cells that wrap the\n     * corner are in the same region.\n     * @param borderDirection  The direction of the obstacle region border.\n     * @param cornerDirection The direction of the outer corner from the\n     * reference cell.\n     * @return The region the cell should be a member of. May be the\n     * region the cell is currently a member of.\n     */\n    ObstacleRegionBordersCleaner.prototype.selectedRegionID = function (grid, referenceCell, borderDirection, cornerDirection) {\n        // Initial example state:\n        //\n        // a - Known region.\n        // x - Null region.\n        // u - Unknown, not checked yet.\n        //\n        //     u u u\n        //     u a x\n        //     u a a\n        // The only possible alternate region id is from\n        // the cell that is opposite the border. So check it first.\n        var regionID = grid.getNeighbor(referenceCell, (borderDirection + 2) & 0x3)\n            .regionID;\n        if (regionID === referenceCell.regionID ||\n            regionID === RasterizationCell.OBSTACLE_REGION_ID)\n            // The region away from the border is either a obstacle region\n            // or the same region. So we keep the current region.\n            //\n            //     u u u      u u u\n            //     a a x  or  x a x  <-- Potentially bad, but stuck with it.\n            //     u a a      u a a\n            return referenceCell.regionID;\n        // Candidate region for re-assignment.\n        var potentialRegion = regionID;\n        // Next we check the region opposite from the corner direction.\n        // If it is the current region, then we definitely can't\n        // change the region id without risk of splitting the region.\n        regionID = grid.getNeighbor(referenceCell, (cornerDirection + 2) & 0x3)\n            .regionID;\n        if (regionID === referenceCell.regionID ||\n            regionID === RasterizationCell.OBSTACLE_REGION_ID)\n            // The region opposite from the corner direction is\n            // either a obstacle region or the same region. So we\n            // keep the current region.\n            //\n            //     u a u      u x u\n            //     b a x  or  b a x\n            //     u a a      u a a\n            return referenceCell.regionID;\n        // We have checked the early exit special cases. Now a generalized\n        // brute count is performed.\n        //\n        // Priority is given to the potential region. Here is why:\n        // (Highly unlikely worst case scenario)\n        //\n        //     c c c    c c c\n        //     b a x -> b b x  Select b even though b count == a count.\n        //     b a a    b a a\n        // Neighbors in potential region.\n        // We know this will have a minimum value of 1.\n        var potentialCount = 0;\n        // Neighbors in the cell's current region.\n        // We know this will have a minimum value of 2.\n        var currentCount = 0;\n        // Maximum edge case:\n        //\n        //     b b b\n        //     b a x\n        //     b a a\n        //\n        // The maximum edge case for region A can't exist. It\n        // is filtered out during one of the earlier special cases\n        // handlers.\n        //\n        // Other cases may exist if more regions are involved.\n        // Such cases will tend to favor the current region.\n        for (var direction = 0; direction < 8; direction++) {\n            var regionID_1 = grid.getNeighbor(referenceCell, direction).regionID;\n            if (regionID_1 === referenceCell.regionID)\n                currentCount++;\n            else if (regionID_1 === potentialRegion)\n                potentialCount++;\n        }\n        return potentialCount < currentCount\n            ? referenceCell.regionID\n            : potentialRegion;\n    };\n    /**\n     * Returns the direction of the first neighbor in a non-obstacle region.\n     * @param grid\n     * @param cell The cell to check.\n     * @return The direction of the first neighbor in a non-obstacle region, or\n     * -1 if all neighbors are in the obstacle region.\n     */\n    ObstacleRegionBordersCleaner.prototype.getNonNullBorderDirection = function (grid, cell) {\n        // Search axis-neighbors.\n        for (var direction = 0; direction < RasterizationGrid.neighbor4Deltas.length; direction++) {\n            var delta = RasterizationGrid.neighbor4Deltas[direction];\n            var neighbor = grid.get(cell.x + delta.x, cell.y + delta.y);\n            if (neighbor.regionID !== RasterizationCell.OBSTACLE_REGION_ID)\n                // The neighbor is a obstacle region.\n                return direction;\n        }\n        // All neighbors are in a non-obstacle region.\n        return -1;\n    };\n    return ObstacleRegionBordersCleaner;\n}());\n\n// This implementation is strongly inspired from a Java one\n// by Stephen A. Pratt:\n// http://www.critterai.org/projects/nmgen_study/\n//\n// Most of the comments were written by him and were adapted to fit this implementation.\n// This implementation differs a bit from the original:\n// - it's only 2D instead of 3D\n// - it has less features (see TODO) and might have lesser performance\n// - it uses objects for points instead of pointer-like in arrays of numbers\n// - the rasterization comes from other sources because of the 2d focus\n// - partialFloodRegion was rewritten to fix an issue\n// - filterNonObstacleVertices was added\n//\n// The Java implementation was also inspired from Recast that can be found here:\n// https://github.com/recastnavigation/recastnavigation\nvar NavMeshGenerator = /** @class */ (function () {\n    function NavMeshGenerator(areaLeftBound, areaTopBound, areaRightBound, areaBottomBound, rasterizationCellSize, isometricRatio) {\n        if (isometricRatio === void 0) { isometricRatio = 1; }\n        this.grid = new RasterizationGrid(areaLeftBound, areaTopBound, areaRightBound, areaBottomBound, rasterizationCellSize, \n        // make cells square in the world\n        rasterizationCellSize / isometricRatio);\n        this.isometricRatio = isometricRatio;\n        this.obstacleRasterizer = new ObstacleRasterizer();\n        this.regionGenerator = new RegionGenerator();\n        this.contourBuilder = new ContourBuilder();\n        this.convexPolygonGenerator = new ConvexPolygonGenerator();\n        this.gridCoordinateConverter = new GridCoordinateConverter();\n    }\n    NavMeshGenerator.prototype.buildNavMesh = function (obstacles, obstacleCellPadding) {\n        var _this = this;\n        this.grid.clear();\n        this.obstacleRasterizer.rasterizeObstacles(this.grid, obstacles);\n        this.regionGenerator.generateDistanceField(this.grid);\n        this.regionGenerator.generateRegions(this.grid, obstacleCellPadding);\n        // It's probably not a good idea to expose the vectorization threshold.\n        // As stated in the parameter documentation, the value 1 gives good\n        // results in any situations.\n        var threshold = 1;\n        var contours = this.contourBuilder.buildContours(this.grid, threshold);\n        var meshField = this.convexPolygonGenerator.splitToConvexPolygons(contours, 16);\n        var scaledMeshField = this.gridCoordinateConverter.convertFromGridBasis(this.grid, meshField);\n        if (this.isometricRatio != 1) {\n            // Rescale the mesh to have the same unit length on the 2 axis for the pathfinding.\n            scaledMeshField.forEach(function (polygon) {\n                return polygon.forEach(function (point) {\n                    point.y *= _this.isometricRatio;\n                });\n            });\n        }\n        return scaledMeshField;\n    };\n    return NavMeshGenerator;\n}());\n\n/*\nGDevelop - NavMesh Pathfinding Behavior Extension\n    */\n/**\n * PathfindingObstaclesManager manages the common objects shared by objects having a\n * pathfinding behavior: In particular, the obstacles behaviors are required to declare\n * themselves (see `PathfindingObstaclesManager.addObstacle`) to the manager of their associated scene\n * (see `gdjs.NavMeshPathfindingRuntimeBehavior.obstaclesManagers`).\n */\nvar NavMeshPathfindingObstaclesManager = /** @class */ (function () {\n    function NavMeshPathfindingObstaclesManager(instanceContainer, configuration) {\n        /**\n         * The navigation meshes by moving object size\n         * (rounded on _cellSize)\n         */\n        this._navMeshes = new Map();\n        /**\n         * Used while NavMeshes update is disabled to remember to do the update\n         * when it's enable back.\n         */\n        this._navMeshesAreUpToDate = true;\n        /**\n         * This allows to continue finding paths with the old NavMeshes while\n         * moving obstacles.\n         */\n        this._navMeshesUpdateIsEnabled = true;\n        var viewpoint = configuration._getViewpoint();\n        if (viewpoint === 'Isometry 2:1 (26.565°)') {\n            configuration._setIsometricRatio(2);\n        }\n        else if (viewpoint === 'True Isometry (30°)') {\n            configuration._setIsometricRatio(Math.sqrt(3));\n        }\n        else {\n            configuration._setIsometricRatio(1);\n        }\n        if (configuration._getCellSize() <= 0) {\n            configuration._setCellSize(10);\n        }\n        if (configuration._getAreaLeftBound() === 0 &&\n            configuration._getAreaTopBound() === 0 &&\n            configuration._getAreaRightBound() === 0 &&\n            configuration._getAreaBottomBound() === 0) {\n            var game = instanceContainer.getGame();\n            configuration._setAreaLeftBound(0);\n            configuration._setAreaTopBound(0);\n            configuration._setAreaRightBound(game.getGameResolutionWidth());\n            configuration._setAreaBottomBound(game.getGameResolutionHeight());\n        }\n        this.configuration = configuration;\n        this._obstacles = new Set();\n        this._polygonIterableAdapter = new PolygonIterableAdapter();\n        this._navMeshGenerator = new NavMeshGenerator(configuration._getAreaLeftBound(), configuration._getAreaTopBound(), configuration._getAreaRightBound(), configuration._getAreaBottomBound(), configuration._getCellSize(), \n        // make cells square in the world\n        configuration._getIsometricRatio());\n    }\n    /**\n     * Get the obstacles manager of a scene.\n     */\n    NavMeshPathfindingObstaclesManager.getManager = function (instanceContainer) {\n        // @ts-ignore\n        return instanceContainer.navMeshPathfindingObstaclesManager;\n    };\n    NavMeshPathfindingObstaclesManager.getManagerOrCreate = function (instanceContainer, configuration) {\n        // @ts-ignore\n        if (!instanceContainer.navMeshPathfindingObstaclesManager) {\n            // Create the shared manager if necessary.\n            // @ts-ignore\n            instanceContainer.navMeshPathfindingObstaclesManager = new NavMeshPathfindingObstaclesManager(instanceContainer, configuration);\n        }\n        // @ts-ignore\n        return instanceContainer.navMeshPathfindingObstaclesManager;\n    };\n    NavMeshPathfindingObstaclesManager.prototype.setNavMeshesUpdateEnabled = function (navMeshesUpdateIsEnabled) {\n        this._navMeshesUpdateIsEnabled = navMeshesUpdateIsEnabled;\n        if (navMeshesUpdateIsEnabled && !this._navMeshesAreUpToDate) {\n            this._navMeshes.clear();\n            this._navMeshesAreUpToDate = true;\n        }\n    };\n    /**\n     * Add a obstacle to the list of existing obstacles.\n     */\n    NavMeshPathfindingObstaclesManager.prototype.addObstacle = function (pathfindingObstacleBehavior) {\n        this._obstacles.add(pathfindingObstacleBehavior.behavior.owner);\n        this.invalidateNavMesh();\n    };\n    /**\n     * Remove a obstacle from the list of existing obstacles. Be sure that the obstacle was\n     * added before.\n     */\n    NavMeshPathfindingObstaclesManager.prototype.removeObstacle = function (pathfindingObstacleBehavior) {\n        this._obstacles.delete(pathfindingObstacleBehavior.behavior.owner);\n        this.invalidateNavMesh();\n    };\n    NavMeshPathfindingObstaclesManager.prototype.invalidateNavMesh = function () {\n        if (this._navMeshesUpdateIsEnabled) {\n            this._navMeshes.clear();\n            this._navMeshesAreUpToDate = true;\n        }\n        else {\n            this._navMeshesAreUpToDate = false;\n        }\n    };\n    NavMeshPathfindingObstaclesManager.prototype.getNavMesh = function (obstacleCellPadding) {\n        var navMesh = this._navMeshes.get(obstacleCellPadding);\n        if (!navMesh) {\n            var navMeshPolygons = this._navMeshGenerator.buildNavMesh(this._getVerticesIterable(this._obstacles), obstacleCellPadding);\n            navMesh = new NavMesh(navMeshPolygons);\n            this._navMeshes.set(obstacleCellPadding, navMesh);\n        }\n        return navMesh;\n    };\n    NavMeshPathfindingObstaclesManager.prototype._getVerticesIterable = function (objects) {\n        this._polygonIterableAdapter.set(objects);\n        return this._polygonIterableAdapter;\n    };\n    return NavMeshPathfindingObstaclesManager;\n}());\n/**\n * Iterable that adapts `RuntimeObject` to `Iterable<{x: float y: float}>`.\n *\n * This is an allocation free iterable\n * that can only do one iteration at a time.\n */\nvar PolygonIterableAdapter = /** @class */ (function () {\n    function PolygonIterableAdapter() {\n        this.objects = [];\n        this.objectsItr = this.objects[Symbol.iterator]();\n        this.polygonsItr = [][Symbol.iterator]();\n        this.pointIterableAdapter = new PointIterableAdapter();\n        this.result = {\n            value: this.pointIterableAdapter,\n            done: false,\n        };\n    }\n    PolygonIterableAdapter.prototype.set = function (objects) {\n        this.objects = objects;\n    };\n    PolygonIterableAdapter.prototype[Symbol.iterator] = function () {\n        this.objectsItr = this.objects[Symbol.iterator]();\n        this.polygonsItr = [][Symbol.iterator]();\n        return this;\n    };\n    PolygonIterableAdapter.prototype.next = function () {\n        var polygonNext = this.polygonsItr.next();\n        while (polygonNext.done) {\n            var objectNext = this.objectsItr.next();\n            if (objectNext.done) {\n                // IteratorReturnResult<gdjs.RuntimeObject> require a defined value\n                // even though the spec state otherwise.\n                // So, this class can't be typed as an iterable.\n                this.result.value = undefined;\n                this.result.done = true;\n                return this.result;\n            }\n            this.polygonsItr = objectNext.value.getHitBoxes().values();\n            polygonNext = this.polygonsItr.next();\n        }\n        this.pointIterableAdapter.set(polygonNext.value.vertices);\n        this.result.value = this.pointIterableAdapter;\n        this.result.done = false;\n        return this.result;\n    };\n    return PolygonIterableAdapter;\n}());\n/**\n * Iterable that adapts coordinates from `[int, int]` to `{x: int, y: int}`.\n *\n * This is an allocation free iterable\n * that can only do one iteration at a time.\n */\nvar PointIterableAdapter = /** @class */ (function () {\n    function PointIterableAdapter() {\n        this.vertices = [];\n        this.verticesItr = this.vertices[Symbol.iterator]();\n        this.result = {\n            value: { x: 0, y: 0 },\n            done: false,\n        };\n    }\n    PointIterableAdapter.prototype.set = function (vertices) {\n        this.vertices = vertices;\n    };\n    PointIterableAdapter.prototype[Symbol.iterator] = function () {\n        this.verticesItr = this.vertices[Symbol.iterator]();\n        return this;\n    };\n    PointIterableAdapter.prototype.next = function () {\n        var next = this.verticesItr.next();\n        if (next.done) {\n            return next;\n        }\n        this.result.value.x = next.value[0];\n        this.result.value.y = next.value[1];\n        return this.result;\n    };\n    return PointIterableAdapter;\n}());\n\n/*\nGDevelop - NavMesh Pathfinding Behavior Extension\n    */\n/**\n * NavMeshPathfindingRuntimeBehavior represents a behavior allowing objects to\n * follow a path computed to avoid obstacles.\n */\nvar NavMeshRenderer = /** @class */ (function () {\n    function NavMeshRenderer() {\n        /** Used to draw traces for debugging */\n        this._lastUsedObstacleCellPadding = null;\n    }\n    NavMeshRenderer.prototype.setLastUsedObstacleCellPadding = function (lastUsedObstacleCellPadding) {\n        this._lastUsedObstacleCellPadding = lastUsedObstacleCellPadding;\n    };\n    NavMeshRenderer.prototype.render = function (instanceContainer, shapePainter) {\n        if (this._lastUsedObstacleCellPadding === null) {\n            return;\n        }\n        var manager = NavMeshPathfindingObstaclesManager.getManager(instanceContainer);\n        if (!manager) {\n            return;\n        }\n        var isometricRatio = manager.configuration._getIsometricRatio();\n        // TODO find a way to rebuild drawing only when necessary.\n        // Draw the navigation mesh on a shape painter object for debugging purpose\n        var navMesh = manager.getNavMesh(this._lastUsedObstacleCellPadding);\n        for (var _i = 0, _a = navMesh.getPolygons(); _i < _a.length; _i++) {\n            var navPoly = _a[_i];\n            var polygon = navPoly.getPoints();\n            if (polygon.length === 0)\n                continue;\n            for (var index = 1; index < polygon.length; index++) {\n                // It helps to spot vertices with 180° between edges.\n                shapePainter.drawCircle(polygon[index].x, polygon[index].y / isometricRatio, 3);\n            }\n        }\n        for (var _b = 0, _c = navMesh.getPolygons(); _b < _c.length; _b++) {\n            var navPoly = _c[_b];\n            var polygon = navPoly.getPoints();\n            if (polygon.length === 0)\n                continue;\n            shapePainter.beginFillPath(polygon[0].x, polygon[0].y / isometricRatio);\n            for (var index = 1; index < polygon.length; index++) {\n                shapePainter.drawPathLineTo(polygon[index].x, polygon[index].y / isometricRatio);\n            }\n            shapePainter.closePath();\n            shapePainter.endFillPath();\n        }\n    };\n    return NavMeshRenderer;\n}());\n\n/**\n * NavMeshPathfindingRuntimeBehavior represents a behavior allowing objects to\n * follow a path computed to avoid obstacles.\n */\nvar PathFollower = /** @class */ (function () {\n    function PathFollower(configuration) {\n        // Attributes used for traveling on the path:\n        this._path = [];\n        this._speed = 0;\n        this._distanceOnSegment = 0;\n        this._totalSegmentDistance = 0;\n        this._currentSegment = 0;\n        this._movementAngle = 0;\n        this.configuration = configuration;\n    }\n    PathFollower.prototype.setSpeed = function (speed) {\n        this._speed = speed;\n    };\n    PathFollower.prototype.getSpeed = function () {\n        return this._speed;\n    };\n    PathFollower.prototype.getMovementAngle = function () {\n        return this._movementAngle;\n    };\n    PathFollower.prototype.movementAngleIsAround = function (degreeAngle, tolerance) {\n        return (Math.abs(gdjs.evtTools.common.angleDifference(this._movementAngle, degreeAngle)) <= tolerance);\n    };\n    PathFollower.prototype.getNodeX = function (index) {\n        if (index < this._path.length) {\n            return this._path[index][0];\n        }\n        return 0;\n    };\n    PathFollower.prototype.getNodeY = function (index) {\n        if (index < this._path.length) {\n            return this._path[index][1];\n        }\n        return 0;\n    };\n    PathFollower.prototype.getNextNodeIndex = function () {\n        return Math.min(this._currentSegment + 1, this._path.length - 1);\n    };\n    PathFollower.prototype.getNodeCount = function () {\n        return this._path.length;\n    };\n    PathFollower.prototype.getNextNodeX = function () {\n        if (this._path.length === 0) {\n            return 0;\n        }\n        var nextIndex = Math.min(this._currentSegment + 1, this._path.length - 1);\n        return this._path[nextIndex][0];\n    };\n    PathFollower.prototype.getNextNodeY = function () {\n        if (this._path.length === 0) {\n            return 0;\n        }\n        var nextIndex = Math.min(this._currentSegment + 1, this._path.length - 1);\n        return this._path[nextIndex][1];\n    };\n    PathFollower.prototype.getPreviousNodeX = function () {\n        if (this._path.length === 0) {\n            return 0;\n        }\n        var previousIndex = Math.min(this._currentSegment, this._path.length - 1);\n        return this._path[previousIndex][0];\n    };\n    PathFollower.prototype.getPreviousNodeY = function () {\n        if (this._path.length === 0) {\n            return 0;\n        }\n        var previousIndex = Math.min(this._currentSegment, this._path.length - 1);\n        return this._path[previousIndex][1];\n    };\n    PathFollower.prototype.getDestinationX = function () {\n        if (this._path.length === 0) {\n            return 0;\n        }\n        return this._path[this._path.length - 1][0];\n    };\n    PathFollower.prototype.getDestinationY = function () {\n        if (this._path.length === 0) {\n            return 0;\n        }\n        return (this._path[this._path.length - 1][1]);\n    };\n    /**\n     * Return true if the object reached its destination.\n     */\n    PathFollower.prototype.destinationReached = function () {\n        return this._currentSegment >= this._path.length - 1;\n    };\n    /**\n     * Compute and move on the path to the specified destination.\n     */\n    PathFollower.prototype.setPath = function (path) {\n        this._path = path;\n        this._enterSegment(0);\n    };\n    PathFollower.prototype._enterSegment = function (segmentNumber) {\n        if (this._path.length === 0) {\n            return;\n        }\n        this._currentSegment = segmentNumber;\n        if (this._currentSegment < this._path.length - 1) {\n            var pathX = this._path[this._currentSegment + 1][0] -\n                this._path[this._currentSegment][0];\n            var pathY = this._path[this._currentSegment + 1][1] -\n                this._path[this._currentSegment][1];\n            this._totalSegmentDistance = Math.sqrt(pathX * pathX + pathY * pathY);\n            this._distanceOnSegment = 0;\n            this._movementAngle =\n                (gdjs.toDegrees(Math.atan2(pathY, pathX)) + 360) % 360;\n        }\n        else {\n            this._speed = 0;\n        }\n    };\n    PathFollower.prototype.isMoving = function () {\n        return !(this._path.length === 0 || this.destinationReached());\n    };\n    PathFollower.prototype.step = function (timeDelta) {\n        if (this._path.length === 0 || this.destinationReached()) {\n            return;\n        }\n        // Update the speed of the object\n        var previousSpeed = this._speed;\n        var maxSpeed = this.configuration._getMaxSpeed();\n        if (this._speed !== maxSpeed) {\n            this._speed += this.configuration._getAcceleration() * timeDelta;\n            if (this._speed > maxSpeed) {\n                this._speed = maxSpeed;\n            }\n        }\n        // Update the time on the segment and change segment if needed\n        // Use a Verlet integration to be frame rate independent.\n        this._distanceOnSegment +=\n            ((this._speed + previousSpeed) / 2) * timeDelta;\n        var remainingDistanceOnSegment = this._totalSegmentDistance - this._distanceOnSegment;\n        if (remainingDistanceOnSegment <= 0 &&\n            this._currentSegment < this._path.length) {\n            this._enterSegment(this._currentSegment + 1);\n            this._distanceOnSegment = -remainingDistanceOnSegment;\n        }\n    };\n    PathFollower.prototype.getX = function () {\n        return this._currentSegment < this._path.length - 1 ? gdjs.evtTools.common.lerp(this._path[this._currentSegment][0], this._path[this._currentSegment + 1][0], this._distanceOnSegment / this._totalSegmentDistance) : this._path[this._path.length - 1][0];\n    };\n    PathFollower.prototype.getY = function () {\n        return this._currentSegment < this._path.length - 1 ? gdjs.evtTools.common.lerp(this._path[this._currentSegment][1], this._path[this._currentSegment + 1][1], this._distanceOnSegment / this._totalSegmentDistance) : this._path[this._path.length - 1][1];\n    };\n    return PathFollower;\n}());\n\n/**\n * NavMeshPathfindingRuntimeBehavior represents a behavior allowing objects to\n * follow a path computed to avoid obstacles.\n */\nvar NavMeshPathfindingBehavior = /** @class */ (function () {\n    function NavMeshPathfindingBehavior(behavior) {\n        // Attributes used for traveling on the path:\n        this._pathFound = false;\n        this.behavior = behavior;\n        this.pathFollower = new PathFollower(behavior);\n        this.navMeshRenderer = new NavMeshRenderer();\n    }\n    /**\n     * Return true if the latest call to moveTo succeeded.\n     */\n    NavMeshPathfindingBehavior.prototype.pathFound = function () {\n        return this._pathFound;\n    };\n    /**\n     * Compute and move on the path to the specified destination.\n     */\n    NavMeshPathfindingBehavior.prototype.moveTo = function (instanceContainer, x, y) {\n        var owner = this.behavior.owner;\n        var manager = NavMeshPathfindingObstaclesManager.getManager(instanceContainer);\n        if (!manager) {\n            this._pathFound = true;\n            this.pathFollower.setPath([[owner.getX(), owner.getY()], [x, y]]);\n            return;\n        }\n        var isometricRatio = manager.configuration._getIsometricRatio();\n        var cellSize = manager.configuration._getCellSize();\n        var collisionShape = this.behavior._getCollisionShape();\n        var extraBorder = this.behavior._getExtraBorder();\n        var radiusSqMax = 0;\n        if (collisionShape !== 'Dot at center') {\n            var centerX = owner.getCenterXInScene();\n            var centerY = owner.getCenterYInScene();\n            for (var _i = 0, _a = owner.getHitBoxes(); _i < _a.length; _i++) {\n                var hitBox = _a[_i];\n                for (var _b = 0, _c = hitBox.vertices; _b < _c.length; _b++) {\n                    var vertex = _c[_b];\n                    var deltaX = vertex[0] - centerX;\n                    // to have the same unit on x and y\n                    var deltaY = (vertex[1] - centerY) * isometricRatio;\n                    var radiusSq = deltaX * deltaX + deltaY * deltaY;\n                    radiusSqMax = Math.max(radiusSq, radiusSqMax);\n                }\n            }\n        }\n        // Round to avoid to flicker between 2 NavMesh\n        // because of trigonometry rounding errors.\n        // Round the padding on cellSize to avoid almost identical NavMesh\n        var obstacleCellPadding = Math.max(0, Math.round((Math.sqrt(radiusSqMax) + extraBorder) / cellSize));\n        this.navMeshRenderer.setLastUsedObstacleCellPadding(obstacleCellPadding);\n        var navMesh = manager.getNavMesh(obstacleCellPadding);\n        // TODO avoid the path allocation\n        var path = navMesh.findPath({\n            x: owner.getX(),\n            y: owner.getY() * isometricRatio,\n        }, { x: x, y: y * isometricRatio }) || [];\n        this._pathFound = path.length > 0;\n        this.pathFollower.setPath(path.map(function (_a) {\n            var x = _a.x, y = _a.y;\n            return [x, y];\n        }));\n    };\n    NavMeshPathfindingBehavior.prototype.doStepPreEvents = function (instanceContainer) {\n        if (this.pathFollower.destinationReached()) {\n            return;\n        }\n        var manager = NavMeshPathfindingObstaclesManager.getManager(instanceContainer);\n        if (!manager) {\n            return;\n        }\n        var isometricRatio = manager.configuration._getIsometricRatio();\n        var owner = this.behavior.owner;\n        var angleOffset = this.behavior._getAngleOffset();\n        var angularMaxSpeed = this.behavior._getMaxSpeed();\n        var rotateObject = this.behavior._getRotateObject();\n        var timeDelta = owner.getElapsedTime(instanceContainer) / 1000;\n        this.pathFollower.step(timeDelta);\n        // Position object on the segment and update its angle\n        var movementAngle = this.pathFollower.getMovementAngle();\n        if (rotateObject &&\n            owner.getAngle() !== movementAngle + angleOffset) {\n            owner.rotateTowardAngle(movementAngle + angleOffset, angularMaxSpeed, instanceContainer);\n        }\n        owner.setX(this.pathFollower.getX());\n        // In case of isometry, convert coords back in screen.\n        owner.setY(this.pathFollower.getY() / isometricRatio);\n    };\n    return NavMeshPathfindingBehavior;\n}());\n\n/*\nGDevelop - NavMesh Pathfinding Behavior Extension\n    */\n/**\n * NavMeshPathfindingObstacleRuntimeBehavior represents a behavior allowing objects to be\n * considered as a obstacle by objects having Pathfinding Behavior.\n */\nvar NavMeshPathfindingObstacleBehavior = /** @class */ (function () {\n    function NavMeshPathfindingObstacleBehavior(instanceContainer, behavior) {\n        this._oldX = 0;\n        this._oldY = 0;\n        this._oldWidth = 0;\n        this._oldHeight = 0;\n        this._registeredInManager = false;\n        this.behavior = behavior;\n        this._manager = NavMeshPathfindingObstaclesManager.getManagerOrCreate(instanceContainer, \n        // @ts-ignore\n        behavior._sharedData);\n        //Note that we can't use getX(), getWidth()... of owner here:\n        //The owner is not yet fully constructed.\n    }\n    NavMeshPathfindingObstacleBehavior.prototype.onDestroy = function () {\n        if (this._manager && this._registeredInManager) {\n            this._manager.removeObstacle(this);\n        }\n    };\n    NavMeshPathfindingObstacleBehavior.prototype.doStepPreEvents = function (instanceContainer) {\n        var owner = this.behavior.owner;\n        //Make sure the obstacle is or is not in the obstacles manager.\n        if (!this.behavior.activated() && this._registeredInManager) {\n            this._manager.removeObstacle(this);\n            this._registeredInManager = false;\n        }\n        else {\n            if (this.behavior.activated() && !this._registeredInManager) {\n                this._manager.addObstacle(this);\n                this._registeredInManager = true;\n            }\n        }\n        //Track changes in size or position\n        if (this._oldX !== owner.getX() ||\n            this._oldY !== owner.getY() ||\n            this._oldWidth !== owner.getWidth() ||\n            this._oldHeight !== owner.getHeight()) {\n            if (this._registeredInManager) {\n                this._manager.removeObstacle(this);\n                this._manager.addObstacle(this);\n            }\n            this._oldX = owner.getX();\n            this._oldY = owner.getY();\n            this._oldWidth = owner.getWidth();\n            this._oldHeight = owner.getHeight();\n        }\n    };\n    NavMeshPathfindingObstacleBehavior.prototype.doStepPostEvents = function (instanceContainer) { };\n    NavMeshPathfindingObstacleBehavior.prototype.onActivate = function () {\n        if (this._registeredInManager) {\n            return;\n        }\n        this._manager.addObstacle(this);\n        this._registeredInManager = true;\n    };\n    NavMeshPathfindingObstacleBehavior.prototype.onDeActivate = function () {\n        if (!this._registeredInManager) {\n            return;\n        }\n        this._manager.removeObstacle(this);\n        this._registeredInManager = false;\n    };\n    return NavMeshPathfindingObstacleBehavior;\n}());\n\ngdjs.__NavMeshPathfinding = gdjs.__NavMeshPathfinding || {};\ngdjs.__NavMeshPathfinding.NavMeshPathfindingBehavior = NavMeshPathfindingBehavior;\ngdjs.__NavMeshPathfinding.NavMeshPathfindingObstacleBehavior = NavMeshPathfindingObstacleBehavior;\n",
              "parameterObjects": "",
              "useStrict": true,
              "eventsSheetExpanded": true
            }
          ]
        }
      ],
      "parameters": [],
      "objectGroups": []
    }
  ],
  "eventsBasedBehaviors": [
    {
      "description": "Move the object to a target in straight lines while avoiding all objects that are flagged as obstacles.",
      "fullName": "Navigation mesh pathfinding (experimental)",
      "name": "NavMeshPathfindingBehavior",
      "objectType": "",
      "eventsFunctions": [
        {
          "fullName": "",
          "functionType": "Action",
          "name": "onCreated",
          "sentence": "",
          "events": [
            {
              "type": "BuiltinCommonInstructions::Comment",
              "color": {
                "b": 109,
                "g": 230,
                "r": 255,
                "textB": 0,
                "textG": 0,
                "textR": 0
              },
              "comment": "Initiate and attach properties as objects variables",
              "comment2": ""
            },
            {
              "type": "BuiltinCommonInstructions::Standard",
              "conditions": [],
              "actions": [
                {
                  "type": {
                    "value": "NavMeshPathfinding::DefineJavaScript"
                  },
                  "parameters": [
                    "",
                    ""
                  ]
                }
              ]
            },
            {
              "type": "BuiltinCommonInstructions::JsCode",
              "inlineCode": "const object = objects[0];\r\nconst behaviorName = eventsFunctionContext.getBehaviorName(\"Behavior\");\r\nconst behavior = object.getBehavior(behaviorName);\r\nbehavior.__NavMeshPathfinding = behavior.__NavMeshPathfinding || {};\r\nbehavior.__NavMeshPathfinding.pathfinding = new gdjs.__NavMeshPathfinding.NavMeshPathfindingBehavior(behavior);\r\n",
              "parameterObjects": "Object",
              "useStrict": true,
              "eventsSheetExpanded": true
            }
          ],
          "parameters": [
            {
              "description": "Object",
              "name": "Object",
              "type": "object"
            },
            {
              "description": "Behavior",
              "name": "Behavior",
              "supplementaryInformation": "NavMeshPathfinding::NavMeshPathfindingBehavior",
              "type": "behavior"
            }
          ],
          "objectGroups": []
        },
        {
          "fullName": "",
          "functionType": "Action",
          "name": "doStepPreEvents",
          "sentence": "",
          "events": [
            {
              "type": "BuiltinCommonInstructions::JsCode",
              "inlineCode": "const object = objects[0];\r\nconst behaviorName = eventsFunctionContext.getBehaviorName(\"Behavior\");\r\nconst behavior = object.getBehavior(behaviorName);\r\n\r\nbehavior.__NavMeshPathfinding.pathfinding.doStepPreEvents(runtimeScene);\r\n",
              "parameterObjects": "Object",
              "useStrict": true,
              "eventsSheetExpanded": true
            }
          ],
          "parameters": [
            {
              "description": "Object",
              "name": "Object",
              "type": "object"
            },
            {
              "description": "Behavior",
              "name": "Behavior",
              "supplementaryInformation": "NavMeshPathfinding::NavMeshPathfindingBehavior",
              "type": "behavior"
            }
          ],
          "objectGroups": []
        },
        {
          "description": "Move the object to a position.",
          "fullName": "Move to a position",
          "functionType": "Action",
          "group": "Movement on the path (navigation mesh)",
          "name": "SetDestination",
          "sentence": "Move _PARAM0_ to _PARAM2_;_PARAM3_",
          "events": [
            {
              "type": "BuiltinCommonInstructions::JsCode",
              "inlineCode": "const object = objects[0];\nconst behaviorName = eventsFunctionContext.getBehaviorName(\"Behavior\");\nconst behavior = object.getBehavior(behaviorName);\n\nconst destinationX = eventsFunctionContext.getArgument(\"DestinationX\");\nconst destinationY = eventsFunctionContext.getArgument(\"DestinationY\");\n\nbehavior.__NavMeshPathfinding.pathfinding.moveTo(runtimeScene, destinationX, destinationY);\n",
              "parameterObjects": "Object",
              "useStrict": true,
              "eventsSheetExpanded": true
            }
          ],
          "parameters": [
            {
              "description": "Object",
              "name": "Object",
              "type": "object"
            },
            {
              "description": "Behavior",
              "name": "Behavior",
              "supplementaryInformation": "NavMeshPathfinding::NavMeshPathfindingBehavior",
              "type": "behavior"
            },
            {
              "description": "Destination X position",
              "name": "DestinationX",
              "type": "expression"
            },
            {
              "description": "Destination Y position",
              "name": "DestinationY",
              "type": "expression"
            }
          ],
          "objectGroups": []
        },
        {
          "description": "Check if the object is moving on a path.",
          "fullName": "Is moving",
          "functionType": "Condition",
          "group": "Movement on the path (navigation mesh)",
          "name": "IsMoving",
          "sentence": "_PARAM0_ is moving on a path",
          "events": [
            {
              "type": "BuiltinCommonInstructions::JsCode",
              "inlineCode": "const object = objects[0];\nconst behaviorName = eventsFunctionContext.getBehaviorName(\"Behavior\");\nconst behavior = object.getBehavior(behaviorName);\n\neventsFunctionContext.returnValue = behavior.__NavMeshPathfinding.pathfinding.pathFollower.isMoving();\n",
              "parameterObjects": "Object",
              "useStrict": true,
              "eventsSheetExpanded": false
            }
          ],
          "parameters": [
            {
              "description": "Object",
              "name": "Object",
              "type": "object"
            },
            {
              "description": "Behavior",
              "name": "Behavior",
              "supplementaryInformation": "NavMeshPathfinding::NavMeshPathfindingBehavior",
              "type": "behavior"
            }
          ],
          "objectGroups": []
        },
        {
          "description": "Check if a path has been found.",
          "fullName": "Path found",
          "functionType": "Condition",
          "group": "Movement on the path (navigation mesh)",
          "name": "PathFound",
          "sentence": "A path has been found for _PARAM0_",
          "events": [
            {
              "type": "BuiltinCommonInstructions::JsCode",
              "inlineCode": "const object = objects[0];\nconst behaviorName = eventsFunctionContext.getBehaviorName(\"Behavior\");\nconst behavior = object.getBehavior(behaviorName);\n\neventsFunctionContext.returnValue = behavior.__NavMeshPathfinding.pathfinding.pathFound();\n",
              "parameterObjects": "Object",
              "useStrict": true,
              "eventsSheetExpanded": false
            }
          ],
          "parameters": [
            {
              "description": "Object",
              "name": "Object",
              "type": "object"
            },
            {
              "description": "Behavior",
              "name": "Behavior",
              "supplementaryInformation": "NavMeshPathfinding::NavMeshPathfindingBehavior",
              "type": "behavior"
            }
          ],
          "objectGroups": []
        },
        {
          "description": "Check if the destination was reached.",
          "fullName": "Destination reached",
          "functionType": "Condition",
          "group": "Movement on the path (navigation mesh)",
          "name": "DestinationReached",
          "sentence": "_PARAM0_ reached its destination",
          "events": [
            {
              "type": "BuiltinCommonInstructions::JsCode",
              "inlineCode": "const object = objects[0];\nconst behaviorName = eventsFunctionContext.getBehaviorName(\"Behavior\");\nconst behavior = object.getBehavior(behaviorName);\n\neventsFunctionContext.returnValue = behavior.__NavMeshPathfinding.pathfinding.pathFollower.destinationReached();\n",
              "parameterObjects": "Object",
              "useStrict": true,
              "eventsSheetExpanded": false
            }
          ],
          "parameters": [
            {
              "description": "Object",
              "name": "Object",
              "type": "object"
            },
            {
              "description": "Behavior",
              "name": "Behavior",
              "supplementaryInformation": "NavMeshPathfinding::NavMeshPathfindingBehavior",
              "type": "behavior"
            }
          ],
          "objectGroups": []
        },
        {
          "description": "Get the number of waypoints on the path.",
          "fullName": "Waypoint count",
          "functionType": "Expression",
          "group": "Movement on the path (navigation mesh)",
          "name": "NodeCount",
          "sentence": "",
          "events": [
            {
              "type": "BuiltinCommonInstructions::JsCode",
              "inlineCode": "const object = objects[0];\nconst behaviorName = eventsFunctionContext.getBehaviorName(\"Behavior\");\nconst behavior = object.getBehavior(behaviorName);\n\neventsFunctionContext.returnValue = behavior.__NavMeshPathfinding.pathfinding.pathFollower.getNodeCount();\n",
              "parameterObjects": "Object",
              "useStrict": true,
              "eventsSheetExpanded": false
            }
          ],
          "expressionType": {
            "type": "expression"
          },
          "parameters": [
            {
              "description": "Object",
              "name": "Object",
              "type": "object"
            },
            {
              "description": "Behavior",
              "name": "Behavior",
              "supplementaryInformation": "NavMeshPathfinding::NavMeshPathfindingBehavior",
              "type": "behavior"
            }
          ],
          "objectGroups": []
        },
        {
          "description": "Return a waypoint X position.",
          "fullName": "Waypoint X position",
          "functionType": "Expression",
          "group": "Movement on the path (navigation mesh)",
          "name": "NodeX",
          "sentence": "",
          "events": [
            {
              "type": "BuiltinCommonInstructions::JsCode",
              "inlineCode": "const object = objects[0];\nconst behaviorName = eventsFunctionContext.getBehaviorName(\"Behavior\");\nconst behavior = object.getBehavior(behaviorName);\n\nconst nodeIndex = eventsFunctionContext.getArgument(\"NodeIndex\");\n\neventsFunctionContext.returnValue = behavior.__NavMeshPathfinding.pathfinding.pathFollower.getNodeX(nodeIndex);\n",
              "parameterObjects": "Object",
              "useStrict": true,
              "eventsSheetExpanded": false
            }
          ],
          "expressionType": {
            "type": "expression"
          },
          "parameters": [
            {
              "description": "Object",
              "name": "Object",
              "type": "object"
            },
            {
              "description": "Behavior",
              "name": "Behavior",
              "supplementaryInformation": "NavMeshPathfinding::NavMeshPathfindingBehavior",
              "type": "behavior"
            },
            {
              "description": "Node index (start at 0)",
              "name": "NodeIndex",
              "type": "expression"
            }
          ],
          "objectGroups": []
        },
        {
          "description": "Return a waypoint Y position.",
          "fullName": "Waypoint Y position",
          "functionType": "Expression",
          "group": "Movement on the path (navigation mesh)",
          "name": "NodeY",
          "sentence": "",
          "events": [
            {
              "type": "BuiltinCommonInstructions::JsCode",
              "inlineCode": "const object = objects[0];\nconst behaviorName = eventsFunctionContext.getBehaviorName(\"Behavior\");\nconst behavior = object.getBehavior(behaviorName);\n\nconst nodeIndex = eventsFunctionContext.getArgument(\"NodeIndex\");\n\neventsFunctionContext.returnValue = behavior.__NavMeshPathfinding.pathfinding.pathFollower.getNodeY(nodeIndex);\n",
              "parameterObjects": "Object",
              "useStrict": true,
              "eventsSheetExpanded": false
            }
          ],
          "expressionType": {
            "type": "expression"
          },
          "parameters": [
            {
              "description": "Object",
              "name": "Object",
              "type": "object"
            },
            {
              "description": "Behavior",
              "name": "Behavior",
              "supplementaryInformation": "NavMeshPathfinding::NavMeshPathfindingBehavior",
              "type": "behavior"
            },
            {
              "description": "Node index (start at 0)",
              "name": "NodeIndex",
              "type": "expression"
            }
          ],
          "objectGroups": []
        },
        {
          "description": "Return the index of the next waypoint to reach.",
          "fullName": "Index of the next waypoint",
          "functionType": "Expression",
          "group": "Movement on the path (navigation mesh)",
          "name": "NextNodeIndex",
          "sentence": "",
          "events": [
            {
              "type": "BuiltinCommonInstructions::JsCode",
              "inlineCode": "const object = objects[0];\nconst behaviorName = eventsFunctionContext.getBehaviorName(\"Behavior\");\nconst behavior = object.getBehavior(behaviorName);\n\neventsFunctionContext.returnValue = behavior.__NavMeshPathfinding.pathfinding.pathFollower.getNextNodeIndex();\n",
              "parameterObjects": "Object",
              "useStrict": true,
              "eventsSheetExpanded": false
            }
          ],
          "expressionType": {
            "type": "expression"
          },
          "parameters": [
            {
              "description": "Object",
              "name": "Object",
              "type": "object"
            },
            {
              "description": "Behavior",
              "name": "Behavior",
              "supplementaryInformation": "NavMeshPathfinding::NavMeshPathfindingBehavior",
              "type": "behavior"
            }
          ],
          "objectGroups": []
        },
        {
          "description": "Return the next waypoint X position.",
          "fullName": "Next waypoint X position",
          "functionType": "Expression",
          "group": "Movement on the path (navigation mesh)",
          "name": "NextNodeX",
          "sentence": "",
          "events": [
            {
              "type": "BuiltinCommonInstructions::Standard",
              "conditions": [],
              "actions": [
                {
                  "type": {
                    "value": "SetReturnNumber"
                  },
                  "parameters": [
                    "Object.Behavior::NodeX(Object.Behavior::NextNodeIndex())"
                  ]
                }
              ]
            }
          ],
          "expressionType": {
            "type": "expression"
          },
          "parameters": [
            {
              "description": "Object",
              "name": "Object",
              "type": "object"
            },
            {
              "description": "Behavior",
              "name": "Behavior",
              "supplementaryInformation": "NavMeshPathfinding::NavMeshPathfindingBehavior",
              "type": "behavior"
            }
          ],
          "objectGroups": []
        },
        {
          "description": "Return the next waypoint Y position.",
          "fullName": "Next waypoint Y position",
          "functionType": "Expression",
          "group": "Movement on the path (navigation mesh)",
          "name": "NextNodeY",
          "sentence": "",
          "events": [
            {
              "type": "BuiltinCommonInstructions::Standard",
              "conditions": [],
              "actions": [
                {
                  "type": {
                    "value": "SetReturnNumber"
                  },
                  "parameters": [
                    "Object.Behavior::NodeY(Object.Behavior::NextNodeIndex())"
                  ]
                }
              ]
            }
          ],
          "expressionType": {
            "type": "expression"
          },
          "parameters": [
            {
              "description": "Object",
              "name": "Object",
              "type": "object"
            },
            {
              "description": "Behavior",
              "name": "Behavior",
              "supplementaryInformation": "NavMeshPathfinding::NavMeshPathfindingBehavior",
              "type": "behavior"
            }
          ],
          "objectGroups": []
        },
        {
          "description": "Return the previous waypoint X position.",
          "fullName": "Previous waypoint X position",
          "functionType": "Expression",
          "group": "Movement on the path (navigation mesh)",
          "name": "PreviousNodeX",
          "sentence": "",
          "events": [
            {
              "type": "BuiltinCommonInstructions::Standard",
              "conditions": [],
              "actions": [
                {
                  "type": {
                    "value": "SetReturnNumber"
                  },
                  "parameters": [
                    "Object.Behavior::NodeX(Object.Behavior::NextNodeIndex() - 1)"
                  ]
                }
              ]
            }
          ],
          "expressionType": {
            "type": "expression"
          },
          "parameters": [
            {
              "description": "Object",
              "name": "Object",
              "type": "object"
            },
            {
              "description": "Behavior",
              "name": "Behavior",
              "supplementaryInformation": "NavMeshPathfinding::NavMeshPathfindingBehavior",
              "type": "behavior"
            }
          ],
          "objectGroups": []
        },
        {
          "description": "Return the previous waypoint Y position.",
          "fullName": "Previous waypoint Y position",
          "functionType": "Expression",
          "group": "Movement on the path (navigation mesh)",
          "name": "PreviousNodeY",
          "sentence": "",
          "events": [
            {
              "type": "BuiltinCommonInstructions::Standard",
              "conditions": [],
              "actions": [
                {
                  "type": {
                    "value": "SetReturnNumber"
                  },
                  "parameters": [
                    "Object.Behavior::NodeY(Object.Behavior::NextNodeIndex() - 1)"
                  ]
                }
              ]
            }
          ],
          "expressionType": {
            "type": "expression"
          },
          "parameters": [
            {
              "description": "Object",
              "name": "Object",
              "type": "object"
            },
            {
              "description": "Behavior",
              "name": "Behavior",
              "supplementaryInformation": "NavMeshPathfinding::NavMeshPathfindingBehavior",
              "type": "behavior"
            }
          ],
          "objectGroups": []
        },
        {
          "description": "Return the destination X position.",
          "fullName": "Destination X position",
          "functionType": "Expression",
          "group": "Movement on the path (navigation mesh)",
          "name": "DestinationX",
          "sentence": "",
          "events": [
            {
              "type": "BuiltinCommonInstructions::Standard",
              "conditions": [],
              "actions": [
                {
                  "type": {
                    "value": "SetReturnNumber"
                  },
                  "parameters": [
                    "Object.Behavior::NodeX(Object.Behavior::NodeCount() - 1)"
                  ]
                }
              ]
            }
          ],
          "expressionType": {
            "type": "expression"
          },
          "parameters": [
            {
              "description": "Object",
              "name": "Object",
              "type": "object"
            },
            {
              "description": "Behavior",
              "name": "Behavior",
              "supplementaryInformation": "NavMeshPathfinding::NavMeshPathfindingBehavior",
              "type": "behavior"
            }
          ],
          "objectGroups": []
        },
        {
          "description": "Return the destination Y position.",
          "fullName": "Destination Y position",
          "functionType": "Expression",
          "group": "Movement on the path (navigation mesh)",
          "name": "DestinationY",
          "sentence": "",
          "events": [
            {
              "type": "BuiltinCommonInstructions::Standard",
              "conditions": [],
              "actions": [
                {
                  "type": {
                    "value": "SetReturnNumber"
                  },
                  "parameters": [
                    "Object.Behavior::NodeY(Object.Behavior::NodeCount() - 1)"
                  ]
                }
              ]
            }
          ],
          "expressionType": {
            "type": "expression"
          },
          "parameters": [
            {
              "description": "Object",
              "name": "Object",
              "type": "object"
            },
            {
              "description": "Behavior",
              "name": "Behavior",
              "supplementaryInformation": "NavMeshPathfinding::NavMeshPathfindingBehavior",
              "type": "behavior"
            }
          ],
          "objectGroups": []
        },
        {
          "description": "Return the angle of movement of an object on its path.",
          "fullName": "Angle of movement on its path",
          "functionType": "Expression",
          "group": "Movement on the path (navigation mesh)",
          "name": "MovementAngle",
          "sentence": "",
          "events": [
            {
              "type": "BuiltinCommonInstructions::JsCode",
              "inlineCode": "const object = objects[0];\nconst behaviorName = eventsFunctionContext.getBehaviorName(\"Behavior\");\nconst behavior = object.getBehavior(behaviorName);\n\nconst angle = eventsFunctionContext.getArgument(\"Angle\");\nconst tolerance = eventsFunctionContext.getArgument(\"Tolerance\");\n\neventsFunctionContext.returnValue = behavior.__NavMeshPathfinding.pathfinding.pathFollower.getMovementAngle(angle, tolerance);\n",
              "parameterObjects": "Object",
              "useStrict": true,
              "eventsSheetExpanded": false
            }
          ],
          "expressionType": {
            "type": "expression"
          },
          "parameters": [
            {
              "description": "Object",
              "name": "Object",
              "type": "object"
            },
            {
              "description": "Behavior",
              "name": "Behavior",
              "supplementaryInformation": "NavMeshPathfinding::NavMeshPathfindingBehavior",
              "type": "behavior"
            }
          ],
          "objectGroups": []
        },
        {
          "description": "Compare the angle of movement of an object on its path.",
          "fullName": "Angle of movement on its path",
          "functionType": "Condition",
          "group": "Movement on the path (navigation mesh)",
          "name": "MovementAngleIsAround",
          "sentence": "Angle of movement of _PARAM0_ is _PARAM2_ (tolerance: _PARAM3_ degrees)",
          "events": [
            {
              "type": "BuiltinCommonInstructions::Standard",
              "conditions": [
                {
                  "type": {
                    "value": "BuiltinCommonInstructions::CompareNumbers"
                  },
                  "parameters": [
                    "AngleDifference(GetArgumentAsNumber(\"Angle\"), Object.Behavior::MovementAngle())",
                    "<",
                    "GetArgumentAsNumber(\"Tolerance\")"
                  ]
                }
              ],
              "actions": [
                {
                  "type": {
                    "value": "SetReturnBoolean"
                  },
                  "parameters": [
                    "True"
                  ]
                }
              ]
            }
          ],
          "parameters": [
            {
              "description": "Object",
              "name": "Object",
              "type": "object"
            },
            {
              "description": "Behavior",
              "name": "Behavior",
              "supplementaryInformation": "NavMeshPathfinding::NavMeshPathfindingBehavior",
              "type": "behavior"
            },
            {
              "description": "Angle (in degrees)",
              "name": "Angle",
              "type": "expression"
            },
            {
              "description": "Tolerance (in degrees)",
              "name": "Tolerance",
              "type": "expression"
            }
          ],
          "objectGroups": []
        },
        {
          "description": "the number of waypoints on the path.",
          "fullName": "Speed on the path",
          "functionType": "ExpressionAndCondition",
          "group": "Movement on the path (navigation mesh)",
          "name": "Speed",
          "sentence": "the speed on the path",
          "events": [
            {
              "type": "BuiltinCommonInstructions::JsCode",
              "inlineCode": "const object = objects[0];\nconst behaviorName = eventsFunctionContext.getBehaviorName(\"Behavior\");\nconst behavior = object.getBehavior(behaviorName);\n\neventsFunctionContext.returnValue = behavior.__NavMeshPathfinding.pathfinding.pathFollower.getSpeed();\n",
              "parameterObjects": "Object",
              "useStrict": true,
              "eventsSheetExpanded": false
            }
          ],
          "expressionType": {
            "type": "expression"
          },
          "parameters": [
            {
              "description": "Object",
              "name": "Object",
              "type": "object"
            },
            {
              "description": "Behavior",
              "name": "Behavior",
              "supplementaryInformation": "NavMeshPathfinding::NavMeshPathfindingBehavior",
              "type": "behavior"
            }
          ],
          "objectGroups": []
        },
        {
          "fullName": "Draw navigation mesh",
          "functionType": "Action",
          "group": "Debug (navigation mesh)",
          "name": "DrawNavMesh",
          "sentence": "Draw the navigation mesh used for _PARAM0_ on _PARAM2_",
          "events": [
            {
              "type": "BuiltinCommonInstructions::JsCode",
              "inlineCode": "const object = objects[0];\nconst behaviorName = eventsFunctionContext.getBehaviorName(\"Behavior\");\nconst behavior = object.getBehavior(behaviorName);\n\nconst shapePainters = eventsFunctionContext.getObjects(\"ShapePainter\");\n\nfor (const shapePainter of shapePainters) {\n    behavior.__NavMeshPathfinding.pathfinding.navMeshRenderer.render(runtimeScene, shapePainter);\n}\n",
              "parameterObjects": "Object",
              "useStrict": true,
              "eventsSheetExpanded": true
            }
          ],
          "parameters": [
            {
              "description": "Object",
              "name": "Object",
              "type": "object"
            },
            {
              "description": "Behavior",
              "name": "Behavior",
              "supplementaryInformation": "NavMeshPathfinding::NavMeshPathfindingBehavior",
              "type": "behavior"
            },
            {
              "description": "Shape painter",
              "name": "ShapePainter",
              "supplementaryInformation": "PrimitiveDrawing::Drawer",
              "type": "objectList"
            }
          ],
          "objectGroups": []
        },
        {
          "description": "the acceleration of the object.",
          "fullName": "Acceleration",
          "functionType": "ExpressionAndCondition",
          "group": "Pathfinding configuration (navigation mesh)",
          "name": "Acceleration",
          "sentence": "the acceleration",
          "events": [
            {
              "type": "BuiltinCommonInstructions::Standard",
              "conditions": [],
              "actions": [
                {
                  "type": {
                    "value": "SetReturnNumber"
                  },
                  "parameters": [
                    "Object.Behavior::PropertyAcceleration()"
                  ]
                }
              ]
            }
          ],
          "expressionType": {
            "type": "expression"
          },
          "parameters": [
            {
              "description": "Object",
              "name": "Object",
              "type": "object"
            },
            {
              "description": "Behavior",
              "name": "Behavior",
              "supplementaryInformation": "NavMeshPathfinding::NavMeshPathfindingBehavior",
              "type": "behavior"
            }
          ],
          "objectGroups": []
        },
        {
          "fullName": "",
          "functionType": "ActionWithOperator",
          "getterName": "Acceleration",
          "name": "SetAcceleration",
          "sentence": "",
          "events": [
            {
              "type": "BuiltinCommonInstructions::Standard",
              "conditions": [],
              "actions": [
                {
                  "type": {
                    "value": "NavMeshPathfinding::NavMeshPathfindingBehavior::SetPropertyAcceleration"
                  },
                  "parameters": [
                    "Object",
                    "Behavior",
                    "=",
                    "GetArgumentAsNumber(\"Value\")"
                  ]
                }
              ]
            }
          ],
          "parameters": [
            {
              "description": "Object",
              "name": "Object",
              "type": "object"
            },
            {
              "description": "Behavior",
              "name": "Behavior",
              "supplementaryInformation": "NavMeshPathfinding::NavMeshPathfindingBehavior",
              "type": "behavior"
            }
          ],
          "objectGroups": []
        },
        {
          "description": "the max. speed of the object.",
          "fullName": "Max. speed",
          "functionType": "ExpressionAndCondition",
          "group": "Pathfinding configuration (navigation mesh)",
          "name": "MaxSpeed",
          "sentence": "the max. speed",
          "events": [
            {
              "type": "BuiltinCommonInstructions::Standard",
              "conditions": [],
              "actions": [
                {
                  "type": {
                    "value": "SetReturnNumber"
                  },
                  "parameters": [
                    "Object.Behavior::PropertyMaxSpeed()"
                  ]
                }
              ]
            }
          ],
          "expressionType": {
            "type": "expression"
          },
          "parameters": [
            {
              "description": "Object",
              "name": "Object",
              "type": "object"
            },
            {
              "description": "Behavior",
              "name": "Behavior",
              "supplementaryInformation": "NavMeshPathfinding::NavMeshPathfindingBehavior",
              "type": "behavior"
            }
          ],
          "objectGroups": []
        },
        {
          "fullName": "",
          "functionType": "ActionWithOperator",
          "getterName": "MaxSpeed",
          "name": "SetMaxSpeed",
          "sentence": "",
          "events": [
            {
              "type": "BuiltinCommonInstructions::Standard",
              "conditions": [],
              "actions": [
                {
                  "type": {
                    "value": "NavMeshPathfinding::NavMeshPathfindingBehavior::SetPropertyMaxSpeed"
                  },
                  "parameters": [
                    "Object",
                    "Behavior",
                    "=",
                    "GetArgumentAsNumber(\"Value\")"
                  ]
                }
              ]
            }
          ],
          "parameters": [
            {
              "description": "Object",
              "name": "Object",
              "type": "object"
            },
            {
              "description": "Behavior",
              "name": "Behavior",
              "supplementaryInformation": "NavMeshPathfinding::NavMeshPathfindingBehavior",
              "type": "behavior"
            }
          ],
          "objectGroups": []
        },
        {
          "description": "the rotate speed of the object.",
          "fullName": "Rotate speed",
          "functionType": "ExpressionAndCondition",
          "group": "Pathfinding configuration (navigation mesh)",
          "name": "AngularMaxSpeed",
          "sentence": "the rotate speed",
          "events": [
            {
              "type": "BuiltinCommonInstructions::Standard",
              "conditions": [],
              "actions": [
                {
                  "type": {
                    "value": "SetReturnNumber"
                  },
                  "parameters": [
                    "Object.Behavior::PropertyAngularMaxSpeed()"
                  ]
                }
              ]
            }
          ],
          "expressionType": {
            "type": "expression"
          },
          "parameters": [
            {
              "description": "Object",
              "name": "Object",
              "type": "object"
            },
            {
              "description": "Behavior",
              "name": "Behavior",
              "supplementaryInformation": "NavMeshPathfinding::NavMeshPathfindingBehavior",
              "type": "behavior"
            }
          ],
          "objectGroups": []
        },
        {
          "fullName": "",
          "functionType": "ActionWithOperator",
          "getterName": "AngularMaxSpeed",
          "name": "SetAngularMaxSpeed",
          "sentence": "",
          "events": [
            {
              "type": "BuiltinCommonInstructions::Standard",
              "conditions": [],
              "actions": [
                {
                  "type": {
                    "value": "NavMeshPathfinding::NavMeshPathfindingBehavior::SetPropertyAngularMaxSpeed"
                  },
                  "parameters": [
                    "Object",
                    "Behavior",
                    "=",
                    "GetArgumentAsNumber(\"Value\")"
                  ]
                }
              ]
            }
          ],
          "parameters": [
            {
              "description": "Object",
              "name": "Object",
              "type": "object"
            },
            {
              "description": "Behavior",
              "name": "Behavior",
              "supplementaryInformation": "NavMeshPathfinding::NavMeshPathfindingBehavior",
              "type": "behavior"
            }
          ],
          "objectGroups": []
        },
        {
          "description": "the angle offset of the object.",
          "fullName": "Angle offset",
          "functionType": "ExpressionAndCondition",
          "group": "Pathfinding configuration (navigation mesh)",
          "name": "AngleOffset",
          "sentence": "the angle offset",
          "events": [
            {
              "type": "BuiltinCommonInstructions::Standard",
              "conditions": [],
              "actions": [
                {
                  "type": {
                    "value": "SetReturnNumber"
                  },
                  "parameters": [
                    "Object.Behavior::PropertyAngleOffset()"
                  ]
                }
              ]
            }
          ],
          "expressionType": {
            "type": "expression"
          },
          "parameters": [
            {
              "description": "Object",
              "name": "Object",
              "type": "object"
            },
            {
              "description": "Behavior",
              "name": "Behavior",
              "supplementaryInformation": "NavMeshPathfinding::NavMeshPathfindingBehavior",
              "type": "behavior"
            }
          ],
          "objectGroups": []
        },
        {
          "fullName": "",
          "functionType": "ActionWithOperator",
          "getterName": "AngleOffset",
          "name": "SetAngleOffset",
          "sentence": "",
          "events": [
            {
              "type": "BuiltinCommonInstructions::Standard",
              "conditions": [],
              "actions": [
                {
                  "type": {
                    "value": "NavMeshPathfinding::NavMeshPathfindingBehavior::SetPropertyAngleOffset"
                  },
                  "parameters": [
                    "Object",
                    "Behavior",
                    "=",
                    "GetArgumentAsNumber(\"Value\")"
                  ]
                }
              ]
            }
          ],
          "parameters": [
            {
              "description": "Object",
              "name": "Object",
              "type": "object"
            },
            {
              "description": "Behavior",
              "name": "Behavior",
              "supplementaryInformation": "NavMeshPathfinding::NavMeshPathfindingBehavior",
              "type": "behavior"
            }
          ],
          "objectGroups": []
        },
        {
          "description": "the extra border size of the object.",
          "fullName": "Extra border size",
          "functionType": "ExpressionAndCondition",
          "group": "Pathfinding configuration (navigation mesh)",
          "name": "ExtraBorder",
          "sentence": "the extra border size",
          "events": [
            {
              "type": "BuiltinCommonInstructions::Standard",
              "conditions": [],
              "actions": [
                {
                  "type": {
                    "value": "SetReturnNumber"
                  },
                  "parameters": [
                    "Object.Behavior::PropertyExtraBorder()"
                  ]
                }
              ]
            }
          ],
          "expressionType": {
            "type": "expression"
          },
          "parameters": [
            {
              "description": "Object",
              "name": "Object",
              "type": "object"
            },
            {
              "description": "Behavior",
              "name": "Behavior",
              "supplementaryInformation": "NavMeshPathfinding::NavMeshPathfindingBehavior",
              "type": "behavior"
            }
          ],
          "objectGroups": []
        },
        {
          "fullName": "",
          "functionType": "ActionWithOperator",
          "getterName": "ExtraBorder",
          "name": "SetExtraBorder",
          "sentence": "",
          "events": [
            {
              "type": "BuiltinCommonInstructions::Standard",
              "conditions": [],
              "actions": [
                {
                  "type": {
                    "value": "NavMeshPathfinding::NavMeshPathfindingBehavior::SetPropertyExtraBorder"
                  },
                  "parameters": [
                    "Object",
                    "Behavior",
                    "=",
                    "GetArgumentAsNumber(\"Value\")"
                  ]
                }
              ]
            }
          ],
          "parameters": [
            {
              "description": "Object",
              "name": "Object",
              "type": "object"
            },
            {
              "description": "Behavior",
              "name": "Behavior",
              "supplementaryInformation": "NavMeshPathfinding::NavMeshPathfindingBehavior",
              "type": "behavior"
            }
          ],
          "objectGroups": []
        },
        {
          "description": "the collision shape of the object.",
          "fullName": "Collision shape",
          "functionType": "ExpressionAndCondition",
          "group": "Pathfinding configuration (navigation mesh)",
          "name": "CollisionShape",
          "sentence": "the collision shape",
          "events": [
            {
              "type": "BuiltinCommonInstructions::Standard",
              "conditions": [],
              "actions": [
                {
                  "type": {
                    "value": "SetReturnString"
                  },
                  "parameters": [
                    "Object.Behavior::PropertyCollisionShape()"
                  ]
                }
              ]
            }
          ],
          "expressionType": {
            "supplementaryInformation": "[\"Bounding disk\",\"Dot at center\"]",
            "type": "stringWithSelector"
          },
          "parameters": [
            {
              "description": "Object",
              "name": "Object",
              "type": "object"
            },
            {
              "description": "Behavior",
              "name": "Behavior",
              "supplementaryInformation": "NavMeshPathfinding::NavMeshPathfindingBehavior",
              "type": "behavior"
            }
          ],
          "objectGroups": []
        },
        {
          "fullName": "",
          "functionType": "ActionWithOperator",
          "getterName": "CollisionShape",
          "name": "SetCollisionShape",
          "sentence": "",
          "events": [
            {
              "type": "BuiltinCommonInstructions::Standard",
              "conditions": [],
              "actions": [
                {
                  "type": {
                    "value": "NavMeshPathfinding::NavMeshPathfindingBehavior::SetPropertyCollisionShape"
                  },
                  "parameters": [
                    "Object",
                    "Behavior",
                    "=",
                    "GetArgumentAsString(\"Value\")"
                  ]
                }
              ]
            }
          ],
          "parameters": [
            {
              "description": "Object",
              "name": "Object",
              "type": "object"
            },
            {
              "description": "Behavior",
              "name": "Behavior",
              "supplementaryInformation": "NavMeshPathfinding::NavMeshPathfindingBehavior",
              "type": "behavior"
            }
          ],
          "objectGroups": []
        },
        {
          "description": "Check if the object should rotate when following its path.",
          "fullName": "Rotate object",
          "functionType": "Condition",
          "group": "Pathfinding configuration (navigation mesh)",
          "name": "RotateObject",
          "sentence": "_PARAM0_ rotate when following its path",
          "events": [
            {
              "type": "BuiltinCommonInstructions::Standard",
              "conditions": [
                {
                  "type": {
                    "value": "NavMeshPathfinding::NavMeshPathfindingBehavior::PropertyRotateObject"
                  },
                  "parameters": [
                    "Object",
                    "Behavior"
                  ]
                }
              ],
              "actions": [
                {
                  "type": {
                    "value": "SetReturnBoolean"
                  },
                  "parameters": [
                    "True"
                  ]
                }
              ]
            }
          ],
          "parameters": [
            {
              "description": "Object",
              "name": "Object",
              "type": "object"
            },
            {
              "description": "Behavior",
              "name": "Behavior",
              "supplementaryInformation": "NavMeshPathfinding::NavMeshPathfindingBehavior",
              "type": "behavior"
            }
          ],
          "objectGroups": []
        },
        {
          "fullName": "",
          "functionType": "Action",
          "getterName": "RotateObject",
          "group": "Pathfinding configuration (navigation mesh)",
          "name": "SetRotateObject",
          "sentence": "",
          "events": [
            {
              "type": "BuiltinCommonInstructions::Standard",
              "conditions": [
                {
                  "type": {
                    "value": "GetArgumentAsBoolean"
                  },
                  "parameters": [
                    "\"Value\""
                  ]
                }
              ],
              "actions": [
                {
                  "type": {
                    "value": "NavMeshPathfinding::NavMeshPathfindingBehavior::SetPropertyRotateObject"
                  },
                  "parameters": [
                    "Object",
                    "Behavior",
                    "yes"
                  ]
                }
              ]
            },
            {
              "type": "BuiltinCommonInstructions::Standard",
              "conditions": [
                {
                  "type": {
                    "inverted": true,
                    "value": "GetArgumentAsBoolean"
                  },
                  "parameters": [
                    "\"Value\""
                  ]
                }
              ],
              "actions": [
                {
                  "type": {
                    "value": "NavMeshPathfinding::NavMeshPathfindingBehavior::SetPropertyRotateObject"
                  },
                  "parameters": [
                    "Object",
                    "Behavior",
                    "no"
                  ]
                }
              ]
            }
          ],
          "parameters": [
            {
              "description": "Object",
              "name": "Object",
              "type": "object"
            },
            {
              "description": "Behavior",
              "name": "Behavior",
              "supplementaryInformation": "NavMeshPathfinding::NavMeshPathfindingBehavior",
              "type": "behavior"
            },
            {
              "description": "Rotate object",
              "name": "Value",
              "type": "yesorno"
            }
          ],
          "objectGroups": []
        }
      ],
      "propertyDescriptors": [
        {
          "value": "400",
          "type": "Number",
          "label": "Acceleration",
          "description": "",
          "group": "",
          "extraInformation": [],
          "hidden": false,
          "name": "Acceleration"
        },
        {
          "value": "200",
          "type": "Number",
          "label": "Max. speed",
          "description": "",
          "group": "",
          "extraInformation": [],
          "hidden": false,
          "name": "MaxSpeed"
        },
        {
          "value": "180",
          "type": "Number",
          "label": "Rotate speed",
          "description": "",
          "group": "Rotation",
          "extraInformation": [],
          "hidden": false,
          "name": "AngularMaxSpeed"
        },
        {
          "value": "",
          "type": "Boolean",
          "label": "Rotate object",
          "description": "",
          "group": "Rotation",
          "extraInformation": [],
          "hidden": false,
          "name": "RotateObject"
        },
        {
          "value": "0",
          "type": "Number",
          "label": "Angle offset",
          "description": "",
          "group": "Rotation",
          "extraInformation": [],
          "hidden": false,
          "name": "AngleOffset"
        },
        {
          "value": "Bounding disk",
          "type": "Choice",
          "label": "Collision shape",
          "description": "",
          "group": "Collision",
          "extraInformation": [
            "Bounding disk",
            "Dot at center"
          ],
          "hidden": false,
          "name": "CollisionShape"
        },
        {
          "value": "0",
          "type": "Number",
          "label": "Extra border size",
          "description": "",
          "group": "Collision",
          "extraInformation": [],
          "hidden": false,
          "name": "ExtraBorder"
        }
      ],
      "sharedPropertyDescriptors": []
    },
    {
      "description": "Flag the object as being an obstacle for pathfinding.",
      "fullName": "Obstacle for pathfinding (navigation mesh, experimental)",
      "name": "NavMeshPathfindingObstacleBehavior",
      "objectType": "",
      "eventsFunctions": [
        {
          "fullName": "",
          "functionType": "Action",
          "name": "onCreated",
          "sentence": "",
          "events": [
            {
              "type": "BuiltinCommonInstructions::Comment",
              "color": {
                "b": 109,
                "g": 230,
                "r": 255,
                "textB": 0,
                "textG": 0,
                "textR": 0
              },
              "comment": "Initiate and attach properties as objects variables",
              "comment2": ""
            },
            {
              "type": "BuiltinCommonInstructions::Standard",
              "conditions": [],
              "actions": [
                {
                  "type": {
                    "value": "NavMeshPathfinding::DefineJavaScript"
                  },
                  "parameters": [
                    "",
                    ""
                  ]
                }
              ]
            },
            {
              "type": "BuiltinCommonInstructions::JsCode",
              "inlineCode": "const object = objects[0];\r\nconst behaviorName = eventsFunctionContext.getBehaviorName(\"Behavior\");\r\nconst behavior = object.getBehavior(behaviorName);\r\nbehavior.__NavMeshPathfinding = behavior.__NavMeshPathfinding || {};\r\nbehavior.__NavMeshPathfinding.obstacle =\r\n    new gdjs.__NavMeshPathfinding.NavMeshPathfindingObstacleBehavior(\r\n        runtimeScene, behavior);\r\n",
              "parameterObjects": "Object",
              "useStrict": true,
              "eventsSheetExpanded": true
            }
          ],
          "parameters": [
            {
              "description": "Object",
              "name": "Object",
              "type": "object"
            },
            {
              "description": "Behavior",
              "name": "Behavior",
              "supplementaryInformation": "NavMeshPathfinding::NavMeshPathfindingObstacleBehavior",
              "type": "behavior"
            }
          ],
          "objectGroups": []
        },
        {
          "fullName": "",
          "functionType": "Action",
          "name": "doStepPreEvents",
          "sentence": "",
          "events": [
            {
              "type": "BuiltinCommonInstructions::JsCode",
              "inlineCode": "const object = objects[0];\r\nconst behaviorName = eventsFunctionContext.getBehaviorName(\"Behavior\");\r\nconst behavior = object.getBehavior(behaviorName);\r\n\r\nbehavior.__NavMeshPathfinding.obstacle.doStepPreEvents(runtimeScene);",
              "parameterObjects": "Object",
              "useStrict": true,
              "eventsSheetExpanded": true
            }
          ],
          "parameters": [
            {
              "description": "Object",
              "name": "Object",
              "type": "object"
            },
            {
              "description": "Behavior",
              "name": "Behavior",
              "supplementaryInformation": "NavMeshPathfinding::NavMeshPathfindingObstacleBehavior",
              "type": "behavior"
            }
          ],
          "objectGroups": []
        },
        {
          "description": "the cell size for obstacle collision mask rasterization. While an object is needed, this will apply to all objects using the behavior.",
          "fullName": "Cell size",
          "functionType": "ExpressionAndCondition",
          "group": "Obstacle for pathfinding (navigation mesh, experimental)  configuration",
          "name": "CellSize",
          "sentence": "the cell size",
          "events": [
            {
              "type": "BuiltinCommonInstructions::Standard",
              "conditions": [],
              "actions": [
                {
                  "type": {
                    "value": "SetReturnNumber"
                  },
                  "parameters": [
                    "Object.Behavior::SharedPropertyCellSize()"
                  ]
                }
              ]
            }
          ],
          "expressionType": {
            "type": "expression"
          },
          "parameters": [
            {
              "description": "Object",
              "name": "Object",
              "type": "object"
            },
            {
              "description": "Behavior",
              "name": "Behavior",
              "supplementaryInformation": "NavMeshPathfinding::NavMeshPathfindingObstacleBehavior",
              "type": "behavior"
            }
          ],
          "objectGroups": []
        },
        {
          "fullName": "",
          "functionType": "ActionWithOperator",
          "getterName": "CellSize",
          "name": "SetCellSize",
          "sentence": "",
          "events": [
            {
              "type": "BuiltinCommonInstructions::Standard",
              "conditions": [],
              "actions": [
                {
                  "type": {
                    "value": "NavMeshPathfinding::NavMeshPathfindingObstacleBehavior::SetSharedPropertyCellSize"
                  },
                  "parameters": [
                    "Object",
                    "Behavior",
                    "=",
                    "GetArgumentAsNumber(\"Value\")"
                  ]
                },
                {
                  "type": {
                    "value": "NavMeshPathfinding::NavMeshPathfindingObstacleBehavior::InvalidateNavMesh"
                  },
                  "parameters": [
                    "Object",
                    "Behavior",
                    ""
                  ]
                }
              ]
            }
          ],
          "parameters": [
            {
              "description": "Object",
              "name": "Object",
              "type": "object"
            },
            {
              "description": "Behavior",
              "name": "Behavior",
              "supplementaryInformation": "NavMeshPathfinding::NavMeshPathfindingObstacleBehavior",
              "type": "behavior"
            }
          ],
          "objectGroups": []
        },
        {
          "description": "the area left bound. The left bound of the area where objects can go. While an object is needed, this will apply to all objects using the behavior.",
          "fullName": "Area left bound",
          "functionType": "ExpressionAndCondition",
          "group": "Obstacle for pathfinding (navigation mesh, experimental) configuration",
          "name": "AreaLeftBound",
          "sentence": "the area left bound",
          "events": [
            {
              "type": "BuiltinCommonInstructions::Standard",
              "conditions": [],
              "actions": [
                {
                  "type": {
                    "value": "SetReturnNumber"
                  },
                  "parameters": [
                    "Object.Behavior::SharedPropertyAreaLeftBound()"
                  ]
                }
              ]
            }
          ],
          "expressionType": {
            "type": "expression"
          },
          "parameters": [
            {
              "description": "Object",
              "name": "Object",
              "type": "object"
            },
            {
              "description": "Behavior",
              "name": "Behavior",
              "supplementaryInformation": "NavMeshPathfinding::NavMeshPathfindingObstacleBehavior",
              "type": "behavior"
            }
          ],
          "objectGroups": []
        },
        {
          "fullName": "",
          "functionType": "ActionWithOperator",
          "getterName": "AreaLeftBound",
          "name": "SetAreaLeftBound",
          "sentence": "",
          "events": [
            {
              "type": "BuiltinCommonInstructions::Standard",
              "conditions": [],
              "actions": [
                {
                  "type": {
                    "value": "NavMeshPathfinding::NavMeshPathfindingObstacleBehavior::SetSharedPropertyAreaLeftBound"
                  },
                  "parameters": [
                    "Object",
                    "Behavior",
                    "=",
                    "GetArgumentAsNumber(\"Value\")"
                  ]
                },
                {
                  "type": {
                    "value": "NavMeshPathfinding::NavMeshPathfindingObstacleBehavior::InvalidateNavMesh"
                  },
                  "parameters": [
                    "Object",
                    "Behavior",
                    ""
                  ]
                }
              ]
            }
          ],
          "parameters": [
            {
              "description": "Object",
              "name": "Object",
              "type": "object"
            },
            {
              "description": "Behavior",
              "name": "Behavior",
              "supplementaryInformation": "NavMeshPathfinding::NavMeshPathfindingObstacleBehavior",
              "type": "behavior"
            }
          ],
          "objectGroups": []
        },
        {
          "description": "the area top bound. The top bound of the area where objects can go. While an object is needed, this will apply to all objects using the behavior.",
          "fullName": "Area top bound",
          "functionType": "ExpressionAndCondition",
          "group": "Obstacle for pathfinding (navigation mesh, experimental) configuration",
          "name": "AreaTopBound",
          "sentence": "the area top bound",
          "events": [
            {
              "type": "BuiltinCommonInstructions::Standard",
              "conditions": [],
              "actions": [
                {
                  "type": {
                    "value": "SetReturnNumber"
                  },
                  "parameters": [
                    "Object.Behavior::SharedPropertyAreaTopBound()"
                  ]
                }
              ]
            }
          ],
          "expressionType": {
            "type": "expression"
          },
          "parameters": [
            {
              "description": "Object",
              "name": "Object",
              "type": "object"
            },
            {
              "description": "Behavior",
              "name": "Behavior",
              "supplementaryInformation": "NavMeshPathfinding::NavMeshPathfindingObstacleBehavior",
              "type": "behavior"
            }
          ],
          "objectGroups": []
        },
        {
          "fullName": "",
          "functionType": "ActionWithOperator",
          "getterName": "AreaTopBound",
          "name": "SetAreaTopBound",
          "sentence": "",
          "events": [
            {
              "type": "BuiltinCommonInstructions::Standard",
              "conditions": [],
              "actions": [
                {
                  "type": {
                    "value": "NavMeshPathfinding::NavMeshPathfindingObstacleBehavior::SetSharedPropertyAreaTopBound"
                  },
                  "parameters": [
                    "Object",
                    "Behavior",
                    "=",
                    "GetArgumentAsNumber(\"Value\")"
                  ]
                },
                {
                  "type": {
                    "value": "NavMeshPathfinding::NavMeshPathfindingObstacleBehavior::InvalidateNavMesh"
                  },
                  "parameters": [
                    "Object",
                    "Behavior",
                    ""
                  ]
                }
              ]
            }
          ],
          "parameters": [
            {
              "description": "Object",
              "name": "Object",
              "type": "object"
            },
            {
              "description": "Behavior",
              "name": "Behavior",
              "supplementaryInformation": "NavMeshPathfinding::NavMeshPathfindingObstacleBehavior",
              "type": "behavior"
            }
          ],
          "objectGroups": []
        },
        {
          "description": "the area right bound. The right bound of the area where objects can go (default to the game resolution). While an object is needed, this will apply to all objects using the behavior.",
          "fullName": "Area right bound",
          "functionType": "ExpressionAndCondition",
          "group": "Obstacle for pathfinding (navigation mesh, experimental) configuration",
          "name": "AreaRightBound",
          "sentence": "the area right bound",
          "events": [
            {
              "type": "BuiltinCommonInstructions::Standard",
              "conditions": [],
              "actions": [
                {
                  "type": {
                    "value": "SetReturnNumber"
                  },
                  "parameters": [
                    "Object.Behavior::SharedPropertyAreaRightBound()"
                  ]
                }
              ]
            }
          ],
          "expressionType": {
            "type": "expression"
          },
          "parameters": [
            {
              "description": "Object",
              "name": "Object",
              "type": "object"
            },
            {
              "description": "Behavior",
              "name": "Behavior",
              "supplementaryInformation": "NavMeshPathfinding::NavMeshPathfindingObstacleBehavior",
              "type": "behavior"
            }
          ],
          "objectGroups": []
        },
        {
          "fullName": "",
          "functionType": "ActionWithOperator",
          "getterName": "AreaRightBound",
          "name": "SetAreaRightBound",
          "sentence": "",
          "events": [
            {
              "type": "BuiltinCommonInstructions::Standard",
              "conditions": [],
              "actions": [
                {
                  "type": {
                    "value": "NavMeshPathfinding::NavMeshPathfindingObstacleBehavior::SetSharedPropertyAreaRightBound"
                  },
                  "parameters": [
                    "Object",
                    "Behavior",
                    "=",
                    "GetArgumentAsNumber(\"Value\")"
                  ]
                },
                {
                  "type": {
                    "value": "NavMeshPathfinding::NavMeshPathfindingObstacleBehavior::InvalidateNavMesh"
                  },
                  "parameters": [
                    "Object",
                    "Behavior",
                    ""
                  ]
                }
              ]
            }
          ],
          "parameters": [
            {
              "description": "Object",
              "name": "Object",
              "type": "object"
            },
            {
              "description": "Behavior",
              "name": "Behavior",
              "supplementaryInformation": "NavMeshPathfinding::NavMeshPathfindingObstacleBehavior",
              "type": "behavior"
            }
          ],
          "objectGroups": []
        },
        {
          "description": "the area bottom bound. The bottom bound of the area where objects can go (default to the game resolution). While an object is needed, this will apply to all objects using the behavior.",
          "fullName": "Area bottom bound",
          "functionType": "ExpressionAndCondition",
          "group": "Obstacle for pathfinding (navigation mesh, experimental) configuration",
          "name": "AreaBottomBound",
          "sentence": "the area bottom bound",
          "events": [
            {
              "type": "BuiltinCommonInstructions::Standard",
              "conditions": [],
              "actions": [
                {
                  "type": {
                    "value": "SetReturnNumber"
                  },
                  "parameters": [
                    "Object.Behavior::SharedPropertyAreaBottomBound()"
                  ]
                }
              ]
            }
          ],
          "expressionType": {
            "type": "expression"
          },
          "parameters": [
            {
              "description": "Object",
              "name": "Object",
              "type": "object"
            },
            {
              "description": "Behavior",
              "name": "Behavior",
              "supplementaryInformation": "NavMeshPathfinding::NavMeshPathfindingObstacleBehavior",
              "type": "behavior"
            }
          ],
          "objectGroups": []
        },
        {
          "fullName": "",
          "functionType": "ActionWithOperator",
          "getterName": "AreaBottomBound",
          "name": "SetAreaBottomBound",
          "sentence": "",
          "events": [
            {
              "type": "BuiltinCommonInstructions::Standard",
              "conditions": [],
              "actions": [
                {
                  "type": {
                    "value": "NavMeshPathfinding::NavMeshPathfindingObstacleBehavior::SetSharedPropertyAreaBottomBound"
                  },
                  "parameters": [
                    "Object",
                    "Behavior",
                    "=",
                    "GetArgumentAsNumber(\"Value\")"
                  ]
                },
                {
                  "type": {
                    "value": "NavMeshPathfinding::NavMeshPathfindingObstacleBehavior::InvalidateNavMesh"
                  },
                  "parameters": [
                    "Object",
                    "Behavior",
                    ""
                  ]
                }
              ]
            }
          ],
          "parameters": [
            {
              "description": "Object",
              "name": "Object",
              "type": "object"
            },
            {
              "description": "Behavior",
              "name": "Behavior",
              "supplementaryInformation": "NavMeshPathfinding::NavMeshPathfindingObstacleBehavior",
              "type": "behavior"
            }
          ],
          "objectGroups": []
        },
        {
          "description": "Invalidate navigation mesh.",
          "fullName": "Invalidate navigation mesh",
          "functionType": "Action",
          "name": "InvalidateNavMesh",
          "private": true,
          "sentence": "Invalidate navigation mesh",
          "events": [
            {
              "type": "BuiltinCommonInstructions::JsCode",
              "inlineCode": "const object = objects[0];\nconst behaviorName = eventsFunctionContext.getBehaviorName(\"Behavior\");\nconst behavior = object.getBehavior(behaviorName);\n\neventsFunctionContext.returnValue = behavior.__NavMeshPathfinding.obstacle._manager.invalidateNavMesh();\n",
              "parameterObjects": "Object",
              "useStrict": true,
              "eventsSheetExpanded": false
            }
          ],
          "parameters": [
            {
              "description": "Object",
              "name": "Object",
              "type": "object"
            },
            {
              "description": "Behavior",
              "name": "Behavior",
              "supplementaryInformation": "NavMeshPathfinding::NavMeshPathfindingObstacleBehavior",
              "type": "behavior"
            }
          ],
          "objectGroups": []
        }
      ],
      "propertyDescriptors": [],
      "sharedPropertyDescriptors": [
        {
          "value": "Top-Down",
          "type": "Choice",
          "label": "Viewpoint",
          "description": "",
          "group": "",
          "extraInformation": [
            "Top-Down",
            "Isometry 2:1 (26.565°)",
            "True Isometry (30°)"
          ],
          "hidden": false,
          "name": "Viewpoint"
        },
        {
          "value": "10",
          "type": "Number",
          "label": "Cell size",
          "description": "Cell size for obstacle collision mask rasterization.",
          "group": "",
          "extraInformation": [],
          "hidden": false,
          "name": "CellSize"
        },
        {
          "value": "",
          "type": "Number",
          "label": "Area left bound",
          "description": "The left bound of the area where objects can go.",
          "group": "",
          "extraInformation": [],
          "hidden": false,
          "name": "AreaLeftBound"
        },
        {
          "value": "",
          "type": "Number",
          "label": "Area top bound",
          "description": "The top bound of the area where objects can go.",
          "group": "",
          "extraInformation": [],
          "hidden": false,
          "name": "AreaTopBound"
        },
        {
          "value": "",
          "type": "Number",
          "label": "Area right bound",
          "description": "The right bound of the area where objects can go (default to the game resolution).",
          "group": "",
          "extraInformation": [],
          "hidden": false,
          "name": "AreaRightBound"
        },
        {
          "value": "",
          "type": "Number",
          "label": "Area bottom bound",
          "description": "The bottom bound of the area where objects can go (default to the game resolution).",
          "group": "",
          "extraInformation": [],
          "hidden": false,
          "name": "AreaBottomBound"
        },
        {
          "value": "",
          "type": "Number",
          "label": "",
          "description": "",
          "group": "",
          "extraInformation": [],
          "hidden": true,
          "name": "IsometricRatio"
        }
      ]
    }
  ],
  "eventsBasedObjects": []
}