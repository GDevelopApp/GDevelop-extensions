{
  "author": "",
  "category": "Game mechanic",
  "extensionNamespace": "",
  "fullName": "Ink Dialog Tree",
  "helpPath": "https://github.com/inkle/ink/blob/master/Documentation/WritingWithInk.md",
  "iconUrl": "data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0idXRmLTgiPz4NCjwhLS0gR2VuZXJhdG9yOiBBZG9iZSBJbGx1c3RyYXRvciAyMy4wLjMsIFNWRyBFeHBvcnQgUGx1Zy1JbiAuIFNWRyBWZXJzaW9uOiA2LjAwIEJ1aWxkIDApICAtLT4NCjxzdmcgdmVyc2lvbj0iMS4xIiBpZD0iSWNvbnMiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgeG1sbnM6eGxpbms9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmsiIHg9IjBweCIgeT0iMHB4Ig0KCSB2aWV3Qm94PSIwIDAgMzIgMzIiIHN0eWxlPSJlbmFibGUtYmFja2dyb3VuZDpuZXcgMCAwIDMyIDMyOyIgeG1sOnNwYWNlPSJwcmVzZXJ2ZSI+DQo8c3R5bGUgdHlwZT0idGV4dC9jc3MiPg0KCS5zdDB7ZmlsbDpub25lO3N0cm9rZTojMDAwMDAwO3N0cm9rZS13aWR0aDoyO3N0cm9rZS1saW5lY2FwOnJvdW5kO3N0cm9rZS1saW5lam9pbjpyb3VuZDtzdHJva2UtbWl0ZXJsaW1pdDoxMDt9DQo8L3N0eWxlPg0KPHBhdGggY2xhc3M9InN0MCIgZD0iTTE2LDI4VjdjMC0xLjctMS4zLTMtMy0zSDJ2MjFoMTFDMTQuNywyNSwxNiwyNi4zLDE2LDI4TDE2LDI4Ii8+DQo8cGF0aCBjbGFzcz0ic3QwIiBkPSJNMTYsMjhWN2MwLTEuNywxLjMtMywzLTNoMTF2MjFIMTlDMTcuMywyNSwxNiwyNi4zLDE2LDI4TDE2LDI4Ii8+DQo8cG9seWxpbmUgY2xhc3M9InN0MCIgcG9pbnRzPSIyLDI1IDIsMjkgMTYsMjkgIi8+DQo8cG9seWxpbmUgY2xhc3M9InN0MCIgcG9pbnRzPSIzMCwyNSAzMCwyOSAxNiwyOSAiLz4NCjwvc3ZnPg0K",
  "name": "InkJS",
  "previewIconUrl": "https://asset-resources.gdevelop.io/public-resources/Icons/Line Hero Pack/Master/SVG/Education and Learning/ee949224f4dd4fa7a0c1b17879f4fde192fe97bf4b419c72a5e4ea6d3e747327_Education and Learning_education_book_open_reading.svg",
  "shortDescription": "Support for Ink writing system.",
  "version": "1.0.0",
  "description": [
    "Ink is a non-linear writing technique created by Inkle.",
    "It helps you to write rich stories where the player can choose where to go.",
    "Export your story from Inky (the writing software) and import it directly to GDevelop.",
    "This extension supports all the major features : ",
    "- Load a JSON story",
    "- Read dialogs and choices",
    "- Read any tag (global, knot, line and choice)",
    "- Catch external events and call internal functions",
    "- Observe variables",
    "- Save history and snapshot",
    "",
    "This extension does not support: ",
    "- Multiple flows (beta)",
    "- Partial list support"
  ],
  "tags": [
    "ink",
    "writing",
    "story",
    "narrative",
    "dialog"
  ],
  "authorIds": [
    "vJeYciaE9tW37HzSPOyo9MLOI5E3"
  ],
  "dependencies": [],
  "eventsFunctions": [
    {
      "fullName": "",
      "functionType": "Action",
      "name": "onFirstSceneLoaded",
      "sentence": "",
      "events": [
        {
          "type": "BuiltinCommonInstructions::Standard",
          "conditions": [],
          "actions": [
            {
              "type": {
                "value": "InkJS::LoadLib"
              },
              "parameters": [
                "",
                ""
              ]
            }
          ]
        }
      ],
      "parameters": [],
      "objectGroups": []
    },
    {
      "fullName": "",
      "functionType": "Action",
      "name": "onScenePreEvents",
      "sentence": "",
      "events": [
        {
          "type": "BuiltinCommonInstructions::JsCode",
          "inlineCode": [
            "if (gdjs._InkJS && gdjs._InkJS.stories)",
            "{",
            "",
            "var keys = Object.keys(gdjs._InkJS.stories);",
            "",
            "keys.forEach(function(elm) {",
            "    gdjs._InkJS.stories[elm].ClearBindValues();",
            "});",
            "",
            "}",
            ""
          ],
          "parameterObjects": "",
          "useStrict": true,
          "eventsSheetExpanded": false
        }
      ],
      "parameters": [],
      "objectGroups": []
    },
    {
      "description": "Load the InkJS library inside GDevelop.",
      "fullName": "Load InkJS library",
      "functionType": "Action",
      "name": "LoadLib",
      "private": true,
      "sentence": "Load Inkjs lib",
      "events": [
        {
          "type": "BuiltinCommonInstructions::Comment",
          "color": {
            "b": 109,
            "g": 230,
            "r": 255,
            "textB": 0,
            "textG": 0,
            "textR": 0
          },
          "comment": "Useful classes"
        },
        {
          "type": "BuiltinCommonInstructions::JsCode",
          "inlineCode": [
            "let story = class GDStory",
            "{",
            "    constructor(storyObj)",
            "    {",
            "        this.story = storyObj;",
            "        this.currentText = null;",
            "        this.observers = {};",
            "        this.listeners = {};",
            "        this.evals = {};",
            "        this.history = null;",
            "        this.lastSavedState = null;",
            "",
            "        storyObj.onError = function(e)",
            "        {",
            "            console.error(e);",
            "        }",
            "    }",
            "",
            "    Next()",
            "    {",
            "        this.currentText = this.story.Continue();",
            "    }",
            "",
            "    BindVariable(v)",
            "    {",
            "        let t = this;",
            "        this.story.ObserveVariable(v, function(n, val) {",
            "            t.observers[n] = val;",
            "        });",
            "    }",
            "",
            "    BindExternalFunction(evt)",
            "    {",
            "        let t = this;",
            "        this.story.BindExternalFunction(evt, function() {",
            "            t.listeners[evt] = arguments;",
            "        });",
            "    }",
            "",
            "    BindAndConnectVariable(v, scn)",
            "    {",
            "        let t = this;",
            "        this.story.ObserveVariable(v, function(n, val) {",
            "            t.observers[n] = val;",
            "            scn.setValue(val);",
            "        });",
            "    }",
            "",
            "    AddMethodParameter(method, val)",
            "    {",
            "        if (!this.evals[method])",
            "        this.evals[method] = [];",
            "",
            "        this.evals[method].push(val);",
            "    }",
            "",
            "    CallMethod(method, ret, content)",
            "    {",
            "        let out = this.story.EvaluateFunction(method, this.evals[method], true);",
            "",
            "        if (ret && out.returned != undefined)",
            "            ret.setValue(out.returned);",
            "",
            "        if (content && out.output != undefined)",
            "            content.setValue(out.output);",
            "",
            "        this.evals[method] = null;",
            "        ",
            "        return out.returned;",
            "    }",
            "",
            "    EvaluateMethod(method, output)",
            "    {",
            "        let out = this.story.EvaluateFunction(method, this.evals[method], true);",
            "",
            "        this.evals[method] = null;",
            "        ",
            "        if (!output)",
            "            return out.returned;",
            "        else",
            "            return out.output;",
            "    }",
            "",
            "    ClearBindValues()",
            "    {",
            "        this.observers = {};",
            "        this.listeners = {};",
            "        this.evals = {};",
            "    }",
            "",
            "    SetHistory(scn)",
            "    {",
            "        if (this.history && !scn)",
            "        {",
            "            this.history.clearChildren();",
            "            this.lastSavedState = null;",
            "        }",
            "",
            "        this.history = scn;",
            "",
            "        if (scn)",
            "        {",
            "            this.history.clearChildren();",
            "            this.SaveHistory();",
            "        }",
            "    }",
            "",
            "    SaveHistory()",
            "    {",
            "        if (!this.history)",
            "            return;",
            "",
            "        if (this.lastSavedState != null)",
            "            this.history.pushValue(this.lastSavedState);",
            "",
            "        this.lastSavedState = this.story.state.ToJson();",
            "",
            "    }",
            "",
            "    Rewind()",
            "    {",
            "        if (!this.history)",
            "            return;",
            "        ",
            "        if (this.history.getChildrenCount() == 0)",
            "        {",
            "            this.story.ResetState();",
            "            return;",
            "        }",
            "",
            "        let idx = this.history.getChildrenCount()-1;",
            "        let json = this.history.getChildAt(idx).getValue();",
            "        this.history.removeAtIndex(idx);",
            "",
            "        this.story.state.LoadJson(json);",
            "    }",
            "}",
            "",
            "gdjs._InkJS = {GDStory:story, stories:{}};"
          ],
          "parameterObjects": "",
          "useStrict": true,
          "eventsSheetExpanded": true
        },
        {
          "type": "BuiltinCommonInstructions::Comment",
          "color": {
            "b": 109,
            "g": 230,
            "r": 255,
            "textB": 0,
            "textG": 0,
            "textR": 0
          },
          "comment": "InkJS file"
        },
        {
          "type": "BuiltinCommonInstructions::JsCode",
          "inlineCode": [
            "(function (global, factory) {",
            "  typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :",
            "  typeof define === 'function' && define.amd ? define(['exports'], factory) :",
            "  (global = typeof globalThis !== 'undefined' ? globalThis : global || self, factory(global.inkjs = {}));",
            "})(this, (function (exports) { 'use strict';",
            "",
            "  class CompilerOptions {",
            "    constructor() {",
            "      let sourceFilename = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;",
            "      let pluginNames = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];",
            "      let countAllVisits = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;",
            "      let errorHandler = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;",
            "      let fileHandler = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : null;",
            "      this.sourceFilename = sourceFilename;",
            "      this.pluginNames = pluginNames;",
            "      this.countAllVisits = countAllVisits;",
            "      this.errorHandler = errorHandler;",
            "      this.fileHandler = fileHandler;",
            "    }",
            "  }",
            "",
            "  class DebugSourceRange {",
            "    constructor(length, debugMetadata, text) {",
            "      this.length = length;",
            "      this.debugMetadata = debugMetadata;",
            "      this.text = text;",
            "    }",
            "  }",
            "",
            "  // TODO: Unifify with Engine.",
            "  var ErrorType$1;",
            "  (function (ErrorType) {",
            "    ErrorType[ErrorType[\"Author\"] = 0] = \"Author\";",
            "    ErrorType[ErrorType[\"Warning\"] = 1] = \"Warning\";",
            "    ErrorType[ErrorType[\"Error\"] = 2] = \"Error\";",
            "  })(ErrorType$1 || (ErrorType$1 = {}));",
            "",
            "  class Argument {",
            "    constructor() {",
            "      let identifier = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;",
            "      let isByReference = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;",
            "      let isDivertTarget = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;",
            "      this.identifier = identifier;",
            "      this.isByReference = isByReference;",
            "      this.isDivertTarget = isDivertTarget;",
            "    }",
            "    get typeName() {",
            "      return \"Argument\";",
            "    }",
            "  }",
            "",
            "  function asOrNull(obj, type) {",
            "    if (obj instanceof type) {",
            "      return unsafeTypeAssertion(obj);",
            "    } else {",
            "      return null;",
            "    }",
            "  }",
            "  function asOrThrows(obj, type) {",
            "    if (obj instanceof type) {",
            "      return unsafeTypeAssertion(obj);",
            "    } else {",
            "      throw new Error(`${obj} is not of type ${type}`);",
            "    }",
            "  }",
            "  function asBooleanOrThrows(obj) {",
            "    if (typeof obj === \"boolean\") {",
            "      return obj;",
            "    } else {",
            "      throw new Error(`${obj} is not a boolean`);",
            "    }",
            "  }",
            "  // So here, in the reference implementation, contentObj is casted to an INamedContent",
            "  // but here we use js-style duck typing: if it implements the same props as the interface,",
            "  // we treat it as valid.",
            "  function asINamedContentOrNull(obj) {",
            "    if (obj.hasValidName && obj.name) {",
            "      return obj;",
            "    }",
            "    return null;",
            "  }",
            "  function nullIfUndefined(obj) {",
            "    if (typeof obj === \"undefined\") {",
            "      return null;",
            "    }",
            "    return obj;",
            "  }",
            "  function isEquatable(type) {",
            "    return typeof type === \"object\" && typeof type.Equals === \"function\";",
            "  }",
            "  function unsafeTypeAssertion(obj, type) {",
            "    return obj;",
            "  }",
            "  function filterUndef(element) {",
            "    return element != undefined;",
            "  }",
            "",
            "  class ParsedObject {",
            "    constructor() {",
            "      var _this = this;",
            "      this._alreadyHadError = false;",
            "      this._alreadyHadWarning = false;",
            "      this._debugMetadata = null;",
            "      this._runtimeObject = null;",
            "      this.content = [];",
            "      this.parent = null;",
            "      this.GetType = () => this.typeName;",
            "      /*",
            "      get descriptionOfScope(): string {",
            "        const locationNames: string[] = [];",
            "                let ancestor: ParsedObject | null = this;",
            "        while (ancestor) {",
            "          var ancestorFlow = ancestor as FlowBase;",
            "          if (ancestorFlow && ancestorFlow.name != null) {",
            "            locationNames.push(`'${ancestorFlow.name}'`);",
            "          }",
            "          ancestor = ancestor.parent;",
            "        }",
            "                let scopeSB = '';",
            "        if (locationNames.length > 0) {",
            "          const locationsListStr = locationNames.join(', ');",
            "          scopeSB += `${locationsListStr} and`;",
            "        }",
            "                scopeSB += 'at top scope';",
            "                return scopeSB;",
            "      }",
            "      */",
            "      // Return the object so that method can be chained easily",
            "      this.AddContent = subContent => {",
            "        if (this.content === null) {",
            "          this.content = [];",
            "        }",
            "        const sub = Array.isArray(subContent) ? subContent : [subContent];",
            "        // Make resilient to content not existing, which can happen",
            "        // in the case of parse errors where we've already reported",
            "        // an error but still want a valid structure so we can",
            "        // carry on parsing.",
            "        for (const ss of sub) {",
            "          if (ss.hasOwnProperty(\"parent\")) {",
            "            ss.parent = this;",
            "          }",
            "          this.content.push(ss);",
            "        }",
            "        if (Array.isArray(subContent)) {",
            "          return;",
            "        } else {",
            "          return subContent;",
            "        }",
            "      };",
            "      this.InsertContent = (index, subContent) => {",
            "        if (this.content === null) {",
            "          this.content = [];",
            "        }",
            "        subContent.parent = this;",
            "        this.content.splice(index, 0, subContent);",
            "        return subContent;",
            "      };",
            "      this.Find = type => function () {",
            "        let queryFunc = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;",
            "        let tObj = asOrNull(_this, type);",
            "        if (tObj !== null && (queryFunc === null || queryFunc(tObj) === true)) {",
            "          return tObj;",
            "        }",
            "        if (_this.content === null) {",
            "          return null;",
            "        }",
            "        for (const obj of _this.content) {",
            "          let nestedResult = obj.Find && obj.Find(type)(queryFunc);",
            "          if (nestedResult) {",
            "            return nestedResult;",
            "          }",
            "        }",
            "        return null;",
            "      };",
            "      this.FindAll = type => (queryFunc, foundSoFar) => {",
            "        const found = Array.isArray(foundSoFar) ? foundSoFar : [];",
            "        const tObj = asOrNull(this, type);",
            "        if (tObj !== null && (!queryFunc || queryFunc(tObj) === true)) {",
            "          found.push(tObj);",
            "        }",
            "        if (this.content === null) {",
            "          return [];",
            "        }",
            "        for (const obj of this.content) {",
            "          obj.FindAll && obj.FindAll(type)(queryFunc, found);",
            "        }",
            "        return found;",
            "      };",
            "      this.Warning = function (message) {",
            "        let source = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;",
            "        _this.Error(message, source, true);",
            "      };",
            "    }",
            "    get debugMetadata() {",
            "      if (this._debugMetadata === null && this.parent) {",
            "        return this.parent.debugMetadata;",
            "      }",
            "      return this._debugMetadata;",
            "    }",
            "    set debugMetadata(value) {",
            "      this._debugMetadata = value;",
            "    }",
            "    get hasOwnDebugMetadata() {",
            "      return Boolean(this.debugMetadata);",
            "    }",
            "    get typeName() {",
            "      return \"ParsedObject\";",
            "    }",
            "    get story() {",
            "      let ancestor = this;",
            "      while (ancestor.parent) {",
            "        ancestor = ancestor.parent;",
            "      }",
            "      return ancestor;",
            "    }",
            "    get runtimeObject() {",
            "      if (!this._runtimeObject) {",
            "        this._runtimeObject = this.GenerateRuntimeObject();",
            "        if (this._runtimeObject) {",
            "          this._runtimeObject.debugMetadata = this.debugMetadata;",
            "        }",
            "      }",
            "      return this._runtimeObject;",
            "    }",
            "    set runtimeObject(value) {",
            "      this._runtimeObject = value;",
            "    }",
            "    get runtimePath() {",
            "      if (!this.runtimeObject.path) {",
            "        throw new Error();",
            "      }",
            "      return this.runtimeObject.path;",
            "    }",
            "    // When counting visits and turns since, different object",
            "    // types may have different containers that needs to be counted.",
            "    // For most it'll just be the object's main runtime object,",
            "    // but for e.g. choices, it'll be the target container.",
            "    get containerForCounting() {",
            "      return this.runtimeObject;",
            "    }",
            "    get ancestry() {",
            "      let result = [];",
            "      let ancestor = this.parent;",
            "      while (ancestor) {",
            "        result.push(ancestor);",
            "        ancestor = ancestor.parent;",
            "      }",
            "      result = result.reverse();",
            "      return result;",
            "    }",
            "    ResolveReferences(context) {",
            "      if (this.content !== null) {",
            "        for (const obj of this.content) {",
            "          obj.ResolveReferences(context);",
            "        }",
            "      }",
            "    }",
            "    Error(message) {",
            "      let source = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;",
            "      let isWarning = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;",
            "      if (source === null) {",
            "        source = this;",
            "      }",
            "      // Only allow a single parsed object to have a single error *directly* associated with it",
            "      if (source._alreadyHadError && !isWarning || source._alreadyHadWarning && isWarning) {",
            "        return;",
            "      }",
            "      if (this.parent) {",
            "        this.parent.Error(message, source, isWarning);",
            "      } else {",
            "        throw new Error(`No parent object to send error to: ${message}`);",
            "      }",
            "      if (isWarning) {",
            "        source._alreadyHadWarning = true;",
            "      } else {",
            "        source._alreadyHadError = true;",
            "      }",
            "    }",
            "  }",
            "",
            "  class AuthorWarning extends ParsedObject {",
            "    constructor(warningMessage) {",
            "      super();",
            "      this.warningMessage = warningMessage;",
            "      this.GenerateRuntimeObject = () => {",
            "        this.Warning(this.warningMessage);",
            "        return null;",
            "      };",
            "    }",
            "    get typeName() {",
            "      return \"AuthorWarning\";",
            "    }",
            "  }",
            "",
            "  class Path$1 {",
            "    constructor() {",
            "      this._components = [];",
            "      this._componentsString = null;",
            "      this._isRelative = false;",
            "      if (typeof arguments[0] == \"string\") {",
            "        let componentsString = arguments[0];",
            "        this.componentsString = componentsString;",
            "      } else if (arguments[0] instanceof Path$1.Component && arguments[1] instanceof Path$1) {",
            "        let head = arguments[0];",
            "        let tail = arguments[1];",
            "        this._components.push(head);",
            "        this._components = this._components.concat(tail._components);",
            "      } else if (arguments[0] instanceof Array) {",
            "        let head = arguments[0];",
            "        let relative = !!arguments[1];",
            "        this._components = this._components.concat(head);",
            "        this._isRelative = relative;",
            "      }",
            "    }",
            "    get isRelative() {",
            "      return this._isRelative;",
            "    }",
            "    get componentCount() {",
            "      return this._components.length;",
            "    }",
            "    get head() {",
            "      if (this._components.length > 0) {",
            "        return this._components[0];",
            "      } else {",
            "        return null;",
            "      }",
            "    }",
            "    get tail() {",
            "      if (this._components.length >= 2) {",
            "        // careful, the original code uses length-1 here. This is because the second argument of",
            "        // List.GetRange is a number of elements to extract, wherease Array.slice uses an index",
            "        let tailComps = this._components.slice(1, this._components.length);",
            "        return new Path$1(tailComps);",
            "      } else {",
            "        return Path$1.self;",
            "      }",
            "    }",
            "    get length() {",
            "      return this._components.length;",
            "    }",
            "    get lastComponent() {",
            "      let lastComponentIdx = this._components.length - 1;",
            "      if (lastComponentIdx >= 0) {",
            "        return this._components[lastComponentIdx];",
            "      } else {",
            "        return null;",
            "      }",
            "    }",
            "    get containsNamedComponent() {",
            "      for (let i = 0, l = this._components.length; i < l; i++) {",
            "        if (!this._components[i].isIndex) {",
            "          return true;",
            "        }",
            "      }",
            "      return false;",
            "    }",
            "    static get self() {",
            "      let path = new Path$1();",
            "      path._isRelative = true;",
            "      return path;",
            "    }",
            "    GetComponent(index) {",
            "      return this._components[index];",
            "    }",
            "    PathByAppendingPath(pathToAppend) {",
            "      let p = new Path$1();",
            "      let upwardMoves = 0;",
            "      for (let i = 0; i < pathToAppend._components.length; ++i) {",
            "        if (pathToAppend._components[i].isParent) {",
            "          upwardMoves++;",
            "        } else {",
            "          break;",
            "        }",
            "      }",
            "      for (let i = 0; i < this._components.length - upwardMoves; ++i) {",
            "        p._components.push(this._components[i]);",
            "      }",
            "      for (let i = upwardMoves; i < pathToAppend._components.length; ++i) {",
            "        p._components.push(pathToAppend._components[i]);",
            "      }",
            "      return p;",
            "    }",
            "    get componentsString() {",
            "      if (this._componentsString == null) {",
            "        this._componentsString = this._components.join(\".\");",
            "        if (this.isRelative) this._componentsString = \".\" + this._componentsString;",
            "      }",
            "      return this._componentsString;",
            "    }",
            "    set componentsString(value) {",
            "      this._components.length = 0;",
            "      this._componentsString = value;",
            "      if (this._componentsString == null || this._componentsString == \"\") return;",
            "      if (this._componentsString[0] == \".\") {",
            "        this._isRelative = true;",
            "        this._componentsString = this._componentsString.substring(1);",
            "      }",
            "      let componentStrings = this._componentsString.split(\".\");",
            "      for (let str of componentStrings) {",
            "        // we need to distinguish between named components that start with a number, eg \"42somewhere\", and indexed components",
            "        // the normal parseInt won't do for the detection because it's too relaxed.",
            "        // see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/parseInt",
            "        if (/^(\\-|\\+)?([0-9]+|Infinity)$/.test(str)) {",
            "          this._components.push(new Path$1.Component(parseInt(str)));",
            "        } else {",
            "          this._components.push(new Path$1.Component(str));",
            "        }",
            "      }",
            "    }",
            "    toString() {",
            "      return this.componentsString;",
            "    }",
            "    Equals(otherPath) {",
            "      if (otherPath == null) return false;",
            "      if (otherPath._components.length != this._components.length) return false;",
            "      if (otherPath.isRelative != this.isRelative) return false;",
            "      // the original code uses SequenceEqual here, so we need to iterate over the components manually.",
            "      for (let i = 0, l = otherPath._components.length; i < l; i++) {",
            "        // it's not quite clear whether this test should use Equals or a simple == operator,",
            "        // see https://github.com/y-lohse/inkjs/issues/22",
            "        if (!otherPath._components[i].Equals(this._components[i])) return false;",
            "      }",
            "      return true;",
            "    }",
            "    PathByAppendingComponent(c) {",
            "      let p = new Path$1();",
            "      p._components.push(...this._components);",
            "      p._components.push(c);",
            "      return p;",
            "    }",
            "  }",
            "  Path$1.parentId = \"^\";",
            "  (function (Path) {",
            "    class Component {",
            "      constructor(indexOrName) {",
            "        this.index = -1;",
            "        this.name = null;",
            "        if (typeof indexOrName == \"string\") {",
            "          this.name = indexOrName;",
            "        } else {",
            "          this.index = indexOrName;",
            "        }",
            "      }",
            "      get isIndex() {",
            "        return this.index >= 0;",
            "      }",
            "      get isParent() {",
            "        return this.name == Path.parentId;",
            "      }",
            "      static ToParent() {",
            "        return new Component(Path.parentId);",
            "      }",
            "      toString() {",
            "        if (this.isIndex) {",
            "          return this.index.toString();",
            "        } else {",
            "          return this.name;",
            "        }",
            "      }",
            "      Equals(otherComp) {",
            "        if (otherComp != null && otherComp.isIndex == this.isIndex) {",
            "          if (this.isIndex) {",
            "            return this.index == otherComp.index;",
            "          } else {",
            "            return this.name == otherComp.name;",
            "          }",
            "        }",
            "        return false;",
            "      }",
            "    }",
            "    Path.Component = Component;",
            "  })(Path$1 || (Path$1 = {}));",
            "",
            "  var Debug;",
            "  (function (Debug) {",
            "    function AssertType(variable, type, message) {",
            "      Assert(variable instanceof type, message);",
            "    }",
            "    Debug.AssertType = AssertType;",
            "    function Assert(condition, message) {",
            "      if (!condition) {",
            "        if (typeof message !== \"undefined\") {",
            "          console.warn(message);",
            "        }",
            "        if (console.trace) {",
            "          console.trace();",
            "        }",
            "        throw new Error(\"\");",
            "      }",
            "    }",
            "    Debug.Assert = Assert;",
            "  })(Debug || (Debug = {}));",
            "",
            "  /**",
            "   * In the original C# code, a SystemException would be thrown when passing",
            "   * null to methods expected a valid instance. Javascript has no such",
            "   * concept, but TypeScript will not allow `null` to be passed to methods",
            "   * explicitely requiring a valid type.",
            "   *",
            "   * Whenever TypeScript complain about the possibility of a `null` value,",
            "   * check the offending value and it it's null, throw this exception using",
            "   * `throwNullException(name: string)`.",
            "   */",
            "  class NullException extends Error {}",
            "  /**",
            "   * Throw a NullException.",
            "   *",
            "   * @param name a short description of the offending value (often its name within the code).",
            "   */",
            "  function throwNullException(name) {",
            "    throw new NullException(`${name} is null or undefined`);",
            "  }",
            "",
            "  class InkObject {",
            "    constructor() {",
            "      this.parent = null;",
            "      this._debugMetadata = null;",
            "      this._path = null;",
            "    }",
            "    get debugMetadata() {",
            "      if (this._debugMetadata === null) {",
            "        if (this.parent) {",
            "          return this.parent.debugMetadata;",
            "        }",
            "      }",
            "      return this._debugMetadata;",
            "    }",
            "    set debugMetadata(value) {",
            "      this._debugMetadata = value;",
            "    }",
            "    get ownDebugMetadata() {",
            "      return this._debugMetadata;",
            "    }",
            "    DebugLineNumberOfPath(path) {",
            "      if (path === null) return null;",
            "      // Try to get a line number from debug metadata",
            "      let root = this.rootContentContainer;",
            "      if (root) {",
            "        let targetContent = root.ContentAtPath(path).obj;",
            "        if (targetContent) {",
            "          let dm = targetContent.debugMetadata;",
            "          if (dm !== null) {",
            "            return dm.startLineNumber;",
            "          }",
            "        }",
            "      }",
            "      return null;",
            "    }",
            "    get path() {",
            "      if (this._path == null) {",
            "        if (this.parent == null) {",
            "          this._path = new Path$1();",
            "        } else {",
            "          let comps = [];",
            "          let child = this;",
            "          let container = asOrNull(child.parent, Container);",
            "          while (container !== null) {",
            "            let namedChild = asINamedContentOrNull(child);",
            "            if (namedChild != null && namedChild.hasValidName) {",
            "              if (namedChild.name === null) return throwNullException(\"namedChild.name\");",
            "              comps.unshift(new Path$1.Component(namedChild.name));",
            "            } else {",
            "              comps.unshift(new Path$1.Component(container.content.indexOf(child)));",
            "            }",
            "            child = container;",
            "            container = asOrNull(container.parent, Container);",
            "          }",
            "          this._path = new Path$1(comps);",
            "        }",
            "      }",
            "      return this._path;",
            "    }",
            "    ResolvePath(path) {",
            "      if (path === null) return throwNullException(\"path\");",
            "      if (path.isRelative) {",
            "        let nearestContainer = asOrNull(this, Container);",
            "        if (nearestContainer === null) {",
            "          Debug.Assert(this.parent !== null, \"Can't resolve relative path because we don't have a parent\");",
            "          nearestContainer = asOrNull(this.parent, Container);",
            "          Debug.Assert(nearestContainer !== null, \"Expected parent to be a container\");",
            "          Debug.Assert(path.GetComponent(0).isParent);",
            "          path = path.tail;",
            "        }",
            "        if (nearestContainer === null) {",
            "          return throwNullException(\"nearestContainer\");",
            "        }",
            "        return nearestContainer.ContentAtPath(path);",
            "      } else {",
            "        let contentContainer = this.rootContentContainer;",
            "        if (contentContainer === null) {",
            "          return throwNullException(\"contentContainer\");",
            "        }",
            "        return contentContainer.ContentAtPath(path);",
            "      }",
            "    }",
            "    ConvertPathToRelative(globalPath) {",
            "      let ownPath = this.path;",
            "      let minPathLength = Math.min(globalPath.length, ownPath.length);",
            "      let lastSharedPathCompIndex = -1;",
            "      for (let i = 0; i < minPathLength; ++i) {",
            "        let ownComp = ownPath.GetComponent(i);",
            "        let otherComp = globalPath.GetComponent(i);",
            "        if (ownComp.Equals(otherComp)) {",
            "          lastSharedPathCompIndex = i;",
            "        } else {",
            "          break;",
            "        }",
            "      }",
            "      // No shared path components, so just use global path",
            "      if (lastSharedPathCompIndex == -1) return globalPath;",
            "      let numUpwardsMoves = ownPath.componentCount - 1 - lastSharedPathCompIndex;",
            "      let newPathComps = [];",
            "      for (let up = 0; up < numUpwardsMoves; ++up) newPathComps.push(Path$1.Component.ToParent());",
            "      for (let down = lastSharedPathCompIndex + 1; down < globalPath.componentCount; ++down) newPathComps.push(globalPath.GetComponent(down));",
            "      let relativePath = new Path$1(newPathComps, true);",
            "      return relativePath;",
            "    }",
            "    CompactPathString(otherPath) {",
            "      let globalPathStr = null;",
            "      let relativePathStr = null;",
            "      if (otherPath.isRelative) {",
            "        relativePathStr = otherPath.componentsString;",
            "        globalPathStr = this.path.PathByAppendingPath(otherPath).componentsString;",
            "      } else {",
            "        let relativePath = this.ConvertPathToRelative(otherPath);",
            "        relativePathStr = relativePath.componentsString;",
            "        globalPathStr = otherPath.componentsString;",
            "      }",
            "      if (relativePathStr.length < globalPathStr.length) return relativePathStr;else return globalPathStr;",
            "    }",
            "    get rootContentContainer() {",
            "      let ancestor = this;",
            "      while (ancestor.parent) {",
            "        ancestor = ancestor.parent;",
            "      }",
            "      return asOrNull(ancestor, Container);",
            "    }",
            "    Copy() {",
            "      throw Error(\"Not Implemented: Doesn't support copying\");",
            "    }",
            "    // SetChild works slightly diferently in the js implementation.",
            "    // Since we can't pass an objets property by reference, we instead pass",
            "    // the object and the property string.",
            "    // TODO: This method can probably be rewritten with type-safety in mind.",
            "    SetChild(obj, prop, value) {",
            "      if (obj[prop]) obj[prop] = null;",
            "      obj[prop] = value;",
            "      if (obj[prop]) obj[prop].parent = this;",
            "    }",
            "    Equals(obj) {",
            "      return obj === this;",
            "    }",
            "  }",
            "",
            "  class StringBuilder {",
            "    constructor(str) {",
            "      str = typeof str !== \"undefined\" ? str.toString() : \"\";",
            "      this.string = str;",
            "    }",
            "    get Length() {",
            "      return this.string.length;",
            "    }",
            "    Append(str) {",
            "      if (str !== null) {",
            "        this.string += str;",
            "      }",
            "    }",
            "    AppendLine(str) {",
            "      if (typeof str !== \"undefined\") this.Append(str);",
            "      this.string += \"\\n\";",
            "    }",
            "    AppendFormat(format) {",
            "      for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {",
            "        args[_key - 1] = arguments[_key];",
            "      }",
            "      // taken from http://stackoverflow.com/questions/610406/javascript-equivalent-to-printf-string-format",
            "      this.string += format.replace(/{(\\d+)}/g, (match, num) => typeof args[num] != \"undefined\" ? args[num] : match);",
            "    }",
            "    toString() {",
            "      return this.string;",
            "    }",
            "    Clear() {",
            "      this.string = \"\";",
            "    }",
            "  }",
            "",
            "  class InkListItem {",
            "    constructor() {",
            "      // InkListItem is a struct",
            "      this.originName = null;",
            "      this.itemName = null;",
            "      if (typeof arguments[1] !== \"undefined\") {",
            "        let originName = arguments[0];",
            "        let itemName = arguments[1];",
            "        this.originName = originName;",
            "        this.itemName = itemName;",
            "      } else if (arguments[0]) {",
            "        let fullName = arguments[0];",
            "        let nameParts = fullName.toString().split(\".\");",
            "        this.originName = nameParts[0];",
            "        this.itemName = nameParts[1];",
            "      }",
            "    }",
            "    static get Null() {",
            "      return new InkListItem(null, null);",
            "    }",
            "    get isNull() {",
            "      return this.originName == null && this.itemName == null;",
            "    }",
            "    get fullName() {",
            "      return (this.originName !== null ? this.originName : \"?\") + \".\" + this.itemName;",
            "    }",
            "    toString() {",
            "      return this.fullName;",
            "    }",
            "    Equals(obj) {",
            "      if (obj instanceof InkListItem) {",
            "        let otherItem = obj;",
            "        return otherItem.itemName == this.itemName && otherItem.originName == this.originName;",
            "      }",
            "      return false;",
            "    }",
            "    // These methods did not exist in the original C# code. Their purpose is to",
            "    // make `InkListItem` mimics the value-type semantics of the original",
            "    // struct. Please refer to the end of this file, for a more in-depth",
            "    // explanation.",
            "    /**",
            "     * Returns a shallow clone of the current instance.",
            "     */",
            "    copy() {",
            "      return new InkListItem(this.originName, this.itemName);",
            "    }",
            "    /**",
            "     * Returns a `SerializedInkListItem` representing the current",
            "     * instance. The result is intended to be used as a key inside a Map.",
            "     */",
            "    serialized() {",
            "      // We are simply using a JSON representation as a value-typed key.",
            "      return JSON.stringify({",
            "        originName: this.originName,",
            "        itemName: this.itemName",
            "      });",
            "    }",
            "    /**",
            "     * Reconstructs a `InkListItem` from the given SerializedInkListItem.",
            "     */",
            "    static fromSerializedKey(key) {",
            "      let obj = JSON.parse(key);",
            "      if (!InkListItem.isLikeInkListItem(obj)) return InkListItem.Null;",
            "      let inkListItem = obj;",
            "      return new InkListItem(inkListItem.originName, inkListItem.itemName);",
            "    }",
            "    /**",
            "     * Determines whether the given item is sufficiently `InkListItem`-like",
            "     * to be used as a template when reconstructing the InkListItem.",
            "     */",
            "    static isLikeInkListItem(item) {",
            "      if (typeof item !== \"object\") return false;",
            "      if (!item.hasOwnProperty(\"originName\") || !item.hasOwnProperty(\"itemName\")) return false;",
            "      if (typeof item.originName !== \"string\" && typeof item.originName !== null) return false;",
            "      if (typeof item.itemName !== \"string\" && typeof item.itemName !== null) return false;",
            "      return true;",
            "    }",
            "  }",
            "  class InkList extends Map {",
            "    constructor() {",
            "      // Trying to be smart here, this emulates the constructor inheritance found",
            "      // in the original code, but only if otherList is an InkList. IIFE FTW.",
            "      super((() => {",
            "        if (arguments[0] instanceof InkList) {",
            "          return arguments[0];",
            "        } else {",
            "          return [];",
            "        }",
            "      })());",
            "      this.origins = null;",
            "      this._originNames = [];",
            "      if (arguments[0] instanceof InkList) {",
            "        let otherList = arguments[0];",
            "        let otherOriginNames = otherList.originNames;",
            "        if (otherOriginNames !== null) this._originNames = otherOriginNames.slice();",
            "        if (otherList.origins !== null) {",
            "          this.origins = otherList.origins.slice();",
            "        }",
            "      } else if (typeof arguments[0] === \"string\") {",
            "        let singleOriginListName = arguments[0];",
            "        let originStory = arguments[1];",
            "        this.SetInitialOriginName(singleOriginListName);",
            "        if (originStory.listDefinitions === null) {",
            "          return throwNullException(\"originStory.listDefinitions\");",
            "        }",
            "        let def = originStory.listDefinitions.TryListGetDefinition(singleOriginListName, null);",
            "        if (def.exists) {",
            "          // Throwing now, because if the value is `null` it will",
            "          // eventually throw down the line.",
            "          if (def.result === null) {",
            "            return throwNullException(\"def.result\");",
            "          }",
            "          this.origins = [def.result];",
            "        } else {",
            "          throw new Error(\"InkList origin could not be found in story when constructing new list: \" + singleOriginListName);",
            "        }",
            "      } else if (typeof arguments[0] === \"object\" && arguments[0].hasOwnProperty(\"Key\") && arguments[0].hasOwnProperty(\"Value\")) {",
            "        let singleElement = arguments[0];",
            "        this.Add(singleElement.Key, singleElement.Value);",
            "      }",
            "    }",
            "    static FromString(myListItem, originStory) {",
            "      var _a;",
            "      let listValue = (_a = originStory.listDefinitions) === null || _a === void 0 ? void 0 : _a.FindSingleItemListWithName(myListItem);",
            "      if (listValue) {",
            "        if (listValue.value === null) {",
            "          return throwNullException(\"listValue.value\");",
            "        }",
            "        return new InkList(listValue.value);",
            "      } else {",
            "        throw new Error(\"Could not find the InkListItem from the string '\" + myListItem + \"' to create an InkList because it doesn't exist in the original list definition in ink.\");",
            "      }",
            "    }",
            "    AddItem(itemOrItemName) {",
            "      if (itemOrItemName instanceof InkListItem) {",
            "        let item = itemOrItemName;",
            "        if (item.originName == null) {",
            "          this.AddItem(item.itemName);",
            "          return;",
            "        }",
            "        if (this.origins === null) return throwNullException(\"this.origins\");",
            "        for (let origin of this.origins) {",
            "          if (origin.name == item.originName) {",
            "            let intVal = origin.TryGetValueForItem(item, 0);",
            "            if (intVal.exists) {",
            "              this.Add(item, intVal.result);",
            "              return;",
            "            } else {",
            "              throw new Error(\"Could not add the item \" + item + \" to this list because it doesn't exist in the original list definition in ink.\");",
            "            }",
            "          }",
            "        }",
            "        throw new Error(\"Failed to add item to list because the item was from a new list definition that wasn't previously known to this list. Only items from previously known lists can be used, so that the int value can be found.\");",
            "      } else {",
            "        let itemName = itemOrItemName;",
            "        let foundListDef = null;",
            "        if (this.origins === null) return throwNullException(\"this.origins\");",
            "        for (let origin of this.origins) {",
            "          if (itemName === null) return throwNullException(\"itemName\");",
            "          if (origin.ContainsItemWithName(itemName)) {",
            "            if (foundListDef != null) {",
            "              throw new Error(\"Could not add the item \" + itemName + \" to this list because it could come from either \" + origin.name + \" or \" + foundListDef.name);",
            "            } else {",
            "              foundListDef = origin;",
            "            }",
            "          }",
            "        }",
            "        if (foundListDef == null) throw new Error(\"Could not add the item \" + itemName + \" to this list because it isn't known to any list definitions previously associated with this list.\");",
            "        let item = new InkListItem(foundListDef.name, itemName);",
            "        let itemVal = foundListDef.ValueForItem(item);",
            "        this.Add(item, itemVal);",
            "      }",
            "    }",
            "    ContainsItemNamed(itemName) {",
            "      for (let [key] of this) {",
            "        let item = InkListItem.fromSerializedKey(key);",
            "        if (item.itemName == itemName) return true;",
            "      }",
            "      return false;",
            "    }",
            "    ContainsKey(key) {",
            "      return this.has(key.serialized());",
            "    }",
            "    Add(key, value) {",
            "      let serializedKey = key.serialized();",
            "      if (this.has(serializedKey)) {",
            "        // Throw an exception to match the C# behavior.",
            "        throw new Error(`The Map already contains an entry for ${key}`);",
            "      }",
            "      this.set(serializedKey, value);",
            "    }",
            "    Remove(key) {",
            "      return this.delete(key.serialized());",
            "    }",
            "    get Count() {",
            "      return this.size;",
            "    }",
            "    get originOfMaxItem() {",
            "      if (this.origins == null) return null;",
            "      let maxOriginName = this.maxItem.Key.originName;",
            "      let result = null;",
            "      this.origins.every(origin => {",
            "        if (origin.name == maxOriginName) {",
            "          result = origin;",
            "          return false;",
            "        } else return true;",
            "      });",
            "      return result;",
            "    }",
            "    get originNames() {",
            "      if (this.Count > 0) {",
            "        if (this._originNames == null && this.Count > 0) this._originNames = [];else {",
            "          if (!this._originNames) this._originNames = [];",
            "          this._originNames.length = 0;",
            "        }",
            "        for (let [key] of this) {",
            "          let item = InkListItem.fromSerializedKey(key);",
            "          if (item.originName === null) return throwNullException(\"item.originName\");",
            "          this._originNames.push(item.originName);",
            "        }",
            "      }",
            "      return this._originNames;",
            "    }",
            "    SetInitialOriginName(initialOriginName) {",
            "      this._originNames = [initialOriginName];",
            "    }",
            "    SetInitialOriginNames(initialOriginNames) {",
            "      if (initialOriginNames == null) this._originNames = null;else this._originNames = initialOriginNames.slice(); // store a copy",
            "    }",
            "    get maxItem() {",
            "      let max = {",
            "        Key: InkListItem.Null,",
            "        Value: 0",
            "      };",
            "      for (let [key, value] of this) {",
            "        let item = InkListItem.fromSerializedKey(key);",
            "        if (max.Key.isNull || value > max.Value) max = {",
            "          Key: item,",
            "          Value: value",
            "        };",
            "      }",
            "      return max;",
            "    }",
            "    get minItem() {",
            "      let min = {",
            "        Key: InkListItem.Null,",
            "        Value: 0",
            "      };",
            "      for (let [key, value] of this) {",
            "        let item = InkListItem.fromSerializedKey(key);",
            "        if (min.Key.isNull || value < min.Value) {",
            "          min = {",
            "            Key: item,",
            "            Value: value",
            "          };",
            "        }",
            "      }",
            "      return min;",
            "    }",
            "    get inverse() {",
            "      let list = new InkList();",
            "      if (this.origins != null) {",
            "        for (let origin of this.origins) {",
            "          for (let [key, value] of origin.items) {",
            "            let item = InkListItem.fromSerializedKey(key);",
            "            if (!this.ContainsKey(item)) list.Add(item, value);",
            "          }",
            "        }",
            "      }",
            "      return list;",
            "    }",
            "    get all() {",
            "      let list = new InkList();",
            "      if (this.origins != null) {",
            "        for (let origin of this.origins) {",
            "          for (let [key, value] of origin.items) {",
            "            let item = InkListItem.fromSerializedKey(key);",
            "            list.set(item.serialized(), value);",
            "          }",
            "        }",
            "      }",
            "      return list;",
            "    }",
            "    Union(otherList) {",
            "      let union = new InkList(this);",
            "      for (let [key, value] of otherList) {",
            "        union.set(key, value);",
            "      }",
            "      return union;",
            "    }",
            "    Intersect(otherList) {",
            "      let intersection = new InkList();",
            "      for (let [key, value] of this) {",
            "        if (otherList.has(key)) intersection.set(key, value);",
            "      }",
            "      return intersection;",
            "    }",
            "    HasIntersection(otherList) {",
            "      for (let [key] of this) {",
            "        if (otherList.has(key)) return true;",
            "      }",
            "      return false;",
            "    }",
            "    Without(listToRemove) {",
            "      let result = new InkList(this);",
            "      for (let [key] of listToRemove) {",
            "        result.delete(key);",
            "      }",
            "      return result;",
            "    }",
            "    Contains(what) {",
            "      if (typeof what == \"string\") return this.ContainsItemNamed(what);",
            "      const otherList = what;",
            "      if (otherList.size == 0 || this.size == 0) return false;",
            "      for (let [key] of otherList) {",
            "        if (!this.has(key)) return false;",
            "      }",
            "      return true;",
            "    }",
            "    GreaterThan(otherList) {",
            "      if (this.Count == 0) return false;",
            "      if (otherList.Count == 0) return true;",
            "      return this.minItem.Value > otherList.maxItem.Value;",
            "    }",
            "    GreaterThanOrEquals(otherList) {",
            "      if (this.Count == 0) return false;",
            "      if (otherList.Count == 0) return true;",
            "      return this.minItem.Value >= otherList.minItem.Value && this.maxItem.Value >= otherList.maxItem.Value;",
            "    }",
            "    LessThan(otherList) {",
            "      if (otherList.Count == 0) return false;",
            "      if (this.Count == 0) return true;",
            "      return this.maxItem.Value < otherList.minItem.Value;",
            "    }",
            "    LessThanOrEquals(otherList) {",
            "      if (otherList.Count == 0) return false;",
            "      if (this.Count == 0) return true;",
            "      return this.maxItem.Value <= otherList.maxItem.Value && this.minItem.Value <= otherList.minItem.Value;",
            "    }",
            "    MaxAsList() {",
            "      if (this.Count > 0) return new InkList(this.maxItem);else return new InkList();",
            "    }",
            "    MinAsList() {",
            "      if (this.Count > 0) return new InkList(this.minItem);else return new InkList();",
            "    }",
            "    ListWithSubRange(minBound, maxBound) {",
            "      if (this.Count == 0) return new InkList();",
            "      let ordered = this.orderedItems;",
            "      let minValue = 0;",
            "      let maxValue = Number.MAX_SAFE_INTEGER;",
            "      if (Number.isInteger(minBound)) {",
            "        minValue = minBound;",
            "      } else {",
            "        if (minBound instanceof InkList && minBound.Count > 0) minValue = minBound.minItem.Value;",
            "      }",
            "      if (Number.isInteger(maxBound)) {",
            "        maxValue = maxBound;",
            "      } else {",
            "        if (maxBound instanceof InkList && maxBound.Count > 0) maxValue = maxBound.maxItem.Value;",
            "      }",
            "      let subList = new InkList();",
            "      subList.SetInitialOriginNames(this.originNames);",
            "      for (let item of ordered) {",
            "        if (item.Value >= minValue && item.Value <= maxValue) {",
            "          subList.Add(item.Key, item.Value);",
            "        }",
            "      }",
            "      return subList;",
            "    }",
            "    Equals(otherInkList) {",
            "      if (otherInkList instanceof InkList === false) return false;",
            "      if (otherInkList.Count != this.Count) return false;",
            "      for (let [key] of this) {",
            "        if (!otherInkList.has(key)) return false;",
            "      }",
            "      return true;",
            "    }",
            "    // GetHashCode not implemented",
            "    get orderedItems() {",
            "      // List<KeyValuePair<InkListItem, int>>",
            "      let ordered = new Array();",
            "      for (let [key, value] of this) {",
            "        let item = InkListItem.fromSerializedKey(key);",
            "        ordered.push({",
            "          Key: item,",
            "          Value: value",
            "        });",
            "      }",
            "      ordered.sort((x, y) => {",
            "        if (x.Key.originName === null) {",
            "          return throwNullException(\"x.Key.originName\");",
            "        }",
            "        if (y.Key.originName === null) {",
            "          return throwNullException(\"y.Key.originName\");",
            "        }",
            "        if (x.Value == y.Value) {",
            "          return x.Key.originName.localeCompare(y.Key.originName);",
            "        } else {",
            "          // TODO: refactor this bit into a numberCompareTo method?",
            "          if (x.Value < y.Value) return -1;",
            "          return x.Value > y.Value ? 1 : 0;",
            "        }",
            "      });",
            "      return ordered;",
            "    }",
            "    toString() {",
            "      let ordered = this.orderedItems;",
            "      let sb = new StringBuilder();",
            "      for (let i = 0; i < ordered.length; i++) {",
            "        if (i > 0) sb.Append(\", \");",
            "        let item = ordered[i].Key;",
            "        if (item.itemName === null) return throwNullException(\"item.itemName\");",
            "        sb.Append(item.itemName);",
            "      }",
            "      return sb.toString();",
            "    }",
            "    // casting a InkList to a Number, for somereason, actually gives a number.",
            "    // This messes up the type detection when creating a Value from a InkList.",
            "    // Returning NaN here prevents that.",
            "    valueOf() {",
            "      return NaN;",
            "    }",
            "  }",
            "",
            "  class StoryException extends Error {",
            "    constructor(message) {",
            "      super(message);",
            "      this.useEndLineNumber = false;",
            "      this.message = message;",
            "      this.name = \"StoryException\";",
            "    }",
            "  }",
            "",
            "  function tryGetValueFromMap(map, key, /* out */value) {",
            "    if (map === null) {",
            "      return {",
            "        result: value,",
            "        exists: false",
            "      };",
            "    }",
            "    let val = map.get(key);",
            "    if (typeof val === \"undefined\") {",
            "      return {",
            "        result: value,",
            "        exists: false",
            "      };",
            "    } else {",
            "      return {",
            "        result: val,",
            "        exists: true",
            "      };",
            "    }",
            "  }",
            "  function tryParseInt(value) {",
            "    let defaultValue = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;",
            "    let val = parseInt(value);",
            "    if (!Number.isNaN(val)) {",
            "      return {",
            "        result: val,",
            "        exists: true",
            "      };",
            "    } else {",
            "      return {",
            "        result: defaultValue,",
            "        exists: false",
            "      };",
            "    }",
            "  }",
            "  function tryParseFloat(value) {",
            "    let defaultValue = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;",
            "    let val = parseFloat(value);",
            "    if (!Number.isNaN(val)) {",
            "      return {",
            "        result: val,",
            "        exists: true",
            "      };",
            "    } else {",
            "      return {",
            "        result: defaultValue,",
            "        exists: false",
            "      };",
            "    }",
            "  }",
            "",
            "  class AbstractValue extends InkObject {",
            "    static Create(val, preferredNumberType) {",
            "      // This code doesn't exist in upstream and is simply here to enforce",
            "      // the creation of the proper number value.",
            "      // If `preferredNumberType` is not provided or if value doesn't match",
            "      // `preferredNumberType`, this conditional does nothing.",
            "      if (preferredNumberType) {",
            "        if (preferredNumberType === ValueType.Int && Number.isInteger(Number(val))) {",
            "          return new IntValue(Number(val));",
            "        } else if (preferredNumberType === ValueType.Float && !isNaN(val)) {",
            "          return new FloatValue(Number(val));",
            "        }",
            "      }",
            "      if (typeof val === \"boolean\") {",
            "        return new BoolValue(Boolean(val));",
            "      }",
            "      // https://github.com/y-lohse/inkjs/issues/425",
            "      // Changed condition sequence, because Number('') is",
            "      // parsed to 0, which made setting string to empty",
            "      // impossible",
            "      if (typeof val === \"string\") {",
            "        return new StringValue(String(val));",
            "      } else if (Number.isInteger(Number(val))) {",
            "        return new IntValue(Number(val));",
            "      } else if (!isNaN(val)) {",
            "        return new FloatValue(Number(val));",
            "      } else if (val instanceof Path$1) {",
            "        return new DivertTargetValue(asOrThrows(val, Path$1));",
            "      } else if (val instanceof InkList) {",
            "        return new ListValue(asOrThrows(val, InkList));",
            "      }",
            "      return null;",
            "    }",
            "    Copy() {",
            "      return asOrThrows(AbstractValue.Create(this.valueObject), InkObject);",
            "    }",
            "    BadCastException(targetType) {",
            "      return new StoryException(\"Can't cast \" + this.valueObject + \" from \" + this.valueType + \" to \" + targetType);",
            "    }",
            "  }",
            "  class Value extends AbstractValue {",
            "    constructor(val) {",
            "      super();",
            "      this.value = val;",
            "    }",
            "    get valueObject() {",
            "      return this.value;",
            "    }",
            "    toString() {",
            "      if (this.value === null) return throwNullException(\"Value.value\");",
            "      return this.value.toString();",
            "    }",
            "  }",
            "  class BoolValue extends Value {",
            "    constructor(val) {",
            "      super(val || false);",
            "    }",
            "    get isTruthy() {",
            "      return Boolean(this.value);",
            "    }",
            "    get valueType() {",
            "      return ValueType.Bool;",
            "    }",
            "    Cast(newType) {",
            "      if (this.value === null) return throwNullException(\"Value.value\");",
            "      if (newType == this.valueType) {",
            "        return this;",
            "      }",
            "      if (newType == ValueType.Int) {",
            "        return new IntValue(this.value ? 1 : 0);",
            "      }",
            "      if (newType == ValueType.Float) {",
            "        return new FloatValue(this.value ? 1.0 : 0.0);",
            "      }",
            "      if (newType == ValueType.String) {",
            "        return new StringValue(this.value ? \"true\" : \"false\");",
            "      }",
            "      throw this.BadCastException(newType);",
            "    }",
            "    toString() {",
            "      return this.value ? \"true\" : \"false\";",
            "    }",
            "  }",
            "  class IntValue extends Value {",
            "    constructor(val) {",
            "      super(val || 0);",
            "    }",
            "    get isTruthy() {",
            "      return this.value != 0;",
            "    }",
            "    get valueType() {",
            "      return ValueType.Int;",
            "    }",
            "    Cast(newType) {",
            "      if (this.value === null) return throwNullException(\"Value.value\");",
            "      if (newType == this.valueType) {",
            "        return this;",
            "      }",
            "      if (newType == ValueType.Bool) {",
            "        return new BoolValue(this.value === 0 ? false : true);",
            "      }",
            "      if (newType == ValueType.Float) {",
            "        return new FloatValue(this.value);",
            "      }",
            "      if (newType == ValueType.String) {",
            "        return new StringValue(\"\" + this.value);",
            "      }",
            "      throw this.BadCastException(newType);",
            "    }",
            "  }",
            "  class FloatValue extends Value {",
            "    constructor(val) {",
            "      super(val || 0.0);",
            "    }",
            "    get isTruthy() {",
            "      return this.value != 0.0;",
            "    }",
            "    get valueType() {",
            "      return ValueType.Float;",
            "    }",
            "    Cast(newType) {",
            "      if (this.value === null) return throwNullException(\"Value.value\");",
            "      if (newType == this.valueType) {",
            "        return this;",
            "      }",
            "      if (newType == ValueType.Bool) {",
            "        return new BoolValue(this.value === 0.0 ? false : true);",
            "      }",
            "      if (newType == ValueType.Int) {",
            "        return new IntValue(this.value);",
            "      }",
            "      if (newType == ValueType.String) {",
            "        return new StringValue(\"\" + this.value);",
            "      }",
            "      throw this.BadCastException(newType);",
            "    }",
            "  }",
            "  class StringValue extends Value {",
            "    constructor(val) {",
            "      super(val || \"\");",
            "      this._isNewline = this.value == \"\\n\";",
            "      this._isInlineWhitespace = true;",
            "      if (this.value === null) return throwNullException(\"Value.value\");",
            "      if (this.value.length > 0) {",
            "        this.value.split(\"\").every(c => {",
            "          if (c != \" \" && c != \"\\t\") {",
            "            this._isInlineWhitespace = false;",
            "            return false;",
            "          }",
            "          return true;",
            "        });",
            "      }",
            "    }",
            "    get valueType() {",
            "      return ValueType.String;",
            "    }",
            "    get isTruthy() {",
            "      if (this.value === null) return throwNullException(\"Value.value\");",
            "      return this.value.length > 0;",
            "    }",
            "    get isNewline() {",
            "      return this._isNewline;",
            "    }",
            "    get isInlineWhitespace() {",
            "      return this._isInlineWhitespace;",
            "    }",
            "    get isNonWhitespace() {",
            "      return !this.isNewline && !this.isInlineWhitespace;",
            "    }",
            "    Cast(newType) {",
            "      if (newType == this.valueType) {",
            "        return this;",
            "      }",
            "      if (newType == ValueType.Int) {",
            "        let parsedInt = tryParseInt(this.value);",
            "        if (parsedInt.exists) {",
            "          return new IntValue(parsedInt.result);",
            "        } else {",
            "          throw this.BadCastException(newType);",
            "        }",
            "      }",
            "      if (newType == ValueType.Float) {",
            "        let parsedFloat = tryParseFloat(this.value);",
            "        if (parsedFloat.exists) {",
            "          return new FloatValue(parsedFloat.result);",
            "        } else {",
            "          throw this.BadCastException(newType);",
            "        }",
            "      }",
            "      throw this.BadCastException(newType);",
            "    }",
            "  }",
            "  class DivertTargetValue extends Value {",
            "    constructor() {",
            "      let targetPath = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;",
            "      super(targetPath);",
            "    }",
            "    get valueType() {",
            "      return ValueType.DivertTarget;",
            "    }",
            "    get targetPath() {",
            "      if (this.value === null) return throwNullException(\"Value.value\");",
            "      return this.value;",
            "    }",
            "    set targetPath(value) {",
            "      this.value = value;",
            "    }",
            "    get isTruthy() {",
            "      throw new Error(\"Shouldn't be checking the truthiness of a divert target\");",
            "    }",
            "    Cast(newType) {",
            "      if (newType == this.valueType) return this;",
            "      throw this.BadCastException(newType);",
            "    }",
            "    toString() {",
            "      return \"DivertTargetValue(\" + this.targetPath + \")\";",
            "    }",
            "  }",
            "  class VariablePointerValue extends Value {",
            "    constructor(variableName) {",
            "      let contextIndex = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : -1;",
            "      super(variableName);",
            "      this._contextIndex = contextIndex;",
            "    }",
            "    get contextIndex() {",
            "      return this._contextIndex;",
            "    }",
            "    set contextIndex(value) {",
            "      this._contextIndex = value;",
            "    }",
            "    get variableName() {",
            "      if (this.value === null) return throwNullException(\"Value.value\");",
            "      return this.value;",
            "    }",
            "    set variableName(value) {",
            "      this.value = value;",
            "    }",
            "    get valueType() {",
            "      return ValueType.VariablePointer;",
            "    }",
            "    get isTruthy() {",
            "      throw new Error(\"Shouldn't be checking the truthiness of a variable pointer\");",
            "    }",
            "    Cast(newType) {",
            "      if (newType == this.valueType) return this;",
            "      throw this.BadCastException(newType);",
            "    }",
            "    toString() {",
            "      return \"VariablePointerValue(\" + this.variableName + \")\";",
            "    }",
            "    Copy() {",
            "      return new VariablePointerValue(this.variableName, this.contextIndex);",
            "    }",
            "  }",
            "  class ListValue extends Value {",
            "    get isTruthy() {",
            "      if (this.value === null) {",
            "        return throwNullException(\"this.value\");",
            "      }",
            "      return this.value.Count > 0;",
            "    }",
            "    get valueType() {",
            "      return ValueType.List;",
            "    }",
            "    Cast(newType) {",
            "      if (this.value === null) return throwNullException(\"Value.value\");",
            "      if (newType == ValueType.Int) {",
            "        let max = this.value.maxItem;",
            "        if (max.Key.isNull) return new IntValue(0);else return new IntValue(max.Value);",
            "      } else if (newType == ValueType.Float) {",
            "        let max = this.value.maxItem;",
            "        if (max.Key.isNull) return new FloatValue(0.0);else return new FloatValue(max.Value);",
            "      } else if (newType == ValueType.String) {",
            "        let max = this.value.maxItem;",
            "        if (max.Key.isNull) return new StringValue(\"\");else {",
            "          return new StringValue(max.Key.toString());",
            "        }",
            "      }",
            "      if (newType == this.valueType) return this;",
            "      throw this.BadCastException(newType);",
            "    }",
            "    constructor(listOrSingleItem, singleValue) {",
            "      super(null);",
            "      if (!listOrSingleItem && !singleValue) {",
            "        this.value = new InkList();",
            "      } else if (listOrSingleItem instanceof InkList) {",
            "        this.value = new InkList(listOrSingleItem);",
            "      } else if (listOrSingleItem instanceof InkListItem && typeof singleValue === \"number\") {",
            "        this.value = new InkList({",
            "          Key: listOrSingleItem,",
            "          Value: singleValue",
            "        });",
            "      }",
            "    }",
            "    static RetainListOriginsForAssignment(oldValue, newValue) {",
            "      let oldList = asOrNull(oldValue, ListValue);",
            "      let newList = asOrNull(newValue, ListValue);",
            "      if (newList && newList.value === null) return throwNullException(\"newList.value\");",
            "      if (oldList && oldList.value === null) return throwNullException(\"oldList.value\");",
            "      // When assigning the empty list, try to retain any initial origin names",
            "      if (oldList && newList && newList.value.Count == 0) newList.value.SetInitialOriginNames(oldList.value.originNames);",
            "    }",
            "  }",
            "  var ValueType;",
            "  (function (ValueType) {",
            "    ValueType[ValueType[\"Bool\"] = -1] = \"Bool\";",
            "    ValueType[ValueType[\"Int\"] = 0] = \"Int\";",
            "    ValueType[ValueType[\"Float\"] = 1] = \"Float\";",
            "    ValueType[ValueType[\"List\"] = 2] = \"List\";",
            "    ValueType[ValueType[\"String\"] = 3] = \"String\";",
            "    ValueType[ValueType[\"DivertTarget\"] = 4] = \"DivertTarget\";",
            "    ValueType[ValueType[\"VariablePointer\"] = 5] = \"VariablePointer\";",
            "  })(ValueType || (ValueType = {}));",
            "",
            "  class SearchResult {",
            "    constructor() {",
            "      this.obj = null;",
            "      this.approximate = false;",
            "    }",
            "    get correctObj() {",
            "      return this.approximate ? null : this.obj;",
            "    }",
            "    get container() {",
            "      return this.obj instanceof Container ? this.obj : null;",
            "    }",
            "    copy() {",
            "      let searchResult = new SearchResult();",
            "      searchResult.obj = this.obj;",
            "      searchResult.approximate = this.approximate;",
            "      return searchResult;",
            "    }",
            "  }",
            "",
            "  class Container extends InkObject {",
            "    constructor() {",
            "      super(...arguments);",
            "      this.name = null;",
            "      this._content = [];",
            "      this.namedContent = new Map();",
            "      this.visitsShouldBeCounted = false;",
            "      this.turnIndexShouldBeCounted = false;",
            "      this.countingAtStartOnly = false;",
            "      this._pathToFirstLeafContent = null;",
            "    }",
            "    get hasValidName() {",
            "      return this.name != null && this.name.length > 0;",
            "    }",
            "    get content() {",
            "      return this._content;",
            "    }",
            "    set content(value) {",
            "      this.AddContent(value);",
            "    }",
            "    get namedOnlyContent() {",
            "      let namedOnlyContentDict = new Map();",
            "      for (let [key, value] of this.namedContent) {",
            "        let inkObject = asOrThrows(value, InkObject);",
            "        namedOnlyContentDict.set(key, inkObject);",
            "      }",
            "      for (let c of this.content) {",
            "        let named = asINamedContentOrNull(c);",
            "        if (named != null && named.hasValidName) {",
            "          namedOnlyContentDict.delete(named.name);",
            "        }",
            "      }",
            "      if (namedOnlyContentDict.size == 0) namedOnlyContentDict = null;",
            "      return namedOnlyContentDict;",
            "    }",
            "    set namedOnlyContent(value) {",
            "      let existingNamedOnly = this.namedOnlyContent;",
            "      if (existingNamedOnly != null) {",
            "        for (let [key] of existingNamedOnly) {",
            "          this.namedContent.delete(key);",
            "        }",
            "      }",
            "      if (value == null) return;",
            "      for (let [, val] of value) {",
            "        let named = asINamedContentOrNull(val);",
            "        if (named != null) this.AddToNamedContentOnly(named);",
            "      }",
            "    }",
            "    get countFlags() {",
            "      let flags = 0;",
            "      if (this.visitsShouldBeCounted) flags |= Container.CountFlags.Visits;",
            "      if (this.turnIndexShouldBeCounted) flags |= Container.CountFlags.Turns;",
            "      if (this.countingAtStartOnly) flags |= Container.CountFlags.CountStartOnly;",
            "      if (flags == Container.CountFlags.CountStartOnly) {",
            "        flags = 0;",
            "      }",
            "      return flags;",
            "    }",
            "    set countFlags(value) {",
            "      let flag = value;",
            "      if ((flag & Container.CountFlags.Visits) > 0) this.visitsShouldBeCounted = true;",
            "      if ((flag & Container.CountFlags.Turns) > 0) this.turnIndexShouldBeCounted = true;",
            "      if ((flag & Container.CountFlags.CountStartOnly) > 0) this.countingAtStartOnly = true;",
            "    }",
            "    get pathToFirstLeafContent() {",
            "      if (this._pathToFirstLeafContent == null) this._pathToFirstLeafContent = this.path.PathByAppendingPath(this.internalPathToFirstLeafContent);",
            "      return this._pathToFirstLeafContent;",
            "    }",
            "    get internalPathToFirstLeafContent() {",
            "      let components = [];",
            "      let container = this;",
            "      while (container instanceof Container) {",
            "        if (container.content.length > 0) {",
            "          components.push(new Path$1.Component(0));",
            "          container = container.content[0];",
            "        }",
            "      }",
            "      return new Path$1(components);",
            "    }",
            "    AddContent(contentObjOrList) {",
            "      if (contentObjOrList instanceof Array) {",
            "        let contentList = contentObjOrList;",
            "        for (let c of contentList) {",
            "          this.AddContent(c);",
            "        }",
            "      } else {",
            "        let contentObj = contentObjOrList;",
            "        this._content.push(contentObj);",
            "        if (contentObj.parent) {",
            "          throw new Error(\"content is already in \" + contentObj.parent);",
            "        }",
            "        contentObj.parent = this;",
            "        this.TryAddNamedContent(contentObj);",
            "      }",
            "    }",
            "    TryAddNamedContent(contentObj) {",
            "      let namedContentObj = asINamedContentOrNull(contentObj);",
            "      if (namedContentObj != null && namedContentObj.hasValidName) {",
            "        this.AddToNamedContentOnly(namedContentObj);",
            "      }",
            "    }",
            "    AddToNamedContentOnly(namedContentObj) {",
            "      Debug.AssertType(namedContentObj, InkObject, \"Can only add Runtime.Objects to a Runtime.Container\");",
            "      let runtimeObj = asOrThrows(namedContentObj, InkObject);",
            "      runtimeObj.parent = this;",
            "      if (namedContentObj.name === null) return throwNullException(\"namedContentObj.name\");",
            "      this.namedContent.set(namedContentObj.name, namedContentObj);",
            "    }",
            "    ContentAtPath(path) {",
            "      let partialPathStart = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;",
            "      let partialPathLength = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : -1;",
            "      if (partialPathLength == -1) partialPathLength = path.length;",
            "      let result = new SearchResult();",
            "      result.approximate = false;",
            "      let currentContainer = this;",
            "      let currentObj = this;",
            "      for (let i = partialPathStart; i < partialPathLength; ++i) {",
            "        let comp = path.GetComponent(i);",
            "        if (currentContainer == null) {",
            "          result.approximate = true;",
            "          break;",
            "        }",
            "        let foundObj = currentContainer.ContentWithPathComponent(comp);",
            "        if (foundObj == null) {",
            "          result.approximate = true;",
            "          break;",
            "        }",
            "        currentObj = foundObj;",
            "        currentContainer = asOrNull(foundObj, Container);",
            "      }",
            "      result.obj = currentObj;",
            "      return result;",
            "    }",
            "    InsertContent(contentObj, index) {",
            "      this.content.splice(index, 0, contentObj);",
            "      if (contentObj.parent) {",
            "        throw new Error(\"content is already in \" + contentObj.parent);",
            "      }",
            "      contentObj.parent = this;",
            "      this.TryAddNamedContent(contentObj);",
            "    }",
            "    AddContentsOfContainer(otherContainer) {",
            "      this.content.push(...otherContainer.content);",
            "      for (let obj of otherContainer.content) {",
            "        obj.parent = this;",
            "        this.TryAddNamedContent(obj);",
            "      }",
            "    }",
            "    ContentWithPathComponent(component) {",
            "      if (component.isIndex) {",
            "        if (component.index >= 0 && component.index < this.content.length) {",
            "          return this.content[component.index];",
            "        } else {",
            "          return null;",
            "        }",
            "      } else if (component.isParent) {",
            "        return this.parent;",
            "      } else {",
            "        if (component.name === null) {",
            "          return throwNullException(\"component.name\");",
            "        }",
            "        let foundContent = tryGetValueFromMap(this.namedContent, component.name, null);",
            "        if (foundContent.exists) {",
            "          return asOrThrows(foundContent.result, InkObject);",
            "        } else {",
            "          return null;",
            "        }",
            "      }",
            "    }",
            "    BuildStringOfHierarchy() {",
            "      let sb;",
            "      if (arguments.length == 0) {",
            "        sb = new StringBuilder();",
            "        this.BuildStringOfHierarchy(sb, 0, null);",
            "        return sb.toString();",
            "      }",
            "      sb = arguments[0];",
            "      let indentation = arguments[1];",
            "      let pointedObj = arguments[2];",
            "      function appendIndentation() {",
            "        const spacesPerIndent = 4; // Truly const in the original code",
            "        for (let i = 0; i < spacesPerIndent * indentation; ++i) {",
            "          sb.Append(\" \");",
            "        }",
            "      }",
            "      appendIndentation();",
            "      sb.Append(\"[\");",
            "      if (this.hasValidName) {",
            "        sb.AppendFormat(\" ({0})\", this.name);",
            "      }",
            "      if (this == pointedObj) {",
            "        sb.Append(\"  <---\");",
            "      }",
            "      sb.AppendLine();",
            "      indentation++;",
            "      for (let i = 0; i < this.content.length; ++i) {",
            "        let obj = this.content[i];",
            "        if (obj instanceof Container) {",
            "          let container = obj;",
            "          container.BuildStringOfHierarchy(sb, indentation, pointedObj);",
            "        } else {",
            "          appendIndentation();",
            "          if (obj instanceof StringValue) {",
            "            sb.Append('\"');",
            "            sb.Append(obj.toString().replace(\"\\n\", \"\\\\n\"));",
            "            sb.Append('\"');",
            "          } else {",
            "            sb.Append(obj.toString());",
            "          }",
            "        }",
            "        if (i != this.content.length - 1) {",
            "          sb.Append(\",\");",
            "        }",
            "        if (!(obj instanceof Container) && obj == pointedObj) {",
            "          sb.Append(\"  <---\");",
            "        }",
            "        sb.AppendLine();",
            "      }",
            "      let onlyNamed = new Map();",
            "      for (let [key, value] of this.namedContent) {",
            "        if (this.content.indexOf(asOrThrows(value, InkObject)) >= 0) {",
            "          continue;",
            "        } else {",
            "          onlyNamed.set(key, value);",
            "        }",
            "      }",
            "      if (onlyNamed.size > 0) {",
            "        appendIndentation();",
            "        sb.AppendLine(\"-- named: --\");",
            "        for (let [, value] of onlyNamed) {",
            "          Debug.AssertType(value, Container, \"Can only print out named Containers\");",
            "          let container = value;",
            "          container.BuildStringOfHierarchy(sb, indentation, pointedObj);",
            "          sb.AppendLine();",
            "        }",
            "      }",
            "      indentation--;",
            "      appendIndentation();",
            "      sb.Append(\"]\");",
            "    }",
            "  }",
            "  (function (Container) {",
            "    (function (CountFlags) {",
            "      CountFlags[CountFlags[\"Visits\"] = 1] = \"Visits\";",
            "      CountFlags[CountFlags[\"Turns\"] = 2] = \"Turns\";",
            "      CountFlags[CountFlags[\"CountStartOnly\"] = 4] = \"CountStartOnly\";",
            "    })(Container.CountFlags || (Container.CountFlags = {}));",
            "  })(Container || (Container = {}));",
            "",
            "  class ControlCommand extends InkObject {",
            "    get commandType() {",
            "      return this._commandType;",
            "    }",
            "    constructor() {",
            "      let commandType = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : ControlCommand.CommandType.NotSet;",
            "      super();",
            "      this._commandType = commandType;",
            "    }",
            "    Copy() {",
            "      return new ControlCommand(this.commandType);",
            "    }",
            "    static EvalStart() {",
            "      return new ControlCommand(ControlCommand.CommandType.EvalStart);",
            "    }",
            "    static EvalOutput() {",
            "      return new ControlCommand(ControlCommand.CommandType.EvalOutput);",
            "    }",
            "    static EvalEnd() {",
            "      return new ControlCommand(ControlCommand.CommandType.EvalEnd);",
            "    }",
            "    static Duplicate() {",
            "      return new ControlCommand(ControlCommand.CommandType.Duplicate);",
            "    }",
            "    static PopEvaluatedValue() {",
            "      return new ControlCommand(ControlCommand.CommandType.PopEvaluatedValue);",
            "    }",
            "    static PopFunction() {",
            "      return new ControlCommand(ControlCommand.CommandType.PopFunction);",
            "    }",
            "    static PopTunnel() {",
            "      return new ControlCommand(ControlCommand.CommandType.PopTunnel);",
            "    }",
            "    static BeginString() {",
            "      return new ControlCommand(ControlCommand.CommandType.BeginString);",
            "    }",
            "    static EndString() {",
            "      return new ControlCommand(ControlCommand.CommandType.EndString);",
            "    }",
            "    static NoOp() {",
            "      return new ControlCommand(ControlCommand.CommandType.NoOp);",
            "    }",
            "    static ChoiceCount() {",
            "      return new ControlCommand(ControlCommand.CommandType.ChoiceCount);",
            "    }",
            "    static Turns() {",
            "      return new ControlCommand(ControlCommand.CommandType.Turns);",
            "    }",
            "    static TurnsSince() {",
            "      return new ControlCommand(ControlCommand.CommandType.TurnsSince);",
            "    }",
            "    static ReadCount() {",
            "      return new ControlCommand(ControlCommand.CommandType.ReadCount);",
            "    }",
            "    static Random() {",
            "      return new ControlCommand(ControlCommand.CommandType.Random);",
            "    }",
            "    static SeedRandom() {",
            "      return new ControlCommand(ControlCommand.CommandType.SeedRandom);",
            "    }",
            "    static VisitIndex() {",
            "      return new ControlCommand(ControlCommand.CommandType.VisitIndex);",
            "    }",
            "    static SequenceShuffleIndex() {",
            "      return new ControlCommand(ControlCommand.CommandType.SequenceShuffleIndex);",
            "    }",
            "    static StartThread() {",
            "      return new ControlCommand(ControlCommand.CommandType.StartThread);",
            "    }",
            "    static Done() {",
            "      return new ControlCommand(ControlCommand.CommandType.Done);",
            "    }",
            "    static End() {",
            "      return new ControlCommand(ControlCommand.CommandType.End);",
            "    }",
            "    static ListFromInt() {",
            "      return new ControlCommand(ControlCommand.CommandType.ListFromInt);",
            "    }",
            "    static ListRange() {",
            "      return new ControlCommand(ControlCommand.CommandType.ListRange);",
            "    }",
            "    static ListRandom() {",
            "      return new ControlCommand(ControlCommand.CommandType.ListRandom);",
            "    }",
            "    static BeginTag() {",
            "      return new ControlCommand(ControlCommand.CommandType.BeginTag);",
            "    }",
            "    static EndTag() {",
            "      return new ControlCommand(ControlCommand.CommandType.EndTag);",
            "    }",
            "    toString() {",
            "      return this.commandType.toString();",
            "    }",
            "  }",
            "  (function (ControlCommand) {",
            "    (function (CommandType) {",
            "      CommandType[CommandType[\"NotSet\"] = -1] = \"NotSet\";",
            "      CommandType[CommandType[\"EvalStart\"] = 0] = \"EvalStart\";",
            "      CommandType[CommandType[\"EvalOutput\"] = 1] = \"EvalOutput\";",
            "      CommandType[CommandType[\"EvalEnd\"] = 2] = \"EvalEnd\";",
            "      CommandType[CommandType[\"Duplicate\"] = 3] = \"Duplicate\";",
            "      CommandType[CommandType[\"PopEvaluatedValue\"] = 4] = \"PopEvaluatedValue\";",
            "      CommandType[CommandType[\"PopFunction\"] = 5] = \"PopFunction\";",
            "      CommandType[CommandType[\"PopTunnel\"] = 6] = \"PopTunnel\";",
            "      CommandType[CommandType[\"BeginString\"] = 7] = \"BeginString\";",
            "      CommandType[CommandType[\"EndString\"] = 8] = \"EndString\";",
            "      CommandType[CommandType[\"NoOp\"] = 9] = \"NoOp\";",
            "      CommandType[CommandType[\"ChoiceCount\"] = 10] = \"ChoiceCount\";",
            "      CommandType[CommandType[\"Turns\"] = 11] = \"Turns\";",
            "      CommandType[CommandType[\"TurnsSince\"] = 12] = \"TurnsSince\";",
            "      CommandType[CommandType[\"ReadCount\"] = 13] = \"ReadCount\";",
            "      CommandType[CommandType[\"Random\"] = 14] = \"Random\";",
            "      CommandType[CommandType[\"SeedRandom\"] = 15] = \"SeedRandom\";",
            "      CommandType[CommandType[\"VisitIndex\"] = 16] = \"VisitIndex\";",
            "      CommandType[CommandType[\"SequenceShuffleIndex\"] = 17] = \"SequenceShuffleIndex\";",
            "      CommandType[CommandType[\"StartThread\"] = 18] = \"StartThread\";",
            "      CommandType[CommandType[\"Done\"] = 19] = \"Done\";",
            "      CommandType[CommandType[\"End\"] = 20] = \"End\";",
            "      CommandType[CommandType[\"ListFromInt\"] = 21] = \"ListFromInt\";",
            "      CommandType[CommandType[\"ListRange\"] = 22] = \"ListRange\";",
            "      CommandType[CommandType[\"ListRandom\"] = 23] = \"ListRandom\";",
            "      CommandType[CommandType[\"BeginTag\"] = 24] = \"BeginTag\";",
            "      CommandType[CommandType[\"EndTag\"] = 25] = \"EndTag\";",
            "      CommandType[CommandType[\"TOTAL_VALUES\"] = 26] = \"TOTAL_VALUES\";",
            "    })(ControlCommand.CommandType || (ControlCommand.CommandType = {}));",
            "  })(ControlCommand || (ControlCommand = {}));",
            "",
            "  class Expression extends ParsedObject {",
            "    constructor() {",
            "      super(...arguments);",
            "      this._prototypeRuntimeConstantExpression = null;",
            "      this.outputWhenComplete = false;",
            "      this.GenerateRuntimeObject = () => {",
            "        const container = new Container();",
            "        // Tell Runtime to start evaluating the following content as an expression",
            "        container.AddContent(ControlCommand.EvalStart());",
            "        this.GenerateIntoContainer(container);",
            "        // Tell Runtime to output the result of the expression evaluation to the output stream",
            "        if (this.outputWhenComplete) {",
            "          container.AddContent(ControlCommand.EvalOutput());",
            "        }",
            "        // Tell Runtime to stop evaluating the content as an expression",
            "        container.AddContent(ControlCommand.EvalEnd());",
            "        return container;",
            "      };",
            "      // When generating the value of a constant expression,",
            "      // we can't just keep generating the same constant expression into",
            "      // different places where the constant value is referenced, since then",
            "      // the same runtime objects would be used in multiple places, which",
            "      // is impossible since each runtime object should have one parent.",
            "      // Instead, we generate a prototype of the runtime object(s), then",
            "      // copy them each time they're used.",
            "      this.GenerateConstantIntoContainer = container => {",
            "        if (this._prototypeRuntimeConstantExpression === null) {",
            "          this._prototypeRuntimeConstantExpression = new Container();",
            "          this.GenerateIntoContainer(this._prototypeRuntimeConstantExpression);",
            "        }",
            "        for (const runtimeObj of this._prototypeRuntimeConstantExpression.content) {",
            "          const copy = runtimeObj.Copy();",
            "          if (copy) {",
            "            container.AddContent(copy);",
            "          }",
            "        }",
            "      };",
            "      this.toString = () => \"No string value in JavaScript.\";",
            "    }",
            "    get typeName() {",
            "      return \"Expression\";",
            "    }",
            "    Equals(obj) {",
            "      return false;",
            "    }",
            "  }",
            "",
            "  class Void extends InkObject {}",
            "",
            "  class NativeFunctionCall extends InkObject {",
            "    static CallWithName(functionName) {",
            "      return new NativeFunctionCall(functionName);",
            "    }",
            "    static CallExistsWithName(functionName) {",
            "      this.GenerateNativeFunctionsIfNecessary();",
            "      return this._nativeFunctions.get(functionName);",
            "    }",
            "    get name() {",
            "      if (this._name === null) return throwNullException(\"NativeFunctionCall._name\");",
            "      return this._name;",
            "    }",
            "    set name(value) {",
            "      this._name = value;",
            "      if (!this._isPrototype) {",
            "        if (NativeFunctionCall._nativeFunctions === null) throwNullException(\"NativeFunctionCall._nativeFunctions\");else this._prototype = NativeFunctionCall._nativeFunctions.get(this._name) || null;",
            "      }",
            "    }",
            "    get numberOfParameters() {",
            "      if (this._prototype) {",
            "        return this._prototype.numberOfParameters;",
            "      } else {",
            "        return this._numberOfParameters;",
            "      }",
            "    }",
            "    set numberOfParameters(value) {",
            "      this._numberOfParameters = value;",
            "    }",
            "    Call(parameters) {",
            "      if (this._prototype) {",
            "        return this._prototype.Call(parameters);",
            "      }",
            "      if (this.numberOfParameters != parameters.length) {",
            "        throw new Error(\"Unexpected number of parameters\");",
            "      }",
            "      let hasList = false;",
            "      for (let p of parameters) {",
            "        if (p instanceof Void) throw new StoryException('Attempting to perform operation on a void value. Did you forget to \"return\" a value from a function you called here?');",
            "        if (p instanceof ListValue) hasList = true;",
            "      }",
            "      if (parameters.length == 2 && hasList) {",
            "        return this.CallBinaryListOperation(parameters);",
            "      }",
            "      let coercedParams = this.CoerceValuesToSingleType(parameters);",
            "      let coercedType = coercedParams[0].valueType;",
            "      if (coercedType == ValueType.Int) {",
            "        return this.CallType(coercedParams);",
            "      } else if (coercedType == ValueType.Float) {",
            "        return this.CallType(coercedParams);",
            "      } else if (coercedType == ValueType.String) {",
            "        return this.CallType(coercedParams);",
            "      } else if (coercedType == ValueType.DivertTarget) {",
            "        return this.CallType(coercedParams);",
            "      } else if (coercedType == ValueType.List) {",
            "        return this.CallType(coercedParams);",
            "      }",
            "      return null;",
            "    }",
            "    CallType(parametersOfSingleType) {",
            "      let param1 = asOrThrows(parametersOfSingleType[0], Value);",
            "      let valType = param1.valueType;",
            "      let val1 = param1;",
            "      let paramCount = parametersOfSingleType.length;",
            "      if (paramCount == 2 || paramCount == 1) {",
            "        if (this._operationFuncs === null) return throwNullException(\"NativeFunctionCall._operationFuncs\");",
            "        let opForTypeObj = this._operationFuncs.get(valType);",
            "        if (!opForTypeObj) {",
            "          const key = ValueType[valType];",
            "          throw new StoryException(\"Cannot perform operation \" + this.name + \" on \" + key);",
            "        }",
            "        if (paramCount == 2) {",
            "          let param2 = asOrThrows(parametersOfSingleType[1], Value);",
            "          let val2 = param2;",
            "          let opForType = opForTypeObj;",
            "          if (val1.value === null || val2.value === null) return throwNullException(\"NativeFunctionCall.Call BinaryOp values\");",
            "          let resultVal = opForType(val1.value, val2.value);",
            "          return Value.Create(resultVal);",
            "        } else {",
            "          let opForType = opForTypeObj;",
            "          if (val1.value === null) return throwNullException(\"NativeFunctionCall.Call UnaryOp value\");",
            "          let resultVal = opForType(val1.value);",
            "          // This code is different from upstream. Since JavaScript treats",
            "          // integers and floats as the same numbers, it's impossible",
            "          // to force an number to be either an integer or a float.",
            "          //",
            "          // It can be useful to force a specific number type",
            "          // (especially for divisions), so the result of INT() & FLOAT()",
            "          // is coerced to the the proper value type.",
            "          //",
            "          // Note that we also force all other unary operation to",
            "          // return the same value type, although this is only",
            "          // meaningful for numbers. See `Value.Create`.",
            "          if (this.name === NativeFunctionCall.Int) {",
            "            return Value.Create(resultVal, ValueType.Int);",
            "          } else if (this.name === NativeFunctionCall.Float) {",
            "            return Value.Create(resultVal, ValueType.Float);",
            "          } else {",
            "            return Value.Create(resultVal, param1.valueType);",
            "          }",
            "        }",
            "      } else {",
            "        throw new Error(\"Unexpected number of parameters to NativeFunctionCall: \" + parametersOfSingleType.length);",
            "      }",
            "    }",
            "    CallBinaryListOperation(parameters) {",
            "      if ((this.name == \"+\" || this.name == \"-\") && parameters[0] instanceof ListValue && parameters[1] instanceof IntValue) return this.CallListIncrementOperation(parameters);",
            "      let v1 = asOrThrows(parameters[0], Value);",
            "      let v2 = asOrThrows(parameters[1], Value);",
            "      if ((this.name == \"&&\" || this.name == \"||\") && (v1.valueType != ValueType.List || v2.valueType != ValueType.List)) {",
            "        if (this._operationFuncs === null) return throwNullException(\"NativeFunctionCall._operationFuncs\");",
            "        let op = this._operationFuncs.get(ValueType.Int);",
            "        if (op === null) return throwNullException(\"NativeFunctionCall.CallBinaryListOperation op\");",
            "        let result = asBooleanOrThrows(op(v1.isTruthy ? 1 : 0, v2.isTruthy ? 1 : 0));",
            "        return new BoolValue(result);",
            "      }",
            "      if (v1.valueType == ValueType.List && v2.valueType == ValueType.List) return this.CallType([v1, v2]);",
            "      throw new StoryException(\"Can not call use \" + this.name + \" operation on \" + ValueType[v1.valueType] + \" and \" + ValueType[v2.valueType]);",
            "    }",
            "    CallListIncrementOperation(listIntParams) {",
            "      let listVal = asOrThrows(listIntParams[0], ListValue);",
            "      let intVal = asOrThrows(listIntParams[1], IntValue);",
            "      let resultInkList = new InkList();",
            "      if (listVal.value === null) return throwNullException(\"NativeFunctionCall.CallListIncrementOperation listVal.value\");",
            "      for (let [listItemKey, listItemValue] of listVal.value) {",
            "        let listItem = InkListItem.fromSerializedKey(listItemKey);",
            "        if (this._operationFuncs === null) return throwNullException(\"NativeFunctionCall._operationFuncs\");",
            "        let intOp = this._operationFuncs.get(ValueType.Int);",
            "        if (intVal.value === null) return throwNullException(\"NativeFunctionCall.CallListIncrementOperation intVal.value\");",
            "        let targetInt = intOp(listItemValue, intVal.value);",
            "        let itemOrigin = null;",
            "        if (listVal.value.origins === null) return throwNullException(\"NativeFunctionCall.CallListIncrementOperation listVal.value.origins\");",
            "        for (let origin of listVal.value.origins) {",
            "          if (origin.name == listItem.originName) {",
            "            itemOrigin = origin;",
            "            break;",
            "          }",
            "        }",
            "        if (itemOrigin != null) {",
            "          let incrementedItem = itemOrigin.TryGetItemWithValue(targetInt, InkListItem.Null);",
            "          if (incrementedItem.exists) resultInkList.Add(incrementedItem.result, targetInt);",
            "        }",
            "      }",
            "      return new ListValue(resultInkList);",
            "    }",
            "    CoerceValuesToSingleType(parametersIn) {",
            "      let valType = ValueType.Int;",
            "      let specialCaseList = null;",
            "      for (let obj of parametersIn) {",
            "        let val = asOrThrows(obj, Value);",
            "        if (val.valueType > valType) {",
            "          valType = val.valueType;",
            "        }",
            "        if (val.valueType == ValueType.List) {",
            "          specialCaseList = asOrNull(val, ListValue);",
            "        }",
            "      }",
            "      let parametersOut = [];",
            "      if (ValueType[valType] == ValueType[ValueType.List]) {",
            "        for (let inkObjectVal of parametersIn) {",
            "          let val = asOrThrows(inkObjectVal, Value);",
            "          if (val.valueType == ValueType.List) {",
            "            parametersOut.push(val);",
            "          } else if (val.valueType == ValueType.Int) {",
            "            let intVal = parseInt(val.valueObject);",
            "            specialCaseList = asOrThrows(specialCaseList, ListValue);",
            "            if (specialCaseList.value === null) return throwNullException(\"NativeFunctionCall.CoerceValuesToSingleType specialCaseList.value\");",
            "            let list = specialCaseList.value.originOfMaxItem;",
            "            if (list === null) return throwNullException(\"NativeFunctionCall.CoerceValuesToSingleType list\");",
            "            let item = list.TryGetItemWithValue(intVal, InkListItem.Null);",
            "            if (item.exists) {",
            "              let castedValue = new ListValue(item.result, intVal);",
            "              parametersOut.push(castedValue);",
            "            } else throw new StoryException(\"Could not find List item with the value \" + intVal + \" in \" + list.name);",
            "          } else {",
            "            const key = ValueType[val.valueType];",
            "            throw new StoryException(\"Cannot mix Lists and \" + key + \" values in this operation\");",
            "          }",
            "        }",
            "      } else {",
            "        for (let inkObjectVal of parametersIn) {",
            "          let val = asOrThrows(inkObjectVal, Value);",
            "          let castedValue = val.Cast(valType);",
            "          parametersOut.push(castedValue);",
            "        }",
            "      }",
            "      return parametersOut;",
            "    }",
            "    constructor() {",
            "      super();",
            "      this._name = null;",
            "      this._numberOfParameters = 0;",
            "      this._prototype = null;",
            "      this._isPrototype = false;",
            "      this._operationFuncs = null;",
            "      if (arguments.length === 0) {",
            "        NativeFunctionCall.GenerateNativeFunctionsIfNecessary();",
            "      } else if (arguments.length === 1) {",
            "        let name = arguments[0];",
            "        NativeFunctionCall.GenerateNativeFunctionsIfNecessary();",
            "        this.name = name;",
            "      } else if (arguments.length === 2) {",
            "        let name = arguments[0];",
            "        let numberOfParameters = arguments[1];",
            "        this._isPrototype = true;",
            "        this.name = name;",
            "        this.numberOfParameters = numberOfParameters;",
            "      }",
            "    }",
            "    static Identity(t) {",
            "      return t;",
            "    }",
            "    static GenerateNativeFunctionsIfNecessary() {",
            "      if (this._nativeFunctions == null) {",
            "        this._nativeFunctions = new Map();",
            "        // Int operations",
            "        this.AddIntBinaryOp(this.Add, (x, y) => x + y);",
            "        this.AddIntBinaryOp(this.Subtract, (x, y) => x - y);",
            "        this.AddIntBinaryOp(this.Multiply, (x, y) => x * y);",
            "        this.AddIntBinaryOp(this.Divide, (x, y) => Math.floor(x / y));",
            "        this.AddIntBinaryOp(this.Mod, (x, y) => x % y);",
            "        this.AddIntUnaryOp(this.Negate, x => -x);",
            "        this.AddIntBinaryOp(this.Equal, (x, y) => x == y);",
            "        this.AddIntBinaryOp(this.Greater, (x, y) => x > y);",
            "        this.AddIntBinaryOp(this.Less, (x, y) => x < y);",
            "        this.AddIntBinaryOp(this.GreaterThanOrEquals, (x, y) => x >= y);",
            "        this.AddIntBinaryOp(this.LessThanOrEquals, (x, y) => x <= y);",
            "        this.AddIntBinaryOp(this.NotEquals, (x, y) => x != y);",
            "        this.AddIntUnaryOp(this.Not, x => x == 0);",
            "        this.AddIntBinaryOp(this.And, (x, y) => x != 0 && y != 0);",
            "        this.AddIntBinaryOp(this.Or, (x, y) => x != 0 || y != 0);",
            "        this.AddIntBinaryOp(this.Max, (x, y) => Math.max(x, y));",
            "        this.AddIntBinaryOp(this.Min, (x, y) => Math.min(x, y));",
            "        this.AddIntBinaryOp(this.Pow, (x, y) => Math.pow(x, y));",
            "        this.AddIntUnaryOp(this.Floor, NativeFunctionCall.Identity);",
            "        this.AddIntUnaryOp(this.Ceiling, NativeFunctionCall.Identity);",
            "        this.AddIntUnaryOp(this.Int, NativeFunctionCall.Identity);",
            "        this.AddIntUnaryOp(this.Float, x => x);",
            "        // Float operations",
            "        this.AddFloatBinaryOp(this.Add, (x, y) => x + y);",
            "        this.AddFloatBinaryOp(this.Subtract, (x, y) => x - y);",
            "        this.AddFloatBinaryOp(this.Multiply, (x, y) => x * y);",
            "        this.AddFloatBinaryOp(this.Divide, (x, y) => x / y);",
            "        this.AddFloatBinaryOp(this.Mod, (x, y) => x % y);",
            "        this.AddFloatUnaryOp(this.Negate, x => -x);",
            "        this.AddFloatBinaryOp(this.Equal, (x, y) => x == y);",
            "        this.AddFloatBinaryOp(this.Greater, (x, y) => x > y);",
            "        this.AddFloatBinaryOp(this.Less, (x, y) => x < y);",
            "        this.AddFloatBinaryOp(this.GreaterThanOrEquals, (x, y) => x >= y);",
            "        this.AddFloatBinaryOp(this.LessThanOrEquals, (x, y) => x <= y);",
            "        this.AddFloatBinaryOp(this.NotEquals, (x, y) => x != y);",
            "        this.AddFloatUnaryOp(this.Not, x => x == 0.0);",
            "        this.AddFloatBinaryOp(this.And, (x, y) => x != 0.0 && y != 0.0);",
            "        this.AddFloatBinaryOp(this.Or, (x, y) => x != 0.0 || y != 0.0);",
            "        this.AddFloatBinaryOp(this.Max, (x, y) => Math.max(x, y));",
            "        this.AddFloatBinaryOp(this.Min, (x, y) => Math.min(x, y));",
            "        this.AddFloatBinaryOp(this.Pow, (x, y) => Math.pow(x, y));",
            "        this.AddFloatUnaryOp(this.Floor, x => Math.floor(x));",
            "        this.AddFloatUnaryOp(this.Ceiling, x => Math.ceil(x));",
            "        this.AddFloatUnaryOp(this.Int, x => Math.floor(x));",
            "        this.AddFloatUnaryOp(this.Float, NativeFunctionCall.Identity);",
            "        // String operations",
            "        this.AddStringBinaryOp(this.Add, (x, y) => x + y); // concat",
            "        this.AddStringBinaryOp(this.Equal, (x, y) => x === y);",
            "        this.AddStringBinaryOp(this.NotEquals, (x, y) => !(x === y));",
            "        this.AddStringBinaryOp(this.Has, (x, y) => x.includes(y));",
            "        this.AddStringBinaryOp(this.Hasnt, (x, y) => !x.includes(y));",
            "        this.AddListBinaryOp(this.Add, (x, y) => x.Union(y));",
            "        this.AddListBinaryOp(this.Subtract, (x, y) => x.Without(y));",
            "        this.AddListBinaryOp(this.Has, (x, y) => x.Contains(y));",
            "        this.AddListBinaryOp(this.Hasnt, (x, y) => !x.Contains(y));",
            "        this.AddListBinaryOp(this.Intersect, (x, y) => x.Intersect(y));",
            "        this.AddListBinaryOp(this.Equal, (x, y) => x.Equals(y));",
            "        this.AddListBinaryOp(this.Greater, (x, y) => x.GreaterThan(y));",
            "        this.AddListBinaryOp(this.Less, (x, y) => x.LessThan(y));",
            "        this.AddListBinaryOp(this.GreaterThanOrEquals, (x, y) => x.GreaterThanOrEquals(y));",
            "        this.AddListBinaryOp(this.LessThanOrEquals, (x, y) => x.LessThanOrEquals(y));",
            "        this.AddListBinaryOp(this.NotEquals, (x, y) => !x.Equals(y));",
            "        this.AddListBinaryOp(this.And, (x, y) => x.Count > 0 && y.Count > 0);",
            "        this.AddListBinaryOp(this.Or, (x, y) => x.Count > 0 || y.Count > 0);",
            "        this.AddListUnaryOp(this.Not, x => x.Count == 0 ? 1 : 0);",
            "        this.AddListUnaryOp(this.Invert, x => x.inverse);",
            "        this.AddListUnaryOp(this.All, x => x.all);",
            "        this.AddListUnaryOp(this.ListMin, x => x.MinAsList());",
            "        this.AddListUnaryOp(this.ListMax, x => x.MaxAsList());",
            "        this.AddListUnaryOp(this.Count, x => x.Count);",
            "        this.AddListUnaryOp(this.ValueOfList, x => x.maxItem.Value);",
            "        let divertTargetsEqual = (d1, d2) => d1.Equals(d2);",
            "        let divertTargetsNotEqual = (d1, d2) => !d1.Equals(d2);",
            "        this.AddOpToNativeFunc(this.Equal, 2, ValueType.DivertTarget, divertTargetsEqual);",
            "        this.AddOpToNativeFunc(this.NotEquals, 2, ValueType.DivertTarget, divertTargetsNotEqual);",
            "      }",
            "    }",
            "    AddOpFuncForType(valType, op) {",
            "      if (this._operationFuncs == null) {",
            "        this._operationFuncs = new Map();",
            "      }",
            "      this._operationFuncs.set(valType, op);",
            "    }",
            "    static AddOpToNativeFunc(name, args, valType, op) {",
            "      if (this._nativeFunctions === null) return throwNullException(\"NativeFunctionCall._nativeFunctions\");",
            "      let nativeFunc = this._nativeFunctions.get(name);",
            "      if (!nativeFunc) {",
            "        nativeFunc = new NativeFunctionCall(name, args);",
            "        this._nativeFunctions.set(name, nativeFunc);",
            "      }",
            "      nativeFunc.AddOpFuncForType(valType, op);",
            "    }",
            "    static AddIntBinaryOp(name, op) {",
            "      this.AddOpToNativeFunc(name, 2, ValueType.Int, op);",
            "    }",
            "    static AddIntUnaryOp(name, op) {",
            "      this.AddOpToNativeFunc(name, 1, ValueType.Int, op);",
            "    }",
            "    static AddFloatBinaryOp(name, op) {",
            "      this.AddOpToNativeFunc(name, 2, ValueType.Float, op);",
            "    }",
            "    static AddFloatUnaryOp(name, op) {",
            "      this.AddOpToNativeFunc(name, 1, ValueType.Float, op);",
            "    }",
            "    static AddStringBinaryOp(name, op) {",
            "      this.AddOpToNativeFunc(name, 2, ValueType.String, op);",
            "    }",
            "    static AddListBinaryOp(name, op) {",
            "      this.AddOpToNativeFunc(name, 2, ValueType.List, op);",
            "    }",
            "    static AddListUnaryOp(name, op) {",
            "      this.AddOpToNativeFunc(name, 1, ValueType.List, op);",
            "    }",
            "    toString() {",
            "      return 'Native \"' + this.name + '\"';",
            "    }",
            "  }",
            "  NativeFunctionCall.Add = \"+\";",
            "  NativeFunctionCall.Subtract = \"-\";",
            "  NativeFunctionCall.Divide = \"/\";",
            "  NativeFunctionCall.Multiply = \"*\";",
            "  NativeFunctionCall.Mod = \"%\";",
            "  NativeFunctionCall.Negate = \"_\";",
            "  NativeFunctionCall.Equal = \"==\";",
            "  NativeFunctionCall.Greater = \">\";",
            "  NativeFunctionCall.Less = \"<\";",
            "  NativeFunctionCall.GreaterThanOrEquals = \">=\";",
            "  NativeFunctionCall.LessThanOrEquals = \"<=\";",
            "  NativeFunctionCall.NotEquals = \"!=\";",
            "  NativeFunctionCall.Not = \"!\";",
            "  NativeFunctionCall.And = \"&&\";",
            "  NativeFunctionCall.Or = \"||\";",
            "  NativeFunctionCall.Min = \"MIN\";",
            "  NativeFunctionCall.Max = \"MAX\";",
            "  NativeFunctionCall.Pow = \"POW\";",
            "  NativeFunctionCall.Floor = \"FLOOR\";",
            "  NativeFunctionCall.Ceiling = \"CEILING\";",
            "  NativeFunctionCall.Int = \"INT\";",
            "  NativeFunctionCall.Float = \"FLOAT\";",
            "  NativeFunctionCall.Has = \"?\";",
            "  NativeFunctionCall.Hasnt = \"!?\";",
            "  NativeFunctionCall.Intersect = \"^\";",
            "  NativeFunctionCall.ListMin = \"LIST_MIN\";",
            "  NativeFunctionCall.ListMax = \"LIST_MAX\";",
            "  NativeFunctionCall.All = \"LIST_ALL\";",
            "  NativeFunctionCall.Count = \"LIST_COUNT\";",
            "  NativeFunctionCall.ValueOfList = \"LIST_VALUE\";",
            "  NativeFunctionCall.Invert = \"LIST_INVERT\";",
            "  NativeFunctionCall._nativeFunctions = null;",
            "",
            "  // This class is named Number in the C# codebase",
            "  // but this conflict with the built-in Number class",
            "  class NumberExpression extends Expression {",
            "    constructor(value, subtype) {",
            "      super();",
            "      this.isInt = () => this.subtype == \"int\";",
            "      this.isFloat = () => this.subtype == \"float\";",
            "      this.isBool = () => this.subtype == \"bool\";",
            "      this.GenerateIntoContainer = container => {",
            "        if (this.isInt()) {",
            "          container.AddContent(new IntValue(this.value));",
            "        } else if (this.isFloat()) {",
            "          container.AddContent(new FloatValue(this.value));",
            "        } else if (this.isBool()) {",
            "          container.AddContent(new BoolValue(this.value));",
            "        }",
            "      };",
            "      this.toString = () => String(this.value);",
            "      if (typeof value === \"number\" && !Number.isNaN(value) || typeof value == \"boolean\") {",
            "        this.value = value;",
            "        this.subtype = subtype;",
            "      } else {",
            "        throw new Error(\"Unexpected object type in NumberExpression.\");",
            "      }",
            "    }",
            "    get typeName() {",
            "      return \"Number\";",
            "    }",
            "    Equals(obj) {",
            "      const numberExpression = asOrNull(obj, NumberExpression);",
            "      if (!numberExpression) return false;",
            "      return numberExpression.subtype == this.subtype && numberExpression.value == this.value;",
            "    }",
            "  }",
            "",
            "  class UnaryExpression extends Expression {",
            "    get nativeNameForOp() {",
            "      // Replace \"-\" with \"_\" to make it unique (compared to subtraction)",
            "      if (this.op === \"-\") {",
            "        return \"_\";",
            "      } else if (this.op === \"not\") {",
            "        return \"!\";",
            "      }",
            "      return this.op;",
            "    }",
            "    constructor(inner, op) {",
            "      super();",
            "      this.op = op;",
            "      this.GenerateIntoContainer = container => {",
            "        this.innerExpression.GenerateIntoContainer(container);",
            "        container.AddContent(NativeFunctionCall.CallWithName(this.nativeNameForOp));",
            "      };",
            "      this.toString = () => this.nativeNameForOp + this.innerExpression;",
            "      this.innerExpression = this.AddContent(inner);",
            "    }",
            "    get typeName() {",
            "      return \"UnaryExpression\";",
            "    }",
            "  }",
            "  // Attempt to flatten inner expression immediately",
            "  // e.g. convert (-(5)) into (-5)",
            "  UnaryExpression.WithInner = (inner, op) => {",
            "    const innerNumber = asOrNull(inner, NumberExpression);",
            "    if (innerNumber) {",
            "      if (op === \"-\") {",
            "        if (innerNumber.isInt()) {",
            "          return new NumberExpression(-innerNumber.value, \"int\");",
            "        } else if (innerNumber.isFloat()) {",
            "          return new NumberExpression(-innerNumber.value, \"float\");",
            "        }",
            "      } else if (op == \"!\" || op == \"not\") {",
            "        if (innerNumber.isInt()) {",
            "          return new NumberExpression(innerNumber.value == 0, \"bool\");",
            "        } else if (innerNumber.isFloat()) {",
            "          return new NumberExpression(innerNumber.value == 0.0, \"bool\");",
            "        } else if (innerNumber.isBool()) {",
            "          return new NumberExpression(!innerNumber.value, \"bool\");",
            "        }",
            "      }",
            "      throw new Error(\"Unexpected operation or number type\");",
            "    }",
            "    // Normal fallback",
            "    const unary = new UnaryExpression(inner, op);",
            "    return unary;",
            "  };",
            "",
            "  class BinaryExpression extends Expression {",
            "    constructor(left, right, opName) {",
            "      super();",
            "      this.opName = opName;",
            "      this.GenerateIntoContainer = container => {",
            "        this.leftExpression.GenerateIntoContainer(container);",
            "        this.rightExpression.GenerateIntoContainer(container);",
            "        this.opName = this.NativeNameForOp(this.opName);",
            "        container.AddContent(NativeFunctionCall.CallWithName(this.opName));",
            "      };",
            "      this.NativeNameForOp = opName => {",
            "        if (opName === \"and\") {",
            "          return \"&&\";",
            "        } else if (opName === \"or\") {",
            "          return \"||\";",
            "        } else if (opName === \"mod\") {",
            "          return \"%\";",
            "        } else if (opName === \"has\") {",
            "          return \"?\";",
            "        } else if (opName === \"hasnt\") {",
            "          return \"!?\";",
            "        }",
            "        return opName;",
            "      };",
            "      this.toString = () => `(${this.leftExpression} ${this.opName} ${this.rightExpression})`;",
            "      this.leftExpression = this.AddContent(left);",
            "      this.rightExpression = this.AddContent(right);",
            "      this.opName = opName;",
            "    }",
            "    get typeName() {",
            "      return \"BinaryExpression\";",
            "    }",
            "    ResolveReferences(context) {",
            "      super.ResolveReferences(context);",
            "      // Check for the following case:",
            "      //",
            "      //    (not A) ? B",
            "      //",
            "      // Since this easy to accidentally do:",
            "      //",
            "      //    not A ? B",
            "      //",
            "      // when you intend:",
            "      //",
            "      //    not (A ? B)",
            "      if (this.NativeNameForOp(this.opName) === \"?\") {",
            "        const leftUnary = asOrNull(this.leftExpression, UnaryExpression);",
            "        if (leftUnary !== null && (leftUnary.op === \"not\" || leftUnary.op === \"!\")) {",
            "          this.Error(`Using 'not' or '!' here negates '${leftUnary.innerExpression}' rather than the result of the '?' or 'has' operator. You need to add parentheses around the (A ? B) expression.`);",
            "        }",
            "      }",
            "    }",
            "  }",
            "",
            "  class CharacterSet {",
            "    constructor(arg) {",
            "      this.set = new Set();",
            "      this.Add = arg => this.set.add(arg);",
            "      this.AddRange = (start, end) => {",
            "        for (let c = start.charCodeAt(0); c <= end.charCodeAt(0); ++c) {",
            "          this.Add(String.fromCharCode(c));",
            "        }",
            "        return this;",
            "      };",
            "      this.AddCharacters = chars => {",
            "        if (typeof chars === \"string\" || Array.isArray(chars)) {",
            "          for (const c of chars) {",
            "            this.Add(c);",
            "          }",
            "        } else {",
            "          for (const c of chars.set) {",
            "            this.Add(c);",
            "          }",
            "        }",
            "        return this;",
            "      };",
            "      if (arg) {",
            "        this.AddCharacters(arg);",
            "      }",
            "    }",
            "  }",
            "  CharacterSet.FromRange = (start, end) => new CharacterSet().AddRange(start, end);",
            "",
            "  /// <summary>",
            "  /// A class representing a character range. Allows for lazy-loading a corresponding <see cref=\"CharacterSet\">character set</see>.",
            "  /// </summary>",
            "  class CharacterRange {",
            "    constructor(_start, _end) {",
            "      let excludes = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [];",
            "      this._start = _start;",
            "      this._end = _end;",
            "      this._correspondingCharSet = new CharacterSet();",
            "      this._excludes = new Set();",
            "      /// <summary>",
            "      /// Returns a <see cref=\"CharacterSet\">character set</see> instance corresponding to the character range",
            "      /// represented by the current instance.",
            "      /// </summary>",
            "      /// <remarks>",
            "      /// The internal character set is created once and cached in memory.",
            "      /// </remarks>",
            "      /// <returns>The char set.</returns>",
            "      this.ToCharacterSet = () => {",
            "        if (this._correspondingCharSet.set.size === 0) {",
            "          for (let ii = this.start.charCodeAt(0), c; ii <= this.end.charCodeAt(0); ii += 1) {",
            "            c = String.fromCharCode(ii);",
            "            if (!this._excludes.has(c)) {",
            "              this._correspondingCharSet.AddCharacters(c);",
            "            }",
            "          }",
            "        }",
            "        return this._correspondingCharSet;",
            "      };",
            "      if (excludes instanceof CharacterSet) {",
            "        this._excludes = excludes.set;",
            "      } else {",
            "        for (const item of excludes) {",
            "          this._excludes.add(item);",
            "        }",
            "      }",
            "    }",
            "    get start() {",
            "      return this._start;",
            "    }",
            "    get end() {",
            "      return this._end;",
            "    }",
            "  }",
            "  CharacterRange.Define = function (start, end) {",
            "    let excludes = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [];",
            "    return new CharacterRange(start, end, excludes);",
            "  };",
            "",
            "  class ChoicePoint extends InkObject {",
            "    constructor() {",
            "      let onceOnly = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;",
            "      super();",
            "      this._pathOnChoice = null;",
            "      this.hasCondition = false;",
            "      this.hasStartContent = false;",
            "      this.hasChoiceOnlyContent = false;",
            "      this.isInvisibleDefault = false;",
            "      this.onceOnly = true;",
            "      this.onceOnly = onceOnly;",
            "    }",
            "    get pathOnChoice() {",
            "      if (this._pathOnChoice != null && this._pathOnChoice.isRelative) {",
            "        let choiceTargetObj = this.choiceTarget;",
            "        if (choiceTargetObj) {",
            "          this._pathOnChoice = choiceTargetObj.path;",
            "        }",
            "      }",
            "      return this._pathOnChoice;",
            "    }",
            "    set pathOnChoice(value) {",
            "      this._pathOnChoice = value;",
            "    }",
            "    get choiceTarget() {",
            "      if (this._pathOnChoice === null) return throwNullException(\"ChoicePoint._pathOnChoice\");",
            "      return this.ResolvePath(this._pathOnChoice).container;",
            "    }",
            "    get pathStringOnChoice() {",
            "      if (this.pathOnChoice === null) return throwNullException(\"ChoicePoint.pathOnChoice\");",
            "      return this.CompactPathString(this.pathOnChoice);",
            "    }",
            "    set pathStringOnChoice(value) {",
            "      this.pathOnChoice = new Path$1(value);",
            "    }",
            "    get flags() {",
            "      let flags = 0;",
            "      if (this.hasCondition) flags |= 1;",
            "      if (this.hasStartContent) flags |= 2;",
            "      if (this.hasChoiceOnlyContent) flags |= 4;",
            "      if (this.isInvisibleDefault) flags |= 8;",
            "      if (this.onceOnly) flags |= 16;",
            "      return flags;",
            "    }",
            "    set flags(value) {",
            "      this.hasCondition = (value & 1) > 0;",
            "      this.hasStartContent = (value & 2) > 0;",
            "      this.hasChoiceOnlyContent = (value & 4) > 0;",
            "      this.isInvisibleDefault = (value & 8) > 0;",
            "      this.onceOnly = (value & 16) > 0;",
            "    }",
            "    toString() {",
            "      if (this.pathOnChoice === null) return throwNullException(\"ChoicePoint.pathOnChoice\");",
            "      let targetString = this.pathOnChoice.toString();",
            "      return \"Choice: -> \" + targetString;",
            "    }",
            "  }",
            "",
            "  var PushPopType;",
            "  (function (PushPopType) {",
            "    PushPopType[PushPopType[\"Tunnel\"] = 0] = \"Tunnel\";",
            "    PushPopType[PushPopType[\"Function\"] = 1] = \"Function\";",
            "    PushPopType[PushPopType[\"FunctionEvaluationFromGame\"] = 2] = \"FunctionEvaluationFromGame\";",
            "  })(PushPopType || (PushPopType = {}));",
            "",
            "  class Pointer {",
            "    constructor() {",
            "      this.container = null;",
            "      this.index = -1;",
            "      if (arguments.length === 2) {",
            "        this.container = arguments[0];",
            "        this.index = arguments[1];",
            "      }",
            "    }",
            "    Resolve() {",
            "      if (this.index < 0) return this.container;",
            "      if (this.container == null) return null;",
            "      if (this.container.content.length == 0) return this.container;",
            "      if (this.index >= this.container.content.length) return null;",
            "      return this.container.content[this.index];",
            "    }",
            "    get isNull() {",
            "      return this.container == null;",
            "    }",
            "    get path() {",
            "      if (this.isNull) return null;",
            "      if (this.index >= 0) return this.container.path.PathByAppendingComponent(new Path$1.Component(this.index));else return this.container.path;",
            "    }",
            "    toString() {",
            "      if (!this.container) return \"Ink Pointer (null)\";",
            "      return \"Ink Pointer -> \" + this.container.path.toString() + \" -- index \" + this.index;",
            "    }",
            "    // This method does not exist in the original C# code, but is here to maintain the",
            "    // value semantics of Pointer.",
            "    copy() {",
            "      return new Pointer(this.container, this.index);",
            "    }",
            "    static StartOf(container) {",
            "      return new Pointer(container, 0);",
            "    }",
            "    static get Null() {",
            "      return new Pointer(null, -1);",
            "    }",
            "  }",
            "",
            "  class Divert$1 extends InkObject {",
            "    get targetPath() {",
            "      if (this._targetPath != null && this._targetPath.isRelative) {",
            "        let targetObj = this.targetPointer.Resolve();",
            "        if (targetObj) {",
            "          this._targetPath = targetObj.path;",
            "        }",
            "      }",
            "      return this._targetPath;",
            "    }",
            "    set targetPath(value) {",
            "      this._targetPath = value;",
            "      this._targetPointer = Pointer.Null;",
            "    }",
            "    get targetPointer() {",
            "      if (this._targetPointer.isNull) {",
            "        let targetObj = this.ResolvePath(this._targetPath).obj;",
            "        if (this._targetPath === null) return throwNullException(\"this._targetPath\");",
            "        if (this._targetPath.lastComponent === null) return throwNullException(\"this._targetPath.lastComponent\");",
            "        if (this._targetPath.lastComponent.isIndex) {",
            "          if (targetObj === null) return throwNullException(\"targetObj\");",
            "          this._targetPointer.container = targetObj.parent instanceof Container ? targetObj.parent : null;",
            "          this._targetPointer.index = this._targetPath.lastComponent.index;",
            "        } else {",
            "          this._targetPointer = Pointer.StartOf(targetObj instanceof Container ? targetObj : null);",
            "        }",
            "      }",
            "      return this._targetPointer.copy();",
            "    }",
            "    get targetPathString() {",
            "      if (this.targetPath == null) return null;",
            "      return this.CompactPathString(this.targetPath);",
            "    }",
            "    set targetPathString(value) {",
            "      if (value == null) {",
            "        this.targetPath = null;",
            "      } else {",
            "        this.targetPath = new Path$1(value);",
            "      }",
            "    }",
            "    get hasVariableTarget() {",
            "      return this.variableDivertName != null;",
            "    }",
            "    constructor(stackPushType) {",
            "      super();",
            "      this._targetPath = null;",
            "      this._targetPointer = Pointer.Null;",
            "      this.variableDivertName = null;",
            "      this.pushesToStack = false;",
            "      this.stackPushType = 0;",
            "      this.isExternal = false;",
            "      this.externalArgs = 0;",
            "      this.isConditional = false;",
            "      this.pushesToStack = false;",
            "      if (typeof stackPushType !== \"undefined\") {",
            "        this.pushesToStack = true;",
            "        this.stackPushType = stackPushType;",
            "      }",
            "    }",
            "    Equals(obj) {",
            "      let otherDivert = obj;",
            "      if (otherDivert instanceof Divert$1) {",
            "        if (this.hasVariableTarget == otherDivert.hasVariableTarget) {",
            "          if (this.hasVariableTarget) {",
            "            return this.variableDivertName == otherDivert.variableDivertName;",
            "          } else {",
            "            if (this.targetPath === null) return throwNullException(\"this.targetPath\");",
            "            return this.targetPath.Equals(otherDivert.targetPath);",
            "          }",
            "        }",
            "      }",
            "      return false;",
            "    }",
            "    toString() {",
            "      if (this.hasVariableTarget) {",
            "        return \"Divert(variable: \" + this.variableDivertName + \")\";",
            "      } else if (this.targetPath == null) {",
            "        return \"Divert(null)\";",
            "      } else {",
            "        let sb = new StringBuilder();",
            "        let targetStr = this.targetPath.toString();",
            "        sb.Append(\"Divert\");",
            "        if (this.isConditional) sb.Append(\"?\");",
            "        if (this.pushesToStack) {",
            "          if (this.stackPushType == PushPopType.Function) {",
            "            sb.Append(\" function\");",
            "          } else {",
            "            sb.Append(\" tunnel\");",
            "          }",
            "        }",
            "        sb.Append(\" -> \");",
            "        sb.Append(this.targetPathString);",
            "        sb.Append(\" (\");",
            "        sb.Append(targetStr);",
            "        sb.Append(\")\");",
            "        return sb.toString();",
            "      }",
            "    }",
            "  }",
            "",
            "  var SymbolType;",
            "  (function (SymbolType) {",
            "    SymbolType[SymbolType[\"Knot\"] = 0] = \"Knot\";",
            "    SymbolType[SymbolType[\"List\"] = 1] = \"List\";",
            "    SymbolType[SymbolType[\"ListItem\"] = 2] = \"ListItem\";",
            "    SymbolType[SymbolType[\"Var\"] = 3] = \"Var\";",
            "    SymbolType[SymbolType[\"SubFlowAndWeave\"] = 4] = \"SubFlowAndWeave\";",
            "    SymbolType[SymbolType[\"Arg\"] = 5] = \"Arg\";",
            "    SymbolType[SymbolType[\"Temp\"] = 6] = \"Temp\";",
            "  })(SymbolType || (SymbolType = {}));",
            "",
            "  class VariableAssignment$1 extends InkObject {",
            "    constructor(variableName, isNewDeclaration) {",
            "      super();",
            "      this.variableName = variableName || null;",
            "      this.isNewDeclaration = !!isNewDeclaration;",
            "      this.isGlobal = false;",
            "    }",
            "    toString() {",
            "      return \"VarAssign to \" + this.variableName;",
            "    }",
            "  }",
            "",
            "  class Choice$1 extends ParsedObject {",
            "    get runtimeChoice() {",
            "      if (!this._runtimeChoice) {",
            "        throw new Error();",
            "      }",
            "      return this._runtimeChoice;",
            "    }",
            "    get name() {",
            "      var _a;",
            "      return ((_a = this.identifier) === null || _a === void 0 ? void 0 : _a.name) || null;",
            "    }",
            "    get condition() {",
            "      return this._condition;",
            "    }",
            "    set condition(value) {",
            "      this._condition = value;",
            "      if (value) {",
            "        this.AddContent(value);",
            "      }",
            "    }",
            "    // Required for IWeavePoint interface",
            "    // Choice's target container. Used by weave to append any extra",
            "    // nested weave content into.",
            "    get runtimeContainer() {",
            "      return this._innerContentContainer;",
            "    }",
            "    get innerContentContainer() {",
            "      return this._innerContentContainer;",
            "    }",
            "    get containerForCounting() {",
            "      return this._innerContentContainer;",
            "    }",
            "    // Override runtimePath to point to the Choice's target content (after it's chosen),",
            "    // as opposed to the default implementation which would point to the choice itself",
            "    // (or it's outer container), which is what runtimeObject is.",
            "    get runtimePath() {",
            "      if (!this.innerContentContainer || !this.innerContentContainer.path) {",
            "        throw new Error();",
            "      }",
            "      return this.innerContentContainer.path;",
            "    }",
            "    constructor(startContent, choiceOnlyContent, innerContent) {",
            "      super();",
            "      this._condition = null;",
            "      this._innerContentContainer = null;",
            "      this._outerContainer = null;",
            "      this._runtimeChoice = null;",
            "      this._returnToR1 = null;",
            "      this._returnToR2 = null;",
            "      this._r1Label = null;",
            "      this._r2Label = null;",
            "      this._divertToStartContentOuter = null;",
            "      this._divertToStartContentInner = null;",
            "      this._startContentRuntimeContainer = null;",
            "      this.isInvisibleDefault = false;",
            "      this.hasWeaveStyleInlineBrackets = false;",
            "      this.GenerateRuntimeObject = () => {",
            "        this._outerContainer = new Container();",
            "        // Content names for different types of choice:",
            "        //  * start content [choice only content] inner content",
            "        //  * start content   -> divert",
            "        //  * start content",
            "        //  * [choice only content]",
            "        // Hmm, this structure has become slightly insane!",
            "        //",
            "        // [",
            "        //     EvalStart",
            "        //     assign $r = $r1   -- return target = return label 1",
            "        //     BeginString",
            "        //     -> s",
            "        //     [(r1)]            -- return label 1 (after start content)",
            "        //     EndString",
            "        //     BeginString",
            "        //     ... choice only content",
            "        //     EndEval",
            "        //     Condition expression",
            "        //     choice: -> \"c-0\"",
            "        //     (s) = [",
            "        //         start content",
            "        //         -> r          -- goto return label 1 or 2",
            "        //     ]",
            "        //  ]",
            "        //",
            "        //  in parent's container: (the inner content for the choice)",
            "        //",
            "        //  (c-0) = [",
            "        //      EvalStart",
            "        //      assign $r = $r2   -- return target = return label 2",
            "        //      EndEval",
            "        //      -> s",
            "        //      [(r2)]            -- return label 1 (after start content)",
            "        //      inner content",
            "        //  ]",
            "        //",
            "        this._runtimeChoice = new ChoicePoint(this.onceOnly);",
            "        this._runtimeChoice.isInvisibleDefault = this.isInvisibleDefault;",
            "        if (this.startContent || this.choiceOnlyContent || this.condition) {",
            "          this._outerContainer.AddContent(ControlCommand.EvalStart());",
            "        }",
            "        // Start content is put into a named container that's referenced both",
            "        // when displaying the choice initially, and when generating the text",
            "        // when the choice is chosen.",
            "        if (this.startContent) {",
            "          // Generate start content and return",
            "          //  - We can't use a function since it uses a call stack element, which would",
            "          //    put temporary values out of scope. Instead we manually divert around.",
            "          //  - $r is a variable divert target contains the return point",
            "          this._returnToR1 = new DivertTargetValue();",
            "          this._outerContainer.AddContent(this._returnToR1);",
            "          const varAssign = new VariableAssignment$1(\"$r\", true);",
            "          this._outerContainer.AddContent(varAssign);",
            "          // Mark the start of the choice text generation, so that the runtime",
            "          // knows where to rewind to to extract the content from the output stream.",
            "          this._outerContainer.AddContent(ControlCommand.BeginString());",
            "          this._divertToStartContentOuter = new Divert$1();",
            "          this._outerContainer.AddContent(this._divertToStartContentOuter);",
            "          // Start content itself in a named container",
            "          this._startContentRuntimeContainer = this.startContent.GenerateRuntimeObject();",
            "          this._startContentRuntimeContainer.name = \"s\";",
            "          // Effectively, the \"return\" statement - return to the point specified by $r",
            "          const varDivert = new Divert$1();",
            "          varDivert.variableDivertName = \"$r\";",
            "          this._startContentRuntimeContainer.AddContent(varDivert);",
            "          // Add the container",
            "          this._outerContainer.AddToNamedContentOnly(this._startContentRuntimeContainer);",
            "          // This is the label to return to",
            "          this._r1Label = new Container();",
            "          this._r1Label.name = \"$r1\";",
            "          this._outerContainer.AddContent(this._r1Label);",
            "          this._outerContainer.AddContent(ControlCommand.EndString());",
            "          this._runtimeChoice.hasStartContent = true;",
            "        }",
            "        // Choice only content - mark the start, then generate it directly into the outer container",
            "        if (this.choiceOnlyContent) {",
            "          this._outerContainer.AddContent(ControlCommand.BeginString());",
            "          const choiceOnlyRuntimeContent = this.choiceOnlyContent.GenerateRuntimeObject();",
            "          this._outerContainer.AddContentsOfContainer(choiceOnlyRuntimeContent);",
            "          this._outerContainer.AddContent(ControlCommand.EndString());",
            "          this._runtimeChoice.hasChoiceOnlyContent = true;",
            "        }",
            "        // Generate any condition for this choice",
            "        if (this.condition) {",
            "          this.condition.GenerateIntoContainer(this._outerContainer);",
            "          this._runtimeChoice.hasCondition = true;",
            "        }",
            "        if (this.startContent || this.choiceOnlyContent || this.condition) {",
            "          this._outerContainer.AddContent(ControlCommand.EvalEnd());",
            "        }",
            "        // Add choice itself",
            "        this._outerContainer.AddContent(this._runtimeChoice);",
            "        // Container that choice points to for when it's chosen",
            "        this._innerContentContainer = new Container();",
            "        // Repeat start content by diverting to its container",
            "        if (this.startContent) {",
            "          // Set the return point when jumping back into the start content",
            "          //  - In this case, it's the $r2 point, within the choice content \"c\".",
            "          this._returnToR2 = new DivertTargetValue();",
            "          this._innerContentContainer.AddContent(ControlCommand.EvalStart());",
            "          this._innerContentContainer.AddContent(this._returnToR2);",
            "          this._innerContentContainer.AddContent(ControlCommand.EvalEnd());",
            "          const varAssign = new VariableAssignment$1(\"$r\", true);",
            "          this._innerContentContainer.AddContent(varAssign);",
            "          // Main divert into start content",
            "          this._divertToStartContentInner = new Divert$1();",
            "          this._innerContentContainer.AddContent(this._divertToStartContentInner);",
            "          // Define label to return to",
            "          this._r2Label = new Container();",
            "          this._r2Label.name = \"$r2\";",
            "          this._innerContentContainer.AddContent(this._r2Label);",
            "        }",
            "        // Choice's own inner content",
            "        if (this.innerContent) {",
            "          const innerChoiceOnlyContent = this.innerContent.GenerateRuntimeObject();",
            "          this._innerContentContainer.AddContentsOfContainer(innerChoiceOnlyContent);",
            "        }",
            "        if (this.story.countAllVisits) {",
            "          this._innerContentContainer.visitsShouldBeCounted = true;",
            "        }",
            "        this._innerContentContainer.countingAtStartOnly = true;",
            "        return this._outerContainer;",
            "      };",
            "      this.toString = () => {",
            "        if (this.choiceOnlyContent !== null) {",
            "          return `* ${this.startContent}[${this.choiceOnlyContent}]...`;",
            "        }",
            "        return `* ${this.startContent}...`;",
            "      };",
            "      this.startContent = startContent;",
            "      this.choiceOnlyContent = choiceOnlyContent;",
            "      this.innerContent = innerContent;",
            "      this.indentationDepth = 1;",
            "      if (startContent) {",
            "        this.AddContent(this.startContent);",
            "      }",
            "      if (choiceOnlyContent) {",
            "        this.AddContent(this.choiceOnlyContent);",
            "      }",
            "      if (innerContent) {",
            "        this.AddContent(this.innerContent);",
            "      }",
            "      this.onceOnly = true; // default",
            "    }",
            "    get typeName() {",
            "      return \"Choice\";",
            "    }",
            "    ResolveReferences(context) {",
            "      var _a;",
            "      // Weave style choice - target own content container",
            "      if (this._innerContentContainer) {",
            "        this.runtimeChoice.pathOnChoice = this._innerContentContainer.path;",
            "        if (this.onceOnly) {",
            "          this._innerContentContainer.visitsShouldBeCounted = true;",
            "        }",
            "      }",
            "      if (this._returnToR1) {",
            "        if (!this._r1Label) {",
            "          throw new Error();",
            "        }",
            "        this._returnToR1.targetPath = this._r1Label.path;",
            "      }",
            "      if (this._returnToR2) {",
            "        if (!this._r2Label) {",
            "          throw new Error();",
            "        }",
            "        this._returnToR2.targetPath = this._r2Label.path;",
            "      }",
            "      if (this._divertToStartContentOuter) {",
            "        if (!this._startContentRuntimeContainer) {",
            "          throw new Error();",
            "        }",
            "        this._divertToStartContentOuter.targetPath = this._startContentRuntimeContainer.path;",
            "      }",
            "      if (this._divertToStartContentInner) {",
            "        if (!this._startContentRuntimeContainer) {",
            "          throw new Error();",
            "        }",
            "        this._divertToStartContentInner.targetPath = this._startContentRuntimeContainer.path;",
            "      }",
            "      super.ResolveReferences(context);",
            "      if (this.identifier && (((_a = this.identifier) === null || _a === void 0 ? void 0 : _a.name) || \"\").length > 0) {",
            "        context.CheckForNamingCollisions(this, this.identifier, SymbolType.SubFlowAndWeave);",
            "      }",
            "    }",
            "  }",
            "",
            "  class StringParserElement {",
            "    constructor() {",
            "      this.characterIndex = 0;",
            "      this.characterInLineIndex = 0;",
            "      this.lineIndex = 0;",
            "      this.reportedErrorInScope = false;",
            "      this.uniqueId = 0;",
            "      this.customFlags = 0;",
            "      this.CopyFrom = fromElement => {",
            "        StringParserElement._uniqueIdCounter++;",
            "        this.uniqueId = StringParserElement._uniqueIdCounter;",
            "        this.characterIndex = fromElement.characterIndex;",
            "        this.characterInLineIndex = fromElement.characterInLineIndex;",
            "        this.lineIndex = fromElement.lineIndex;",
            "        this.customFlags = fromElement.customFlags;",
            "        this.reportedErrorInScope = false;",
            "      };",
            "      // Squash is used when succeeding from a rule,",
            "      // so only the state information we wanted to carry forward is",
            "      // retained. e.g. characterIndex and lineIndex are global,",
            "      // however uniqueId is specific to the individual rule,",
            "      // and likewise, custom flags are designed for the temporary",
            "      // state of the individual rule too.",
            "      this.SquashFrom = fromElement => {",
            "        this.characterIndex = fromElement.characterIndex;",
            "        this.characterInLineIndex = fromElement.characterInLineIndex;",
            "        this.lineIndex = fromElement.lineIndex;",
            "        this.reportedErrorInScope = fromElement.reportedErrorInScope;",
            "        this.customFlags = fromElement.customFlags;",
            "      };",
            "    }",
            "  }",
            "  StringParserElement._uniqueIdCounter = 1000;",
            "",
            "  class StringParserState {",
            "    get currentElement() {",
            "      return this._stack[this._numElements - 1];",
            "    }",
            "    get lineIndex() {",
            "      return this.currentElement.lineIndex;",
            "    }",
            "    set lineIndex(value) {",
            "      this.currentElement.lineIndex = value;",
            "    }",
            "    get characterIndex() {",
            "      return this.currentElement.characterIndex;",
            "    }",
            "    set characterIndex(value) {",
            "      this.currentElement.characterIndex = value;",
            "    }",
            "    get characterInLineIndex() {",
            "      return this.currentElement.characterInLineIndex;",
            "    }",
            "    set characterInLineIndex(value) {",
            "      this.currentElement.characterInLineIndex = value;",
            "    }",
            "    get customFlags() {",
            "      return this.currentElement.customFlags;",
            "    }",
            "    set customFlags(value) {",
            "      this.currentElement.customFlags = value;",
            "    }",
            "    get errorReportedAlreadyInScope() {",
            "      return this.currentElement.reportedErrorInScope;",
            "    }",
            "    get stackHeight() {",
            "      return this._numElements;",
            "    }",
            "    constructor() {",
            "      this._stack = [];",
            "      this._numElements = 0;",
            "      this.StringParserState = () => {",
            "        const kExpectedMaxStackDepth = 200;",
            "        this._stack = new Array(kExpectedMaxStackDepth);",
            "        for (let ii = 0; ii < kExpectedMaxStackDepth; ++ii) {",
            "          this._stack[ii] = new StringParserElement();",
            "        }",
            "        this._numElements = 1;",
            "      };",
            "      this.Push = () => {",
            "        if (this._numElements >= this._stack.length && this._numElements > 0) {",
            "          throw new Error(\"Stack overflow in parser state.\");",
            "        }",
            "        const prevElement = this._stack[this._numElements - 1];",
            "        const newElement = this._stack[this._numElements];",
            "        this._numElements++;",
            "        newElement.CopyFrom(prevElement);",
            "        return newElement.uniqueId;",
            "      };",
            "      this.Pop = expectedRuleId => {",
            "        if (this._numElements == 1) {",
            "          throw new Error(\"Attempting to remove final stack element is illegal! Mismatched Begin/Succceed/Fail?\");",
            "        }",
            "        if (this.currentElement.uniqueId != expectedRuleId) {",
            "          throw new Error(\"Mismatched rule IDs while Poping - do you have mismatched Begin/Succeed/Fail?\");",
            "        }",
            "        // Restore state",
            "        this._numElements -= 1;",
            "      };",
            "      this.Peek = expectedRuleId => {",
            "        if (this.currentElement.uniqueId != expectedRuleId) {",
            "          throw new Error(\"Mismatched rule IDs while Peeking - do you have mismatched Begin/Succeed/Fail?\");",
            "        }",
            "        return this._stack[this._numElements - 1];",
            "      };",
            "      this.PeekPenultimate = () => {",
            "        if (this._numElements >= 2) {",
            "          return this._stack[this._numElements - 2];",
            "        }",
            "        return null;",
            "      };",
            "      // Reduce stack height while maintaining currentElement",
            "      // Remove second last element: i.e. \"squash last two elements together\"",
            "      // Used when succeeding from a rule (and ONLY when succeeding, since",
            "      // the state of the top element is retained).",
            "      this.Squash = () => {",
            "        if (this._numElements < 2) {",
            "          throw new Error(\"Attempting to remove final stack element is illegal! Mismatched Begin/Succceed/Fail?\");",
            "        }",
            "        const penultimateEl = this._stack[this._numElements - 2];",
            "        const lastEl = this._stack[this._numElements - 1];",
            "        penultimateEl.SquashFrom(lastEl);",
            "        this._numElements -= 1;",
            "      };",
            "      this.NoteErrorReported = () => {",
            "        for (const el of this._stack) {",
            "          el.reportedErrorInScope = true;",
            "        }",
            "      };",
            "      const kExpectedMaxStackDepth = 200;",
            "      for (let i = 0; i < kExpectedMaxStackDepth; i++) {",
            "        this._stack[i] = new StringParserElement();",
            "      }",
            "      this._numElements = 1;",
            "    }",
            "  }",
            "",
            "  const ParseSuccess = Symbol(\"ParseSuccessStruct\");",
            "  class StringParser {",
            "    constructor(str) {",
            "      var _this = this;",
            "      this.ParseRule = null;",
            "      this.errorHandler = null;",
            "      this.hadError = false;",
            "      //--------------------------------",
            "      // Parse state",
            "      //--------------------------------",
            "      this.BeginRule = () => this.state.Push();",
            "      this.FailRule = expectedRuleId => {",
            "        this.state.Pop(expectedRuleId);",
            "        return null;",
            "      };",
            "      this.CancelRule = expectedRuleId => {",
            "        this.state.Pop(expectedRuleId);",
            "      };",
            "      this.SucceedRule = function (expectedRuleId) {",
            "        let result = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;",
            "        // Get state at point where this rule stared evaluating",
            "        const stateAtSucceedRule = _this.state.Peek(expectedRuleId);",
            "        const stateAtBeginRule = _this.state.PeekPenultimate();",
            "        // Allow subclass to receive callback",
            "        if (_this.RuleDidSucceed) {",
            "          _this.RuleDidSucceed(result, stateAtBeginRule, stateAtSucceedRule);",
            "        }",
            "        // Flatten state stack so that we maintain the same values,",
            "        // but remove one level in the stack.",
            "        _this.state.Squash();",
            "        let finalResult = result;",
            "        if (finalResult === null) {",
            "          finalResult = StringParser.ParseSuccess;",
            "        }",
            "        return finalResult;",
            "      };",
            "      this.Expect = function (rule) {",
            "        let message = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;",
            "        let recoveryRule = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;",
            "        let result = _this.ParseObject(rule);",
            "        if (result === null) {",
            "          if (message === null) {",
            "            message = rule.name;",
            "          }",
            "          let butSaw;",
            "          const lineRemainder = _this.LineRemainder();",
            "          if (lineRemainder === null || lineRemainder.length === 0) {",
            "            butSaw = \"end of line\";",
            "          } else {",
            "            butSaw = `'${lineRemainder}'`;",
            "          }",
            "          _this.Error(`Expected ${message} but saw ${butSaw}`);",
            "          if (recoveryRule !== null) {",
            "            result = recoveryRule();",
            "          }",
            "        }",
            "        return result;",
            "      };",
            "      this.Error = function (message) {",
            "        let isWarning = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;",
            "        _this.ErrorOnLine(message, _this.lineIndex + 1, isWarning);",
            "      };",
            "      this.ErrorWithParsedObject = function (message, result) {",
            "        let isWarning = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;",
            "        _this.ErrorOnLine(message, result.debugMetadata ? result.debugMetadata.startLineNumber : -1, isWarning);",
            "      };",
            "      this.ErrorOnLine = (message, lineNumber, isWarning) => {",
            "        if (!this.state.errorReportedAlreadyInScope) {",
            "          const errorType = isWarning ? \"Warning\" : \"Error\";",
            "          if (!this.errorHandler) {",
            "            throw new Error(`${errorType} on line ${lineNumber}: ${message}`);",
            "          } else {",
            "            this.errorHandler(message, this.index, lineNumber - 1, isWarning);",
            "          }",
            "          this.state.NoteErrorReported();",
            "        }",
            "        if (!isWarning) {",
            "          this.hadError = true;",
            "        }",
            "      };",
            "      this.Warning = message => this.Error(message, true);",
            "      this.LineRemainder = () => this.Peek(() => this.ParseUntilCharactersFromString(\"\\n\\r\"));",
            "      this.SetFlag = (flag, trueOrFalse) => {",
            "        if (trueOrFalse) {",
            "          this.state.customFlags |= flag;",
            "        } else {",
            "          this.state.customFlags &= ~flag;",
            "        }",
            "      };",
            "      this.GetFlag = flag => Boolean(this.state.customFlags & flag);",
            "      //--------------------------------",
            "      // Structuring",
            "      //--------------------------------",
            "      this.ParseObject = rule => {",
            "        const ruleId = this.BeginRule();",
            "        const stackHeightBefore = this.state.stackHeight;",
            "        const result = rule();",
            "        if (stackHeightBefore !== this.state.stackHeight) {",
            "          throw new Error(\"Mismatched Begin/Fail/Succeed rules\");",
            "        }",
            "        if (result === null) {",
            "          return this.FailRule(ruleId);",
            "        }",
            "        this.SucceedRule(ruleId, result);",
            "        return result;",
            "      };",
            "      this.Parse = rule => {",
            "        const ruleId = this.BeginRule();",
            "        const result = rule();",
            "        if (result === null) {",
            "          this.FailRule(ruleId);",
            "          return null;",
            "        }",
            "        this.SucceedRule(ruleId, result);",
            "        return result;",
            "      };",
            "      this.OneOf = array => {",
            "        for (const rule of array) {",
            "          const result = this.ParseObject(rule);",
            "          if (result !== null) {",
            "            return result;",
            "          }",
            "        }",
            "        return null;",
            "      };",
            "      this.OneOrMore = rule => {",
            "        const results = [];",
            "        let result = null;",
            "        do {",
            "          result = this.ParseObject(rule);",
            "          if (result !== null) {",
            "            results.push(result);",
            "          }",
            "        } while (result !== null);",
            "        if (results.length > 0) {",
            "          return results;",
            "        }",
            "        return null;",
            "      };",
            "      this.Optional = rule => () => {",
            "        const result = this.ParseObject(rule);",
            "        if (result === null) return StringParser.ParseSuccess;",
            "        return result;",
            "      };",
            "      // Return ParseSuccess instead the real result so that it gets excluded",
            "      // from result arrays (e.g. Interleave)",
            "      this.Exclude = rule => () => this.ParseObject(rule) && StringParser.ParseSuccess;",
            "      // Combination of both of the above",
            "      this.OptionalExclude = rule => () => {",
            "        this.ParseObject(rule);",
            "        return StringParser.ParseSuccess;",
            "      };",
            "      // Convenience method for creating more readable ParseString rules that can be combined",
            "      // in other structuring rules (like OneOf etc)",
            "      // e.g. OneOf(String(\"one\"), String(\"two\"))",
            "      this.String = str => () => this.ParseString(str);",
            "      this.TryAddResultToList = function (result, list) {",
            "        let flatten = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;",
            "        if (result === StringParser.ParseSuccess) {",
            "          return;",
            "        }",
            "        if (flatten && Array.isArray(result)) {",
            "          const resultCollection = result;",
            "          if (resultCollection !== null) {",
            "            for (const obj of resultCollection) {",
            "              list.push(obj);",
            "            }",
            "            return;",
            "          }",
            "        }",
            "        list.push(result);",
            "      };",
            "      this.Interleave = function (ruleA, ruleB) {",
            "        let untilTerminator = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;",
            "        let flatten = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : true;",
            "        const ruleId = _this.BeginRule();",
            "        const results = [];",
            "        // First outer padding",
            "        const firstA = _this.ParseObject(ruleA);",
            "        if (firstA === null) {",
            "          return _this.FailRule(ruleId);",
            "        } else {",
            "          _this.TryAddResultToList(firstA, results, flatten);",
            "        }",
            "        let lastMainResult = null;",
            "        let outerResult = null;",
            "        do {",
            "          // \"until\" condition hit?",
            "          if (untilTerminator !== null && _this.Peek(untilTerminator) !== null) {",
            "            break;",
            "          }",
            "          // Main inner",
            "          lastMainResult = _this.ParseObject(ruleB);",
            "          if (lastMainResult === null) {",
            "            break;",
            "          } else {",
            "            _this.TryAddResultToList(lastMainResult, results, flatten);",
            "          }",
            "          // Outer result (i.e. last A in ABA)",
            "          outerResult = null;",
            "          if (lastMainResult !== null) {",
            "            outerResult = _this.ParseObject(ruleA);",
            "            if (outerResult === null) {",
            "              break;",
            "            } else {",
            "              _this.TryAddResultToList(outerResult, results, flatten);",
            "            }",
            "          }",
            "          // Stop if there are no results, or if both are the placeholder \"ParseSuccess\" (i.e. Optional success rather than a true value)",
            "        } while ((lastMainResult !== null || outerResult !== null) && !(lastMainResult === StringParser.ParseSuccess && outerResult == StringParser.ParseSuccess) && _this.remainingLength > 0);",
            "        if (results.length === 0) {",
            "          return _this.FailRule(ruleId);",
            "        }",
            "        return _this.SucceedRule(ruleId, results);",
            "      };",
            "      //--------------------------------",
            "      // Basic string parsing",
            "      //--------------------------------",
            "      this.ParseString = str => {",
            "        if (str.length > this.remainingLength) {",
            "          return null;",
            "        }",
            "        const ruleId = this.BeginRule();",
            "        // Optimisation from profiling:",
            "        // Store in temporary local variables",
            "        // since they're properties that would have to access",
            "        // the rule stack every time otherwise.",
            "        let i = this.index;",
            "        let cli = this.characterInLineIndex;",
            "        let li = this.lineIndex;",
            "        let success = true;",
            "        for (let tempIdx = 0; tempIdx < str.length; tempIdx += 1) {",
            "          const c = str[tempIdx];",
            "          if (this._chars[i] !== c) {",
            "            success = false;",
            "            break;",
            "          }",
            "          if (c === \"\\n\") {",
            "            li++;",
            "            cli = -1;",
            "          }",
            "          i++;",
            "          cli++;",
            "        }",
            "        this.index = i;",
            "        this.characterInLineIndex = cli;",
            "        this.lineIndex = li;",
            "        if (success) {",
            "          return this.SucceedRule(ruleId, str);",
            "        }",
            "        return this.FailRule(ruleId);",
            "      };",
            "      this.ParseSingleCharacter = () => {",
            "        if (this.remainingLength > 0) {",
            "          const c = this._chars[this.index];",
            "          if (c === \"\\n\") {",
            "            this.lineIndex += 1;",
            "            this.characterInLineIndex = -1;",
            "          }",
            "          this.index += 1;",
            "          this.characterInLineIndex += 1;",
            "          return c;",
            "        }",
            "        return \"0\";",
            "      };",
            "      this.ParseUntilCharactersFromString = function (str) {",
            "        let maxCount = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : -1;",
            "        return _this.ParseCharactersFromString(str, false, maxCount);",
            "      };",
            "      this.ParseUntilCharactersFromCharSet = function (charSet) {",
            "        let maxCount = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : -1;",
            "        return _this.ParseCharactersFromCharSet(charSet, false, maxCount);",
            "      };",
            "      this.ParseCharactersFromString = function (str) {",
            "        let maxCountOrShouldIncludeStrChars = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : -1;",
            "        let maxCount = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : -1;",
            "        const charSet = new CharacterSet(str);",
            "        if (typeof maxCountOrShouldIncludeStrChars === \"number\") {",
            "          return _this.ParseCharactersFromCharSet(charSet, true, maxCountOrShouldIncludeStrChars);",
            "        }",
            "        return _this.ParseCharactersFromCharSet(charSet, maxCountOrShouldIncludeStrChars, maxCount);",
            "      };",
            "      this.ParseCharactersFromCharSet = function (charSet) {",
            "        let shouldIncludeChars = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;",
            "        let maxCount = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : -1;",
            "        if (maxCount === -1) {",
            "          maxCount = Number.MAX_SAFE_INTEGER;",
            "        }",
            "        const startIndex = _this.index;",
            "        // Optimisation from profiling:",
            "        // Store in temporary local variables",
            "        // since they're properties that would have to access",
            "        // the rule stack every time otherwise.",
            "        let ii = _this.index;",
            "        let cli = _this.characterInLineIndex;",
            "        let li = _this.lineIndex;",
            "        let count = 0;",
            "        while (ii < _this._chars.length && charSet.set.has(_this._chars[ii]) === shouldIncludeChars && count < maxCount) {",
            "          if (_this._chars[ii] === \"\\n\") {",
            "            li += 1;",
            "            cli = -1;",
            "          }",
            "          ii += 1;",
            "          cli += 1;",
            "          count += 1;",
            "        }",
            "        _this.index = ii;",
            "        _this.characterInLineIndex = cli;",
            "        _this.lineIndex = li;",
            "        const lastCharIndex = _this.index;",
            "        if (lastCharIndex > startIndex) {",
            "          return _this._chars.slice(startIndex, _this.index).join(\"\");",
            "        }",
            "        return null;",
            "      };",
            "      this.Peek = rule => {",
            "        const ruleId = this.BeginRule();",
            "        const result = rule();",
            "        this.CancelRule(ruleId);",
            "        return result;",
            "      };",
            "      // No need to Begin/End rule since we never parse a newline, so keeping oldIndex is good enough",
            "      this.ParseInt = () => {",
            "        const oldIndex = this.index;",
            "        const oldCharacterInLineIndex = this.characterInLineIndex;",
            "        const negative = this.ParseString(\"-\") !== null;",
            "        // Optional whitespace",
            "        this.ParseCharactersFromString(\" \\t\");",
            "        const parsedString = this.ParseCharactersFromCharSet(StringParser.numbersCharacterSet);",
            "        if (parsedString === null) {",
            "          // Roll back and fail",
            "          this.index = oldIndex;",
            "          this.characterInLineIndex = oldCharacterInLineIndex;",
            "          return null;",
            "        }",
            "        let parsedInt;",
            "        if (!Number.isNaN(Number(parsedString))) {",
            "          parsedInt = Number(parsedString);",
            "          return negative ? -parsedInt : parsedInt;",
            "        }",
            "        this.Error(\"Failed to read integer value: \" + parsedString + \". Perhaps it's out of the range of acceptable numbers ink supports? (\" + Number.MIN_SAFE_INTEGER + \" to \" + Number.MAX_SAFE_INTEGER + \")\");",
            "        return null;",
            "      };",
            "      // No need to Begin/End rule since we never parse a newline, so keeping oldIndex is good enough",
            "      this.ParseFloat = () => {",
            "        const oldIndex = this.index;",
            "        const oldCharacterInLineIndex = this.characterInLineIndex;",
            "        const leadingInt = this.ParseInt();",
            "        if (leadingInt !== null) {",
            "          if (this.ParseString(\".\") !== null) {",
            "            const afterDecimalPointStr = this.ParseCharactersFromCharSet(StringParser.numbersCharacterSet);",
            "            return Number(`${leadingInt}.${afterDecimalPointStr}`);",
            "          }",
            "        }",
            "        // Roll back and fail",
            "        this.index = oldIndex;",
            "        this.characterInLineIndex = oldCharacterInLineIndex;",
            "        return null;",
            "      };",
            "      this.ParseNewline = () => {",
            "        const ruleId = this.BeginRule();",
            "        // Optional \\r, definite \\n to support Windows (\\r\\n) and Mac/Unix (\\n)",
            "        // 2nd May 2016: Always collapse \\r\\n to just \\n",
            "        this.ParseString(\"\\r\");",
            "        if (this.ParseString(\"\\n\") === null) {",
            "          return this.FailRule(ruleId);",
            "        }",
            "        return this.SucceedRule(ruleId, \"\\n\");",
            "      };",
            "      const strPreProc = this.PreProcessInputString(str);",
            "      this.state = new StringParserState();",
            "      if (str) {",
            "        this._chars = strPreProc.split(\"\");",
            "      } else {",
            "        this._chars = [];",
            "      }",
            "      this.inputString = strPreProc;",
            "    }",
            "    get currentCharacter() {",
            "      if (this.index >= 0 && this.remainingLength > 0) {",
            "        return this._chars[this.index];",
            "      }",
            "      return \"0\";",
            "    }",
            "    // Don't do anything by default, but provide ability for subclasses",
            "    // to manipulate the string before it's used as input (converted to a char array)",
            "    PreProcessInputString(str) {",
            "      return str;",
            "    }",
            "    get endOfInput() {",
            "      return this.index >= this._chars.length;",
            "    }",
            "    get remainingString() {",
            "      return this._chars.slice(this.index, this.index + this.remainingLength).join(\"\");",
            "    }",
            "    get remainingLength() {",
            "      return this._chars.length - this.index;",
            "    }",
            "    get lineIndex() {",
            "      return this.state.lineIndex;",
            "    }",
            "    set lineIndex(value) {",
            "      this.state.lineIndex = value;",
            "    }",
            "    set characterInLineIndex(value) {",
            "      this.state.characterInLineIndex = value;",
            "    }",
            "    get characterInLineIndex() {",
            "      return this.state.characterInLineIndex;",
            "    }",
            "    get index() {",
            "      // If we want subclass parsers to be able to set the index directly,",
            "      // then we would need to know what the lineIndex of the new",
            "      // index would be - would we have to step through manually",
            "      // counting the newlines to do so?",
            "      return this.state.characterIndex;",
            "    }",
            "    set index(value) {",
            "      this.state.characterIndex = value;",
            "    }",
            "    ParseUntil(stopRule) {",
            "      let pauseCharacters = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;",
            "      let endCharacters = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;",
            "      const ruleId = this.BeginRule();",
            "      const pauseAndEnd = new CharacterSet();",
            "      if (pauseCharacters !== null) {",
            "        pauseAndEnd.set = new Set([...pauseAndEnd.set.values(), ...pauseCharacters.set.values()]);",
            "      }",
            "      if (endCharacters !== null) {",
            "        pauseAndEnd.set = new Set([...pauseAndEnd.set.values(), ...endCharacters.set.values()]);",
            "      }",
            "      let parsedString = \"\";",
            "      let ruleResultAtPause = null;",
            "      // Keep attempting to parse strings up to the pause (and end) points.",
            "      //  - At each of the pause points, attempt to parse according to the rule",
            "      //  - When the end point is reached (or EOF), we're done",
            "      do {",
            "        // TODO: Perhaps if no pause or end characters are passed, we should check *every* character for stopRule?",
            "        const partialParsedString = this.ParseUntilCharactersFromCharSet(pauseAndEnd);",
            "        if (partialParsedString) {",
            "          parsedString += partialParsedString;",
            "        }",
            "        // Attempt to run the parse rule at this pause point",
            "        ruleResultAtPause = this.Peek(stopRule);",
            "        // Rule completed - we're done",
            "        if (ruleResultAtPause !== null) {",
            "          break;",
            "        } else {",
            "          if (this.endOfInput) {",
            "            break;",
            "          }",
            "          // Reached a pause point, but rule failed. Step past and continue parsing string",
            "          const pauseCharacter = this.currentCharacter;",
            "          if (pauseCharacters !== null && pauseCharacters.set.has(pauseCharacter)) {",
            "            parsedString += pauseCharacter;",
            "            if (pauseCharacter === \"\\n\") {",
            "              this.lineIndex += 1;",
            "              this.characterInLineIndex = -1;",
            "            }",
            "            this.index += 1;",
            "            this.characterInLineIndex += 1;",
            "            continue;",
            "          } else {",
            "            break;",
            "          }",
            "        }",
            "      } while (true);",
            "      if (parsedString.length > 0) {",
            "        return this.SucceedRule(ruleId, String(parsedString));",
            "      }",
            "      return this.FailRule(ruleId);",
            "    }",
            "  }",
            "  StringParser.ParseSuccess = ParseSuccess;",
            "  StringParser.numbersCharacterSet = new CharacterSet(\"0123456789\");",
            "",
            "  /// <summary>",
            "  /// Pre-pass before main ink parser runs. It actually performs two main tasks:",
            "  ///  - comment elimination to simplify the parse rules in the main parser",
            "  ///  - Conversion of Windows line endings (\\r\\n) to the simpler Unix style (\\n), so",
            "  ///    we don't have to worry about them later.",
            "  /// </summary>",
            "  class CommentEliminator extends StringParser {",
            "    constructor() {",
            "      super(...arguments);",
            "      this._commentOrNewlineStartCharacter = new CharacterSet(\"/\\r\\n\");",
            "      this._commentBlockEndCharacter = new CharacterSet(\"*\");",
            "      this._newlineCharacters = new CharacterSet(\"\\n\\r\");",
            "      this.Process = () => {",
            "        // Make both comments and non-comments optional to handle trivial empty file case (or *only* comments)",
            "        const stringList = this.Interleave(this.Optional(this.CommentsAndNewlines), this.Optional(this.MainInk));",
            "        if (stringList !== null) {",
            "          return stringList.join(\"\");",
            "        } else {",
            "          return \"\";",
            "        }",
            "      };",
            "      this.MainInk = () => this.ParseUntil(this.CommentsAndNewlines, this._commentOrNewlineStartCharacter, null);",
            "      this.CommentsAndNewlines = () => {",
            "        let newLines = this.Interleave(this.Optional(this.ParseNewline), this.Optional(this.ParseSingleComment));",
            "        if (newLines !== null) {",
            "          return newLines.join(\"\");",
            "        }",
            "        return null;",
            "      };",
            "      // Valid comments always return either an empty string or pure newlines,",
            "      // which we want to keep so that line numbers stay the same",
            "      this.ParseSingleComment = () => this.OneOf([this.EndOfLineComment, this.BlockComment]);",
            "      this.EndOfLineComment = () => {",
            "        if (this.ParseString(\"//\") === null) {",
            "          return null;",
            "        }",
            "        this.ParseUntilCharactersFromCharSet(this._newlineCharacters);",
            "        return \"\";",
            "      };",
            "      this.BlockComment = () => {",
            "        if (this.ParseString(\"/*\") === null) {",
            "          return null;",
            "        }",
            "        const startLineIndex = this.lineIndex;",
            "        const commentResult = this.ParseUntil(this.String(\"*/\"), this._commentBlockEndCharacter, null);",
            "        if (!this.endOfInput) {",
            "          this.ParseString(\"*/\");",
            "        }",
            "        // Count the number of lines that were inside the block, and replicate them as newlines",
            "        // so that the line indexing still works from the original source",
            "        if (commentResult != null) {",
            "          return \"\\n\".repeat(this.lineIndex - startLineIndex);",
            "        }",
            "        // No comment at all",
            "        return null;",
            "      };",
            "    }",
            "    PreProcessInputString(str) {",
            "      return str;",
            "    }",
            "  }",
            "",
            "  class Conditional extends ParsedObject {",
            "    constructor(initialCondition, branches) {",
            "      super();",
            "      this.initialCondition = initialCondition;",
            "      this.branches = branches;",
            "      this._reJoinTarget = null;",
            "      this.GenerateRuntimeObject = () => {",
            "        const container = new Container();",
            "        // Initial condition",
            "        if (this.initialCondition) {",
            "          container.AddContent(this.initialCondition.runtimeObject);",
            "        }",
            "        // Individual branches",
            "        for (const branch of this.branches) {",
            "          const branchContainer = branch.runtimeObject;",
            "          container.AddContent(branchContainer);",
            "        }",
            "        // If it's a switch-like conditional, each branch",
            "        // will have a \"duplicate\" operation for the original",
            "        // switched value. If there's no final else clause",
            "        // and we fall all the way through, we need to clean up.",
            "        // (An else clause doesn't dup but it *does* pop)",
            "        if (this.initialCondition !== null && this.branches[0].ownExpression !== null && !this.branches[this.branches.length - 1].isElse) {",
            "          container.AddContent(ControlCommand.PopEvaluatedValue());",
            "        }",
            "        // Target for branches to rejoin to",
            "        this._reJoinTarget = ControlCommand.NoOp();",
            "        container.AddContent(this._reJoinTarget);",
            "        return container;",
            "      };",
            "      if (this.initialCondition) {",
            "        this.AddContent(this.initialCondition);",
            "      }",
            "      if (this.branches !== null) {",
            "        this.AddContent(this.branches);",
            "      }",
            "    }",
            "    get typeName() {",
            "      return \"Conditional\";",
            "    }",
            "    ResolveReferences(context) {",
            "      const pathToReJoin = this._reJoinTarget.path;",
            "      for (const branch of this.branches) {",
            "        if (!branch.returnDivert) {",
            "          throw new Error();",
            "        }",
            "        branch.returnDivert.targetPath = pathToReJoin;",
            "      }",
            "      super.ResolveReferences(context);",
            "    }",
            "  }",
            "",
            "  class Text extends ParsedObject {",
            "    constructor(text) {",
            "      super();",
            "      this.text = text;",
            "      this.GenerateRuntimeObject = () => new StringValue(this.text);",
            "      this.toString = () => this.text;",
            "    }",
            "    get typeName() {",
            "      return \"Text\";",
            "    }",
            "  }",
            "",
            "  class ConstantDeclaration extends ParsedObject {",
            "    get constantName() {",
            "      var _a;",
            "      return (_a = this.constantIdentifier) === null || _a === void 0 ? void 0 : _a.name;",
            "    }",
            "    get expression() {",
            "      if (!this._expression) {",
            "        throw new Error();",
            "      }",
            "      return this._expression;",
            "    }",
            "    constructor(name, assignedExpression) {",
            "      super();",
            "      this._expression = null;",
            "      this.GenerateRuntimeObject = () => {",
            "        // Global declarations don't generate actual procedural",
            "        // runtime objects, but instead add a global variable to the story itself.",
            "        // The story then initialises them all in one go at the start of the game.",
            "        return null;",
            "      };",
            "      this.constantIdentifier = name;",
            "      // Defensive programming in case parsing of assignedExpression failed",
            "      if (assignedExpression) {",
            "        this._expression = this.AddContent(assignedExpression);",
            "      }",
            "    }",
            "    get typeName() {",
            "      return \"CONST\";",
            "    }",
            "    ResolveReferences(context) {",
            "      super.ResolveReferences(context);",
            "      context.CheckForNamingCollisions(this, this.constantIdentifier, SymbolType.Var);",
            "    }",
            "  }",
            "",
            "  var FlowLevel;",
            "  (function (FlowLevel) {",
            "    FlowLevel[FlowLevel[\"Story\"] = 0] = \"Story\";",
            "    FlowLevel[FlowLevel[\"Knot\"] = 1] = \"Knot\";",
            "    FlowLevel[FlowLevel[\"Stitch\"] = 2] = \"Stitch\";",
            "    // not actually a FlowBase, but used for diverts",
            "    FlowLevel[FlowLevel[\"WeavePoint\"] = 3] = \"WeavePoint\";",
            "  })(FlowLevel || (FlowLevel = {}));",
            "",
            "  class Gather extends ParsedObject {",
            "    get name() {",
            "      var _a;",
            "      return ((_a = this.identifier) === null || _a === void 0 ? void 0 : _a.name) || null;",
            "    }",
            "    get runtimeContainer() {",
            "      return this.runtimeObject;",
            "    }",
            "    constructor(identifier, indentationDepth) {",
            "      super();",
            "      this.indentationDepth = indentationDepth;",
            "      this.GenerateRuntimeObject = () => {",
            "        const container = new Container();",
            "        container.name = this.name;",
            "        if (this.story.countAllVisits) {",
            "          container.visitsShouldBeCounted = true;",
            "        }",
            "        container.countingAtStartOnly = true;",
            "        // A gather can have null content, e.g. it's just purely a line with \"-\"",
            "        if (this.content) {",
            "          for (const c of this.content) {",
            "            container.AddContent(c.runtimeObject);",
            "          }",
            "        }",
            "        return container;",
            "      };",
            "      this.toString = () => {",
            "        var _a, _b;",
            "        return `- ${((_a = this.identifier) === null || _a === void 0 ? void 0 : _a.name) ? \"(\" + ((_b = this.identifier) === null || _b === void 0 ? void 0 : _b.name) + \")\" : \"gather\"}`;",
            "      };",
            "      if (identifier) this.identifier = identifier;",
            "    }",
            "    get typeName() {",
            "      return \"Gather\";",
            "    }",
            "    ResolveReferences(context) {",
            "      super.ResolveReferences(context);",
            "      if (this.identifier && (this.identifier.name || \"\").length > 0) {",
            "        context.CheckForNamingCollisions(this, this.identifier, SymbolType.SubFlowAndWeave);",
            "      }",
            "    }",
            "  }",
            "",
            "  class Path {",
            "    get baseTargetLevel() {",
            "      if (this.baseLevelIsAmbiguous) {",
            "        return FlowLevel.Story;",
            "      }",
            "      return this._baseTargetLevel;",
            "    }",
            "    get baseLevelIsAmbiguous() {",
            "      return !this._baseTargetLevel;",
            "    }",
            "    get firstComponent() {",
            "      if (this.components == null || !this.components.length) {",
            "        return null;",
            "      }",
            "      return this.components[0].name;",
            "    }",
            "    get numberOfComponents() {",
            "      return this.components ? this.components.length : 0;",
            "    }",
            "    get dotSeparatedComponents() {",
            "      if (this._dotSeparatedComponents == null) {",
            "        this._dotSeparatedComponents = (this.components ? this.components : []).map(c => c.name).filter(filterUndef).join(\".\");",
            "      }",
            "      return this._dotSeparatedComponents;",
            "    }",
            "    constructor(argOne, argTwo) {",
            "      this._dotSeparatedComponents = null;",
            "      this.toString = () => {",
            "        if (this.components === null || this.components.length === 0) {",
            "          if (this.baseTargetLevel === FlowLevel.WeavePoint) {",
            "            return \"-> <next gather point>\";",
            "          }",
            "          return \"<invalid Path>\";",
            "        }",
            "        return `-> ${this.dotSeparatedComponents}`;",
            "      };",
            "      this.ResolveFromContext = context => {",
            "        if (this.components == null || this.components.length == 0) {",
            "          return null;",
            "        }",
            "        // Find base target of path from current context. e.g.",
            "        //   ==> BASE.sub.sub",
            "        let baseTargetObject = this.ResolveBaseTarget(context);",
            "        if (baseTargetObject === null) {",
            "          return null;",
            "        }",
            "        // Given base of path, resolve final target by working deeper into hierarchy",
            "        //  e.g. ==> base.mid.FINAL",
            "        if (this.components.length > 1) {",
            "          return this.ResolveTailComponents(baseTargetObject);",
            "        }",
            "        return baseTargetObject;",
            "      };",
            "      // Find the root object from the base, i.e. root from:",
            "      //    root.sub1.sub2",
            "      this.ResolveBaseTarget = originalContext => {",
            "        const firstComp = this.firstComponent;",
            "        // Work up the ancestry to find the node that has the named object",
            "        let ancestorContext = originalContext;",
            "        while (ancestorContext) {",
            "          // Only allow deep search when searching deeper from original context.",
            "          // Don't allow search upward *then* downward, since that's searching *everywhere*!",
            "          // Allowed examples:",
            "          //  - From an inner gather of a stitch, you should search up to find a knot called 'x'",
            "          //    at the root of a story, but not a stitch called 'x' in that knot.",
            "          //  - However, from within a knot, you should be able to find a gather/choice",
            "          //    anywhere called 'x'",
            "          // (that latter example is quite loose, but we allow it)",
            "          const deepSearch = ancestorContext === originalContext;",
            "          const foundBase = this.GetChildFromContext(ancestorContext, firstComp, null, deepSearch);",
            "          if (foundBase) {",
            "            return foundBase;",
            "          }",
            "          ancestorContext = ancestorContext.parent;",
            "        }",
            "        return null;",
            "      };",
            "      // Find the final child from path given root, i.e.:",
            "      //   root.sub.finalChild",
            "      this.ResolveTailComponents = rootTarget => {",
            "        let foundComponent = rootTarget;",
            "        if (!this.components) return null;",
            "        for (let ii = 1; ii < this.components.length; ++ii) {",
            "          const compName = this.components[ii].name;",
            "          let minimumExpectedLevel;",
            "          let foundFlow = asOrNull(foundComponent, FlowBase);",
            "          if (foundFlow !== null) {",
            "            minimumExpectedLevel = foundFlow.flowLevel + 1;",
            "          } else {",
            "            minimumExpectedLevel = FlowLevel.WeavePoint;",
            "          }",
            "          foundComponent = this.GetChildFromContext(foundComponent, compName, minimumExpectedLevel);",
            "          if (foundComponent === null) {",
            "            break;",
            "          }",
            "        }",
            "        return foundComponent;",
            "      };",
            "      // See whether \"context\" contains a child with a given name at a given flow level",
            "      // Can either be a named knot/stitch (a FlowBase) or a weave point within a Weave (Choice or Gather)",
            "      // This function also ignores any other object types that are neither FlowBase nor Weave.",
            "      // Called from both ResolveBase (force deep) and ResolveTail for the individual components.",
            "      this.GetChildFromContext = function (context, childName, minimumLevel) {",
            "        let forceDeepSearch = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;",
            "        // null childLevel means that we don't know where to find it",
            "        const ambiguousChildLevel = minimumLevel === null;",
            "        // Search for WeavePoint within Weave",
            "        const weaveContext = asOrNull(context, Weave);",
            "        if (childName && weaveContext !== null && (ambiguousChildLevel || minimumLevel === FlowLevel.WeavePoint)) {",
            "          return weaveContext.WeavePointNamed(childName);",
            "        }",
            "        // Search for content within Flow (either a sub-Flow or a WeavePoint)",
            "        let flowContext = asOrNull(context, FlowBase);",
            "        if (childName && flowContext !== null) {",
            "          // When searching within a Knot, allow a deep searches so that",
            "          // named weave points (choices and gathers) can be found within any stitch",
            "          // Otherwise, we just search within the immediate object.",
            "          const shouldDeepSearch = forceDeepSearch || flowContext.flowLevel === FlowLevel.Knot;",
            "          return flowContext.ContentWithNameAtLevel(childName, minimumLevel, shouldDeepSearch);",
            "        }",
            "        return null;",
            "      };",
            "      if (Object.values(FlowLevel).includes(argOne)) {",
            "        this._baseTargetLevel = argOne;",
            "        this.components = argTwo || [];",
            "      } else if (Array.isArray(argOne)) {",
            "        this._baseTargetLevel = null;",
            "        this.components = argOne || [];",
            "      } else {",
            "        this._baseTargetLevel = null;",
            "        this.components = [argOne];",
            "      }",
            "    }",
            "    get typeName() {",
            "      return \"Path\";",
            "    }",
            "  }",
            "",
            "  class ReturnType extends ParsedObject {",
            "    constructor() {",
            "      let returnedExpression = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;",
            "      super();",
            "      this.returnedExpression = null;",
            "      this.GenerateRuntimeObject = () => {",
            "        const container = new Container();",
            "        if (this.returnedExpression) {",
            "          // Evaluate expression",
            "          container.AddContent(this.returnedExpression.runtimeObject);",
            "        } else {",
            "          // Return Runtime.Void when there's no expression to evaluate",
            "          // (This evaluation will just add the Void object to the evaluation stack)",
            "          container.AddContent(ControlCommand.EvalStart());",
            "          container.AddContent(new Void());",
            "          container.AddContent(ControlCommand.EvalEnd());",
            "        }",
            "        // Then pop the call stack",
            "        // (the evaluated expression will leave the return value on the evaluation stack)",
            "        container.AddContent(ControlCommand.PopFunction());",
            "        return container;",
            "      };",
            "      if (returnedExpression) {",
            "        this.returnedExpression = this.AddContent(returnedExpression);",
            "      }",
            "    }",
            "    get typeName() {",
            "      return \"ReturnType\";",
            "    }",
            "  }",
            "",
            "  // import { FlowBase } from './FlowBase';",
            "  function ClosestFlowBase(obj) {",
            "    let ancestor = obj.parent;",
            "    while (ancestor) {",
            "      if (ancestor.hasOwnProperty(\"iamFlowbase\") && ancestor.iamFlowbase()) {",
            "        return ancestor;",
            "      }",
            "      ancestor = ancestor.parent;",
            "    }",
            "    return null;",
            "  }",
            "",
            "  class Identifier {",
            "    constructor(name) {",
            "      this.debugMetadata = null;",
            "      this.toString = () => this.name || \"undefined identifer\";",
            "      this.name = name;",
            "    }",
            "    get typeName() {",
            "      return \"Identifier\";",
            "    }",
            "    static Done() {",
            "      return new Identifier(\"DONE\");",
            "    }",
            "  }",
            "",
            "  // Base class for Knots and Stitches",
            "  class FlowBase extends ParsedObject {",
            "    get hasParameters() {",
            "      return this.args !== null && this.args.length > 0;",
            "    }",
            "    get subFlowsByName() {",
            "      return this._subFlowsByName;",
            "    }",
            "    get typeName() {",
            "      if (this.isFunction) {",
            "        return \"Function\";",
            "      }",
            "      return String(this.flowLevel);",
            "    }",
            "    get name() {",
            "      var _a;",
            "      return ((_a = this.identifier) === null || _a === void 0 ? void 0 : _a.name) || null;",
            "    }",
            "    constructor(identifier) {",
            "      var _this;",
            "      let topLevelObjects = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;",
            "      let args = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;",
            "      let isFunction = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;",
            "      let isIncludedStory = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : false;",
            "      super();",
            "      _this = this;",
            "      this.isFunction = isFunction;",
            "      this._rootWeave = null;",
            "      this._subFlowsByName = new Map();",
            "      this._startingSubFlowDivert = null;",
            "      this._startingSubFlowRuntime = null;",
            "      this._firstChildFlow = null;",
            "      this.variableDeclarations = new Map();",
            "      this.identifier = null;",
            "      this.args = null;",
            "      this.iamFlowbase = () => true;",
            "      this.SplitWeaveAndSubFlowContent = (contentObjs, isRootStory) => {",
            "        var _a, _b;",
            "        const weaveObjs = [];",
            "        const subFlowObjs = [];",
            "        this._subFlowsByName = new Map();",
            "        for (const obj of contentObjs) {",
            "          const subFlow = asOrNull(obj, FlowBase);",
            "          if (subFlow) {",
            "            if (this._firstChildFlow === null) {",
            "              this._firstChildFlow = subFlow;",
            "            }",
            "            subFlowObjs.push(obj);",
            "            if ((_a = subFlow.identifier) === null || _a === void 0 ? void 0 : _a.name) {",
            "              this._subFlowsByName.set((_b = subFlow.identifier) === null || _b === void 0 ? void 0 : _b.name, subFlow);",
            "            }",
            "          } else {",
            "            weaveObjs.push(obj);",
            "          }",
            "        }",
            "        // Implicit final gather in top level story for ending without warning that you run out of content",
            "        if (isRootStory) {",
            "          weaveObjs.push(new Gather(null, 1), new Divert(new Path(Identifier.Done())));",
            "        }",
            "        const finalContent = [];",
            "        if (weaveObjs.length > 0) {",
            "          this._rootWeave = new Weave(weaveObjs, 0);",
            "          finalContent.push(this._rootWeave);",
            "        }",
            "        if (subFlowObjs.length > 0) {",
            "          finalContent.push(...subFlowObjs);",
            "        }",
            "        return finalContent;",
            "      };",
            "      this.ResolveVariableWithName = (varName, fromNode) => {",
            "        var _a;",
            "        const result = {};",
            "        // Search in the stitch / knot that owns the node first",
            "        const ownerFlow = fromNode === null ? this : ClosestFlowBase(fromNode);",
            "        if (ownerFlow) {",
            "          // Argument",
            "          if (ownerFlow.args !== null) {",
            "            for (const arg of ownerFlow.args) {",
            "              if (((_a = arg.identifier) === null || _a === void 0 ? void 0 : _a.name) === varName) {",
            "                result.found = true;",
            "                result.isArgument = true;",
            "                result.ownerFlow = ownerFlow;",
            "                return result;",
            "              }",
            "            }",
            "          }",
            "          // Temp",
            "          if (ownerFlow !== this.story && ownerFlow.variableDeclarations.has(varName)) {",
            "            result.found = true;",
            "            result.ownerFlow = ownerFlow;",
            "            result.isTemporary = true;",
            "            return result;",
            "          }",
            "        }",
            "        // Global",
            "        if (this.story.variableDeclarations.has(varName)) {",
            "          result.found = true;",
            "          result.ownerFlow = this.story;",
            "          result.isGlobal = true;",
            "          return result;",
            "        }",
            "        result.found = false;",
            "        return result;",
            "      };",
            "      this.AddNewVariableDeclaration = varDecl => {",
            "        const varName = varDecl.variableName;",
            "        if (this.variableDeclarations.has(varName)) {",
            "          const varab = this.variableDeclarations.get(varName);",
            "          let prevDeclError = \"\";",
            "          const debugMetadata = varab.debugMetadata;",
            "          if (debugMetadata) {",
            "            prevDeclError = ` (${varab.debugMetadata})`;",
            "          }",
            "          this.Error(`found declaration variable '${varName}' that was already declared${prevDeclError}`, varDecl, false);",
            "          return;",
            "        }",
            "        this.variableDeclarations.set(varDecl.variableName, varDecl);",
            "      };",
            "      this.ResolveWeavePointNaming = () => {",
            "        // Find all weave points and organise them by name ready for",
            "        // diverting. Also detect naming collisions.",
            "        if (this._rootWeave) {",
            "          this._rootWeave.ResolveWeavePointNaming();",
            "        }",
            "        for (const [, value] of this._subFlowsByName) {",
            "          if (value.hasOwnProperty(\"ResolveWeavePointNaming\")) {",
            "            value.ResolveWeavePointNaming();",
            "          }",
            "        }",
            "      };",
            "      this.GenerateRuntimeObject = () => {",
            "        var _a;",
            "        let foundReturn = null;",
            "        if (this.isFunction) {",
            "          this.CheckForDisallowedFunctionFlowControl();",
            "        } else if (this.flowLevel === FlowLevel.Knot || this.flowLevel === FlowLevel.Stitch) {",
            "          // Non-functon: Make sure knots and stitches don't attempt to use Return statement",
            "          foundReturn = this.Find(ReturnType)();",
            "          if (foundReturn !== null) {",
            "            this.Error(`Return statements can only be used in knots that are declared as functions: == function ${this.identifier} ==`, foundReturn);",
            "          }",
            "        }",
            "        const container = new Container();",
            "        container.name = (_a = this.identifier) === null || _a === void 0 ? void 0 : _a.name;",
            "        if (this.story.countAllVisits) {",
            "          container.visitsShouldBeCounted = true;",
            "        }",
            "        this.GenerateArgumentVariableAssignments(container);",
            "        // Run through content defined for this knot/stitch:",
            "        //  - First of all, any initial content before a sub-stitch",
            "        //    or any weave content is added to the main content container",
            "        //  - The first inner knot/stitch is automatically entered, while",
            "        //    the others are only accessible by an explicit divert",
            "        //       - The exception to this rule is if the knot/stitch takes",
            "        //         parameters, in which case it can't be auto-entered.",
            "        //  - Any Choices and Gathers (i.e. IWeavePoint) found are",
            "        //    processsed by GenerateFlowContent.",
            "        let contentIdx = 0;",
            "        while (this.content !== null && contentIdx < this.content.length) {",
            "          const obj = this.content[contentIdx];",
            "          // Inner knots and stitches",
            "          if (obj instanceof FlowBase) {",
            "            const childFlow = obj;",
            "            const childFlowRuntime = childFlow.runtimeObject;",
            "            // First inner stitch - automatically step into it",
            "            // 20/09/2016 - let's not auto step into knots",
            "            if (contentIdx === 0 && !childFlow.hasParameters && this.flowLevel === FlowLevel.Knot) {",
            "              this._startingSubFlowDivert = new Divert$1();",
            "              container.AddContent(this._startingSubFlowDivert);",
            "              this._startingSubFlowRuntime = childFlowRuntime;",
            "            }",
            "            // Check for duplicate knots/stitches with same name",
            "            const namedChild = childFlowRuntime;",
            "            const existingChild = container.namedContent.get(namedChild.name) || null;",
            "            if (existingChild) {",
            "              const errorMsg = `${this.GetType()} already contains flow named '${namedChild.name}' (at ${existingChild.debugMetadata})`;",
            "              this.Error(errorMsg, childFlow);",
            "            }",
            "            container.AddToNamedContentOnly(namedChild);",
            "          } else if (obj) {",
            "            // Other content (including entire Weaves that were grouped in the constructor)",
            "            // At the time of writing, all FlowBases have a maximum of one piece of \"other content\"",
            "            // and it's always the root Weave",
            "            container.AddContent(obj.runtimeObject);",
            "          }",
            "          contentIdx += 1;",
            "        }",
            "        // CHECK FOR FINAL LOOSE ENDS!",
            "        // Notes:",
            "        //  - Functions don't need to terminate - they just implicitly return",
            "        //  - If return statement was found, don't continue finding warnings for missing control flow,",
            "        // since it's likely that a return statement has been used instead of a ->-> or something,",
            "        // or the writer failed to mark the knot as a function.",
            "        //  - _rootWeave may be null if it's a knot that only has stitches",
            "        if (this.flowLevel !== FlowLevel.Story && !this.isFunction && this._rootWeave !== null && foundReturn === null) {",
            "          this._rootWeave.ValidateTermination(this.WarningInTermination);",
            "        }",
            "        return container;",
            "      };",
            "      this.GenerateArgumentVariableAssignments = container => {",
            "        var _a;",
            "        if (this.args === null || this.args.length === 0) {",
            "          return;",
            "        }",
            "        // Assign parameters in reverse since they'll be popped off the evaluation stack",
            "        // No need to generate EvalStart and EvalEnd since there's nothing being pushed",
            "        // back onto the evaluation stack.",
            "        for (let ii = this.args.length - 1; ii >= 0; --ii) {",
            "          const paramName = ((_a = this.args[ii].identifier) === null || _a === void 0 ? void 0 : _a.name) || null;",
            "          const assign = new VariableAssignment$1(paramName, true);",
            "          container.AddContent(assign);",
            "        }",
            "      };",
            "      this.ContentWithNameAtLevel = function (name) {",
            "        let level = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;",
            "        let deepSearch = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;",
            "        var _a;",
            "        // Referencing self?",
            "        if (level === _this.flowLevel || level === null) {",
            "          if (name === ((_a = _this.identifier) === null || _a === void 0 ? void 0 : _a.name)) {",
            "            return _this;",
            "          }",
            "        }",
            "        if (level === FlowLevel.WeavePoint || level === null) {",
            "          let weavePointResult = null;",
            "          if (_this._rootWeave) {",
            "            weavePointResult = _this._rootWeave.WeavePointNamed(name);",
            "            if (weavePointResult) {",
            "              return weavePointResult;",
            "            }",
            "          }",
            "          // Stop now if we only wanted a result if it's a weave point?",
            "          if (level === FlowLevel.WeavePoint) {",
            "            return deepSearch ? _this.DeepSearchForAnyLevelContent(name) : null;",
            "          }",
            "        }",
            "        // If this flow would be incapable of containing the requested level, early out",
            "        // (e.g. asking for a Knot from a Stitch)",
            "        if (level !== null && level < _this.flowLevel) {",
            "          return null;",
            "        }",
            "        let subFlow = _this._subFlowsByName.get(name) || null;",
            "        if (subFlow && (level === null || level === subFlow.flowLevel)) {",
            "          return subFlow;",
            "        }",
            "        return deepSearch ? _this.DeepSearchForAnyLevelContent(name) : null;",
            "      };",
            "      this.DeepSearchForAnyLevelContent = name => {",
            "        const weaveResultSelf = this.ContentWithNameAtLevel(name, FlowLevel.WeavePoint, false);",
            "        if (weaveResultSelf) {",
            "          return weaveResultSelf;",
            "        }",
            "        for (const [, value] of this._subFlowsByName) {",
            "          const deepResult = value.ContentWithNameAtLevel(name, null, true);",
            "          if (deepResult) {",
            "            return deepResult;",
            "          }",
            "        }",
            "        return null;",
            "      };",
            "      this.CheckForDisallowedFunctionFlowControl = () => {",
            "        // if (!(this instanceof Knot)) { // cannont use Knot here because of circular dependancy",
            "        if (this.flowLevel !== FlowLevel.Knot) {",
            "          this.Error(\"Functions cannot be stitches - i.e. they should be defined as '== function myFunc ==' rather than internal to another knot.\");",
            "        }",
            "        // Not allowed sub-flows",
            "        for (const [key, value] of this._subFlowsByName) {",
            "          this.Error(`Functions may not contain stitches, but saw '${key}' within the function '${this.identifier}'`, value);",
            "        }",
            "        if (!this._rootWeave) {",
            "          throw new Error();",
            "        }",
            "        const allDiverts = this._rootWeave.FindAll(Divert)();",
            "        for (const divert of allDiverts) {",
            "          if (!divert.isFunctionCall && !(divert.parent instanceof DivertTarget)) {",
            "            this.Error(`Functions may not contain diverts, but saw '${divert}'`, divert);",
            "          }",
            "        }",
            "        const allChoices = this._rootWeave.FindAll(Choice$1)();",
            "        for (const choice of allChoices) {",
            "          this.Error(`Functions may not contain choices, but saw '${choice}'`, choice);",
            "        }",
            "      };",
            "      this.WarningInTermination = terminatingObject => {",
            "        let message = \"Apparent loose end exists where the flow runs out. Do you need a '-> DONE' statement, choice or divert?\";",
            "        if (terminatingObject.parent === this._rootWeave && this._firstChildFlow) {",
            "          message = `${message} Note that if you intend to enter '${this._firstChildFlow.identifier}' next, you need to divert to it explicitly.`;",
            "        }",
            "        const terminatingDivert = asOrNull(terminatingObject, Divert);",
            "        if (terminatingDivert && terminatingDivert.isTunnel) {",
            "          message += ` When final tunnel to '${terminatingDivert.target} ->' returns it won't have anywhere to go.`;",
            "        }",
            "        this.Warning(message, terminatingObject);",
            "      };",
            "      this.toString = () => `${this.typeName} '${this.identifier}'`;",
            "      this.identifier = identifier;",
            "      this.args = args;",
            "      if (topLevelObjects === null) {",
            "        topLevelObjects = [];",
            "      }",
            "      // Used by story to add includes",
            "      this.PreProcessTopLevelObjects(topLevelObjects);",
            "      topLevelObjects = this.SplitWeaveAndSubFlowContent(topLevelObjects, this.GetType() == \"Story\" && !isIncludedStory);",
            "      this.AddContent(topLevelObjects);",
            "    }",
            "    PreProcessTopLevelObjects(_) {",
            "      // empty by default, used by Story to process included file references",
            "    }",
            "    ResolveReferences(context) {",
            "      var _a, _b;",
            "      if (this._startingSubFlowDivert) {",
            "        if (!this._startingSubFlowRuntime) {",
            "          throw new Error();",
            "        }",
            "        this._startingSubFlowDivert.targetPath = this._startingSubFlowRuntime.path;",
            "      }",
            "      super.ResolveReferences(context);",
            "      // Check validity of parameter names",
            "      if (this.args !== null) {",
            "        for (const arg of this.args) {",
            "          context.CheckForNamingCollisions(this, arg.identifier, SymbolType.Arg, \"argument\");",
            "        }",
            "        // Separately, check for duplicate arugment names, since they aren't Parsed.Objects,",
            "        // so have to be checked independently.",
            "        for (let ii = 0; ii < this.args.length; ii += 1) {",
            "          for (let jj = ii + 1; jj < this.args.length; jj += 1) {",
            "            if (((_a = this.args[ii].identifier) === null || _a === void 0 ? void 0 : _a.name) == ((_b = this.args[jj].identifier) === null || _b === void 0 ? void 0 : _b.name)) {",
            "              this.Error(`Multiple arguments with the same name: '${this.args[ii].identifier}'`);",
            "            }",
            "          }",
            "        }",
            "      }",
            "      // Check naming collisions for knots and stitches",
            "      if (this.flowLevel !== FlowLevel.Story) {",
            "        // Weave points aren't FlowBases, so this will only be knot or stitch",
            "        const symbolType = this.flowLevel === FlowLevel.Knot ? SymbolType.Knot : SymbolType.SubFlowAndWeave;",
            "        context.CheckForNamingCollisions(this, this.identifier, symbolType);",
            "      }",
            "    }",
            "  }",
            "",
            "  class ContentList extends ParsedObject {",
            "    get runtimeContainer() {",
            "      return this.runtimeObject;",
            "    }",
            "    constructor(objects) {",
            "      super();",
            "      this.dontFlatten = false;",
            "      this.TrimTrailingWhitespace = () => {",
            "        for (let ii = this.content.length - 1; ii >= 0; --ii) {",
            "          const text = asOrNull(this.content[ii], Text);",
            "          if (text === null) {",
            "            break;",
            "          }",
            "          text.text = text.text.replace(new RegExp(/[ \\t]/g), \"\");",
            "          if (text.text.length === 0) {",
            "            this.content.splice(ii, 1);",
            "          } else {",
            "            break;",
            "          }",
            "        }",
            "      };",
            "      this.GenerateRuntimeObject = () => {",
            "        const container = new Container();",
            "        if (this.content !== null) {",
            "          for (const obj of this.content) {",
            "            const contentObjRuntime = obj.runtimeObject;",
            "            // Some objects (e.g. author warnings) don't generate runtime objects",
            "            if (contentObjRuntime) {",
            "              container.AddContent(contentObjRuntime);",
            "            }",
            "          }",
            "        }",
            "        if (this.dontFlatten) {",
            "          this.story.DontFlattenContainer(container);",
            "        }",
            "        return container;",
            "      };",
            "      this.toString = () => `ContentList(${this.content.join(\", \")})`;",
            "      if (objects) {",
            "        this.AddContent(objects);",
            "      }",
            "      for (var _len = arguments.length, moreObjects = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {",
            "        moreObjects[_key - 1] = arguments[_key];",
            "      }",
            "      if (moreObjects) {",
            "        this.AddContent(moreObjects);",
            "      }",
            "    }",
            "    get typeName() {",
            "      return \"ContentList\";",
            "    }",
            "  }",
            "",
            "  class VariableReference$1 extends InkObject {",
            "    get containerForCount() {",
            "      if (this.pathForCount === null) return null;",
            "      return this.ResolvePath(this.pathForCount).container;",
            "    }",
            "    get pathStringForCount() {",
            "      if (this.pathForCount === null) return null;",
            "      return this.CompactPathString(this.pathForCount);",
            "    }",
            "    set pathStringForCount(value) {",
            "      if (value === null) this.pathForCount = null;else this.pathForCount = new Path$1(value);",
            "    }",
            "    constructor() {",
            "      let name = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;",
            "      super();",
            "      this.pathForCount = null;",
            "      this.name = name;",
            "    }",
            "    toString() {",
            "      if (this.name != null) {",
            "        return \"var(\" + this.name + \")\";",
            "      } else {",
            "        let pathStr = this.pathStringForCount;",
            "        return \"read_count(\" + pathStr + \")\";",
            "      }",
            "    }",
            "  }",
            "",
            "  class VariableReference extends Expression {",
            "    // - Normal variables have a single item in their \"path\"",
            "    // - Knot/stitch names for read counts are actual dot-separated paths",
            "    //   (though this isn't actually used at time of writing)",
            "    // - List names are dot separated: listName.itemName (or just itemName)",
            "    get name() {",
            "      return this.path.join(\".\");",
            "    }",
            "    get path() {",
            "      return this.pathIdentifiers.map(id => id.name).filter(filterUndef);",
            "    }",
            "    get identifier() {",
            "      if (!this.pathIdentifiers || this.pathIdentifiers.length == 0) {",
            "        return null;",
            "      }",
            "      const name = this.path.join(\".\");",
            "      const id = new Identifier(name);",
            "      return id;",
            "    }",
            "    get runtimeVarRef() {",
            "      return this._runtimeVarRef;",
            "    }",
            "    constructor(pathIdentifiers) {",
            "      super();",
            "      this.pathIdentifiers = pathIdentifiers;",
            "      this._runtimeVarRef = null;",
            "      // Only known after GenerateIntoContainer has run",
            "      this.isConstantReference = false;",
            "      this.isListItemReference = false;",
            "      this.GenerateIntoContainer = container => {",
            "        let constantValue = this.story.constants.get(this.name);",
            "        // If it's a constant reference, just generate the literal expression value",
            "        // It's okay to access the constants at code generation time, since the",
            "        // first thing the ExportRuntime function does it search for all the constants",
            "        // in the story hierarchy, so they're all available.",
            "        if (constantValue) {",
            "          constantValue.GenerateConstantIntoContainer(container);",
            "          this.isConstantReference = true;",
            "          return;",
            "        }",
            "        this._runtimeVarRef = new VariableReference$1(this.name);",
            "        // List item reference?",
            "        // Path might be to a list (listName.listItemName or just listItemName)",
            "        if (this.path.length === 1 || this.path.length === 2) {",
            "          let listItemName = \"\";",
            "          let listName = \"\";",
            "          if (this.path.length === 1) {",
            "            listItemName = this.path[0];",
            "          } else {",
            "            listName = this.path[0];",
            "            listItemName = this.path[1];",
            "          }",
            "          const listItem = this.story.ResolveListItem(listName, listItemName, this);",
            "          if (listItem) {",
            "            this.isListItemReference = true;",
            "          }",
            "        }",
            "        container.AddContent(this._runtimeVarRef);",
            "      };",
            "      this.toString = () => `{${this.path.join(\".\")}}`;",
            "    }",
            "    get typeName() {",
            "      return \"ref\";",
            "    }",
            "    ResolveReferences(context) {",
            "      super.ResolveReferences(context);",
            "      // Work is already done if it's a constant or list item reference",
            "      if (this.isConstantReference || this.isListItemReference) {",
            "        return;",
            "      }",
            "      // Is it a read count?",
            "      const parsedPath = new Path(this.pathIdentifiers);",
            "      const targetForCount = parsedPath.ResolveFromContext(this);",
            "      if (targetForCount) {",
            "        if (!targetForCount.containerForCounting) {",
            "          throw new Error();",
            "        }",
            "        targetForCount.containerForCounting.visitsShouldBeCounted = true;",
            "        // If this is an argument to a function that wants a variable to be",
            "        // passed by reference, then the Parsed.Divert will have generated a",
            "        // Runtime.VariablePointerValue instead of allowing this object",
            "        // to generate its RuntimeVariableReference. This only happens under",
            "        // error condition since we shouldn't be passing a read count by",
            "        // reference, but we don't want it to crash!",
            "        if (this._runtimeVarRef === null) {",
            "          return;",
            "        }",
            "        this._runtimeVarRef.pathForCount = targetForCount.runtimePath;",
            "        this._runtimeVarRef.name = null;",
            "        // Check for very specific writer error: getting read count and",
            "        // printing it as content rather than as a piece of logic",
            "        // e.g. Writing {myFunc} instead of {myFunc()}",
            "        let targetFlow = asOrNull(targetForCount, FlowBase);",
            "        if (targetFlow && targetFlow.isFunction) {",
            "          // Is parent context content rather than logic?",
            "          if (this.parent instanceof Weave || this.parent instanceof ContentList || this.parent instanceof FlowBase) {",
            "            this.Warning(`'${targetFlow.identifier}' being used as read count rather than being called as function. Perhaps you intended to write ${targetFlow.identifier}()`);",
            "          }",
            "        }",
            "        return;",
            "      }",
            "      // Couldn't find this multi-part path at all, whether as a divert",
            "      // target or as a list item reference.",
            "      if (this.path.length > 1) {",
            "        let errorMsg = `Could not find target for read count: ${parsedPath}`;",
            "        if (this.path.length <= 2) {",
            "          errorMsg += `, or couldn't find list item with the name ${this.path.join(\",\")}`;",
            "        }",
            "        this.Error(errorMsg);",
            "        return;",
            "      }",
            "      if (!context.ResolveVariableWithName(this.name, this).found) {",
            "        this.Error(`Unresolved variable: ${this.name}`, this);",
            "      }",
            "    }",
            "  }",
            "",
            "  class FunctionCall extends Expression {",
            "    get proxyDivert() {",
            "      return this._proxyDivert;",
            "    }",
            "    get name() {",
            "      return this._proxyDivert.target.firstComponent || \"\";",
            "    }",
            "    get args() {",
            "      return this._proxyDivert.args;",
            "    }",
            "    get runtimeDivert() {",
            "      return this._proxyDivert.runtimeDivert;",
            "    }",
            "    get isChoiceCount() {",
            "      return this.name === \"CHOICE_COUNT\";",
            "    }",
            "    get isTurns() {",
            "      return this.name === \"TURNS\";",
            "    }",
            "    get isTurnsSince() {",
            "      return this.name === \"TURNS_SINCE\";",
            "    }",
            "    get isRandom() {",
            "      return this.name === \"RANDOM\";",
            "    }",
            "    get isSeedRandom() {",
            "      return this.name === \"SEED_RANDOM\";",
            "    }",
            "    get isListRange() {",
            "      return this.name === \"LIST_RANGE\";",
            "    }",
            "    get isListRandom() {",
            "      return this.name === \"LIST_RANDOM\";",
            "    }",
            "    get isReadCount() {",
            "      return this.name === \"READ_COUNT\";",
            "    }",
            "    constructor(functionName, args) {",
            "      super();",
            "      this._divertTargetToCount = null;",
            "      this._variableReferenceToCount = null;",
            "      this.shouldPopReturnedValue = false;",
            "      this.GenerateIntoContainer = container => {",
            "        const foundList = this.story.ResolveList(this.name);",
            "        let usingProxyDivert = false;",
            "        if (this.isChoiceCount) {",
            "          if (this.args.length > 0) {",
            "            this.Error(\"The CHOICE_COUNT() function shouldn't take any arguments\");",
            "          }",
            "          container.AddContent(ControlCommand.ChoiceCount());",
            "        } else if (this.isTurns) {",
            "          if (this.args.length > 0) {",
            "            this.Error(\"The TURNS() function shouldn't take any arguments\");",
            "          }",
            "          container.AddContent(ControlCommand.Turns());",
            "        } else if (this.isTurnsSince || this.isReadCount) {",
            "          const divertTarget = asOrNull(this.args[0], DivertTarget);",
            "          const variableDivertTarget = asOrNull(this.args[0], VariableReference);",
            "          if (this.args.length !== 1 || divertTarget === null && variableDivertTarget === null) {",
            "            this.Error(`The ${this.name}() function should take one argument: a divert target to the target knot, stitch, gather or choice you want to check. e.g. TURNS_SINCE(-> myKnot)`);",
            "            return;",
            "          }",
            "          if (divertTarget) {",
            "            this._divertTargetToCount = divertTarget;",
            "            this.AddContent(this._divertTargetToCount);",
            "            this._divertTargetToCount.GenerateIntoContainer(container);",
            "          } else if (variableDivertTarget) {",
            "            this._variableReferenceToCount = variableDivertTarget;",
            "            this.AddContent(this._variableReferenceToCount);",
            "            this._variableReferenceToCount.GenerateIntoContainer(container);",
            "          }",
            "          if (this.isTurnsSince) {",
            "            container.AddContent(ControlCommand.TurnsSince());",
            "          } else {",
            "            container.AddContent(ControlCommand.ReadCount());",
            "          }",
            "        } else if (this.isRandom) {",
            "          if (this.args.length !== 2) {",
            "            this.Error(\"RANDOM should take 2 parameters: a minimum and a maximum integer\");",
            "          }",
            "          // We can type check single values, but not complex expressions",
            "          for (let ii = 0; ii < this.args.length; ii += 1) {",
            "            const num = asOrNull(this.args[ii], NumberExpression);",
            "            if (num && !num.isInt()) {",
            "              const paramName = ii === 0 ? \"minimum\" : \"maximum\";",
            "              this.Error(`RANDOM's ${paramName} parameter should be an integer`);",
            "            }",
            "            this.args[ii].GenerateIntoContainer(container);",
            "          }",
            "          container.AddContent(ControlCommand.Random());",
            "        } else if (this.isSeedRandom) {",
            "          if (this.args.length !== 1) {",
            "            this.Error(\"SEED_RANDOM should take 1 parameter - an integer seed\");",
            "          }",
            "          const num = asOrNull(this.args[0], NumberExpression);",
            "          if (num && !num.isInt()) {",
            "            this.Error(\"SEED_RANDOM's parameter should be an integer seed\");",
            "          }",
            "          this.args[0].GenerateIntoContainer(container);",
            "          container.AddContent(ControlCommand.SeedRandom());",
            "        } else if (this.isListRange) {",
            "          if (this.args.length !== 3) {",
            "            this.Error(\"LIST_RANGE should take 3 parameters - a list, a min and a max\");",
            "          }",
            "          for (let ii = 0; ii < this.args.length; ii += 1) {",
            "            this.args[ii].GenerateIntoContainer(container);",
            "          }",
            "          container.AddContent(ControlCommand.ListRange());",
            "        } else if (this.isListRandom) {",
            "          if (this.args.length !== 1) {",
            "            this.Error(\"LIST_RANDOM should take 1 parameter - a list\");",
            "          }",
            "          this.args[0].GenerateIntoContainer(container);",
            "          container.AddContent(ControlCommand.ListRandom());",
            "        } else if (NativeFunctionCall.CallExistsWithName(this.name)) {",
            "          const nativeCall = NativeFunctionCall.CallWithName(this.name);",
            "          if (nativeCall.numberOfParameters !== this.args.length) {",
            "            let msg = `${name} should take ${nativeCall.numberOfParameters} parameter`;",
            "            if (nativeCall.numberOfParameters > 1) {",
            "              msg += \"s\";",
            "            }",
            "            this.Error(msg);",
            "          }",
            "          for (let ii = 0; ii < this.args.length; ii += 1) {",
            "            this.args[ii].GenerateIntoContainer(container);",
            "          }",
            "          container.AddContent(NativeFunctionCall.CallWithName(this.name));",
            "        } else if (foundList !== null) {",
            "          if (this.args.length > 1) {",
            "            this.Error(\"Can currently only construct a list from one integer (or an empty list from a given list definition)\");",
            "          }",
            "          // List item from given int",
            "          if (this.args.length === 1) {",
            "            container.AddContent(new StringValue(this.name));",
            "            this.args[0].GenerateIntoContainer(container);",
            "            container.AddContent(ControlCommand.ListFromInt());",
            "          } else {",
            "            // Empty list with given origin.",
            "            const list = new InkList();",
            "            list.SetInitialOriginName(this.name);",
            "            container.AddContent(new ListValue(list));",
            "          }",
            "        } else {",
            "          // Normal function call",
            "          container.AddContent(this._proxyDivert.runtimeObject);",
            "          usingProxyDivert = true;",
            "        }",
            "        // Don't attempt to resolve as a divert if we're not doing a normal function call",
            "        if (!usingProxyDivert) {",
            "          this.content.splice(this.content.indexOf(this._proxyDivert), 1);",
            "        }",
            "        // Function calls that are used alone on a tilda-based line:",
            "        //  ~ func()",
            "        // Should tidy up any returned value from the evaluation stack,",
            "        // since it's unused.",
            "        if (this.shouldPopReturnedValue) {",
            "          container.AddContent(ControlCommand.PopEvaluatedValue());",
            "        }",
            "      };",
            "      this.toString = () => {",
            "        const strArgs = this.args.join(\", \");",
            "        return `${this.name}(${strArgs})`;",
            "      };",
            "      this._proxyDivert = new Divert(new Path(functionName), args);",
            "      this._proxyDivert.isFunctionCall = true;",
            "      this.AddContent(this._proxyDivert);",
            "    }",
            "    get typeName() {",
            "      return \"FunctionCall\";",
            "    }",
            "    ResolveReferences(context) {",
            "      super.ResolveReferences(context);",
            "      // If we aren't using the proxy divert after all (e.g. if",
            "      // it's a native function call), but we still have arguments,",
            "      // we need to make sure they get resolved since the proxy divert",
            "      // is no longer in the content array.",
            "      if (!this.content.includes(this._proxyDivert) && this.args !== null) {",
            "        for (const arg of this.args) {",
            "          arg.ResolveReferences(context);",
            "        }",
            "      }",
            "      if (this._divertTargetToCount) {",
            "        const divert = this._divertTargetToCount.divert;",
            "        const attemptingTurnCountOfVariableTarget = divert.runtimeDivert.variableDivertName != null;",
            "        if (attemptingTurnCountOfVariableTarget) {",
            "          this.Error(`When getting the TURNS_SINCE() of a variable target, remove the '->' - i.e. it should just be TURNS_SINCE(${divert.runtimeDivert.variableDivertName})`);",
            "          return;",
            "        }",
            "        const targetObject = divert.targetContent;",
            "        if (targetObject === null) {",
            "          if (!attemptingTurnCountOfVariableTarget) {",
            "            this.Error(`Failed to find target for TURNS_SINCE: '${divert.target}'`);",
            "          }",
            "        } else {",
            "          if (!targetObject.containerForCounting) {",
            "            throw new Error();",
            "          }",
            "          targetObject.containerForCounting.turnIndexShouldBeCounted = true;",
            "        }",
            "      } else if (this._variableReferenceToCount) {",
            "        const runtimeVarRef = this._variableReferenceToCount.runtimeVarRef;",
            "        if (!runtimeVarRef) {",
            "          throw new Error();",
            "        }",
            "        if (runtimeVarRef.pathForCount !== null) {",
            "          this.Error(`Should be '${name}'(-> '${this._variableReferenceToCount.name}). Usage without the '->' only makes sense for variable targets.`);",
            "        }",
            "      }",
            "    }",
            "  }",
            "  FunctionCall.IsBuiltIn = name => {",
            "    if (NativeFunctionCall.CallExistsWithName(name)) {",
            "      return true;",
            "    }",
            "    return name === \"CHOICE_COUNT\" || name === \"TURNS_SINCE\" || name === \"TURNS\" || name === \"RANDOM\" || name === \"SEED_RANDOM\" || name === \"LIST_VALUE\" || name === \"LIST_RANDOM\" || name === \"READ_COUNT\";",
            "  };",
            "",
            "  class MultipleConditionExpression extends Expression {",
            "    get subExpressions() {",
            "      return this.content;",
            "    }",
            "    constructor(conditionExpressions) {",
            "      super();",
            "      this.GenerateIntoContainer = container => {",
            "        //    A && B && C && D",
            "        // => (((A B &&) C &&) D &&) etc",
            "        let isFirst = true;",
            "        for (const conditionExpr of this.subExpressions) {",
            "          conditionExpr.GenerateIntoContainer(container);",
            "          if (!isFirst) {",
            "            container.AddContent(NativeFunctionCall.CallWithName(\"&&\"));",
            "          }",
            "          isFirst = false;",
            "        }",
            "      };",
            "      this.AddContent(conditionExpressions);",
            "    }",
            "    get typeName() {",
            "      return \"MultipleConditionExpression\";",
            "    }",
            "  }",
            "",
            "  class DivertTarget extends Expression {",
            "    get runtimeDivert() {",
            "      if (!this._runtimeDivert) {",
            "        throw new Error();",
            "      }",
            "      return this._runtimeDivert;",
            "    }",
            "    get runtimeDivertTargetValue() {",
            "      if (!this._runtimeDivertTargetValue) {",
            "        throw new Error();",
            "      }",
            "      return this._runtimeDivertTargetValue;",
            "    }",
            "    constructor(divert) {",
            "      super();",
            "      this._runtimeDivert = null;",
            "      this._runtimeDivertTargetValue = null;",
            "      this.GenerateIntoContainer = container => {",
            "        this.divert.GenerateRuntimeObject();",
            "        this._runtimeDivert = this.divert.runtimeDivert;",
            "        this._runtimeDivertTargetValue = new DivertTargetValue();",
            "        container.AddContent(this.runtimeDivertTargetValue);",
            "      };",
            "      // Equals override necessary in order to check for CONST multiple definition equality",
            "      this.Equals = obj => {",
            "        const otherDivTarget = asOrNull(obj, DivertTarget);",
            "        if (!otherDivTarget || !this.divert.target || !otherDivTarget.divert.target) {",
            "          return false;",
            "        }",
            "        const targetStr = this.divert.target.dotSeparatedComponents;",
            "        const otherTargetStr = otherDivTarget.divert.target.dotSeparatedComponents;",
            "        return targetStr === otherTargetStr;",
            "      };",
            "      this.divert = this.AddContent(divert);",
            "    }",
            "    get typeName() {",
            "      return \"DivertTarget\";",
            "    }",
            "    ResolveReferences(context) {",
            "      super.ResolveReferences(context);",
            "      if (this.divert.isDone || this.divert.isEnd) {",
            "        this.Error(`Can't use -> DONE or -> END as variable divert targets`, this);",
            "        return;",
            "      }",
            "      let usageContext = this;",
            "      while (usageContext && usageContext instanceof Expression) {",
            "        let badUsage = false;",
            "        let foundUsage = false;",
            "        const usageParent = usageContext.parent;",
            "        if (usageParent instanceof BinaryExpression) {",
            "          // Only allowed to compare for equality",
            "          const binaryExprParent = usageParent;",
            "          if (binaryExprParent.opName !== \"==\" && binaryExprParent.opName !== \"!=\") {",
            "            badUsage = true;",
            "          } else {",
            "            if (!(binaryExprParent.leftExpression instanceof DivertTarget || binaryExprParent.leftExpression instanceof VariableReference)) {",
            "              badUsage = true;",
            "            } else if (!(binaryExprParent.rightExpression instanceof DivertTarget || binaryExprParent.rightExpression instanceof VariableReference)) {",
            "              badUsage = true;",
            "            }",
            "          }",
            "          foundUsage = true;",
            "        } else if (usageParent instanceof FunctionCall) {",
            "          const funcCall = usageParent;",
            "          if (!funcCall.isTurnsSince && !funcCall.isReadCount) {",
            "            badUsage = true;",
            "          }",
            "          foundUsage = true;",
            "        } else if (usageParent instanceof Expression) {",
            "          badUsage = true;",
            "          foundUsage = true;",
            "        } else if (usageParent instanceof MultipleConditionExpression) {",
            "          badUsage = true;",
            "          foundUsage = true;",
            "        } else if (usageParent instanceof Choice$1 && usageParent.condition === usageContext) {",
            "          badUsage = true;",
            "          foundUsage = true;",
            "        } else if (usageParent instanceof Conditional || usageParent instanceof ConditionalSingleBranch) {",
            "          badUsage = true;",
            "          foundUsage = true;",
            "        }",
            "        if (badUsage) {",
            "          this.Error(`Can't use a divert target like that. Did you intend to call '${this.divert.target}' as a function: likeThis(), or check the read count: likeThis, with no arrows?`, this);",
            "        }",
            "        if (foundUsage) {",
            "          break;",
            "        }",
            "        usageContext = usageParent;",
            "      }",
            "      // Example ink for this case:",
            "      //",
            "      //     VAR x = -> blah",
            "      //",
            "      // ...which means that \"blah\" is expected to be a literal stitch target rather",
            "      // than a variable name. We can't really intelligently recover from this (e.g. if blah happens to",
            "      // contain a divert target itself) since really we should be generating a variable reference",
            "      // rather than a concrete DivertTarget, so we list it as an error.",
            "      if (this.runtimeDivert.hasVariableTarget) {",
            "        if (!this.divert.target) {",
            "          throw new Error();",
            "        }",
            "        this.Error(`Since '${this.divert.target.dotSeparatedComponents}' is a variable, it shouldn't be preceded by '->' here.`);",
            "      }",
            "      // Main resolve",
            "      this.runtimeDivert.targetPath && (this.runtimeDivertTargetValue.targetPath = this.runtimeDivert.targetPath);",
            "      // Tell hard coded (yet variable) divert targets that they also need to be counted",
            "      // TODO: Only detect DivertTargets that are values rather than being used directly for",
            "      // read or turn counts. Should be able to detect this by looking for other uses of containerForCounting",
            "      let targetContent = this.divert.targetContent;",
            "      if (targetContent !== null) {",
            "        let target = targetContent.containerForCounting;",
            "        if (target !== null) {",
            "          // Purpose is known: used directly in TURNS_SINCE(-> divTarg)",
            "          const parentFunc = asOrNull(this.parent, FunctionCall);",
            "          if (parentFunc && parentFunc.isTurnsSince) {",
            "            target.turnIndexShouldBeCounted = true;",
            "          } else {",
            "            // Unknown purpose, count everything",
            "            target.visitsShouldBeCounted = true;",
            "            target.turnIndexShouldBeCounted = true;",
            "          }",
            "        }",
            "        // Unfortunately not possible:",
            "        // https://github.com/inkle/ink/issues/538",
            "        //",
            "        // VAR func = -> double",
            "        //",
            "        // === function double(ref x)",
            "        //    ~ x = x * 2",
            "        //",
            "        // Because when generating the parameters for a function",
            "        // to be called, it needs to know ahead of time when",
            "        // compiling whether to pass a variable reference or value.",
            "        //",
            "        let targetFlow = asOrNull(targetContent, FlowBase);",
            "        if (targetFlow != null && targetFlow.args !== null) {",
            "          for (const arg of targetFlow.args) {",
            "            if (arg.isByReference) {",
            "              this.Error(`Can't store a divert target to a knot or function that has by-reference arguments ('${targetFlow.identifier}' has 'ref ${arg.identifier}').`);",
            "            }",
            "          }",
            "        }",
            "      }",
            "    }",
            "  }",
            "",
            "  class Divert extends ParsedObject {",
            "    get runtimeDivert() {",
            "      if (!this._runtimeDivert) {",
            "        throw new Error();",
            "      }",
            "      return this._runtimeDivert;",
            "    }",
            "    set runtimeDivert(value) {",
            "      this._runtimeDivert = value;",
            "    }",
            "    get isEnd() {",
            "      return Boolean(this.target && this.target.dotSeparatedComponents === \"END\");",
            "    }",
            "    get isDone() {",
            "      return Boolean(this.target && this.target.dotSeparatedComponents === \"DONE\");",
            "    }",
            "    constructor(target, args) {",
            "      super();",
            "      this.args = [];",
            "      this.target = null;",
            "      this.targetContent = null;",
            "      this._runtimeDivert = null;",
            "      this.isFunctionCall = false;",
            "      this.isEmpty = false;",
            "      this.isTunnel = false;",
            "      this.isThread = false;",
            "      this.GenerateRuntimeObject = () => {",
            "        // End = end flow immediately",
            "        // Done = return from thread or instruct the flow that it's safe to exit",
            "        if (this.isEnd) {",
            "          return ControlCommand.End();",
            "        } else if (this.isDone) {",
            "          return ControlCommand.Done();",
            "        }",
            "        this.runtimeDivert = new Divert$1();",
            "        // Normally we resolve the target content during the",
            "        // Resolve phase, since we expect all runtime objects to",
            "        // be available in order to find the final runtime path for",
            "        // the destination. However, we need to resolve the target",
            "        // (albeit without the runtime target) early so that",
            "        // we can get information about the arguments - whether",
            "        // they're by reference - since it affects the code we",
            "        // generate here.",
            "        this.ResolveTargetContent();",
            "        this.CheckArgumentValidity();",
            "        // Passing arguments to the knot",
            "        const requiresArgCodeGen = this.args !== null && this.args.length > 0;",
            "        if (requiresArgCodeGen || this.isFunctionCall || this.isTunnel || this.isThread) {",
            "          const container = new Container();",
            "          // Generate code for argument evaluation",
            "          // This argument generation is coded defensively - it should",
            "          // attempt to generate the code for all the parameters, even if",
            "          // they don't match the expected arguments. This is so that the",
            "          // parameter objects themselves are generated correctly and don't",
            "          // get into a state of attempting to resolve references etc",
            "          // without being generated.",
            "          if (requiresArgCodeGen) {",
            "            // Function calls already in an evaluation context",
            "            if (!this.isFunctionCall) {",
            "              container.AddContent(ControlCommand.EvalStart());",
            "            }",
            "            let targetArguments = null;",
            "            if (this.targetContent) {",
            "              targetArguments = this.targetContent.args;",
            "            }",
            "            for (let ii = 0; ii < this.args.length; ++ii) {",
            "              const argToPass = this.args[ii];",
            "              let argExpected = null;",
            "              if (targetArguments && ii < targetArguments.length) {",
            "                argExpected = targetArguments[ii];",
            "              }",
            "              // Pass by reference: argument needs to be a variable reference",
            "              if (argExpected && argExpected.isByReference) {",
            "                const varRef = asOrNull(argToPass, VariableReference);",
            "                if (!varRef) {",
            "                  this.Error(`Expected variable name to pass by reference to 'ref ${argExpected.identifier}' but saw ${argToPass}`);",
            "                  break;",
            "                }",
            "                // Check that we're not attempting to pass a read count by reference",
            "                const targetPath = new Path(varRef.pathIdentifiers);",
            "                const targetForCount = targetPath.ResolveFromContext(this);",
            "                if (targetForCount) {",
            "                  this.Error(`can't pass a read count by reference. '${targetPath.dotSeparatedComponents}' is a knot/stitch/label, but '${this.target.dotSeparatedComponents}' requires the name of a VAR to be passed.`);",
            "                  break;",
            "                }",
            "                const varPointer = new VariablePointerValue(varRef.name);",
            "                container.AddContent(varPointer);",
            "              } else {",
            "                // Normal value being passed: evaluate it as normal",
            "                argToPass.GenerateIntoContainer(container);",
            "              }",
            "            }",
            "            // Function calls were already in an evaluation context",
            "            if (!this.isFunctionCall) {",
            "              container.AddContent(ControlCommand.EvalEnd());",
            "            }",
            "          }",
            "          // Starting a thread? A bit like a push to the call stack below... but not.",
            "          // It sort of puts the call stack on a thread stack (argh!) - forks the full flow.",
            "          if (this.isThread) {",
            "            container.AddContent(ControlCommand.StartThread());",
            "          } else if (this.isFunctionCall || this.isTunnel) {",
            "            // If this divert is a function call, tunnel, we push to the call stack",
            "            // so we can return again",
            "            this.runtimeDivert.pushesToStack = true;",
            "            this.runtimeDivert.stackPushType = this.isFunctionCall ? PushPopType.Function : PushPopType.Tunnel;",
            "          }",
            "          // Jump into the \"function\" (knot/stitch)",
            "          container.AddContent(this.runtimeDivert);",
            "          return container;",
            "        }",
            "        // Simple divert",
            "        return this.runtimeDivert;",
            "      };",
            "      // When the divert is to a target that's actually a variable name",
            "      // rather than an explicit knot/stitch name, try interpretting it",
            "      // as such by getting the variable name.",
            "      this.PathAsVariableName = () => this.target ? this.target.firstComponent : null;",
            "      this.ResolveTargetContent = () => {",
            "        if (this.isEmpty || this.isEnd) {",
            "          return;",
            "        }",
            "        if (this.targetContent === null) {",
            "          // Is target of this divert a variable name that will be de-referenced",
            "          // at runtime? If so, there won't be any further reference resolution",
            "          // we can do at this point.",
            "          let variableTargetName = this.PathAsVariableName();",
            "          if (variableTargetName !== null) {",
            "            const flowBaseScope = asOrNull(ClosestFlowBase(this), FlowBase);",
            "            if (flowBaseScope) {",
            "              const resolveResult = flowBaseScope.ResolveVariableWithName(variableTargetName, this);",
            "              if (resolveResult.found) {",
            "                // Make sure that the flow was typed correctly, given that we know that this",
            "                // is meant to be a divert target",
            "                if (resolveResult.isArgument && resolveResult.ownerFlow && resolveResult.ownerFlow.args) {",
            "                  let argument = resolveResult.ownerFlow.args.find(a => {",
            "                    var _a;",
            "                    return ((_a = a.identifier) === null || _a === void 0 ? void 0 : _a.name) == variableTargetName;",
            "                  });",
            "                  if (argument && !argument.isDivertTarget) {",
            "                    this.Error(`Since '${argument.identifier}' is used as a variable divert target (on ${this.debugMetadata}), it should be marked as: -> ${argument.identifier}`, resolveResult.ownerFlow);",
            "                  }",
            "                }",
            "                this.runtimeDivert.variableDivertName = variableTargetName;",
            "                return;",
            "              }",
            "            }",
            "          }",
            "          if (!this.target) {",
            "            throw new Error();",
            "          }",
            "          this.targetContent = this.target.ResolveFromContext(this);",
            "        }",
            "      };",
            "      // Returns false if there's an error",
            "      this.CheckArgumentValidity = () => {",
            "        if (this.isEmpty) {",
            "          return;",
            "        }",
            "        // Argument passing: Check for errors in number of arguments",
            "        let numArgs = 0;",
            "        if (this.args !== null && this.args.length > 0) {",
            "          numArgs = this.args.length;",
            "        }",
            "        // Missing content?",
            "        // Can't check arguments properly. It'll be due to some",
            "        // other error though, so although there's a problem and",
            "        // we report false, we don't need to report a specific error.",
            "        // It may also be because it's a valid call to an external",
            "        // function, that we check at the resolve stage.",
            "        if (this.targetContent === null) {",
            "          return;",
            "        }",
            "        const targetFlow = asOrNull(this.targetContent, FlowBase);",
            "        // No error, crikey!",
            "        if (numArgs === 0 && (targetFlow === null || !targetFlow.hasParameters)) {",
            "          return;",
            "        } else if (targetFlow === null && numArgs > 0) {",
            "          this.Error(\"target needs to be a knot or stitch in order to pass arguments\");",
            "          return;",
            "        } else if (targetFlow !== null && (targetFlow.args === null || !targetFlow.args && numArgs > 0)) {",
            "          this.Error(`target (${targetFlow.name}) doesn't take parameters`);",
            "          return;",
            "        } else if (this.parent instanceof DivertTarget) {",
            "          if (numArgs > 0) {",
            "            this.Error(`can't store arguments in a divert target variable`);",
            "          }",
            "          return;",
            "        }",
            "        const paramCount = targetFlow.args.length;",
            "        if (paramCount !== numArgs) {",
            "          let butClause;",
            "          if (numArgs === 0) {",
            "            butClause = \"but there weren't any passed to it\";",
            "          } else if (numArgs < paramCount) {",
            "            butClause = `but only got ${numArgs}`;",
            "          } else {",
            "            butClause = `but got ${numArgs}`;",
            "          }",
            "          this.Error(`to '${targetFlow.identifier}' requires ${paramCount} arguments, ${butClause}`);",
            "          return;",
            "        }",
            "        // Light type-checking for divert target arguments",
            "        for (let ii = 0; ii < paramCount; ++ii) {",
            "          const flowArg = targetFlow.args[ii];",
            "          const divArgExpr = this.args[ii];",
            "          // Expecting a divert target as an argument, let's do some basic type checking",
            "          if (flowArg.isDivertTarget) {",
            "            // Not passing a divert target or any kind of variable reference?",
            "            let varRef = asOrNull(divArgExpr, VariableReference);",
            "            if (!(divArgExpr instanceof DivertTarget) && varRef === null) {",
            "              this.Error(`Target '${targetFlow.identifier}' expects a divert target for the parameter named -> ${flowArg.identifier} but saw ${divArgExpr}`, divArgExpr);",
            "            } else if (varRef) {",
            "              // Passing 'a' instead of '-> a'?",
            "              // i.e. read count instead of divert target",
            "              // Unfortunately have to manually resolve here since we're still in code gen",
            "              const knotCountPath = new Path(varRef.pathIdentifiers);",
            "              const targetForCount = knotCountPath.ResolveFromContext(varRef);",
            "              if (targetForCount) {",
            "                this.Error(`Passing read count of '${knotCountPath.dotSeparatedComponents}' instead of a divert target. You probably meant '${knotCountPath}'`);",
            "              }",
            "            }",
            "          }",
            "        }",
            "        if (targetFlow === null) {",
            "          this.Error(\"Can't call as a function or with arguments unless it's a knot or stitch\");",
            "          return;",
            "        }",
            "        return;",
            "      };",
            "      this.CheckExternalArgumentValidity = context => {",
            "        const externalName = this.target ? this.target.firstComponent : null;",
            "        const external = context.externals.get(externalName);",
            "        if (!external) {",
            "          throw new Error(\"external not found\");",
            "        }",
            "        const externalArgCount = external.argumentNames.length;",
            "        let ownArgCount = 0;",
            "        if (this.args) {",
            "          ownArgCount = this.args.length;",
            "        }",
            "        if (ownArgCount !== externalArgCount) {",
            "          this.Error(`incorrect number of arguments sent to external function '${externalName}'. Expected ${externalArgCount} but got ${ownArgCount}`);",
            "        }",
            "      };",
            "      this.toString = () => {",
            "        let returnString = \"\";",
            "        if (this.target !== null) {",
            "          returnString += this.target.toString();",
            "        } else {",
            "          return \"-> <empty divert>\";",
            "        }",
            "        if (this.isTunnel) {",
            "          returnString += \" ->\";",
            "        }",
            "        if (this.isFunctionCall) {",
            "          returnString += \" ()\";",
            "        }",
            "        return returnString;",
            "      };",
            "      if (target) {",
            "        this.target = target;",
            "      }",
            "      if (args) {",
            "        this.args = args;",
            "        this.AddContent(args);",
            "      }",
            "    }",
            "    get typeName() {",
            "      return \"Divert\";",
            "    }",
            "    ResolveReferences(context) {",
            "      if (this.isEmpty || this.isEnd || this.isDone) {",
            "        return;",
            "      } else if (!this.runtimeDivert) {",
            "        throw new Error();",
            "      }",
            "      if (this.targetContent) {",
            "        this.runtimeDivert.targetPath = this.targetContent.runtimePath;",
            "      }",
            "      // Resolve children (the arguments)",
            "      super.ResolveReferences(context);",
            "      // May be null if it's a built in function (e.g. TURNS_SINCE)",
            "      // or if it's a variable target.",
            "      let targetFlow = asOrNull(this.targetContent, FlowBase);",
            "      if (targetFlow) {",
            "        if (!targetFlow.isFunction && this.isFunctionCall) {",
            "          super.Error(`${targetFlow.identifier} hasn't been marked as a function, but it's being called as one. Do you need to declare the knot as '== function ${targetFlow.identifier} =='?`);",
            "        } else if (targetFlow.isFunction && !this.isFunctionCall && !(this.parent instanceof DivertTarget)) {",
            "          super.Error(targetFlow.identifier + \" can't be diverted to. It can only be called as a function since it's been marked as such: '\" + targetFlow.identifier + \"(...)'\");",
            "        }",
            "      }",
            "      // Check validity of target content",
            "      const targetWasFound = this.targetContent !== null;",
            "      let isBuiltIn = false;",
            "      let isExternal = false;",
            "      if (!this.target) {",
            "        throw new Error();",
            "      } else if (this.target.numberOfComponents === 1) {",
            "        if (!this.target.firstComponent) {",
            "          throw new Error();",
            "        }",
            "        // BuiltIn means TURNS_SINCE, CHOICE_COUNT, RANDOM or SEED_RANDOM",
            "        isBuiltIn = FunctionCall.IsBuiltIn(this.target.firstComponent);",
            "        // Client-bound function?",
            "        isExternal = context.IsExternal(this.target.firstComponent);",
            "        if (isBuiltIn || isExternal) {",
            "          if (!this.isFunctionCall) {",
            "            super.Error(`${this.target.firstComponent} must be called as a function: ~ ${this.target.firstComponent}()`);",
            "          }",
            "          if (isExternal) {",
            "            this.runtimeDivert.isExternal = true;",
            "            if (this.args !== null) {",
            "              this.runtimeDivert.externalArgs = this.args.length;",
            "            }",
            "            this.runtimeDivert.pushesToStack = false;",
            "            this.runtimeDivert.targetPath = new Path$1(this.target.firstComponent);",
            "            this.CheckExternalArgumentValidity(context);",
            "          }",
            "          return;",
            "        }",
            "      }",
            "      // Variable target?",
            "      if (this.runtimeDivert.variableDivertName != null) {",
            "        return;",
            "      }",
            "      if (!targetWasFound && !isBuiltIn && !isExternal) {",
            "        this.Error(`target not found: '${this.target}'`);",
            "      }",
            "    }",
            "    Error(message) {",
            "      let source = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;",
            "      let isWarning = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;",
            "      // Could be getting an error from a nested Divert",
            "      if (source !== this && source) {",
            "        super.Error(message, source);",
            "        return;",
            "      }",
            "      if (this.isFunctionCall) {",
            "        super.Error(`Function call ${message}`, source, isWarning);",
            "      } else {",
            "        super.Error(`Divert ${message}`, source, isWarning);",
            "      }",
            "    }",
            "  }",
            "",
            "  class GatherPointToResolve {",
            "    constructor(divert, targetRuntimeObj) {",
            "      this.divert = divert;",
            "      this.targetRuntimeObj = targetRuntimeObj;",
            "    }",
            "  }",
            "",
            "  class SequenceDivertToResolve {",
            "    constructor(divert, targetContent) {",
            "      this.divert = divert;",
            "      this.targetContent = targetContent;",
            "    }",
            "  }",
            "",
            "  var SequenceType;",
            "  (function (SequenceType) {",
            "    SequenceType[SequenceType[\"Stopping\"] = 1] = \"Stopping\";",
            "    SequenceType[SequenceType[\"Cycle\"] = 2] = \"Cycle\";",
            "    SequenceType[SequenceType[\"Shuffle\"] = 4] = \"Shuffle\";",
            "    SequenceType[SequenceType[\"Once\"] = 8] = \"Once\";",
            "  })(SequenceType || (SequenceType = {}));",
            "",
            "  class Sequence extends ParsedObject {",
            "    constructor(elementContentLists, sequenceType) {",
            "      super();",
            "      this.sequenceType = sequenceType;",
            "      this._sequenceDivertsToResolve = [];",
            "      // Generate runtime code that looks like:",
            "      //",
            "      //   chosenIndex = MIN(sequence counter, num elements) e.g. for \"Stopping\"",
            "      //   if chosenIndex == 0, divert to s0",
            "      //   if chosenIndex == 1, divert to s1  [etc]",
            "      //",
            "      //   - s0:",
            "      //      <content for sequence element>",
            "      //      divert to no-op",
            "      //   - s1:",
            "      //      <content for sequence element>",
            "      //      divert to no-op",
            "      //   - s2:",
            "      //      empty branch if using \"once\"",
            "      //      divert to no-op",
            "      //",
            "      //    no-op",
            "      //",
            "      this.GenerateRuntimeObject = () => {",
            "        const container = new Container();",
            "        container.visitsShouldBeCounted = true;",
            "        container.countingAtStartOnly = true;",
            "        this._sequenceDivertsToResolve = [];",
            "        // Get sequence read count",
            "        container.AddContent(ControlCommand.EvalStart());",
            "        container.AddContent(ControlCommand.VisitIndex());",
            "        const once = (this.sequenceType & SequenceType.Once) > 0;",
            "        const cycle = (this.sequenceType & SequenceType.Cycle) > 0;",
            "        const stopping = (this.sequenceType & SequenceType.Stopping) > 0;",
            "        const shuffle = (this.sequenceType & SequenceType.Shuffle) > 0;",
            "        let seqBranchCount = this.sequenceElements.length;",
            "        if (once) {",
            "          seqBranchCount += 1;",
            "        }",
            "        // Chosen sequence index:",
            "        //  - Stopping: take the MIN(read count, num elements - 1)",
            "        //  - Once: take the MIN(read count, num elements)",
            "        //    (the last one being empty)",
            "        if (stopping || once) {",
            "          //var limit = stopping ? seqBranchCount-1 : seqBranchCount;",
            "          container.AddContent(new IntValue(seqBranchCount - 1));",
            "          container.AddContent(NativeFunctionCall.CallWithName(\"MIN\"));",
            "        } else if (cycle) {",
            "          // - Cycle: take (read count % num elements)",
            "          container.AddContent(new IntValue(this.sequenceElements.length));",
            "          container.AddContent(NativeFunctionCall.CallWithName(\"%\"));",
            "        }",
            "        // Shuffle",
            "        if (shuffle) {",
            "          // Create point to return to when sequence is complete",
            "          const postShuffleNoOp = ControlCommand.NoOp();",
            "          // When visitIndex == lastIdx, we skip the shuffle",
            "          if (once || stopping) {",
            "            // if( visitIndex == lastIdx ) -> skipShuffle",
            "            const lastIdx = stopping ? this.sequenceElements.length - 1 : this.sequenceElements.length;",
            "            container.AddContent(ControlCommand.Duplicate());",
            "            container.AddContent(new IntValue(lastIdx));",
            "            container.AddContent(NativeFunctionCall.CallWithName(\"==\"));",
            "            const skipShuffleDivert = new Divert$1();",
            "            skipShuffleDivert.isConditional = true;",
            "            container.AddContent(skipShuffleDivert);",
            "            this.AddDivertToResolve(skipShuffleDivert, postShuffleNoOp);",
            "          }",
            "          // This one's a bit more complex! Choose the index at runtime.",
            "          let elementCountToShuffle = this.sequenceElements.length;",
            "          if (stopping) {",
            "            elementCountToShuffle -= 1;",
            "          }",
            "          container.AddContent(new IntValue(elementCountToShuffle));",
            "          container.AddContent(ControlCommand.SequenceShuffleIndex());",
            "          if (once || stopping) {",
            "            container.AddContent(postShuffleNoOp);",
            "          }",
            "        }",
            "        container.AddContent(ControlCommand.EvalEnd());",
            "        // Create point to return to when sequence is complete",
            "        const postSequenceNoOp = ControlCommand.NoOp();",
            "        // Each of the main sequence branches, and one extra empty branch if",
            "        // we have a \"once\" sequence.",
            "        for (let elIndex = 0; elIndex < seqBranchCount; elIndex += 1) {",
            "          // This sequence element:",
            "          //  if( chosenIndex == this index ) divert to this sequence element",
            "          // duplicate chosen sequence index, since it'll be consumed by \"==\"",
            "          container.AddContent(ControlCommand.EvalStart());",
            "          container.AddContent(ControlCommand.Duplicate());",
            "          container.AddContent(new IntValue(elIndex));",
            "          container.AddContent(NativeFunctionCall.CallWithName(\"==\"));",
            "          container.AddContent(ControlCommand.EvalEnd());",
            "          // Divert branch for this sequence element",
            "          const sequenceDivert = new Divert$1();",
            "          sequenceDivert.isConditional = true;",
            "          container.AddContent(sequenceDivert);",
            "          let contentContainerForSequenceBranch;",
            "          // Generate content for this sequence element",
            "          if (elIndex < this.sequenceElements.length) {",
            "            const el = this.sequenceElements[elIndex];",
            "            contentContainerForSequenceBranch = el.runtimeObject;",
            "          } else {",
            "            // Final empty branch for \"once\" sequences",
            "            contentContainerForSequenceBranch = new Container();",
            "          }",
            "          contentContainerForSequenceBranch.name = `s${elIndex}`;",
            "          contentContainerForSequenceBranch.InsertContent(ControlCommand.PopEvaluatedValue(), 0);",
            "          // When sequence element is complete, divert back to end of sequence",
            "          const seqBranchCompleteDivert = new Divert$1();",
            "          contentContainerForSequenceBranch.AddContent(seqBranchCompleteDivert);",
            "          container.AddToNamedContentOnly(contentContainerForSequenceBranch);",
            "          // Save the diverts for reference resolution later (in ResolveReferences)",
            "          this.AddDivertToResolve(sequenceDivert, contentContainerForSequenceBranch);",
            "          this.AddDivertToResolve(seqBranchCompleteDivert, postSequenceNoOp);",
            "        }",
            "        container.AddContent(postSequenceNoOp);",
            "        return container;",
            "      };",
            "      this.AddDivertToResolve = (divert, targetContent) => {",
            "        this._sequenceDivertsToResolve.push(new SequenceDivertToResolve(divert, targetContent));",
            "      };",
            "      this.sequenceType = sequenceType;",
            "      this.sequenceElements = [];",
            "      for (const elementContentList of elementContentLists) {",
            "        const contentObjs = elementContentList.content;",
            "        let seqElObject = null;",
            "        // Don't attempt to create a weave for the sequence element",
            "        // if the content list is empty. Weaves don't like it!",
            "        if (contentObjs === null || contentObjs.length === 0) {",
            "          seqElObject = elementContentList;",
            "        } else {",
            "          seqElObject = new Weave(contentObjs);",
            "        }",
            "        this.sequenceElements.push(seqElObject);",
            "        this.AddContent(seqElObject);",
            "      }",
            "    }",
            "    get typeName() {",
            "      return \"Sequence\";",
            "    }",
            "    ResolveReferences(context) {",
            "      super.ResolveReferences(context);",
            "      for (const toResolve of this._sequenceDivertsToResolve) {",
            "        toResolve.divert.targetPath = toResolve.targetContent.path;",
            "      }",
            "    }",
            "  }",
            "",
            "  class TunnelOnwards extends ParsedObject {",
            "    constructor() {",
            "      super(...arguments);",
            "      this._overrideDivertTarget = null;",
            "      this._divertAfter = null;",
            "      this.GenerateRuntimeObject = () => {",
            "        const container = new Container();",
            "        // Set override path for tunnel onwards (or nothing)",
            "        container.AddContent(ControlCommand.EvalStart());",
            "        if (this.divertAfter) {",
            "          // Generate runtime object's generated code and steal the arguments runtime code",
            "          const returnRuntimeObj = this.divertAfter.GenerateRuntimeObject();",
            "          const returnRuntimeContainer = returnRuntimeObj;",
            "          if (returnRuntimeContainer) {",
            "            // Steal all code for generating arguments from the divert",
            "            const args = this.divertAfter.args;",
            "            if (args !== null && args.length > 0) {",
            "              // Steal everything betwen eval start and eval end",
            "              let evalStart = -1;",
            "              let evalEnd = -1;",
            "              for (let ii = 0; ii < returnRuntimeContainer.content.length; ii += 1) {",
            "                const cmd = returnRuntimeContainer.content[ii];",
            "                if (cmd) {",
            "                  if (evalStart == -1 && cmd.commandType === ControlCommand.CommandType.EvalStart) {",
            "                    evalStart = ii;",
            "                  } else if (cmd.commandType === ControlCommand.CommandType.EvalEnd) {",
            "                    evalEnd = ii;",
            "                  }",
            "                }",
            "              }",
            "              for (let ii = evalStart + 1; ii < evalEnd; ii += 1) {",
            "                const obj = returnRuntimeContainer.content[ii];",
            "                obj.parent = null; // prevent error of being moved between owners",
            "                container.AddContent(returnRuntimeContainer.content[ii]);",
            "              }",
            "            }",
            "          }",
            "          // Supply the divert target for the tunnel onwards target, either variable or more commonly, the explicit name",
            "          // var returnDivertObj = returnRuntimeObj as Runtime.Divert;",
            "          let returnDivertObj = asOrNull(returnRuntimeObj, Divert$1);",
            "          if (returnDivertObj != null && returnDivertObj.hasVariableTarget) {",
            "            let runtimeVarRef = new VariableReference$1(returnDivertObj.variableDivertName);",
            "            container.AddContent(runtimeVarRef);",
            "          } else {",
            "            this._overrideDivertTarget = new DivertTargetValue();",
            "            container.AddContent(this._overrideDivertTarget);",
            "          }",
            "        } else {",
            "          // No divert after tunnel onwards",
            "          container.AddContent(new Void());",
            "        }",
            "        container.AddContent(ControlCommand.EvalEnd());",
            "        container.AddContent(ControlCommand.PopTunnel());",
            "        return container;",
            "      };",
            "      this.toString = () => {",
            "        return ` -> ${this._divertAfter}`;",
            "      };",
            "    }",
            "    get divertAfter() {",
            "      return this._divertAfter;",
            "    }",
            "    set divertAfter(value) {",
            "      this._divertAfter = value;",
            "      if (this._divertAfter) {",
            "        this.AddContent(this._divertAfter);",
            "      }",
            "    }",
            "    get typeName() {",
            "      return \"TunnelOnwards\";",
            "    }",
            "    ResolveReferences(context) {",
            "      super.ResolveReferences(context);",
            "      if (this.divertAfter && this.divertAfter.targetContent) {",
            "        this._overrideDivertTarget.targetPath = this.divertAfter.targetContent.runtimePath;",
            "      }",
            "    }",
            "  }",
            "",
            "  class ListDefinition$1 {",
            "    constructor(name, items) {",
            "      this._name = name || \"\";",
            "      this._items = null;",
            "      this._itemNameToValues = items || new Map();",
            "    }",
            "    get name() {",
            "      return this._name;",
            "    }",
            "    get items() {",
            "      if (this._items == null) {",
            "        this._items = new Map();",
            "        for (let [key, value] of this._itemNameToValues) {",
            "          let item = new InkListItem(this.name, key);",
            "          this._items.set(item.serialized(), value);",
            "        }",
            "      }",
            "      return this._items;",
            "    }",
            "    ValueForItem(item) {",
            "      if (!item.itemName) return 0;",
            "      let intVal = this._itemNameToValues.get(item.itemName);",
            "      if (typeof intVal !== \"undefined\") return intVal;else return 0;",
            "    }",
            "    ContainsItem(item) {",
            "      if (!item.itemName) return false;",
            "      if (item.originName != this.name) return false;",
            "      return this._itemNameToValues.has(item.itemName);",
            "    }",
            "    ContainsItemWithName(itemName) {",
            "      return this._itemNameToValues.has(itemName);",
            "    }",
            "    TryGetItemWithValue(val, /* out */item) {",
            "      for (let [key, value] of this._itemNameToValues) {",
            "        if (value == val) {",
            "          item = new InkListItem(this.name, key);",
            "          return {",
            "            result: item,",
            "            exists: true",
            "          };",
            "        }",
            "      }",
            "      item = InkListItem.Null;",
            "      return {",
            "        result: item,",
            "        exists: false",
            "      };",
            "    }",
            "    TryGetValueForItem(item, /* out */intVal) {",
            "      if (!item.itemName) return {",
            "        result: 0,",
            "        exists: false",
            "      };",
            "      let value = this._itemNameToValues.get(item.itemName);",
            "      if (!value) return {",
            "        result: 0,",
            "        exists: false",
            "      };",
            "      return {",
            "        result: value,",
            "        exists: true",
            "      };",
            "    }",
            "  }",
            "",
            "  class ListDefinition extends ParsedObject {",
            "    get typeName() {",
            "      return \"ListDefinition\";",
            "    }",
            "    get runtimeListDefinition() {",
            "      var _a;",
            "      const allItems = new Map();",
            "      for (const e of this.itemDefinitions) {",
            "        if (!allItems.has(e.name)) {",
            "          allItems.set(e.name, e.seriesValue);",
            "        } else {",
            "          this.Error(`List '${this.identifier}' contains duplicate items called '${e.name}'`);",
            "        }",
            "      }",
            "      return new ListDefinition$1(((_a = this.identifier) === null || _a === void 0 ? void 0 : _a.name) || \"\", allItems);",
            "    }",
            "    constructor(itemDefinitions) {",
            "      super();",
            "      this.itemDefinitions = itemDefinitions;",
            "      this.identifier = null;",
            "      this.variableAssignment = null;",
            "      this._elementsByName = null;",
            "      this.ItemNamed = itemName => {",
            "        if (this._elementsByName === null) {",
            "          this._elementsByName = new Map();",
            "          for (const el of this.itemDefinitions) {",
            "            this._elementsByName.set(el.name, el);",
            "          }",
            "        }",
            "        const foundElement = this._elementsByName.get(itemName) || null;",
            "        return foundElement;",
            "      };",
            "      this.GenerateRuntimeObject = () => {",
            "        var _a, _b;",
            "        const initialValues = new InkList();",
            "        for (const itemDef of this.itemDefinitions) {",
            "          if (itemDef.inInitialList) {",
            "            const item = new InkListItem(((_a = this.identifier) === null || _a === void 0 ? void 0 : _a.name) || null, itemDef.name || null);",
            "            initialValues.Add(item, itemDef.seriesValue);",
            "          }",
            "        }",
            "        // Set origin name, so",
            "        initialValues.SetInitialOriginName(((_b = this.identifier) === null || _b === void 0 ? void 0 : _b.name) || \"\");",
            "        return new ListValue(initialValues);",
            "      };",
            "      let currentValue = 1;",
            "      for (const e of this.itemDefinitions) {",
            "        if (e.explicitValue !== null) {",
            "          currentValue = e.explicitValue;",
            "        }",
            "        e.seriesValue = currentValue;",
            "        currentValue += 1;",
            "      }",
            "      this.AddContent(itemDefinitions);",
            "    }",
            "    ResolveReferences(context) {",
            "      super.ResolveReferences(context);",
            "      context.CheckForNamingCollisions(this, this.identifier, SymbolType.List);",
            "    }",
            "  }",
            "",
            "  class VariableAssignment extends ParsedObject {",
            "    get variableName() {",
            "      return this.variableIdentifier.name;",
            "    }",
            "    get typeName() {",
            "      if (this.isNewTemporaryDeclaration) {",
            "        return \"temp\";",
            "      } else if (this.isGlobalDeclaration) {",
            "        if (this.listDefinition !== null) {",
            "          return \"LIST\";",
            "        }",
            "        return \"VAR\";",
            "      }",
            "      return \"variable assignment\";",
            "    }",
            "    get isDeclaration() {",
            "      return this.isGlobalDeclaration || this.isNewTemporaryDeclaration;",
            "    }",
            "    constructor(_ref) {",
            "      let {",
            "        assignedExpression,",
            "        isGlobalDeclaration,",
            "        isTemporaryNewDeclaration,",
            "        listDef,",
            "        variableIdentifier",
            "      } = _ref;",
            "      super();",
            "      this._runtimeAssignment = null;",
            "      this.expression = null;",
            "      this.listDefinition = null;",
            "      this.GenerateRuntimeObject = () => {",
            "        let newDeclScope = null;",
            "        if (this.isGlobalDeclaration) {",
            "          newDeclScope = this.story;",
            "        } else if (this.isNewTemporaryDeclaration) {",
            "          newDeclScope = ClosestFlowBase(this);",
            "        }",
            "        if (newDeclScope) {",
            "          newDeclScope.AddNewVariableDeclaration(this);",
            "        }",
            "        // Global declarations don't generate actual procedural",
            "        // runtime objects, but instead add a global variable to the story itself.",
            "        // The story then initialises them all in one go at the start of the game.",
            "        if (this.isGlobalDeclaration) {",
            "          return null;",
            "        }",
            "        const container = new Container();",
            "        // The expression's runtimeObject is actually another nested container",
            "        if (this.expression) {",
            "          container.AddContent(this.expression.runtimeObject);",
            "        } else if (this.listDefinition) {",
            "          container.AddContent(this.listDefinition.runtimeObject);",
            "        }",
            "        this._runtimeAssignment = new VariableAssignment$1(this.variableName, this.isNewTemporaryDeclaration);",
            "        container.AddContent(this._runtimeAssignment);",
            "        return container;",
            "      };",
            "      this.toString = () => `${this.isGlobalDeclaration ? \"VAR\" : this.isNewTemporaryDeclaration ? \"~ temp\" : \"\"} ${this.variableName}`;",
            "      this.variableIdentifier = variableIdentifier;",
            "      this.isGlobalDeclaration = Boolean(isGlobalDeclaration);",
            "      this.isNewTemporaryDeclaration = Boolean(isTemporaryNewDeclaration);",
            "      // Defensive programming in case parsing of assignedExpression failed",
            "      if (listDef instanceof ListDefinition) {",
            "        this.listDefinition = this.AddContent(listDef);",
            "        this.listDefinition.variableAssignment = this;",
            "        // List definitions are always global",
            "        this.isGlobalDeclaration = true;",
            "      } else if (assignedExpression) {",
            "        this.expression = this.AddContent(assignedExpression);",
            "      }",
            "    }",
            "    ResolveReferences(context) {",
            "      super.ResolveReferences(context);",
            "      // List definitions are checked for conflicts separately",
            "      if (this.isDeclaration && this.listDefinition === null) {",
            "        context.CheckForNamingCollisions(this, this.variableIdentifier, this.isGlobalDeclaration ? SymbolType.Var : SymbolType.Temp);",
            "      }",
            "      // Initial VAR x = [intialValue] declaration, not re-assignment",
            "      if (this.isGlobalDeclaration) {",
            "        const variableReference = asOrNull(this.expression, VariableReference);",
            "        if (variableReference && !variableReference.isConstantReference && !variableReference.isListItemReference) {",
            "          this.Error(\"global variable assignments cannot refer to other variables, only literal values, constants and list items\");",
            "        }",
            "      }",
            "      if (!this.isNewTemporaryDeclaration) {",
            "        const resolvedVarAssignment = context.ResolveVariableWithName(this.variableName, this);",
            "        if (!resolvedVarAssignment.found) {",
            "          if (this.variableName in this.story.constants) {",
            "            this.Error(`Can't re-assign to a constant (do you need to use VAR when declaring '${this.variableName}'?)`, this);",
            "          } else {",
            "            this.Error(`Variable could not be found to assign to: '${this.variableName}'`, this);",
            "          }",
            "        }",
            "        // A runtime assignment may not have been generated if it's the initial global declaration,",
            "        // since these are hoisted out and handled specially in Story.ExportRuntime.",
            "        if (this._runtimeAssignment) {",
            "          this._runtimeAssignment.isGlobal = resolvedVarAssignment.isGlobal;",
            "        }",
            "      }",
            "    }",
            "  }",
            "",
            "  // Used by the FlowBase when constructing the weave flow from",
            "  // a flat list of content objects.",
            "  class Weave extends ParsedObject {",
            "    // Containers can be chained as multiple gather points",
            "    // get created as the same indentation level.",
            "    // rootContainer is always the first in the chain, while",
            "    // currentContainer is the latest.",
            "    get rootContainer() {",
            "      if (!this._rootContainer) {",
            "        this._rootContainer = this.GenerateRuntimeObject();",
            "      }",
            "      return this._rootContainer;",
            "    }",
            "    get namedWeavePoints() {",
            "      return this._namedWeavePoints;",
            "    }",
            "    get lastParsedSignificantObject() {",
            "      if (this.content.length === 0) {",
            "        return null;",
            "      }",
            "      // Don't count extraneous newlines or VAR/CONST declarations,",
            "      // since they're \"empty\" statements outside of the main flow.",
            "      let lastObject = null;",
            "      for (let ii = this.content.length - 1; ii >= 0; --ii) {",
            "        lastObject = this.content[ii];",
            "        let lastText = asOrNull(lastObject, Text);",
            "        if (lastText && lastText.text === \"\\n\") {",
            "          continue;",
            "        }",
            "        if (this.IsGlobalDeclaration(lastObject)) {",
            "          continue;",
            "        }",
            "        break;",
            "      }",
            "      const lastWeave = asOrNull(lastObject, Weave);",
            "      if (lastWeave) {",
            "        lastObject = lastWeave.lastParsedSignificantObject;",
            "      }",
            "      return lastObject;",
            "    }",
            "    constructor(cont) {",
            "      let indentIndex = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : -1;",
            "      super();",
            "      // Keep track of previous weave point (Choice or Gather)",
            "      // at the current indentation level:",
            "      //  - to add ordinary content to be nested under it",
            "      //  - to add nested content under it when it's indented",
            "      //  - to remove it from the list of loose ends when",
            "      //     - it has indented content since it's no longer a loose end",
            "      //     - it's a gather and it has a choice added to it",
            "      this.previousWeavePoint = null;",
            "      this.addContentToPreviousWeavePoint = false;",
            "      // Used for determining whether the next Gather should auto-enter",
            "      this.hasSeenChoiceInSection = false;",
            "      this.currentContainer = null;",
            "      this._unnamedGatherCount = 0;",
            "      this._choiceCount = 0;",
            "      this._rootContainer = null;",
            "      this._namedWeavePoints = new Map();",
            "      // Loose ends are:",
            "      //  - Choices or Gathers that need to be joined up",
            "      //  - Explicit Divert to gather points (i.e. \"->\" without a target)",
            "      this.looseEnds = [];",
            "      this.gatherPointsToResolve = [];",
            "      this.ResolveWeavePointNaming = () => {",
            "        var _a, _b, _c;",
            "        const namedWeavePoints = [...this.FindAll(Gather)(w => !(w.name === null || w.name === undefined)), ...this.FindAll(Choice$1)(w => !(w.name === null || w.name === undefined))];",
            "        this._namedWeavePoints = new Map();",
            "        for (const weavePoint of namedWeavePoints) {",
            "          // Check for weave point naming collisions",
            "          const existingWeavePoint = this.namedWeavePoints.get(((_a = weavePoint.identifier) === null || _a === void 0 ? void 0 : _a.name) || \"\");",
            "          if (existingWeavePoint) {",
            "            const typeName = existingWeavePoint instanceof Gather ? \"gather\" : \"choice\";",
            "            const existingObj = existingWeavePoint;",
            "            this.Error(`A ${typeName} with the same label name '${weavePoint.name}' already exists in this context on line ${existingObj.debugMetadata ? existingObj.debugMetadata.startLineNumber : \"NO DEBUG METADATA AVAILABLE\"}`, weavePoint);",
            "          }",
            "          if ((_b = weavePoint.identifier) === null || _b === void 0 ? void 0 : _b.name) {",
            "            this.namedWeavePoints.set((_c = weavePoint.identifier) === null || _c === void 0 ? void 0 : _c.name, weavePoint);",
            "          }",
            "        }",
            "      };",
            "      this.ConstructWeaveHierarchyFromIndentation = () => {",
            "        // Find nested indentation and convert to a proper object hierarchy",
            "        // (i.e. indented content is replaced with a Weave object that contains",
            "        // that nested content)",
            "        let contentIdx = 0;",
            "        while (contentIdx < this.content.length) {",
            "          const obj = this.content[contentIdx];",
            "          // Choice or Gather",
            "          if (obj instanceof Choice$1 || obj instanceof Gather) {",
            "            const weavePoint = obj;",
            "            const weaveIndentIdx = weavePoint.indentationDepth - 1;",
            "            // Inner level indentation - recurse",
            "            if (weaveIndentIdx > this.baseIndentIndex) {",
            "              // Step through content until indent jumps out again",
            "              let innerWeaveStartIdx = contentIdx;",
            "              while (contentIdx < this.content.length) {",
            "                const innerWeaveObj = asOrNull(this.content[contentIdx], Choice$1) || asOrNull(this.content[contentIdx], Gather);",
            "                if (innerWeaveObj !== null) {",
            "                  const innerIndentIdx = innerWeaveObj.indentationDepth - 1;",
            "                  if (innerIndentIdx <= this.baseIndentIndex) {",
            "                    break;",
            "                  }",
            "                }",
            "                contentIdx += 1;",
            "              }",
            "              const weaveContentCount = contentIdx - innerWeaveStartIdx;",
            "              const weaveContent = this.content.slice(innerWeaveStartIdx, innerWeaveStartIdx + weaveContentCount);",
            "              this.content.splice(innerWeaveStartIdx, weaveContentCount);",
            "              const weave = new Weave(weaveContent, weaveIndentIdx);",
            "              this.InsertContent(innerWeaveStartIdx, weave);",
            "              // Continue iteration from this point",
            "              contentIdx = innerWeaveStartIdx;",
            "            }",
            "          }",
            "          contentIdx += 1;",
            "        }",
            "      };",
            "      // When the indentation wasn't told to us at construction time using",
            "      // a choice point with a known indentation level, we may be told to",
            "      // determine the indentation level by incrementing from our closest ancestor.",
            "      this.DetermineBaseIndentationFromContent = contentList => {",
            "        for (const obj of contentList) {",
            "          if (obj instanceof Choice$1 || obj instanceof Gather) {",
            "            return obj.indentationDepth - 1;",
            "          }",
            "        }",
            "        // No weave points, so it doesn't matter",
            "        return 0;",
            "      };",
            "      this.GenerateRuntimeObject = () => {",
            "        this._rootContainer = new Container();",
            "        this.currentContainer = this._rootContainer;",
            "        this.looseEnds = [];",
            "        this.gatherPointsToResolve = [];",
            "        // Iterate through content for the block at this level of indentation",
            "        //  - Normal content is nested under Choices and Gathers",
            "        //  - Blocks that are further indented cause recursion",
            "        //  - Keep track of loose ends so that they can be diverted to Gathers",
            "        for (const obj of this.content) {",
            "          // Choice or Gather",
            "          if (obj instanceof Choice$1 || obj instanceof Gather) {",
            "            this.AddRuntimeForWeavePoint(obj);",
            "          } else {",
            "            // Non-weave point",
            "            if (obj instanceof Weave) {",
            "              // Nested weave",
            "              const weave = obj;",
            "              this.AddRuntimeForNestedWeave(weave);",
            "              this.gatherPointsToResolve.splice(0, 0, ...weave.gatherPointsToResolve);",
            "            } else {",
            "              // Other object",
            "              // May be complex object that contains statements - e.g. a multi-line conditional",
            "              this.AddGeneralRuntimeContent(obj.runtimeObject);",
            "            }",
            "          }",
            "        }",
            "        // Pass any loose ends up the hierarhcy",
            "        this.PassLooseEndsToAncestors();",
            "        return this._rootContainer;",
            "      };",
            "      // Found gather point:",
            "      //  - gather any loose ends",
            "      //  - set the gather as the main container to dump new content in",
            "      this.AddRuntimeForGather = gather => {",
            "        // Determine whether this Gather should be auto-entered:",
            "        //  - It is auto-entered if there were no choices in the last section",
            "        //  - A section is \"since the previous gather\" - so reset now",
            "        const autoEnter = !this.hasSeenChoiceInSection;",
            "        this.hasSeenChoiceInSection = false;",
            "        const gatherContainer = gather.runtimeContainer;",
            "        if (!gather.name) {",
            "          // Use disallowed character so it's impossible to have a name collision",
            "          gatherContainer.name = `g-${this._unnamedGatherCount}`;",
            "          this._unnamedGatherCount += 1;",
            "        }",
            "        if (autoEnter) {",
            "          if (!this.currentContainer) {",
            "            throw new Error();",
            "          }",
            "          // Auto-enter: include in main content",
            "          this.currentContainer.AddContent(gatherContainer);",
            "        } else {",
            "          // Don't auto-enter:",
            "          // Add this gather to the main content, but only accessible",
            "          // by name so that it isn't stepped into automatically, but only via",
            "          // a divert from a loose end.",
            "          this.rootContainer.AddToNamedContentOnly(gatherContainer);",
            "        }",
            "        // Consume loose ends: divert them to this gather",
            "        for (const looseEndWeavePoint of this.looseEnds) {",
            "          const looseEnd = looseEndWeavePoint;",
            "          // Skip gather loose ends that are at the same level",
            "          // since they'll be handled by the auto-enter code below",
            "          // that only jumps into the gather if (current runtime choices == 0)",
            "          if (looseEnd instanceof Gather) {",
            "            const prevGather = looseEnd;",
            "            if (prevGather.indentationDepth == gather.indentationDepth) {",
            "              continue;",
            "            }",
            "          }",
            "          let divert = null;",
            "          if (looseEnd instanceof Divert) {",
            "            divert = looseEnd.runtimeObject;",
            "          } else {",
            "            divert = new Divert$1();",
            "            const looseWeavePoint = looseEnd;",
            "            if (!looseWeavePoint.runtimeContainer) {",
            "              throw new Error();",
            "            }",
            "            looseWeavePoint.runtimeContainer.AddContent(divert);",
            "          }",
            "          // Pass back knowledge of this loose end being diverted",
            "          // to the FlowBase so that it can maintain a list of them,",
            "          // and resolve the divert references later",
            "          this.gatherPointsToResolve.push(new GatherPointToResolve(divert, gatherContainer));",
            "        }",
            "        this.looseEnds = [];",
            "        // Replace the current container itself",
            "        this.currentContainer = gatherContainer;",
            "      };",
            "      this.AddRuntimeForWeavePoint = weavePoint => {",
            "        // Current level Gather",
            "        if (weavePoint instanceof Gather) {",
            "          this.AddRuntimeForGather(weavePoint);",
            "        }",
            "        // Current level choice",
            "        else if (weavePoint instanceof Choice$1) {",
            "          if (!this.currentContainer) {",
            "            throw new Error();",
            "          }",
            "          // Gathers that contain choices are no longer loose ends",
            "          // (same as when weave points get nested content)",
            "          if (this.previousWeavePoint instanceof Gather) {",
            "            this.looseEnds.splice(this.looseEnds.indexOf(this.previousWeavePoint), 1);",
            "          }",
            "          // Add choice point content",
            "          const choice = weavePoint; //, Choice);",
            "          this.currentContainer.AddContent(choice.runtimeObject);",
            "          if (!choice.innerContentContainer) {",
            "            throw new Error();",
            "          } //guaranteed not to happen",
            "          // Add choice's inner content to self",
            "          choice.innerContentContainer.name = `c-${this._choiceCount}`;",
            "          this.currentContainer.AddToNamedContentOnly(choice.innerContentContainer);",
            "          this._choiceCount += 1;",
            "          this.hasSeenChoiceInSection = true;",
            "        }",
            "        // Keep track of loose ends",
            "        this.addContentToPreviousWeavePoint = false; // default",
            "        if (this.WeavePointHasLooseEnd(weavePoint)) {",
            "          this.looseEnds.push(weavePoint);",
            "          const looseChoice = asOrNull(weavePoint, Choice$1);",
            "          if (looseChoice) {",
            "            this.addContentToPreviousWeavePoint = true;",
            "          }",
            "        }",
            "        this.previousWeavePoint = weavePoint;",
            "      };",
            "      // Add nested block at a greater indentation level",
            "      this.AddRuntimeForNestedWeave = nestedResult => {",
            "        // Add this inner block to current container",
            "        // (i.e. within the main container, or within the last defined Choice/Gather)",
            "        this.AddGeneralRuntimeContent(nestedResult.rootContainer);",
            "        // Now there's a deeper indentation level, the previous weave point doesn't",
            "        // count as a loose end (since it will have content to go to)",
            "        if (this.previousWeavePoint !== null) {",
            "          this.looseEnds.splice(this.looseEnds.indexOf(this.previousWeavePoint), 1);",
            "          this.addContentToPreviousWeavePoint = false;",
            "        }",
            "      };",
            "      // Normal content gets added into the latest Choice or Gather by default,",
            "      // unless there hasn't been one yet.",
            "      this.AddGeneralRuntimeContent = content => {",
            "        // Content is allowed to evaluate runtimeObject to null",
            "        // (e.g. AuthorWarning, which doesn't make it into the runtime)",
            "        if (content === null) {",
            "          return;",
            "        }",
            "        if (this.addContentToPreviousWeavePoint) {",
            "          if (!this.previousWeavePoint || !this.previousWeavePoint.runtimeContainer) {",
            "            throw new Error();",
            "          }",
            "          this.previousWeavePoint.runtimeContainer.AddContent(content);",
            "        } else {",
            "          if (!this.currentContainer) {",
            "            throw new Error();",
            "          }",
            "          this.currentContainer.AddContent(content);",
            "        }",
            "      };",
            "      this.PassLooseEndsToAncestors = () => {",
            "        if (this.looseEnds.length === 0) {",
            "          return;",
            "        }",
            "        // Search for Weave ancestor to pass loose ends to for gathering.",
            "        // There are two types depending on whether the current weave",
            "        // is separated by a conditional or sequence.",
            "        //  - An \"inner\" weave is one that is directly connected to the current",
            "        //    weave - i.e. you don't have to pass through a conditional or",
            "        //    sequence to get to it. We're allowed to pass all loose ends to",
            "        //    one of these.",
            "        //  - An \"outer\" weave is one that is outside of a conditional/sequence",
            "        //    that the current weave is nested within. We're only allowed to",
            "        //    pass gathers (i.e. 'normal flow') loose ends up there, not normal",
            "        //    choices. The rule is that choices have to be diverted explicitly",
            "        //    by the author since it's ambiguous where flow should go otherwise.",
            "        //",
            "        // e.g.:",
            "        //",
            "        //   - top                       <- e.g. outer weave",
            "        //   {true:",
            "        //       * choice                <- e.g. inner weave",
            "        //         * * choice 2",
            "        //             more content      <- e.g. current weave",
            "        //       * choice 2",
            "        //   }",
            "        //   - more of outer weave",
            "        //",
            "        let closestInnerWeaveAncestor = null;",
            "        let closestOuterWeaveAncestor = null;",
            "        // Find inner and outer ancestor weaves as defined above.",
            "        let nested = false;",
            "        for (let ancestor = this.parent; ancestor !== null; ancestor = ancestor.parent) {",
            "          // Found ancestor?",
            "          const weaveAncestor = asOrNull(ancestor, Weave);",
            "          if (weaveAncestor) {",
            "            if (!nested && closestInnerWeaveAncestor === null) {",
            "              closestInnerWeaveAncestor = weaveAncestor;",
            "            }",
            "            if (nested && closestOuterWeaveAncestor === null) {",
            "              closestOuterWeaveAncestor = weaveAncestor;",
            "            }",
            "          }",
            "          // Weaves nested within Sequences or Conditionals are",
            "          // \"sealed\" - any loose ends require explicit diverts.",
            "          if (ancestor instanceof Sequence || ancestor instanceof Conditional) {",
            "            nested = true;",
            "          }",
            "        }",
            "        // No weave to pass loose ends to at all?",
            "        if (closestInnerWeaveAncestor === null && closestOuterWeaveAncestor === null) {",
            "          return;",
            "        }",
            "        // Follow loose end passing logic as defined above",
            "        for (let ii = this.looseEnds.length - 1; ii >= 0; ii -= 1) {",
            "          const looseEnd = this.looseEnds[ii];",
            "          let received = false;",
            "          if (nested) {",
            "            // This weave is nested within a conditional or sequence:",
            "            //  - choices can only be passed up to direct ancestor (\"inner\") weaves",
            "            //  - gathers can be passed up to either, but favour the closer (inner) weave",
            "            //    if there is one",
            "            if (looseEnd instanceof Choice$1 && closestInnerWeaveAncestor !== null) {",
            "              closestInnerWeaveAncestor.ReceiveLooseEnd(looseEnd);",
            "              received = true;",
            "            } else if (!(looseEnd instanceof Choice$1)) {",
            "              const receivingWeave = closestInnerWeaveAncestor || closestOuterWeaveAncestor;",
            "              if (receivingWeave !== null) {",
            "                receivingWeave.ReceiveLooseEnd(looseEnd);",
            "                received = true;",
            "              }",
            "            }",
            "          } else {",
            "            // No nesting, all loose ends can be safely passed up",
            "            if (closestInnerWeaveAncestor === null || closestInnerWeaveAncestor === void 0 ? void 0 : closestInnerWeaveAncestor.hasOwnProperty(\"ReceiveLooseEnd\")) {",
            "              closestInnerWeaveAncestor.ReceiveLooseEnd(looseEnd);",
            "            }",
            "            received = true;",
            "          }",
            "          if (received) {",
            "            this.looseEnds.splice(ii, 1);",
            "          }",
            "        }",
            "      };",
            "      this.ReceiveLooseEnd = childWeaveLooseEnd => {",
            "        this.looseEnds.push(childWeaveLooseEnd);",
            "      };",
            "      this.WeavePointNamed = name => {",
            "        if (!this.namedWeavePoints) {",
            "          return null;",
            "        }",
            "        let weavePointResult = this.namedWeavePoints.get(name);",
            "        if (weavePointResult) {",
            "          return weavePointResult;",
            "        }",
            "        return null;",
            "      };",
            "      // Global VARs and CONSTs are treated as \"outside of the flow\"",
            "      // when iterating over content that follows loose ends",
            "      this.IsGlobalDeclaration = obj => {",
            "        const varAss = asOrNull(obj, VariableAssignment);",
            "        if (varAss && varAss.isGlobalDeclaration && varAss.isDeclaration) {",
            "          return true;",
            "        }",
            "        const constDecl = asOrNull(obj, ConstantDeclaration);",
            "        if (constDecl) {",
            "          return true;",
            "        }",
            "        return false;",
            "      };",
            "      // While analysing final loose ends, we look to see whether there",
            "      // are any diverts etc which choices etc divert from",
            "      this.ContentThatFollowsWeavePoint = weavePoint => {",
            "        const returned = [];",
            "        const obj = weavePoint;",
            "        // Inner content first (e.g. for a choice)",
            "        if (obj.content !== null) {",
            "          for (const contentObj of obj.content) {",
            "            // Global VARs and CONSTs are treated as \"outside of the flow\"",
            "            if (this.IsGlobalDeclaration(contentObj)) {",
            "              continue;",
            "            }",
            "            returned.push(contentObj);",
            "          }",
            "        }",
            "        const parentWeave = asOrNull(obj.parent, Weave);",
            "        if (parentWeave === null) {",
            "          throw new Error(\"Expected weave point parent to be weave?\");",
            "        }",
            "        const weavePointIdx = parentWeave.content.indexOf(obj);",
            "        for (let ii = weavePointIdx + 1; ii < parentWeave.content.length; ii += 1) {",
            "          const laterObj = parentWeave.content[ii];",
            "          // Global VARs and CONSTs are treated as \"outside of the flow\"",
            "          if (this.IsGlobalDeclaration(laterObj)) {",
            "            continue;",
            "          }",
            "          // End of the current flow",
            "          // if (laterObj instanceof IWeavePoint) // cannot test on interface in ts",
            "          if (laterObj instanceof Choice$1 || laterObj instanceof Gather) {",
            "            break;",
            "          }",
            "          // Other weaves will be have their own loose ends",
            "          if (laterObj instanceof Weave) {",
            "            break;",
            "          }",
            "          returned.push(laterObj);",
            "        }",
            "        return returned;",
            "      };",
            "      this.ValidateTermination = badTerminationHandler => {",
            "        // Don't worry if the last object in the flow is a \"TODO\",",
            "        // even if there are other loose ends in other places",
            "        if (this.lastParsedSignificantObject instanceof AuthorWarning) {",
            "          return;",
            "        }",
            "        // By now, any sub-weaves will have passed loose ends up to the root weave (this).",
            "        // So there are 2 possible situations:",
            "        //  - There are loose ends from somewhere in the flow.",
            "        //    These aren't necessarily \"real\" loose ends - they're weave points",
            "        //    that don't connect to any lower weave points, so we just",
            "        //    have to check that they terminate properly.",
            "        //  - This weave is just a list of content with no actual weave points,",
            "        //    so we just need to check that the list of content terminates.",
            "        const hasLooseEnds = this.looseEnds !== null && this.looseEnds.length > 0;",
            "        if (hasLooseEnds) {",
            "          for (const looseEnd of this.looseEnds) {",
            "            const looseEndFlow = this.ContentThatFollowsWeavePoint(looseEnd);",
            "            this.ValidateFlowOfObjectsTerminates(looseEndFlow, looseEnd, badTerminationHandler);",
            "          }",
            "        } else {",
            "          // No loose ends... is there any inner weaving at all?",
            "          // If not, make sure the single content stream is terminated correctly",
            "          //",
            "          // If there's any actual weaving, assume that content is",
            "          // terminated correctly since we would've had a loose end otherwise",
            "          for (const obj of this.content) {",
            "            if (obj instanceof Choice$1 || obj instanceof Divert) {",
            "              return;",
            "            }",
            "          }",
            "          // Straight linear flow? Check it terminates",
            "          this.ValidateFlowOfObjectsTerminates(this.content, this, badTerminationHandler);",
            "        }",
            "      };",
            "      this.BadNestedTerminationHandler = terminatingObj => {",
            "        let conditional = null;",
            "        for (let ancestor = terminatingObj.parent; ancestor !== null; ancestor = ancestor.parent) {",
            "          if (ancestor instanceof Sequence || ancestor instanceof Conditional) {",
            "            conditional = asOrNull(ancestor, Conditional);",
            "            break;",
            "          }",
            "        }",
            "        let errorMsg = \"Choices nested in conditionals or sequences need to explicitly divert afterwards.\";",
            "        // Tutorialise proper choice syntax if this looks like a single choice within a condition, e.g.",
            "        // { condition:",
            "        //      * choice",
            "        // }",
            "        if (conditional !== null) {",
            "          let numChoices = conditional.FindAll(Choice$1)().length;",
            "          if (numChoices === 1) {",
            "            errorMsg = `Choices with conditions should be written: '* {condition} choice'. Otherwise, ${errorMsg.toLowerCase()}`;",
            "          }",
            "        }",
            "        this.Error(errorMsg, terminatingObj);",
            "      };",
            "      this.ValidateFlowOfObjectsTerminates = (objFlow, defaultObj, badTerminationHandler) => {",
            "        let terminated = false;",
            "        let terminatingObj = defaultObj;",
            "        for (const flowObj of objFlow) {",
            "          const divert = flowObj.Find(Divert)(d => !d.isThread && !d.isTunnel && !d.isFunctionCall && !(d.parent instanceof DivertTarget));",
            "          if (divert !== null) {",
            "            terminated = true;",
            "          }",
            "          if (flowObj.Find(TunnelOnwards)() != null) {",
            "            terminated = true;",
            "            break;",
            "          }",
            "          terminatingObj = flowObj;",
            "        }",
            "        if (!terminated) {",
            "          // Author has left a note to self here - clearly we don't need",
            "          // to leave them with another warning since they know what they're doing.",
            "          if (terminatingObj instanceof AuthorWarning) {",
            "            return;",
            "          }",
            "          badTerminationHandler(terminatingObj);",
            "        }",
            "      };",
            "      this.WeavePointHasLooseEnd = weavePoint => {",
            "        // No content, must be a loose end.",
            "        if (weavePoint.content === null) {",
            "          return true;",
            "        }",
            "        // If a weave point is diverted from, it doesn't have a loose end.",
            "        // Detect a divert object within a weavePoint's main content",
            "        // Work backwards since we're really interested in the end,",
            "        // although it doesn't actually make a difference!",
            "        // (content after a divert will simply be inaccessible)",
            "        for (let ii = weavePoint.content.length - 1; ii >= 0; --ii) {",
            "          let innerDivert = asOrNull(weavePoint.content[ii], Divert);",
            "          if (innerDivert) {",
            "            const willReturn = innerDivert.isThread || innerDivert.isTunnel || innerDivert.isFunctionCall;",
            "            if (!willReturn) {",
            "              return false;",
            "            }",
            "          }",
            "        }",
            "        return true;",
            "      };",
            "      // Enforce rule that weave points must not have the same",
            "      // name as any stitches or knots upwards in the hierarchy",
            "      this.CheckForWeavePointNamingCollisions = () => {",
            "        if (!this.namedWeavePoints) {",
            "          return;",
            "        }",
            "        const ancestorFlows = [];",
            "        for (const obj of this.ancestry) {",
            "          const flow = asOrNull(obj, FlowBase);",
            "          if (flow) {",
            "            ancestorFlows.push(flow);",
            "          } else {",
            "            break;",
            "          }",
            "        }",
            "        for (const [weavePointName, weavePoint] of this.namedWeavePoints) {",
            "          for (const flow of ancestorFlows) {",
            "            // Shallow search",
            "            const otherContentWithName = flow.ContentWithNameAtLevel(weavePointName);",
            "            if (otherContentWithName && otherContentWithName !== weavePoint) {",
            "              const errorMsg = `${weavePoint.GetType()} '${weavePointName}' has the same label name as a ${otherContentWithName.GetType()} (on ${otherContentWithName.debugMetadata})`;",
            "              this.Error(errorMsg, weavePoint);",
            "            }",
            "          }",
            "        }",
            "      };",
            "      if (indentIndex == -1) {",
            "        this.baseIndentIndex = this.DetermineBaseIndentationFromContent(cont);",
            "      } else {",
            "        this.baseIndentIndex = indentIndex;",
            "      }",
            "      this.AddContent(cont);",
            "      this.ConstructWeaveHierarchyFromIndentation();",
            "    }",
            "    get typeName() {",
            "      return \"Weave\";",
            "    }",
            "    ResolveReferences(context) {",
            "      super.ResolveReferences(context);",
            "      // Check that choices nested within conditionals and sequences are terminated",
            "      if (this.looseEnds !== null && this.looseEnds.length > 0) {",
            "        let isNestedWeave = false;",
            "        for (let ancestor = this.parent; ancestor !== null; ancestor = ancestor.parent) {",
            "          if (ancestor instanceof Sequence || ancestor instanceof Conditional) {",
            "            isNestedWeave = true;",
            "            break;",
            "          }",
            "        }",
            "        if (isNestedWeave) {",
            "          this.ValidateTermination(this.BadNestedTerminationHandler);",
            "        }",
            "      }",
            "      for (const gatherPoint of this.gatherPointsToResolve) {",
            "        gatherPoint.divert.targetPath = gatherPoint.targetRuntimeObj.path;",
            "      }",
            "      this.CheckForWeavePointNamingCollisions();",
            "    }",
            "  }",
            "",
            "  class ConditionalSingleBranch extends ParsedObject {",
            "    // When each branch has its own expression like a switch statement,",
            "    // this is non-null. e.g.",
            "    // { x:",
            "    //    - 4: the value of x is four (ownExpression is the value 4)",
            "    //    - 3: the value of x is three",
            "    // }",
            "    get ownExpression() {",
            "      return this._ownExpression;",
            "    }",
            "    set ownExpression(value) {",
            "      this._ownExpression = value;",
            "      if (this._ownExpression) {",
            "        this.AddContent(this._ownExpression);",
            "      }",
            "    }",
            "    constructor(content) {",
            "      super();",
            "      this._contentContainer = null;",
            "      this._conditionalDivert = null;",
            "      this._ownExpression = null;",
            "      this._innerWeave = null;",
            "      // bool condition, e.g.:",
            "      // { 5 == 4:",
            "      //   - the true branch",
            "      //   - the false branch",
            "      // }",
            "      this.isTrueBranch = false;",
            "      // In the above example, match equality of x with 4 for the first branch.",
            "      // This is as opposed to simply evaluating boolean equality for each branch,",
            "      // example when shouldMatchEquality is FALSE:",
            "      // {",
            "      //    3 > 2:  This will happen",
            "      //    2 > 3:  This won't happen",
            "      // }",
            "      this.matchingEquality = false;",
            "      this.isElse = false;",
            "      this.isInline = false;",
            "      this.returnDivert = null;",
            "      // Runtime content can be summarised as follows:",
            "      //  - Evaluate an expression if necessary to branch on",
            "      //  - Branch to a named container if true",
            "      //       - Divert back to main flow",
            "      //         (owner Conditional is in control of this target point)",
            "      this.GenerateRuntimeObject = () => {",
            "        // Check for common mistake, of putting \"else:\" instead of \"- else:\"",
            "        if (this._innerWeave) {",
            "          for (const c of this._innerWeave.content) {",
            "            const text = asOrNull(c, Text);",
            "            if (text) {",
            "              // Don't need to trim at the start since the parser handles that already",
            "              if (text.text.startsWith(\"else:\")) {",
            "                this.Warning(\"Saw the text 'else:' which is being treated as content. Did you mean '- else:'?\", text);",
            "              }",
            "            }",
            "          }",
            "        }",
            "        const container = new Container();",
            "        // Are we testing against a condition that's used for more than just this",
            "        // branch? If so, the first thing we need to do is replicate the value that's",
            "        // on the evaluation stack so that we don't fully consume it, in case other",
            "        // branches need to use it.",
            "        const duplicatesStackValue = this.matchingEquality && !this.isElse;",
            "        if (duplicatesStackValue) {",
            "          container.AddContent(ControlCommand.Duplicate());",
            "        }",
            "        this._conditionalDivert = new Divert$1();",
            "        // else clause is unconditional catch-all, otherwise the divert is conditional",
            "        this._conditionalDivert.isConditional = !this.isElse;",
            "        // Need extra evaluation?",
            "        if (!this.isTrueBranch && !this.isElse) {",
            "          const needsEval = this.ownExpression !== null;",
            "          if (needsEval) {",
            "            container.AddContent(ControlCommand.EvalStart());",
            "          }",
            "          if (this.ownExpression) {",
            "            this.ownExpression.GenerateIntoContainer(container);",
            "          }",
            "          // Uses existing duplicated value",
            "          if (this.matchingEquality) {",
            "            container.AddContent(NativeFunctionCall.CallWithName(\"==\"));",
            "          }",
            "          if (needsEval) {",
            "            container.AddContent(ControlCommand.EvalEnd());",
            "          }",
            "        }",
            "        // Will pop from stack if conditional",
            "        container.AddContent(this._conditionalDivert);",
            "        this._contentContainer = this.GenerateRuntimeForContent();",
            "        this._contentContainer.name = \"b\";",
            "        // Multi-line conditionals get a newline at the start of each branch",
            "        // (as opposed to the start of the multi-line conditional since the condition",
            "        //  may evaluate to false.)",
            "        if (!this.isInline) {",
            "          this._contentContainer.InsertContent(new StringValue(\"\\n\"), 0);",
            "        }",
            "        if (duplicatesStackValue || this.isElse && this.matchingEquality) {",
            "          this._contentContainer.InsertContent(ControlCommand.PopEvaluatedValue(), 0);",
            "        }",
            "        container.AddToNamedContentOnly(this._contentContainer);",
            "        this.returnDivert = new Divert$1();",
            "        this._contentContainer.AddContent(this.returnDivert);",
            "        return container;",
            "      };",
            "      this.GenerateRuntimeForContent = () => {",
            "        // Empty branch - create empty container",
            "        if (this._innerWeave === null) {",
            "          return new Container();",
            "        }",
            "        return this._innerWeave.rootContainer;",
            "      };",
            "      // Branches are allowed to be empty",
            "      if (content) {",
            "        this._innerWeave = new Weave(content);",
            "        this.AddContent(this._innerWeave);",
            "      }",
            "    }",
            "    get typeName() {",
            "      return \"ConditionalSingleBranch\";",
            "    }",
            "    ResolveReferences(context) {",
            "      if (!this._conditionalDivert || !this._contentContainer) {",
            "        throw new Error();",
            "      }",
            "      this._conditionalDivert.targetPath = this._contentContainer.path;",
            "      super.ResolveReferences(context);",
            "    }",
            "  }",
            "",
            "  var CustomFlags;",
            "  (function (CustomFlags) {",
            "    CustomFlags[CustomFlags[\"ParsingString\"] = 1] = \"ParsingString\";",
            "    CustomFlags[CustomFlags[\"TagActive\"] = 2] = \"TagActive\";",
            "  })(CustomFlags || (CustomFlags = {}));",
            "",
            "  class DebugMetadata {",
            "    constructor() {",
            "      this.startLineNumber = 0;",
            "      this.endLineNumber = 0;",
            "      this.startCharacterNumber = 0;",
            "      this.endCharacterNumber = 0;",
            "      this.fileName = null;",
            "      this.sourceName = null;",
            "    }",
            "    Merge(dm) {",
            "      let newDebugMetadata = new DebugMetadata();",
            "      newDebugMetadata.fileName = this.fileName;",
            "      newDebugMetadata.sourceName = this.sourceName;",
            "      if (this.startLineNumber < dm.startLineNumber) {",
            "        newDebugMetadata.startLineNumber = this.startLineNumber;",
            "        newDebugMetadata.startCharacterNumber = this.startCharacterNumber;",
            "      } else if (this.startLineNumber > dm.startLineNumber) {",
            "        newDebugMetadata.startLineNumber = dm.startLineNumber;",
            "        newDebugMetadata.startCharacterNumber = dm.startCharacterNumber;",
            "      } else {",
            "        newDebugMetadata.startLineNumber = this.startLineNumber;",
            "        newDebugMetadata.startCharacterNumber = Math.min(this.startCharacterNumber, dm.startCharacterNumber);",
            "      }",
            "      if (this.endLineNumber > dm.endLineNumber) {",
            "        newDebugMetadata.endLineNumber = this.endLineNumber;",
            "        newDebugMetadata.endCharacterNumber = this.endCharacterNumber;",
            "      } else if (this.endLineNumber < dm.endLineNumber) {",
            "        newDebugMetadata.endLineNumber = dm.endLineNumber;",
            "        newDebugMetadata.endCharacterNumber = dm.endCharacterNumber;",
            "      } else {",
            "        newDebugMetadata.endLineNumber = this.endLineNumber;",
            "        newDebugMetadata.endCharacterNumber = Math.max(this.endCharacterNumber, dm.endCharacterNumber);",
            "      }",
            "      return newDebugMetadata;",
            "    }",
            "    toString() {",
            "      if (this.fileName !== null) {",
            "        return `line ${this.startLineNumber} of ${this.fileName}\"`;",
            "      } else {",
            "        return \"line \" + this.startLineNumber;",
            "      }",
            "    }",
            "  }",
            "",
            "  class ExternalDeclaration extends ParsedObject {",
            "    get name() {",
            "      var _a;",
            "      return ((_a = this.identifier) === null || _a === void 0 ? void 0 : _a.name) || null;",
            "    }",
            "    constructor(identifier, argumentNames) {",
            "      super();",
            "      this.identifier = identifier;",
            "      this.argumentNames = argumentNames;",
            "      this.GenerateRuntimeObject = () => {",
            "        this.story.AddExternal(this);",
            "        // No runtime code exists for an external, only metadata",
            "        return null;",
            "      };",
            "    }",
            "    get typeName() {",
            "      return \"EXTERNAL\";",
            "    }",
            "    toString() {",
            "      var _a;",
            "      return `EXTERNAL ${(_a = this.identifier) === null || _a === void 0 ? void 0 : _a.name}`;",
            "    }",
            "  }",
            "",
            "  class FlowDecl {",
            "    constructor(name, args, isFunction) {",
            "      this.name = name;",
            "      this.args = args;",
            "      this.isFunction = isFunction;",
            "    }",
            "  }",
            "",
            "  class Wrap extends ParsedObject {",
            "    constructor(_objToWrap) {",
            "      super();",
            "      this._objToWrap = _objToWrap;",
            "      this.GenerateRuntimeObject = () => this._objToWrap;",
            "    }",
            "  }",
            "",
            "  class Glue$1 extends Wrap {",
            "    constructor(glue) {",
            "      super(glue);",
            "    }",
            "    get typeName() {",
            "      return \"Glue\";",
            "    }",
            "  }",
            "",
            "  class Glue extends InkObject {",
            "    toString() {",
            "      return \"Glue\";",
            "    }",
            "  }",
            "",
            "  class IncDecExpression extends Expression {",
            "    constructor(varIdentifier, isIncOrExpression, isInc) {",
            "      super();",
            "      this.varIdentifier = varIdentifier;",
            "      this._runtimeAssignment = null;",
            "      this.expression = null;",
            "      this.GenerateIntoContainer = container => {",
            "        // x = x + y",
            "        // ^^^ ^ ^ ^",
            "        //  4  1 3 2",
            "        // Reverse polish notation: (x 1 +) (assign to x)",
            "        var _a, _b;",
            "        // 1.",
            "        container.AddContent(new VariableReference$1(((_a = this.varIdentifier) === null || _a === void 0 ? void 0 : _a.name) || null));",
            "        // 2.",
            "        // - Expression used in the form ~ x += y",
            "        // - Simple version: ~ x++",
            "        if (this.expression) {",
            "          this.expression.GenerateIntoContainer(container);",
            "        } else {",
            "          container.AddContent(new IntValue(1));",
            "        }",
            "        // 3.",
            "        container.AddContent(NativeFunctionCall.CallWithName(this.isInc ? \"+\" : \"-\"));",
            "        // 4.",
            "        this._runtimeAssignment = new VariableAssignment$1(((_b = this.varIdentifier) === null || _b === void 0 ? void 0 : _b.name) || null, false);",
            "        container.AddContent(this._runtimeAssignment);",
            "      };",
            "      this.toString = () => {",
            "        var _a, _b;",
            "        if (this.expression) {",
            "          return `${(_a = this.varIdentifier) === null || _a === void 0 ? void 0 : _a.name}${this.isInc ? \" += \" : \" -= \"}${this.expression}`;",
            "        }",
            "        return `${(_b = this.varIdentifier) === null || _b === void 0 ? void 0 : _b.name}` + (this.isInc ? \"++\" : \"--\");",
            "      };",
            "      if (isIncOrExpression instanceof Expression) {",
            "        this.expression = isIncOrExpression;",
            "        this.AddContent(this.expression);",
            "        this.isInc = Boolean(isInc);",
            "      } else {",
            "        this.isInc = isIncOrExpression;",
            "      }",
            "    }",
            "    get typeName() {",
            "      return \"IncDecExpression\";",
            "    }",
            "    ResolveReferences(context) {",
            "      var _a;",
            "      super.ResolveReferences(context);",
            "      const varResolveResult = context.ResolveVariableWithName(((_a = this.varIdentifier) === null || _a === void 0 ? void 0 : _a.name) || \"\", this);",
            "      if (!varResolveResult.found) {",
            "        this.Error(`variable for ${this.incrementDecrementWord} could not be found: '${this.varIdentifier}' after searching: {this.descriptionOfScope}`);",
            "      }",
            "      if (!this._runtimeAssignment) {",
            "        throw new Error();",
            "      }",
            "      this._runtimeAssignment.isGlobal = varResolveResult.isGlobal;",
            "      if (!(this.parent instanceof Weave) && !(this.parent instanceof FlowBase) && !(this.parent instanceof ContentList)) {",
            "        this.Error(`Can't use ${this.incrementDecrementWord} as sub-expression`);",
            "      }",
            "    }",
            "    get incrementDecrementWord() {",
            "      if (this.isInc) {",
            "        return \"increment\";",
            "      }",
            "      return \"decrement\";",
            "    }",
            "  }",
            "",
            "  class IncludedFile extends ParsedObject {",
            "    constructor(includedStory) {",
            "      super();",
            "      this.includedStory = includedStory;",
            "      this.GenerateRuntimeObject = () => {",
            "        // Left to the main story to process",
            "        return null;",
            "      };",
            "    }",
            "    get typeName() {",
            "      return \"IncludedFile\";",
            "    }",
            "  }",
            "",
            "  class InfixOperator {",
            "    constructor(type, precedence, requireWhitespace) {",
            "      this.type = type;",
            "      this.precedence = precedence;",
            "      this.requireWhitespace = requireWhitespace;",
            "      this.toString = () => this.type;",
            "    }",
            "  }",
            "",
            "  class Knot extends FlowBase {",
            "    get flowLevel() {",
            "      return FlowLevel.Knot;",
            "    }",
            "    constructor(name, topLevelObjects, args, isFunction) {",
            "      super(name, topLevelObjects, args, isFunction);",
            "    }",
            "    get typeName() {",
            "      return this.isFunction ? \"Function\" : \"Knot\";",
            "    }",
            "    ResolveReferences(context) {",
            "      super.ResolveReferences(context);",
            "      let parentStory = this.story;",
            "      // Enforce rule that stitches must not have the same",
            "      // name as any knots that exist in the story",
            "      for (const stitchName in this.subFlowsByName) {",
            "        const knotWithStitchName = parentStory.ContentWithNameAtLevel(stitchName, FlowLevel.Knot, false);",
            "        if (knotWithStitchName) {",
            "          const stitch = this.subFlowsByName.get(stitchName);",
            "          const errorMsg = `Stitch '${stitch ? stitch.name : \"NO STITCH FOUND\"}' has the same name as a knot (on ${knotWithStitchName.debugMetadata})`;",
            "          this.Error(errorMsg, stitch);",
            "        }",
            "      }",
            "    }",
            "  }",
            "",
            "  class List extends Expression {",
            "    constructor(itemIdentifierList) {",
            "      super();",
            "      this.itemIdentifierList = itemIdentifierList;",
            "      this.GenerateIntoContainer = container => {",
            "        var _a, _b;",
            "        const runtimeRawList = new InkList();",
            "        if (this.itemIdentifierList != null) {",
            "          for (const itemIdentifier of this.itemIdentifierList) {",
            "            const nameParts = ((_a = itemIdentifier === null || itemIdentifier === void 0 ? void 0 : itemIdentifier.name) === null || _a === void 0 ? void 0 : _a.split(\".\")) || [];",
            "            let listName = null;",
            "            let listItemName = \"\";",
            "            if (nameParts.length > 1) {",
            "              listName = nameParts[0];",
            "              listItemName = nameParts[1];",
            "            } else {",
            "              listItemName = nameParts[0];",
            "            }",
            "            const listItem = this.story.ResolveListItem(listName, listItemName, this);",
            "            if (listItem === null) {",
            "              if (listName === null) {",
            "                this.Error(`Could not find list definition that contains item '${itemIdentifier}'`);",
            "              } else {",
            "                this.Error(`Could not find list item ${itemIdentifier}`);",
            "              }",
            "            } else {",
            "              if (listItem.parent == null) {",
            "                this.Error(`Could not find list definition for item ${itemIdentifier}`);",
            "                return;",
            "              }",
            "              if (!listName) {",
            "                listName = ((_b = listItem.parent.identifier) === null || _b === void 0 ? void 0 : _b.name) || null;",
            "              }",
            "              const item = new InkListItem(listName, listItem.name || null);",
            "              if (runtimeRawList.has(item.serialized())) {",
            "                this.Warning(`Duplicate of item '${itemIdentifier}' in list.`);",
            "              } else {",
            "                runtimeRawList.Add(item, listItem.seriesValue);",
            "              }",
            "            }",
            "          }",
            "        }",
            "        container.AddContent(new ListValue(runtimeRawList));",
            "      };",
            "    }",
            "    get typeName() {",
            "      return \"List\";",
            "    }",
            "  }",
            "",
            "  class ListElementDefinition extends ParsedObject {",
            "    get fullName() {",
            "      var _a;",
            "      const parentList = this.parent;",
            "      if (parentList === null) {",
            "        throw new Error(\"Can't get full name without a parent list.\");",
            "      }",
            "      return `${(_a = parentList.identifier) === null || _a === void 0 ? void 0 : _a.name}.${this.name}`;",
            "    }",
            "    get typeName() {",
            "      return \"ListElement\";",
            "    }",
            "    get name() {",
            "      var _a;",
            "      return ((_a = this.indentifier) === null || _a === void 0 ? void 0 : _a.name) || null;",
            "    }",
            "    constructor(indentifier, inInitialList) {",
            "      let explicitValue = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;",
            "      super();",
            "      this.indentifier = indentifier;",
            "      this.inInitialList = inInitialList;",
            "      this.explicitValue = explicitValue;",
            "      this.seriesValue = 0;",
            "      this.parent = null;",
            "      this.GenerateRuntimeObject = () => {",
            "        throw new Error(\"Not implemented.\");",
            "      };",
            "      this.toString = () => this.fullName;",
            "      this.parent = super.parent;",
            "    }",
            "    ResolveReferences(context) {",
            "      super.ResolveReferences(context);",
            "      context.CheckForNamingCollisions(this, this.indentifier, SymbolType.ListItem);",
            "    }",
            "  }",
            "",
            "  exports.StatementLevel = void 0;",
            "  (function (StatementLevel) {",
            "    StatementLevel[StatementLevel[\"InnerBlock\"] = 0] = \"InnerBlock\";",
            "    StatementLevel[StatementLevel[\"Stitch\"] = 1] = \"Stitch\";",
            "    StatementLevel[StatementLevel[\"Knot\"] = 2] = \"Knot\";",
            "    StatementLevel[StatementLevel[\"Top\"] = 3] = \"Top\";",
            "  })(exports.StatementLevel || (exports.StatementLevel = {}));",
            "",
            "  class Stitch extends FlowBase {",
            "    get flowLevel() {",
            "      return FlowLevel.Stitch;",
            "    }",
            "    constructor(name, topLevelObjects, args, isFunction) {",
            "      super(name, topLevelObjects, args, isFunction);",
            "      this.toString = () => {",
            "        return `${this.parent !== null ? this.parent + \" > \" : \"\"}${super.toString()}`;",
            "      };",
            "    }",
            "    get typeName() {",
            "      return \"Stitch\";",
            "    }",
            "  }",
            "",
            "  // New version of tags is dynamic - it constructs the tags",
            "  // at runtime based on BeginTag and EndTag control commands.",
            "  // Plain text that's in the output stream is turned into tags",
            "  // when you do story.currentTags.",
            "  // The only place this is used is when flattening tags down",
            "  // to string in advance, during dynamic string generation if",
            "  // there's a tag embedded in it. See how ControlCommand.EndString",
            "  // is implemented in Story.cs for more details + comment",
            "  class Tag$1 extends InkObject {",
            "    constructor(tagText) {",
            "      super();",
            "      this.text = tagText.toString() || \"\";",
            "    }",
            "    toString() {",
            "      return \"# \" + this.text;",
            "    }",
            "  }",
            "",
            "  class Choice extends InkObject {",
            "    constructor() {",
            "      super(...arguments);",
            "      this.text = \"\";",
            "      this.index = 0;",
            "      this.threadAtGeneration = null;",
            "      this.sourcePath = \"\";",
            "      this.targetPath = null;",
            "      this.isInvisibleDefault = false;",
            "      this.tags = null;",
            "      this.originalThreadIndex = 0;",
            "    }",
            "    get pathStringOnChoice() {",
            "      if (this.targetPath === null) return throwNullException(\"Choice.targetPath\");",
            "      return this.targetPath.toString();",
            "    }",
            "    set pathStringOnChoice(value) {",
            "      this.targetPath = new Path$1(value);",
            "    }",
            "  }",
            "",
            "  class ListDefinitionsOrigin {",
            "    constructor(lists) {",
            "      this._lists = new Map();",
            "      this._allUnambiguousListValueCache = new Map();",
            "      for (let list of lists) {",
            "        this._lists.set(list.name, list);",
            "        for (let [key, val] of list.items) {",
            "          let item = InkListItem.fromSerializedKey(key);",
            "          let listValue = new ListValue(item, val);",
            "          if (!item.itemName) {",
            "            throw new Error(\"item.itemName is null or undefined.\");",
            "          }",
            "          this._allUnambiguousListValueCache.set(item.itemName, listValue);",
            "          this._allUnambiguousListValueCache.set(item.fullName, listValue);",
            "        }",
            "      }",
            "    }",
            "    get lists() {",
            "      let listOfLists = [];",
            "      for (let [, value] of this._lists) {",
            "        listOfLists.push(value);",
            "      }",
            "      return listOfLists;",
            "    }",
            "    TryListGetDefinition(name, /* out */def) {",
            "      if (name === null) {",
            "        return {",
            "          result: def,",
            "          exists: false",
            "        };",
            "      }",
            "      // initially, this function returns a boolean and the second parameter is an out.",
            "      let definition = this._lists.get(name);",
            "      if (!definition) return {",
            "        result: def,",
            "        exists: false",
            "      };",
            "      return {",
            "        result: definition,",
            "        exists: true",
            "      };",
            "    }",
            "    FindSingleItemListWithName(name) {",
            "      if (name === null) {",
            "        return throwNullException(\"name\");",
            "      }",
            "      let val = this._allUnambiguousListValueCache.get(name);",
            "      if (typeof val !== \"undefined\") {",
            "        return val;",
            "      }",
            "      return null;",
            "    }",
            "  }",
            "",
            "  class JsonSerialisation {",
            "    static JArrayToRuntimeObjList(jArray) {",
            "      let skipLast = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;",
            "      let count = jArray.length;",
            "      if (skipLast) count--;",
            "      let list = [];",
            "      for (let i = 0; i < count; i++) {",
            "        let jTok = jArray[i];",
            "        let runtimeObj = this.JTokenToRuntimeObject(jTok);",
            "        if (runtimeObj === null) {",
            "          return throwNullException(\"runtimeObj\");",
            "        }",
            "        list.push(runtimeObj);",
            "      }",
            "      return list;",
            "    }",
            "    static WriteDictionaryRuntimeObjs(writer, dictionary) {",
            "      writer.WriteObjectStart();",
            "      for (let [key, value] of dictionary) {",
            "        writer.WritePropertyStart(key);",
            "        this.WriteRuntimeObject(writer, value);",
            "        writer.WritePropertyEnd();",
            "      }",
            "      writer.WriteObjectEnd();",
            "    }",
            "    static WriteListRuntimeObjs(writer, list) {",
            "      writer.WriteArrayStart();",
            "      for (let value of list) {",
            "        this.WriteRuntimeObject(writer, value);",
            "      }",
            "      writer.WriteArrayEnd();",
            "    }",
            "    static WriteIntDictionary(writer, dict) {",
            "      writer.WriteObjectStart();",
            "      for (let [key, value] of dict) {",
            "        writer.WriteIntProperty(key, value);",
            "      }",
            "      writer.WriteObjectEnd();",
            "    }",
            "    static WriteRuntimeObject(writer, obj) {",
            "      let container = asOrNull(obj, Container);",
            "      if (container) {",
            "        this.WriteRuntimeContainer(writer, container);",
            "        return;",
            "      }",
            "      let divert = asOrNull(obj, Divert$1);",
            "      if (divert) {",
            "        let divTypeKey = \"->\";",
            "        if (divert.isExternal) {",
            "          divTypeKey = \"x()\";",
            "        } else if (divert.pushesToStack) {",
            "          if (divert.stackPushType == PushPopType.Function) {",
            "            divTypeKey = \"f()\";",
            "          } else if (divert.stackPushType == PushPopType.Tunnel) {",
            "            divTypeKey = \"->t->\";",
            "          }",
            "        }",
            "        let targetStr;",
            "        if (divert.hasVariableTarget) {",
            "          targetStr = divert.variableDivertName;",
            "        } else {",
            "          targetStr = divert.targetPathString;",
            "        }",
            "        writer.WriteObjectStart();",
            "        writer.WriteProperty(divTypeKey, targetStr);",
            "        if (divert.hasVariableTarget) {",
            "          writer.WriteProperty(\"var\", true);",
            "        }",
            "        if (divert.isConditional) {",
            "          writer.WriteProperty(\"c\", true);",
            "        }",
            "        if (divert.externalArgs > 0) {",
            "          writer.WriteIntProperty(\"exArgs\", divert.externalArgs);",
            "        }",
            "        writer.WriteObjectEnd();",
            "        return;",
            "      }",
            "      let choicePoint = asOrNull(obj, ChoicePoint);",
            "      if (choicePoint) {",
            "        writer.WriteObjectStart();",
            "        writer.WriteProperty(\"*\", choicePoint.pathStringOnChoice);",
            "        writer.WriteIntProperty(\"flg\", choicePoint.flags);",
            "        writer.WriteObjectEnd();",
            "        return;",
            "      }",
            "      let boolVal = asOrNull(obj, BoolValue);",
            "      if (boolVal) {",
            "        writer.WriteBool(boolVal.value);",
            "        return;",
            "      }",
            "      let intVal = asOrNull(obj, IntValue);",
            "      if (intVal) {",
            "        writer.WriteInt(intVal.value);",
            "        return;",
            "      }",
            "      let floatVal = asOrNull(obj, FloatValue);",
            "      if (floatVal) {",
            "        writer.WriteFloat(floatVal.value);",
            "        return;",
            "      }",
            "      let strVal = asOrNull(obj, StringValue);",
            "      if (strVal) {",
            "        if (strVal.isNewline) {",
            "          writer.Write(\"\\n\", false);",
            "        } else {",
            "          writer.WriteStringStart();",
            "          writer.WriteStringInner(\"^\");",
            "          writer.WriteStringInner(strVal.value);",
            "          writer.WriteStringEnd();",
            "        }",
            "        return;",
            "      }",
            "      let listVal = asOrNull(obj, ListValue);",
            "      if (listVal) {",
            "        this.WriteInkList(writer, listVal);",
            "        return;",
            "      }",
            "      let divTargetVal = asOrNull(obj, DivertTargetValue);",
            "      if (divTargetVal) {",
            "        writer.WriteObjectStart();",
            "        if (divTargetVal.value === null) {",
            "          return throwNullException(\"divTargetVal.value\");",
            "        }",
            "        writer.WriteProperty(\"^->\", divTargetVal.value.componentsString);",
            "        writer.WriteObjectEnd();",
            "        return;",
            "      }",
            "      let varPtrVal = asOrNull(obj, VariablePointerValue);",
            "      if (varPtrVal) {",
            "        writer.WriteObjectStart();",
            "        writer.WriteProperty(\"^var\", varPtrVal.value);",
            "        writer.WriteIntProperty(\"ci\", varPtrVal.contextIndex);",
            "        writer.WriteObjectEnd();",
            "        return;",
            "      }",
            "      let glue = asOrNull(obj, Glue);",
            "      if (glue) {",
            "        writer.Write(\"<>\");",
            "        return;",
            "      }",
            "      let controlCmd = asOrNull(obj, ControlCommand);",
            "      if (controlCmd) {",
            "        writer.Write(JsonSerialisation._controlCommandNames[controlCmd.commandType]);",
            "        return;",
            "      }",
            "      let nativeFunc = asOrNull(obj, NativeFunctionCall);",
            "      if (nativeFunc) {",
            "        let name = nativeFunc.name;",
            "        if (name == \"^\") name = \"L^\";",
            "        writer.Write(name);",
            "        return;",
            "      }",
            "      let varRef = asOrNull(obj, VariableReference$1);",
            "      if (varRef) {",
            "        writer.WriteObjectStart();",
            "        let readCountPath = varRef.pathStringForCount;",
            "        if (readCountPath != null) {",
            "          writer.WriteProperty(\"CNT?\", readCountPath);",
            "        } else {",
            "          writer.WriteProperty(\"VAR?\", varRef.name);",
            "        }",
            "        writer.WriteObjectEnd();",
            "        return;",
            "      }",
            "      let varAss = asOrNull(obj, VariableAssignment$1);",
            "      if (varAss) {",
            "        writer.WriteObjectStart();",
            "        let key = varAss.isGlobal ? \"VAR=\" : \"temp=\";",
            "        writer.WriteProperty(key, varAss.variableName);",
            "        // Reassignment?",
            "        if (!varAss.isNewDeclaration) writer.WriteProperty(\"re\", true);",
            "        writer.WriteObjectEnd();",
            "        return;",
            "      }",
            "      let voidObj = asOrNull(obj, Void);",
            "      if (voidObj) {",
            "        writer.Write(\"void\");",
            "        return;",
            "      }",
            "      let tag = asOrNull(obj, Tag$1);",
            "      if (tag) {",
            "        writer.WriteObjectStart();",
            "        writer.WriteProperty(\"#\", tag.text);",
            "        writer.WriteObjectEnd();",
            "        return;",
            "      }",
            "      let choice = asOrNull(obj, Choice);",
            "      if (choice) {",
            "        this.WriteChoice(writer, choice);",
            "        return;",
            "      }",
            "      throw new Error(\"Failed to convert runtime object to Json token: \" + obj);",
            "    }",
            "    static JObjectToDictionaryRuntimeObjs(jObject) {",
            "      let dict = new Map();",
            "      for (let key in jObject) {",
            "        if (jObject.hasOwnProperty(key)) {",
            "          let inkObject = this.JTokenToRuntimeObject(jObject[key]);",
            "          if (inkObject === null) {",
            "            return throwNullException(\"inkObject\");",
            "          }",
            "          dict.set(key, inkObject);",
            "        }",
            "      }",
            "      return dict;",
            "    }",
            "    static JObjectToIntDictionary(jObject) {",
            "      let dict = new Map();",
            "      for (let key in jObject) {",
            "        if (jObject.hasOwnProperty(key)) {",
            "          dict.set(key, parseInt(jObject[key]));",
            "        }",
            "      }",
            "      return dict;",
            "    }",
            "    static JTokenToRuntimeObject(token) {",
            "      if (typeof token === \"number\" && !isNaN(token) || typeof token === \"boolean\") {",
            "        return Value.Create(token);",
            "      }",
            "      if (typeof token === \"string\") {",
            "        let str = token.toString();",
            "        // String value",
            "        let firstChar = str[0];",
            "        if (firstChar == \"^\") return new StringValue(str.substring(1));else if (firstChar == \"\\n\" && str.length == 1) return new StringValue(\"\\n\");",
            "        // Glue",
            "        if (str == \"<>\") return new Glue();",
            "        // Control commands (would looking up in a hash set be faster?)",
            "        for (let i = 0; i < JsonSerialisation._controlCommandNames.length; ++i) {",
            "          let cmdName = JsonSerialisation._controlCommandNames[i];",
            "          if (str == cmdName) {",
            "            return new ControlCommand(i);",
            "          }",
            "        }",
            "        // Native functions",
            "        if (str == \"L^\") str = \"^\";",
            "        if (NativeFunctionCall.CallExistsWithName(str)) return NativeFunctionCall.CallWithName(str);",
            "        // Pop",
            "        if (str == \"->->\") return ControlCommand.PopTunnel();else if (str == \"~ret\") return ControlCommand.PopFunction();",
            "        // Void",
            "        if (str == \"void\") return new Void();",
            "      }",
            "      if (typeof token === \"object\" && !Array.isArray(token)) {",
            "        let obj = token;",
            "        let propValue;",
            "        // Divert target value to path",
            "        if (obj[\"^->\"]) {",
            "          propValue = obj[\"^->\"];",
            "          return new DivertTargetValue(new Path$1(propValue.toString()));",
            "        }",
            "        // VariablePointerValue",
            "        if (obj[\"^var\"]) {",
            "          propValue = obj[\"^var\"];",
            "          let varPtr = new VariablePointerValue(propValue.toString());",
            "          if (\"ci\" in obj) {",
            "            propValue = obj[\"ci\"];",
            "            varPtr.contextIndex = parseInt(propValue);",
            "          }",
            "          return varPtr;",
            "        }",
            "        // Divert",
            "        let isDivert = false;",
            "        let pushesToStack = false;",
            "        let divPushType = PushPopType.Function;",
            "        let external = false;",
            "        if (propValue = obj[\"->\"]) {",
            "          isDivert = true;",
            "        } else if (propValue = obj[\"f()\"]) {",
            "          isDivert = true;",
            "          pushesToStack = true;",
            "          divPushType = PushPopType.Function;",
            "        } else if (propValue = obj[\"->t->\"]) {",
            "          isDivert = true;",
            "          pushesToStack = true;",
            "          divPushType = PushPopType.Tunnel;",
            "        } else if (propValue = obj[\"x()\"]) {",
            "          isDivert = true;",
            "          external = true;",
            "          pushesToStack = false;",
            "          divPushType = PushPopType.Function;",
            "        }",
            "        if (isDivert) {",
            "          let divert = new Divert$1();",
            "          divert.pushesToStack = pushesToStack;",
            "          divert.stackPushType = divPushType;",
            "          divert.isExternal = external;",
            "          let target = propValue.toString();",
            "          if (propValue = obj[\"var\"]) divert.variableDivertName = target;else divert.targetPathString = target;",
            "          divert.isConditional = !!obj[\"c\"];",
            "          if (external) {",
            "            if (propValue = obj[\"exArgs\"]) divert.externalArgs = parseInt(propValue);",
            "          }",
            "          return divert;",
            "        }",
            "        // Choice",
            "        if (propValue = obj[\"*\"]) {",
            "          let choice = new ChoicePoint();",
            "          choice.pathStringOnChoice = propValue.toString();",
            "          if (propValue = obj[\"flg\"]) choice.flags = parseInt(propValue);",
            "          return choice;",
            "        }",
            "        // Variable reference",
            "        if (propValue = obj[\"VAR?\"]) {",
            "          return new VariableReference$1(propValue.toString());",
            "        } else if (propValue = obj[\"CNT?\"]) {",
            "          let readCountVarRef = new VariableReference$1();",
            "          readCountVarRef.pathStringForCount = propValue.toString();",
            "          return readCountVarRef;",
            "        }",
            "        // Variable assignment",
            "        let isVarAss = false;",
            "        let isGlobalVar = false;",
            "        if (propValue = obj[\"VAR=\"]) {",
            "          isVarAss = true;",
            "          isGlobalVar = true;",
            "        } else if (propValue = obj[\"temp=\"]) {",
            "          isVarAss = true;",
            "          isGlobalVar = false;",
            "        }",
            "        if (isVarAss) {",
            "          let varName = propValue.toString();",
            "          let isNewDecl = !obj[\"re\"];",
            "          let varAss = new VariableAssignment$1(varName, isNewDecl);",
            "          varAss.isGlobal = isGlobalVar;",
            "          return varAss;",
            "        }",
            "        if (obj[\"#\"] !== undefined) {",
            "          propValue = obj[\"#\"];",
            "          return new Tag$1(propValue.toString());",
            "        }",
            "        // List value",
            "        if (propValue = obj[\"list\"]) {",
            "          // var listContent = (Dictionary<string, object>)propValue;",
            "          let listContent = propValue;",
            "          let rawList = new InkList();",
            "          if (propValue = obj[\"origins\"]) {",
            "            // var namesAsObjs = (List<object>)propValue;",
            "            let namesAsObjs = propValue;",
            "            // rawList.SetInitialOriginNames(namesAsObjs.Cast<string>().ToList());",
            "            rawList.SetInitialOriginNames(namesAsObjs);",
            "          }",
            "          for (let key in listContent) {",
            "            if (listContent.hasOwnProperty(key)) {",
            "              let nameToVal = listContent[key];",
            "              let item = new InkListItem(key);",
            "              let val = parseInt(nameToVal);",
            "              rawList.Add(item, val);",
            "            }",
            "          }",
            "          return new ListValue(rawList);",
            "        }",
            "        if (obj[\"originalChoicePath\"] != null) return this.JObjectToChoice(obj);",
            "      }",
            "      // Array is always a Runtime.Container",
            "      if (Array.isArray(token)) {",
            "        return this.JArrayToContainer(token);",
            "      }",
            "      if (token === null || token === undefined) return null;",
            "      throw new Error(\"Failed to convert token to runtime object: \" + this.toJson(token, [\"parent\"]));",
            "    }",
            "    static toJson(me, removes, space) {",
            "      return JSON.stringify(me, (k, v) => (removes === null || removes === void 0 ? void 0 : removes.some(r => r === k)) ? undefined : v, space);",
            "    }",
            "    static WriteRuntimeContainer(writer, container) {",
            "      let withoutName = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;",
            "      writer.WriteArrayStart();",
            "      if (container === null) {",
            "        return throwNullException(\"container\");",
            "      }",
            "      for (let c of container.content) this.WriteRuntimeObject(writer, c);",
            "      let namedOnlyContent = container.namedOnlyContent;",
            "      let countFlags = container.countFlags;",
            "      let hasNameProperty = container.name != null && !withoutName;",
            "      let hasTerminator = namedOnlyContent != null || countFlags > 0 || hasNameProperty;",
            "      if (hasTerminator) {",
            "        writer.WriteObjectStart();",
            "      }",
            "      if (namedOnlyContent != null) {",
            "        for (let [key, value] of namedOnlyContent) {",
            "          let name = key;",
            "          let namedContainer = asOrNull(value, Container);",
            "          writer.WritePropertyStart(name);",
            "          this.WriteRuntimeContainer(writer, namedContainer, true);",
            "          writer.WritePropertyEnd();",
            "        }",
            "      }",
            "      if (countFlags > 0) writer.WriteIntProperty(\"#f\", countFlags);",
            "      if (hasNameProperty) writer.WriteProperty(\"#n\", container.name);",
            "      if (hasTerminator) writer.WriteObjectEnd();else writer.WriteNull();",
            "      writer.WriteArrayEnd();",
            "    }",
            "    static JArrayToContainer(jArray) {",
            "      let container = new Container();",
            "      container.content = this.JArrayToRuntimeObjList(jArray, true);",
            "      let terminatingObj = jArray[jArray.length - 1];",
            "      if (terminatingObj != null) {",
            "        let namedOnlyContent = new Map();",
            "        for (let key in terminatingObj) {",
            "          if (key == \"#f\") {",
            "            container.countFlags = parseInt(terminatingObj[key]);",
            "          } else if (key == \"#n\") {",
            "            container.name = terminatingObj[key].toString();",
            "          } else {",
            "            let namedContentItem = this.JTokenToRuntimeObject(terminatingObj[key]);",
            "            // var namedSubContainer = namedContentItem as Container;",
            "            let namedSubContainer = asOrNull(namedContentItem, Container);",
            "            if (namedSubContainer) namedSubContainer.name = key;",
            "            namedOnlyContent.set(key, namedContentItem);",
            "          }",
            "        }",
            "        container.namedOnlyContent = namedOnlyContent;",
            "      }",
            "      return container;",
            "    }",
            "    static JObjectToChoice(jObj) {",
            "      let choice = new Choice();",
            "      choice.text = jObj[\"text\"].toString();",
            "      choice.index = parseInt(jObj[\"index\"]);",
            "      choice.sourcePath = jObj[\"originalChoicePath\"].toString();",
            "      choice.originalThreadIndex = parseInt(jObj[\"originalThreadIndex\"]);",
            "      choice.pathStringOnChoice = jObj[\"targetPath\"].toString();",
            "      if (jObj[\"tags\"]) {",
            "        choice.tags = jObj[\"tags\"];",
            "      }",
            "      return choice;",
            "    }",
            "    static WriteChoice(writer, choice) {",
            "      writer.WriteObjectStart();",
            "      writer.WriteProperty(\"text\", choice.text);",
            "      writer.WriteIntProperty(\"index\", choice.index);",
            "      writer.WriteProperty(\"originalChoicePath\", choice.sourcePath);",
            "      writer.WriteIntProperty(\"originalThreadIndex\", choice.originalThreadIndex);",
            "      writer.WriteProperty(\"targetPath\", choice.pathStringOnChoice);",
            "      if (choice.tags) {",
            "        writer.WriteProperty(\"tags\", w => {",
            "          w.WriteArrayStart();",
            "          for (const tag of choice.tags) {",
            "            w.WriteStringStart();",
            "            w.WriteStringInner(tag);",
            "            w.WriteStringEnd();",
            "          }",
            "          w.WriteArrayEnd();",
            "        });",
            "      }",
            "      writer.WriteObjectEnd();",
            "    }",
            "    static WriteInkList(writer, listVal) {",
            "      let rawList = listVal.value;",
            "      if (rawList === null) {",
            "        return throwNullException(\"rawList\");",
            "      }",
            "      writer.WriteObjectStart();",
            "      writer.WritePropertyStart(\"list\");",
            "      writer.WriteObjectStart();",
            "      for (let [key, val] of rawList) {",
            "        let item = InkListItem.fromSerializedKey(key);",
            "        let itemVal = val;",
            "        if (item.itemName === null) {",
            "          return throwNullException(\"item.itemName\");",
            "        }",
            "        writer.WritePropertyNameStart();",
            "        writer.WritePropertyNameInner(item.originName ? item.originName : \"?\");",
            "        writer.WritePropertyNameInner(\".\");",
            "        writer.WritePropertyNameInner(item.itemName);",
            "        writer.WritePropertyNameEnd();",
            "        writer.Write(itemVal);",
            "        writer.WritePropertyEnd();",
            "      }",
            "      writer.WriteObjectEnd();",
            "      writer.WritePropertyEnd();",
            "      if (rawList.Count == 0 && rawList.originNames != null && rawList.originNames.length > 0) {",
            "        writer.WritePropertyStart(\"origins\");",
            "        writer.WriteArrayStart();",
            "        for (let name of rawList.originNames) writer.Write(name);",
            "        writer.WriteArrayEnd();",
            "        writer.WritePropertyEnd();",
            "      }",
            "      writer.WriteObjectEnd();",
            "    }",
            "    static ListDefinitionsToJToken(origin) {",
            "      let result = {};",
            "      for (let def of origin.lists) {",
            "        let listDefJson = {};",
            "        for (let [key, val] of def.items) {",
            "          let item = InkListItem.fromSerializedKey(key);",
            "          if (item.itemName === null) {",
            "            return throwNullException(\"item.itemName\");",
            "          }",
            "          listDefJson[item.itemName] = val;",
            "        }",
            "        result[def.name] = listDefJson;",
            "      }",
            "      return result;",
            "    }",
            "    static JTokenToListDefinitions(obj) {",
            "      // var defsObj = (Dictionary<string, object>)obj;",
            "      let defsObj = obj;",
            "      let allDefs = [];",
            "      for (let key in defsObj) {",
            "        if (defsObj.hasOwnProperty(key)) {",
            "          let name = key.toString();",
            "          // var listDefJson = (Dictionary<string, object>)kv.Value;",
            "          let listDefJson = defsObj[key];",
            "          // Cast (string, object) to (string, int) for items",
            "          let items = new Map();",
            "          for (let nameValueKey in listDefJson) {",
            "            if (defsObj.hasOwnProperty(key)) {",
            "              let nameValue = listDefJson[nameValueKey];",
            "              items.set(nameValueKey, parseInt(nameValue));",
            "            }",
            "          }",
            "          let def = new ListDefinition$1(name, items);",
            "          allDefs.push(def);",
            "        }",
            "      }",
            "      return new ListDefinitionsOrigin(allDefs);",
            "    }",
            "  }",
            "  JsonSerialisation._controlCommandNames = (() => {",
            "    let _controlCommandNames = [];",
            "    _controlCommandNames[ControlCommand.CommandType.EvalStart] = \"ev\";",
            "    _controlCommandNames[ControlCommand.CommandType.EvalOutput] = \"out\";",
            "    _controlCommandNames[ControlCommand.CommandType.EvalEnd] = \"/ev\";",
            "    _controlCommandNames[ControlCommand.CommandType.Duplicate] = \"du\";",
            "    _controlCommandNames[ControlCommand.CommandType.PopEvaluatedValue] = \"pop\";",
            "    _controlCommandNames[ControlCommand.CommandType.PopFunction] = \"~ret\";",
            "    _controlCommandNames[ControlCommand.CommandType.PopTunnel] = \"->->\";",
            "    _controlCommandNames[ControlCommand.CommandType.BeginString] = \"str\";",
            "    _controlCommandNames[ControlCommand.CommandType.EndString] = \"/str\";",
            "    _controlCommandNames[ControlCommand.CommandType.NoOp] = \"nop\";",
            "    _controlCommandNames[ControlCommand.CommandType.ChoiceCount] = \"choiceCnt\";",
            "    _controlCommandNames[ControlCommand.CommandType.Turns] = \"turn\";",
            "    _controlCommandNames[ControlCommand.CommandType.TurnsSince] = \"turns\";",
            "    _controlCommandNames[ControlCommand.CommandType.ReadCount] = \"readc\";",
            "    _controlCommandNames[ControlCommand.CommandType.Random] = \"rnd\";",
            "    _controlCommandNames[ControlCommand.CommandType.SeedRandom] = \"srnd\";",
            "    _controlCommandNames[ControlCommand.CommandType.VisitIndex] = \"visit\";",
            "    _controlCommandNames[ControlCommand.CommandType.SequenceShuffleIndex] = \"seq\";",
            "    _controlCommandNames[ControlCommand.CommandType.StartThread] = \"thread\";",
            "    _controlCommandNames[ControlCommand.CommandType.Done] = \"done\";",
            "    _controlCommandNames[ControlCommand.CommandType.End] = \"end\";",
            "    _controlCommandNames[ControlCommand.CommandType.ListFromInt] = \"listInt\";",
            "    _controlCommandNames[ControlCommand.CommandType.ListRange] = \"range\";",
            "    _controlCommandNames[ControlCommand.CommandType.ListRandom] = \"lrnd\";",
            "    _controlCommandNames[ControlCommand.CommandType.BeginTag] = \"#\";",
            "    _controlCommandNames[ControlCommand.CommandType.EndTag] = \"/#\";",
            "    for (let i = 0; i < ControlCommand.CommandType.TOTAL_VALUES; ++i) {",
            "      if (_controlCommandNames[i] == null) throw new Error(\"Control command not accounted for in serialisation\");",
            "    }",
            "    return _controlCommandNames;",
            "  })();",
            "",
            "  class CallStack {",
            "    get elements() {",
            "      return this.callStack;",
            "    }",
            "    get depth() {",
            "      return this.elements.length;",
            "    }",
            "    get currentElement() {",
            "      let thread = this._threads[this._threads.length - 1];",
            "      let cs = thread.callstack;",
            "      return cs[cs.length - 1];",
            "    }",
            "    get currentElementIndex() {",
            "      return this.callStack.length - 1;",
            "    }",
            "    get currentThread() {",
            "      return this._threads[this._threads.length - 1];",
            "    }",
            "    set currentThread(value) {",
            "      Debug.Assert(this._threads.length == 1, \"Shouldn't be directly setting the current thread when we have a stack of them\");",
            "      this._threads.length = 0;",
            "      this._threads.push(value);",
            "    }",
            "    get canPop() {",
            "      return this.callStack.length > 1;",
            "    }",
            "    constructor() {",
            "      this._threadCounter = 0;",
            "      this._startOfRoot = Pointer.Null;",
            "      if (arguments[0] instanceof Story$1) {",
            "        let storyContext = arguments[0];",
            "        this._startOfRoot = Pointer.StartOf(storyContext.rootContentContainer);",
            "        this.Reset();",
            "      } else {",
            "        let toCopy = arguments[0];",
            "        this._threads = [];",
            "        for (let otherThread of toCopy._threads) {",
            "          this._threads.push(otherThread.Copy());",
            "        }",
            "        this._threadCounter = toCopy._threadCounter;",
            "        this._startOfRoot = toCopy._startOfRoot.copy();",
            "      }",
            "    }",
            "    Reset() {",
            "      this._threads = [];",
            "      this._threads.push(new CallStack.Thread());",
            "      this._threads[0].callstack.push(new CallStack.Element(PushPopType.Tunnel, this._startOfRoot));",
            "    }",
            "    SetJsonToken(jObject, storyContext) {",
            "      this._threads.length = 0;",
            "      // TODO: (List<object>) jObject [\"threads\"];",
            "      let jThreads = jObject[\"threads\"];",
            "      for (let jThreadTok of jThreads) {",
            "        // TODO: var jThreadObj = (Dictionary<string, object>)jThreadTok;",
            "        let jThreadObj = jThreadTok;",
            "        let thread = new CallStack.Thread(jThreadObj, storyContext);",
            "        this._threads.push(thread);",
            "      }",
            "      // TODO: (int)jObject [\"threadCounter\"];",
            "      this._threadCounter = parseInt(jObject[\"threadCounter\"]);",
            "      this._startOfRoot = Pointer.StartOf(storyContext.rootContentContainer);",
            "    }",
            "    WriteJson(w) {",
            "      w.WriteObject(writer => {",
            "        writer.WritePropertyStart(\"threads\");",
            "        writer.WriteArrayStart();",
            "        for (let thread of this._threads) {",
            "          thread.WriteJson(writer);",
            "        }",
            "        writer.WriteArrayEnd();",
            "        writer.WritePropertyEnd();",
            "        writer.WritePropertyStart(\"threadCounter\");",
            "        writer.WriteInt(this._threadCounter);",
            "        writer.WritePropertyEnd();",
            "      });",
            "    }",
            "    PushThread() {",
            "      let newThread = this.currentThread.Copy();",
            "      this._threadCounter++;",
            "      newThread.threadIndex = this._threadCounter;",
            "      this._threads.push(newThread);",
            "    }",
            "    ForkThread() {",
            "      let forkedThread = this.currentThread.Copy();",
            "      this._threadCounter++;",
            "      forkedThread.threadIndex = this._threadCounter;",
            "      return forkedThread;",
            "    }",
            "    PopThread() {",
            "      if (this.canPopThread) {",
            "        this._threads.splice(this._threads.indexOf(this.currentThread), 1); // should be equivalent to a pop()",
            "      } else {",
            "        throw new Error(\"Can't pop thread\");",
            "      }",
            "    }",
            "    get canPopThread() {",
            "      return this._threads.length > 1 && !this.elementIsEvaluateFromGame;",
            "    }",
            "    get elementIsEvaluateFromGame() {",
            "      return this.currentElement.type == PushPopType.FunctionEvaluationFromGame;",
            "    }",
            "    Push(type) {",
            "      let externalEvaluationStackHeight = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;",
            "      let outputStreamLengthWithPushed = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;",
            "      let element = new CallStack.Element(type, this.currentElement.currentPointer, false);",
            "      element.evaluationStackHeightWhenPushed = externalEvaluationStackHeight;",
            "      element.functionStartInOutputStream = outputStreamLengthWithPushed;",
            "      this.callStack.push(element);",
            "    }",
            "    CanPop() {",
            "      let type = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;",
            "      if (!this.canPop) return false;",
            "      if (type == null) return true;",
            "      return this.currentElement.type == type;",
            "    }",
            "    Pop() {",
            "      let type = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;",
            "      if (this.CanPop(type)) {",
            "        this.callStack.pop();",
            "        return;",
            "      } else {",
            "        throw new Error(\"Mismatched push/pop in Callstack\");",
            "      }",
            "    }",
            "    GetTemporaryVariableWithName(name) {",
            "      let contextIndex = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : -1;",
            "      if (contextIndex == -1) contextIndex = this.currentElementIndex + 1;",
            "      let contextElement = this.callStack[contextIndex - 1];",
            "      let varValue = tryGetValueFromMap(contextElement.temporaryVariables, name, null);",
            "      if (varValue.exists) {",
            "        return varValue.result;",
            "      } else {",
            "        return null;",
            "      }",
            "    }",
            "    SetTemporaryVariable(name, value, declareNew) {",
            "      let contextIndex = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : -1;",
            "      if (contextIndex == -1) contextIndex = this.currentElementIndex + 1;",
            "      let contextElement = this.callStack[contextIndex - 1];",
            "      if (!declareNew && !contextElement.temporaryVariables.get(name)) {",
            "        throw new Error(\"Could not find temporary variable to set: \" + name);",
            "      }",
            "      let oldValue = tryGetValueFromMap(contextElement.temporaryVariables, name, null);",
            "      if (oldValue.exists) ListValue.RetainListOriginsForAssignment(oldValue.result, value);",
            "      contextElement.temporaryVariables.set(name, value);",
            "    }",
            "    ContextForVariableNamed(name) {",
            "      if (this.currentElement.temporaryVariables.get(name)) {",
            "        return this.currentElementIndex + 1;",
            "      } else {",
            "        return 0;",
            "      }",
            "    }",
            "    ThreadWithIndex(index) {",
            "      let filtered = this._threads.filter(t => {",
            "        if (t.threadIndex == index) return t;",
            "      });",
            "      return filtered.length > 0 ? filtered[0] : null;",
            "    }",
            "    get callStack() {",
            "      return this.currentThread.callstack;",
            "    }",
            "    get callStackTrace() {",
            "      let sb = new StringBuilder();",
            "      for (let t = 0; t < this._threads.length; t++) {",
            "        let thread = this._threads[t];",
            "        let isCurrent = t == this._threads.length - 1;",
            "        sb.AppendFormat(\"=== THREAD {0}/{1} {2}===\\n\", t + 1, this._threads.length, isCurrent ? \"(current) \" : \"\");",
            "        for (let i = 0; i < thread.callstack.length; i++) {",
            "          if (thread.callstack[i].type == PushPopType.Function) sb.Append(\"  [FUNCTION] \");else sb.Append(\"  [TUNNEL] \");",
            "          let pointer = thread.callstack[i].currentPointer;",
            "          if (!pointer.isNull) {",
            "            sb.Append(\"<SOMEWHERE IN \");",
            "            if (pointer.container === null) {",
            "              return throwNullException(\"pointer.container\");",
            "            }",
            "            sb.Append(pointer.container.path.toString());",
            "            sb.AppendLine(\">\");",
            "          }",
            "        }",
            "      }",
            "      return sb.toString();",
            "    }",
            "  }",
            "  (function (CallStack) {",
            "    class Element {",
            "      constructor(type, pointer) {",
            "        let inExpressionEvaluation = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;",
            "        this.evaluationStackHeightWhenPushed = 0;",
            "        this.functionStartInOutputStream = 0;",
            "        this.currentPointer = pointer.copy();",
            "        this.inExpressionEvaluation = inExpressionEvaluation;",
            "        this.temporaryVariables = new Map();",
            "        this.type = type;",
            "      }",
            "      Copy() {",
            "        let copy = new Element(this.type, this.currentPointer, this.inExpressionEvaluation);",
            "        copy.temporaryVariables = new Map(this.temporaryVariables);",
            "        copy.evaluationStackHeightWhenPushed = this.evaluationStackHeightWhenPushed;",
            "        copy.functionStartInOutputStream = this.functionStartInOutputStream;",
            "        return copy;",
            "      }",
            "    }",
            "    CallStack.Element = Element;",
            "    class Thread {",
            "      constructor() {",
            "        this.threadIndex = 0;",
            "        this.previousPointer = Pointer.Null;",
            "        this.callstack = [];",
            "        if (arguments[0] && arguments[1]) {",
            "          let jThreadObj = arguments[0];",
            "          let storyContext = arguments[1];",
            "          // TODO: (int) jThreadObj['threadIndex'] can raise;",
            "          this.threadIndex = parseInt(jThreadObj[\"threadIndex\"]);",
            "          let jThreadCallstack = jThreadObj[\"callstack\"];",
            "          for (let jElTok of jThreadCallstack) {",
            "            let jElementObj = jElTok;",
            "            // TODO: (int) jElementObj['type'] can raise;",
            "            let pushPopType = parseInt(jElementObj[\"type\"]);",
            "            let pointer = Pointer.Null;",
            "            let currentContainerPathStr;",
            "            // TODO: jElementObj.TryGetValue (\"cPath\", out currentContainerPathStrToken);",
            "            let currentContainerPathStrToken = jElementObj[\"cPath\"];",
            "            if (typeof currentContainerPathStrToken !== \"undefined\") {",
            "              currentContainerPathStr = currentContainerPathStrToken.toString();",
            "              let threadPointerResult = storyContext.ContentAtPath(new Path$1(currentContainerPathStr));",
            "              pointer.container = threadPointerResult.container;",
            "              pointer.index = parseInt(jElementObj[\"idx\"]);",
            "              if (threadPointerResult.obj == null) throw new Error(\"When loading state, internal story location couldn't be found: \" + currentContainerPathStr + \". Has the story changed since this save data was created?\");else if (threadPointerResult.approximate) {",
            "                if (pointer.container === null) {",
            "                  return throwNullException(\"pointer.container\");",
            "                }",
            "                storyContext.Warning(\"When loading state, exact internal story location couldn't be found: '\" + currentContainerPathStr + \"', so it was approximated to '\" + pointer.container.path.toString() + \"' to recover. Has the story changed since this save data was created?\");",
            "              }",
            "            }",
            "            let inExpressionEvaluation = !!jElementObj[\"exp\"];",
            "            let el = new Element(pushPopType, pointer, inExpressionEvaluation);",
            "            let temps = jElementObj[\"temp\"];",
            "            if (typeof temps !== \"undefined\") {",
            "              el.temporaryVariables = JsonSerialisation.JObjectToDictionaryRuntimeObjs(temps);",
            "            } else {",
            "              el.temporaryVariables.clear();",
            "            }",
            "            this.callstack.push(el);",
            "          }",
            "          let prevContentObjPath = jThreadObj[\"previousContentObject\"];",
            "          if (typeof prevContentObjPath !== \"undefined\") {",
            "            let prevPath = new Path$1(prevContentObjPath.toString());",
            "            this.previousPointer = storyContext.PointerAtPath(prevPath);",
            "          }",
            "        }",
            "      }",
            "      Copy() {",
            "        let copy = new Thread();",
            "        copy.threadIndex = this.threadIndex;",
            "        for (let e of this.callstack) {",
            "          copy.callstack.push(e.Copy());",
            "        }",
            "        copy.previousPointer = this.previousPointer.copy();",
            "        return copy;",
            "      }",
            "      WriteJson(writer) {",
            "        writer.WriteObjectStart();",
            "        writer.WritePropertyStart(\"callstack\");",
            "        writer.WriteArrayStart();",
            "        for (let el of this.callstack) {",
            "          writer.WriteObjectStart();",
            "          if (!el.currentPointer.isNull) {",
            "            if (el.currentPointer.container === null) {",
            "              return throwNullException(\"el.currentPointer.container\");",
            "            }",
            "            writer.WriteProperty(\"cPath\", el.currentPointer.container.path.componentsString);",
            "            writer.WriteIntProperty(\"idx\", el.currentPointer.index);",
            "          }",
            "          writer.WriteProperty(\"exp\", el.inExpressionEvaluation);",
            "          writer.WriteIntProperty(\"type\", el.type);",
            "          if (el.temporaryVariables.size > 0) {",
            "            writer.WritePropertyStart(\"temp\");",
            "            JsonSerialisation.WriteDictionaryRuntimeObjs(writer, el.temporaryVariables);",
            "            writer.WritePropertyEnd();",
            "          }",
            "          writer.WriteObjectEnd();",
            "        }",
            "        writer.WriteArrayEnd();",
            "        writer.WritePropertyEnd();",
            "        writer.WriteIntProperty(\"threadIndex\", this.threadIndex);",
            "        if (!this.previousPointer.isNull) {",
            "          let resolvedPointer = this.previousPointer.Resolve();",
            "          if (resolvedPointer === null) {",
            "            return throwNullException(\"this.previousPointer.Resolve()\");",
            "          }",
            "          writer.WriteProperty(\"previousContentObject\", resolvedPointer.path.toString());",
            "        }",
            "        writer.WriteObjectEnd();",
            "      }",
            "    }",
            "    CallStack.Thread = Thread;",
            "  })(CallStack || (CallStack = {}));",
            "",
            "  // Fake class wrapper around VariableState to have correct typing",
            "  // when using the Proxy syntax in typescript",
            "  function VariablesStateAccessor() {",
            "    return class {};",
            "  }",
            "  class VariablesState extends VariablesStateAccessor() {",
            "    variableChangedEvent(variableName, newValue) {",
            "      for (let callback of this.variableChangedEventCallbacks) {",
            "        callback(variableName, newValue);",
            "      }",
            "    }",
            "    get batchObservingVariableChanges() {",
            "      return this._batchObservingVariableChanges;",
            "    }",
            "    set batchObservingVariableChanges(value) {",
            "      this._batchObservingVariableChanges = value;",
            "      if (value) {",
            "        this._changedVariablesForBatchObs = new Set();",
            "      } else {",
            "        if (this._changedVariablesForBatchObs != null) {",
            "          for (let variableName of this._changedVariablesForBatchObs) {",
            "            let currentValue = this._globalVariables.get(variableName);",
            "            if (!currentValue) {",
            "              throwNullException(\"currentValue\");",
            "            } else {",
            "              this.variableChangedEvent(variableName, currentValue);",
            "            }",
            "          }",
            "          this._changedVariablesForBatchObs = null;",
            "        }",
            "      }",
            "    }",
            "    get callStack() {",
            "      return this._callStack;",
            "    }",
            "    set callStack(callStack) {",
            "      this._callStack = callStack;",
            "    }",
            "    $(variableName, value) {",
            "      if (typeof value === \"undefined\") {",
            "        let varContents = null;",
            "        if (this.patch !== null) {",
            "          varContents = this.patch.TryGetGlobal(variableName, null);",
            "          if (varContents.exists) return varContents.result.valueObject;",
            "        }",
            "        varContents = this._globalVariables.get(variableName);",
            "        if (typeof varContents === \"undefined\") {",
            "          varContents = this._defaultGlobalVariables.get(variableName);",
            "        }",
            "        if (typeof varContents !== \"undefined\") return varContents.valueObject;else return null;",
            "      } else {",
            "        if (typeof this._defaultGlobalVariables.get(variableName) === \"undefined\") throw new StoryException(\"Cannot assign to a variable (\" + variableName + \") that hasn't been declared in the story\");",
            "        let val = Value.Create(value);",
            "        if (val == null) {",
            "          if (value == null) {",
            "            throw new Error(\"Cannot pass null to VariableState\");",
            "          } else {",
            "            throw new Error(\"Invalid value passed to VariableState: \" + value.toString());",
            "          }",
            "        }",
            "        this.SetGlobal(variableName, val);",
            "      }",
            "    }",
            "    constructor(callStack, listDefsOrigin) {",
            "      super();",
            "      // The way variableChangedEvent is a bit different than the reference implementation.",
            "      // Originally it uses the C# += operator to add delegates, but in js we need to maintain",
            "      // an actual collection of delegates (ie. callbacks) to register a new one, there is a",
            "      // special ObserveVariableChange method below.",
            "      this.variableChangedEventCallbacks = [];",
            "      this.patch = null;",
            "      this._batchObservingVariableChanges = false;",
            "      this._defaultGlobalVariables = new Map();",
            "      this._changedVariablesForBatchObs = new Set();",
            "      this._globalVariables = new Map();",
            "      this._callStack = callStack;",
            "      this._listDefsOrigin = listDefsOrigin;",
            "      // if es6 proxies are available, use them.",
            "      try {",
            "        // the proxy is used to allow direct manipulation of global variables.",
            "        // It first tries to access the objects own property, and if none is",
            "        // found it delegates the call to the $ method, defined below",
            "        let p = new Proxy(this, {",
            "          get(target, name) {",
            "            return name in target ? target[name] : target.$(name);",
            "          },",
            "          set(target, name, value) {",
            "            if (name in target) target[name] = value;else target.$(name, value);",
            "            return true; // returning a falsy value make the trap fail",
            "          }",
            "        });",
            "        return p;",
            "      } catch (e) {",
            "        // the proxy object is not available in this context. we should warn the",
            "        // dev but writing to the console feels a bit intrusive.",
            "        // console.log(\"ES6 Proxy not available - direct manipulation of global variables can't work, use $() instead.\");",
            "      }",
            "    }",
            "    ApplyPatch() {",
            "      if (this.patch === null) {",
            "        return throwNullException(\"this.patch\");",
            "      }",
            "      for (let [namedVarKey, namedVarValue] of this.patch.globals) {",
            "        this._globalVariables.set(namedVarKey, namedVarValue);",
            "      }",
            "      if (this._changedVariablesForBatchObs !== null) {",
            "        for (let name of this.patch.changedVariables) {",
            "          this._changedVariablesForBatchObs.add(name);",
            "        }",
            "      }",
            "      this.patch = null;",
            "    }",
            "    SetJsonToken(jToken) {",
            "      this._globalVariables.clear();",
            "      for (let [varValKey, varValValue] of this._defaultGlobalVariables) {",
            "        let loadedToken = jToken[varValKey];",
            "        if (typeof loadedToken !== \"undefined\") {",
            "          let tokenInkObject = JsonSerialisation.JTokenToRuntimeObject(loadedToken);",
            "          if (tokenInkObject === null) {",
            "            return throwNullException(\"tokenInkObject\");",
            "          }",
            "          this._globalVariables.set(varValKey, tokenInkObject);",
            "        } else {",
            "          this._globalVariables.set(varValKey, varValValue);",
            "        }",
            "      }",
            "    }",
            "    WriteJson(writer) {",
            "      writer.WriteObjectStart();",
            "      for (let [keyValKey, keyValValue] of this._globalVariables) {",
            "        let name = keyValKey;",
            "        let val = keyValValue;",
            "        if (VariablesState.dontSaveDefaultValues) {",
            "          if (this._defaultGlobalVariables.has(name)) {",
            "            let defaultVal = this._defaultGlobalVariables.get(name);",
            "            if (this.RuntimeObjectsEqual(val, defaultVal)) continue;",
            "          }",
            "        }",
            "        writer.WritePropertyStart(name);",
            "        JsonSerialisation.WriteRuntimeObject(writer, val);",
            "        writer.WritePropertyEnd();",
            "      }",
            "      writer.WriteObjectEnd();",
            "    }",
            "    RuntimeObjectsEqual(obj1, obj2) {",
            "      if (obj1 === null) {",
            "        return throwNullException(\"obj1\");",
            "      }",
            "      if (obj2 === null) {",
            "        return throwNullException(\"obj2\");",
            "      }",
            "      if (obj1.constructor !== obj2.constructor) return false;",
            "      let boolVal = asOrNull(obj1, BoolValue);",
            "      if (boolVal !== null) {",
            "        return boolVal.value === asOrThrows(obj2, BoolValue).value;",
            "      }",
            "      let intVal = asOrNull(obj1, IntValue);",
            "      if (intVal !== null) {",
            "        return intVal.value === asOrThrows(obj2, IntValue).value;",
            "      }",
            "      let floatVal = asOrNull(obj1, FloatValue);",
            "      if (floatVal !== null) {",
            "        return floatVal.value === asOrThrows(obj2, FloatValue).value;",
            "      }",
            "      let val1 = asOrNull(obj1, Value);",
            "      let val2 = asOrNull(obj2, Value);",
            "      if (val1 !== null && val2 !== null) {",
            "        if (isEquatable(val1.valueObject) && isEquatable(val2.valueObject)) {",
            "          return val1.valueObject.Equals(val2.valueObject);",
            "        } else {",
            "          return val1.valueObject === val2.valueObject;",
            "        }",
            "      }",
            "      throw new Error(\"FastRoughDefinitelyEquals: Unsupported runtime object type: \" + obj1.constructor.name);",
            "    }",
            "    GetVariableWithName(name) {",
            "      let contextIndex = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : -1;",
            "      let varValue = this.GetRawVariableWithName(name, contextIndex);",
            "      // var varPointer = varValue as VariablePointerValue;",
            "      let varPointer = asOrNull(varValue, VariablePointerValue);",
            "      if (varPointer !== null) {",
            "        varValue = this.ValueAtVariablePointer(varPointer);",
            "      }",
            "      return varValue;",
            "    }",
            "    TryGetDefaultVariableValue(name) {",
            "      let val = tryGetValueFromMap(this._defaultGlobalVariables, name, null);",
            "      return val.exists ? val.result : null;",
            "    }",
            "    GlobalVariableExistsWithName(name) {",
            "      return this._globalVariables.has(name) || this._defaultGlobalVariables !== null && this._defaultGlobalVariables.has(name);",
            "    }",
            "    GetRawVariableWithName(name, contextIndex) {",
            "      let varValue = null;",
            "      if (contextIndex == 0 || contextIndex == -1) {",
            "        let variableValue = null;",
            "        if (this.patch !== null) {",
            "          variableValue = this.patch.TryGetGlobal(name, null);",
            "          if (variableValue.exists) return variableValue.result;",
            "        }",
            "        // this is a conditional assignment",
            "        variableValue = tryGetValueFromMap(this._globalVariables, name, null);",
            "        if (variableValue.exists) return variableValue.result;",
            "        if (this._defaultGlobalVariables !== null) {",
            "          variableValue = tryGetValueFromMap(this._defaultGlobalVariables, name, null);",
            "          if (variableValue.exists) return variableValue.result;",
            "        }",
            "        if (this._listDefsOrigin === null) return throwNullException(\"VariablesState._listDefsOrigin\");",
            "        let listItemValue = this._listDefsOrigin.FindSingleItemListWithName(name);",
            "        if (listItemValue) return listItemValue;",
            "      }",
            "      varValue = this._callStack.GetTemporaryVariableWithName(name, contextIndex);",
            "      return varValue;",
            "    }",
            "    ValueAtVariablePointer(pointer) {",
            "      return this.GetVariableWithName(pointer.variableName, pointer.contextIndex);",
            "    }",
            "    Assign(varAss, value) {",
            "      let name = varAss.variableName;",
            "      if (name === null) {",
            "        return throwNullException(\"name\");",
            "      }",
            "      let contextIndex = -1;",
            "      let setGlobal = false;",
            "      if (varAss.isNewDeclaration) {",
            "        setGlobal = varAss.isGlobal;",
            "      } else {",
            "        setGlobal = this.GlobalVariableExistsWithName(name);",
            "      }",
            "      if (varAss.isNewDeclaration) {",
            "        // var varPointer = value as VariablePointerValue;",
            "        let varPointer = asOrNull(value, VariablePointerValue);",
            "        if (varPointer !== null) {",
            "          let fullyResolvedVariablePointer = this.ResolveVariablePointer(varPointer);",
            "          value = fullyResolvedVariablePointer;",
            "        }",
            "      } else {",
            "        let existingPointer = null;",
            "        do {",
            "          // existingPointer = GetRawVariableWithName (name, contextIndex) as VariablePointerValue;",
            "          existingPointer = asOrNull(this.GetRawVariableWithName(name, contextIndex), VariablePointerValue);",
            "          if (existingPointer != null) {",
            "            name = existingPointer.variableName;",
            "            contextIndex = existingPointer.contextIndex;",
            "            setGlobal = contextIndex == 0;",
            "          }",
            "        } while (existingPointer != null);",
            "      }",
            "      if (setGlobal) {",
            "        this.SetGlobal(name, value);",
            "      } else {",
            "        this._callStack.SetTemporaryVariable(name, value, varAss.isNewDeclaration, contextIndex);",
            "      }",
            "    }",
            "    SnapshotDefaultGlobals() {",
            "      this._defaultGlobalVariables = new Map(this._globalVariables);",
            "    }",
            "    RetainListOriginsForAssignment(oldValue, newValue) {",
            "      let oldList = asOrThrows(oldValue, ListValue);",
            "      let newList = asOrThrows(newValue, ListValue);",
            "      if (oldList.value && newList.value && newList.value.Count == 0) {",
            "        newList.value.SetInitialOriginNames(oldList.value.originNames);",
            "      }",
            "    }",
            "    SetGlobal(variableName, value) {",
            "      let oldValue = null;",
            "      if (this.patch === null) {",
            "        oldValue = tryGetValueFromMap(this._globalVariables, variableName, null);",
            "      }",
            "      if (this.patch !== null) {",
            "        oldValue = this.patch.TryGetGlobal(variableName, null);",
            "        if (!oldValue.exists) {",
            "          oldValue = tryGetValueFromMap(this._globalVariables, variableName, null);",
            "        }",
            "      }",
            "      ListValue.RetainListOriginsForAssignment(oldValue.result, value);",
            "      if (variableName === null) {",
            "        return throwNullException(\"variableName\");",
            "      }",
            "      if (this.patch !== null) {",
            "        this.patch.SetGlobal(variableName, value);",
            "      } else {",
            "        this._globalVariables.set(variableName, value);",
            "      }",
            "      // TODO: Not sure !== is equivalent to !value.Equals(oldValue)",
            "      if (this.variableChangedEvent !== null && oldValue !== null && value !== oldValue.result) {",
            "        if (this.batchObservingVariableChanges) {",
            "          if (this._changedVariablesForBatchObs === null) {",
            "            return throwNullException(\"this._changedVariablesForBatchObs\");",
            "          }",
            "          if (this.patch !== null) {",
            "            this.patch.AddChangedVariable(variableName);",
            "          } else if (this._changedVariablesForBatchObs !== null) {",
            "            this._changedVariablesForBatchObs.add(variableName);",
            "          }",
            "        } else {",
            "          this.variableChangedEvent(variableName, value);",
            "        }",
            "      }",
            "    }",
            "    ResolveVariablePointer(varPointer) {",
            "      let contextIndex = varPointer.contextIndex;",
            "      if (contextIndex == -1) contextIndex = this.GetContextIndexOfVariableNamed(varPointer.variableName);",
            "      let valueOfVariablePointedTo = this.GetRawVariableWithName(varPointer.variableName, contextIndex);",
            "      // var doubleRedirectionPointer = valueOfVariablePointedTo as VariablePointerValue;",
            "      let doubleRedirectionPointer = asOrNull(valueOfVariablePointedTo, VariablePointerValue);",
            "      if (doubleRedirectionPointer != null) {",
            "        return doubleRedirectionPointer;",
            "      } else {",
            "        return new VariablePointerValue(varPointer.variableName, contextIndex);",
            "      }",
            "    }",
            "    GetContextIndexOfVariableNamed(varName) {",
            "      if (this.GlobalVariableExistsWithName(varName)) return 0;",
            "      return this._callStack.currentElementIndex;",
            "    }",
            "    /**",
            "     * This function is specific to the js version of ink. It allows to register a",
            "     * callback that will be called when a variable changes. The original code uses",
            "     * `state.variableChangedEvent += callback` instead.",
            "     *",
            "     * @param {function} callback",
            "     */",
            "    ObserveVariableChange(callback) {",
            "      this.variableChangedEventCallbacks.push(callback);",
            "    }",
            "  }",
            "  VariablesState.dontSaveDefaultValues = true;",
            "",
            "  // Taken from https://gist.github.com/blixt/f17b47c62508be59987b",
            "  // Ink uses a seedable PRNG of which there is none in native javascript.",
            "  class PRNG {",
            "    constructor(seed) {",
            "      this.seed = seed % 2147483647;",
            "      if (this.seed <= 0) this.seed += 2147483646;",
            "    }",
            "    next() {",
            "      return this.seed = this.seed * 48271 % 2147483647;",
            "    }",
            "    nextFloat() {",
            "      return (this.next() - 1) / 2147483646;",
            "    }",
            "  }",
            "",
            "  class StatePatch {",
            "    get globals() {",
            "      return this._globals;",
            "    }",
            "    get changedVariables() {",
            "      return this._changedVariables;",
            "    }",
            "    get visitCounts() {",
            "      return this._visitCounts;",
            "    }",
            "    get turnIndices() {",
            "      return this._turnIndices;",
            "    }",
            "    constructor() {",
            "      this._changedVariables = new Set();",
            "      this._visitCounts = new Map();",
            "      this._turnIndices = new Map();",
            "      if (arguments.length === 1 && arguments[0] !== null) {",
            "        let toCopy = arguments[0];",
            "        this._globals = new Map(toCopy._globals);",
            "        this._changedVariables = new Set(toCopy._changedVariables);",
            "        this._visitCounts = new Map(toCopy._visitCounts);",
            "        this._turnIndices = new Map(toCopy._turnIndices);",
            "      } else {",
            "        this._globals = new Map();",
            "        this._changedVariables = new Set();",
            "        this._visitCounts = new Map();",
            "        this._turnIndices = new Map();",
            "      }",
            "    }",
            "    TryGetGlobal(name, /* out */value) {",
            "      if (name !== null && this._globals.has(name)) {",
            "        return {",
            "          result: this._globals.get(name),",
            "          exists: true",
            "        };",
            "      }",
            "      return {",
            "        result: value,",
            "        exists: false",
            "      };",
            "    }",
            "    SetGlobal(name, value) {",
            "      this._globals.set(name, value);",
            "    }",
            "    AddChangedVariable(name) {",
            "      return this._changedVariables.add(name);",
            "    }",
            "    TryGetVisitCount(container, /* out */count) {",
            "      if (this._visitCounts.has(container)) {",
            "        return {",
            "          result: this._visitCounts.get(container),",
            "          exists: true",
            "        };",
            "      }",
            "      return {",
            "        result: count,",
            "        exists: false",
            "      };",
            "    }",
            "    SetVisitCount(container, count) {",
            "      this._visitCounts.set(container, count);",
            "    }",
            "    SetTurnIndex(container, index) {",
            "      this._turnIndices.set(container, index);",
            "    }",
            "    TryGetTurnIndex(container, /* out */index) {",
            "      if (this._turnIndices.has(container)) {",
            "        return {",
            "          result: this._turnIndices.get(container),",
            "          exists: true",
            "        };",
            "      }",
            "      return {",
            "        result: index,",
            "        exists: false",
            "      };",
            "    }",
            "  }",
            "",
            "  class SimpleJson {",
            "    static TextToDictionary(text) {",
            "      return new SimpleJson.Reader(text).ToDictionary();",
            "    }",
            "    static TextToArray(text) {",
            "      return new SimpleJson.Reader(text).ToArray();",
            "    }",
            "  }",
            "  (function (SimpleJson) {",
            "    class Reader {",
            "      constructor(text) {",
            "        this._rootObject = JSON.parse(text);",
            "      }",
            "      ToDictionary() {",
            "        return this._rootObject;",
            "      }",
            "      ToArray() {",
            "        return this._rootObject;",
            "      }",
            "    }",
            "    SimpleJson.Reader = Reader;",
            "    // In C#, this class writes json tokens directly to a StringWriter or",
            "    // another stream. Here, a temporary hierarchy is created in the form",
            "    // of a javascript object, which is serialised in the `toString` method.",
            "    // See individual methods and properties for more information.",
            "    class Writer {",
            "      constructor() {",
            "        // In addition to `_stateStack` present in the original code,",
            "        // this implementation of SimpleJson use two other stacks and two",
            "        // temporary variables holding the current context.",
            "        // Used to keep track of the current property name being built",
            "        // with `WritePropertyNameStart`, `WritePropertyNameInner` and",
            "        // `WritePropertyNameEnd`.",
            "        this._currentPropertyName = null;",
            "        // Used to keep track of the current string value being built",
            "        // with `WriteStringStart`, `WriteStringInner` and",
            "        // `WriteStringEnd`.",
            "        this._currentString = null;",
            "        this._stateStack = [];",
            "        // Keep track of the current collection being built (either an array",
            "        // or an object). For instance, at the '?' step during the hiarchy",
            "        // creation, this hierarchy:",
            "        // [3, {a: [b, ?]}] will have this corresponding stack:",
            "        // (bottom) [Array, Object, Array] (top)",
            "        this._collectionStack = [];",
            "        // Keep track of the current property being assigned. For instance, at",
            "        // the '?' step during the hiarchy creation, this hierarchy:",
            "        // [3, {a: [b, {c: ?}]}] will have this corresponding stack:",
            "        // (bottom) [a, c] (top)",
            "        this._propertyNameStack = [];",
            "        // Object containing the entire hiearchy.",
            "        this._jsonObject = null;",
            "      }",
            "      WriteObject(inner) {",
            "        this.WriteObjectStart();",
            "        inner(this);",
            "        this.WriteObjectEnd();",
            "      }",
            "      // Add a new object.",
            "      WriteObjectStart() {",
            "        this.StartNewObject(true);",
            "        let newObject = {};",
            "        if (this.state === SimpleJson.Writer.State.Property) {",
            "          // This object is created as the value of a property,",
            "          // inside an other object.",
            "          this.Assert(this.currentCollection !== null);",
            "          this.Assert(this.currentPropertyName !== null);",
            "          let propertyName = this._propertyNameStack.pop();",
            "          this.currentCollection[propertyName] = newObject;",
            "          this._collectionStack.push(newObject);",
            "        } else if (this.state === SimpleJson.Writer.State.Array) {",
            "          // This object is created as the child of an array.",
            "          this.Assert(this.currentCollection !== null);",
            "          this.currentCollection.push(newObject);",
            "          this._collectionStack.push(newObject);",
            "        } else {",
            "          // This object is the root object.",
            "          this.Assert(this.state === SimpleJson.Writer.State.None);",
            "          this._jsonObject = newObject;",
            "          this._collectionStack.push(newObject);",
            "        }",
            "        this._stateStack.push(new SimpleJson.Writer.StateElement(SimpleJson.Writer.State.Object));",
            "      }",
            "      WriteObjectEnd() {",
            "        this.Assert(this.state === SimpleJson.Writer.State.Object);",
            "        this._collectionStack.pop();",
            "        this._stateStack.pop();",
            "      }",
            "      // Write a property name / value pair to the current object.",
            "      WriteProperty(name,",
            "      // eslint-disable-next-line @typescript-eslint/no-unused-vars",
            "      innerOrContent) {",
            "        this.WritePropertyStart(name);",
            "        if (arguments[1] instanceof Function) {",
            "          let inner = arguments[1];",
            "          inner(this);",
            "        } else {",
            "          let content = arguments[1];",
            "          this.Write(content);",
            "        }",
            "        this.WritePropertyEnd();",
            "      }",
            "      // Int and Float are separate calls, since there both are",
            "      // numbers in JavaScript, but need to be handled differently.",
            "      WriteIntProperty(name, content) {",
            "        this.WritePropertyStart(name);",
            "        this.WriteInt(content);",
            "        this.WritePropertyEnd();",
            "      }",
            "      WriteFloatProperty(name, content) {",
            "        this.WritePropertyStart(name);",
            "        this.WriteFloat(content);",
            "        this.WritePropertyEnd();",
            "      }",
            "      // Prepare a new property name, which will be use to add the",
            "      // new object when calling _addToCurrentObject() from a Write",
            "      // method.",
            "      WritePropertyStart(name) {",
            "        this.Assert(this.state === SimpleJson.Writer.State.Object);",
            "        this._propertyNameStack.push(name);",
            "        this.IncrementChildCount();",
            "        this._stateStack.push(new SimpleJson.Writer.StateElement(SimpleJson.Writer.State.Property));",
            "      }",
            "      WritePropertyEnd() {",
            "        this.Assert(this.state === SimpleJson.Writer.State.Property);",
            "        this.Assert(this.childCount === 1);",
            "        this._stateStack.pop();",
            "      }",
            "      // Prepare a new property name, except this time, the property name",
            "      // will be created by concatenating all the strings passed to",
            "      // WritePropertyNameInner.",
            "      WritePropertyNameStart() {",
            "        this.Assert(this.state === SimpleJson.Writer.State.Object);",
            "        this.IncrementChildCount();",
            "        this._currentPropertyName = \"\";",
            "        this._stateStack.push(new SimpleJson.Writer.StateElement(SimpleJson.Writer.State.Property));",
            "        this._stateStack.push(new SimpleJson.Writer.StateElement(SimpleJson.Writer.State.PropertyName));",
            "      }",
            "      WritePropertyNameEnd() {",
            "        this.Assert(this.state === SimpleJson.Writer.State.PropertyName);",
            "        this.Assert(this._currentPropertyName !== null);",
            "        this._propertyNameStack.push(this._currentPropertyName);",
            "        this._currentPropertyName = null;",
            "        this._stateStack.pop();",
            "      }",
            "      WritePropertyNameInner(str) {",
            "        this.Assert(this.state === SimpleJson.Writer.State.PropertyName);",
            "        this.Assert(this._currentPropertyName !== null);",
            "        this._currentPropertyName += str;",
            "      }",
            "      // Add a new array.",
            "      WriteArrayStart() {",
            "        this.StartNewObject(true);",
            "        let newObject = [];",
            "        if (this.state === SimpleJson.Writer.State.Property) {",
            "          // This array is created as the value of a property,",
            "          // inside an object.",
            "          this.Assert(this.currentCollection !== null);",
            "          this.Assert(this.currentPropertyName !== null);",
            "          let propertyName = this._propertyNameStack.pop();",
            "          this.currentCollection[propertyName] = newObject;",
            "          this._collectionStack.push(newObject);",
            "        } else if (this.state === SimpleJson.Writer.State.Array) {",
            "          // This array is created as the child of another array.",
            "          this.Assert(this.currentCollection !== null);",
            "          this.currentCollection.push(newObject);",
            "          this._collectionStack.push(newObject);",
            "        } else {",
            "          // This array is the root object.",
            "          this.Assert(this.state === SimpleJson.Writer.State.None);",
            "          this._jsonObject = newObject;",
            "          this._collectionStack.push(newObject);",
            "        }",
            "        this._stateStack.push(new SimpleJson.Writer.StateElement(SimpleJson.Writer.State.Array));",
            "      }",
            "      WriteArrayEnd() {",
            "        this.Assert(this.state === SimpleJson.Writer.State.Array);",
            "        this._collectionStack.pop();",
            "        this._stateStack.pop();",
            "      }",
            "      // Add the value to the appropriate collection (array / object), given the current",
            "      // context.",
            "      Write(value) {",
            "        if (value === null) {",
            "          console.error(\"Warning: trying to write a null value\");",
            "          return;",
            "        }",
            "        this.StartNewObject(false);",
            "        this._addToCurrentObject(value);",
            "      }",
            "      WriteBool(value) {",
            "        if (value === null) {",
            "          return;",
            "        }",
            "        this.StartNewObject(false);",
            "        this._addToCurrentObject(value);",
            "      }",
            "      WriteInt(value) {",
            "        if (value === null) {",
            "          return;",
            "        }",
            "        this.StartNewObject(false);",
            "        // Math.floor is used as a precaution:",
            "        //     1. to ensure that the value is written as an integer",
            "        //        (without a fractional part -> 1 instead of 1.0), even",
            "        //        though it should be the default behaviour of",
            "        //        JSON.serialize;",
            "        //     2. to ensure that if a floating number is passed",
            "        //        accidentally, it's converted to an integer.",
            "        //",
            "        // This guarantees savegame compatibility with the reference",
            "        // implementation.",
            "        this._addToCurrentObject(Math.floor(value));",
            "      }",
            "      // Since JSON doesn't support NaN and Infinity, these values",
            "      // are converted here.",
            "      WriteFloat(value) {",
            "        if (value === null) {",
            "          return;",
            "        }",
            "        this.StartNewObject(false);",
            "        if (value == Number.POSITIVE_INFINITY) {",
            "          this._addToCurrentObject(3.4e38);",
            "        } else if (value == Number.NEGATIVE_INFINITY) {",
            "          this._addToCurrentObject(-3.4e38);",
            "        } else if (isNaN(value)) {",
            "          this._addToCurrentObject(0.0);",
            "        } else {",
            "          this._addToCurrentObject(value);",
            "        }",
            "      }",
            "      WriteNull() {",
            "        this.StartNewObject(false);",
            "        this._addToCurrentObject(null);",
            "      }",
            "      // Prepare a string before adding it to the current collection in",
            "      // WriteStringEnd(). The string will be a concatenation of all the",
            "      // strings passed to WriteStringInner.",
            "      WriteStringStart() {",
            "        this.StartNewObject(false);",
            "        this._currentString = \"\";",
            "        this._stateStack.push(new SimpleJson.Writer.StateElement(SimpleJson.Writer.State.String));",
            "      }",
            "      WriteStringEnd() {",
            "        this.Assert(this.state == SimpleJson.Writer.State.String);",
            "        this._stateStack.pop();",
            "        this._addToCurrentObject(this._currentString);",
            "        this._currentString = null;",
            "      }",
            "      // eslint-disable-next-line @typescript-eslint/no-unused-vars",
            "      WriteStringInner(str) {",
            "        this.Assert(this.state === SimpleJson.Writer.State.String);",
            "        if (str === null) {",
            "          console.error(\"Warning: trying to write a null string\");",
            "          return;",
            "        }",
            "        this._currentString += str;",
            "      }",
            "      // Serialise the root object into a JSON string.",
            "      toString() {",
            "        if (this._jsonObject === null) {",
            "          return \"\";",
            "        }",
            "        return JSON.stringify(this._jsonObject);",
            "      }",
            "      // Prepare the state stack when adding new objects / values.",
            "      StartNewObject(container) {",
            "        if (container) {",
            "          this.Assert(this.state === SimpleJson.Writer.State.None || this.state === SimpleJson.Writer.State.Property || this.state === SimpleJson.Writer.State.Array);",
            "        } else {",
            "          this.Assert(this.state === SimpleJson.Writer.State.Property || this.state === SimpleJson.Writer.State.Array);",
            "        }",
            "        if (this.state === SimpleJson.Writer.State.Property) {",
            "          this.Assert(this.childCount === 0);",
            "        }",
            "        if (this.state === SimpleJson.Writer.State.Array || this.state === SimpleJson.Writer.State.Property) {",
            "          this.IncrementChildCount();",
            "        }",
            "      }",
            "      // These getters peek all the different stacks.",
            "      get state() {",
            "        if (this._stateStack.length > 0) {",
            "          return this._stateStack[this._stateStack.length - 1].type;",
            "        } else {",
            "          return SimpleJson.Writer.State.None;",
            "        }",
            "      }",
            "      get childCount() {",
            "        if (this._stateStack.length > 0) {",
            "          return this._stateStack[this._stateStack.length - 1].childCount;",
            "        } else {",
            "          return 0;",
            "        }",
            "      }",
            "      get currentCollection() {",
            "        if (this._collectionStack.length > 0) {",
            "          return this._collectionStack[this._collectionStack.length - 1];",
            "        } else {",
            "          return null;",
            "        }",
            "      }",
            "      get currentPropertyName() {",
            "        if (this._propertyNameStack.length > 0) {",
            "          return this._propertyNameStack[this._propertyNameStack.length - 1];",
            "        } else {",
            "          return null;",
            "        }",
            "      }",
            "      IncrementChildCount() {",
            "        this.Assert(this._stateStack.length > 0);",
            "        let currEl = this._stateStack.pop();",
            "        currEl.childCount++;",
            "        this._stateStack.push(currEl);",
            "      }",
            "      Assert(condition) {",
            "        if (!condition) throw Error(\"Assert failed while writing JSON\");",
            "      }",
            "      // This method did not exist in the original C# code. It adds",
            "      // the given value to the current collection (used by Write methods).",
            "      _addToCurrentObject(value) {",
            "        this.Assert(this.currentCollection !== null);",
            "        if (this.state === SimpleJson.Writer.State.Array) {",
            "          this.Assert(Array.isArray(this.currentCollection));",
            "          this.currentCollection.push(value);",
            "        } else if (this.state === SimpleJson.Writer.State.Property) {",
            "          this.Assert(!Array.isArray(this.currentCollection));",
            "          this.Assert(this.currentPropertyName !== null);",
            "          this.currentCollection[this.currentPropertyName] = value;",
            "          this._propertyNameStack.pop();",
            "        }",
            "      }",
            "    }",
            "    SimpleJson.Writer = Writer;",
            "    (function (Writer) {",
            "      (function (State) {",
            "        State[State[\"None\"] = 0] = \"None\";",
            "        State[State[\"Object\"] = 1] = \"Object\";",
            "        State[State[\"Array\"] = 2] = \"Array\";",
            "        State[State[\"Property\"] = 3] = \"Property\";",
            "        State[State[\"PropertyName\"] = 4] = \"PropertyName\";",
            "        State[State[\"String\"] = 5] = \"String\";",
            "      })(Writer.State || (Writer.State = {}));",
            "      class StateElement {",
            "        constructor(type) {",
            "          this.type = SimpleJson.Writer.State.None;",
            "          this.childCount = 0;",
            "          this.type = type;",
            "        }",
            "      }",
            "      Writer.StateElement = StateElement;",
            "    })(Writer = SimpleJson.Writer || (SimpleJson.Writer = {}));",
            "  })(SimpleJson || (SimpleJson = {}));",
            "",
            "  class Flow {",
            "    constructor() {",
            "      let name = arguments[0];",
            "      let story = arguments[1];",
            "      this.name = name;",
            "      this.callStack = new CallStack(story);",
            "      if (arguments[2]) {",
            "        let jObject = arguments[2];",
            "        this.callStack.SetJsonToken(jObject[\"callstack\"], story);",
            "        this.outputStream = JsonSerialisation.JArrayToRuntimeObjList(jObject[\"outputStream\"]);",
            "        this.currentChoices = JsonSerialisation.JArrayToRuntimeObjList(jObject[\"currentChoices\"]);",
            "        let jChoiceThreadsObj = jObject[\"choiceThreads\"];",
            "        if (typeof jChoiceThreadsObj !== \"undefined\") {",
            "          this.LoadFlowChoiceThreads(jChoiceThreadsObj, story);",
            "        }",
            "      } else {",
            "        this.outputStream = [];",
            "        this.currentChoices = [];",
            "      }",
            "    }",
            "    WriteJson(writer) {",
            "      writer.WriteObjectStart();",
            "      writer.WriteProperty(\"callstack\", w => this.callStack.WriteJson(w));",
            "      writer.WriteProperty(\"outputStream\", w => JsonSerialisation.WriteListRuntimeObjs(w, this.outputStream));",
            "      let hasChoiceThreads = false;",
            "      for (let c of this.currentChoices) {",
            "        if (c.threadAtGeneration === null) return throwNullException(\"c.threadAtGeneration\");",
            "        c.originalThreadIndex = c.threadAtGeneration.threadIndex;",
            "        if (this.callStack.ThreadWithIndex(c.originalThreadIndex) === null) {",
            "          if (!hasChoiceThreads) {",
            "            hasChoiceThreads = true;",
            "            writer.WritePropertyStart(\"choiceThreads\");",
            "            writer.WriteObjectStart();",
            "          }",
            "          writer.WritePropertyStart(c.originalThreadIndex);",
            "          c.threadAtGeneration.WriteJson(writer);",
            "          writer.WritePropertyEnd();",
            "        }",
            "      }",
            "      if (hasChoiceThreads) {",
            "        writer.WriteObjectEnd();",
            "        writer.WritePropertyEnd();",
            "      }",
            "      writer.WriteProperty(\"currentChoices\", w => {",
            "        w.WriteArrayStart();",
            "        for (let c of this.currentChoices) {",
            "          JsonSerialisation.WriteChoice(w, c);",
            "        }",
            "        w.WriteArrayEnd();",
            "      });",
            "      writer.WriteObjectEnd();",
            "    }",
            "    LoadFlowChoiceThreads(jChoiceThreads, story) {",
            "      for (let choice of this.currentChoices) {",
            "        let foundActiveThread = this.callStack.ThreadWithIndex(choice.originalThreadIndex);",
            "        if (foundActiveThread !== null) {",
            "          choice.threadAtGeneration = foundActiveThread.Copy();",
            "        } else {",
            "          let jSavedChoiceThread = jChoiceThreads[`${choice.originalThreadIndex}`];",
            "          choice.threadAtGeneration = new CallStack.Thread(jSavedChoiceThread, story);",
            "        }",
            "      }",
            "    }",
            "  }",
            "",
            "  class StoryState {",
            "    // eslint-disable-next-line @typescript-eslint/no-unused-vars",
            "    ToJson() {",
            "      let writer = new SimpleJson.Writer();",
            "      this.WriteJson(writer);",
            "      return writer.toString();",
            "    }",
            "    toJson() {",
            "      let indented = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;",
            "      return this.ToJson(indented);",
            "    }",
            "    LoadJson(json) {",
            "      let jObject = SimpleJson.TextToDictionary(json);",
            "      this.LoadJsonObj(jObject);",
            "      if (this.onDidLoadState !== null) this.onDidLoadState();",
            "    }",
            "    VisitCountAtPathString(pathString) {",
            "      let visitCountOut;",
            "      if (this._patch !== null) {",
            "        let container = this.story.ContentAtPath(new Path$1(pathString)).container;",
            "        if (container === null) throw new Error(\"Content at path not found: \" + pathString);",
            "        visitCountOut = this._patch.TryGetVisitCount(container, 0);",
            "        if (visitCountOut.exists) return visitCountOut.result;",
            "      }",
            "      visitCountOut = tryGetValueFromMap(this._visitCounts, pathString, null);",
            "      if (visitCountOut.exists) return visitCountOut.result;",
            "      return 0;",
            "    }",
            "    VisitCountForContainer(container) {",
            "      if (container === null) {",
            "        return throwNullException(\"container\");",
            "      }",
            "      if (!container.visitsShouldBeCounted) {",
            "        this.story.Error(\"Read count for target (\" + container.name + \" - on \" + container.debugMetadata + \") unknown. The story may need to be compiled with countAllVisits flag (-c).\");",
            "        return 0;",
            "      }",
            "      if (this._patch !== null) {",
            "        let count = this._patch.TryGetVisitCount(container, 0);",
            "        if (count.exists) {",
            "          return count.result;",
            "        }",
            "      }",
            "      let containerPathStr = container.path.toString();",
            "      let count2 = tryGetValueFromMap(this._visitCounts, containerPathStr, null);",
            "      if (count2.exists) {",
            "        return count2.result;",
            "      }",
            "      return 0;",
            "    }",
            "    IncrementVisitCountForContainer(container) {",
            "      if (this._patch !== null) {",
            "        let currCount = this.VisitCountForContainer(container);",
            "        currCount++;",
            "        this._patch.SetVisitCount(container, currCount);",
            "        return;",
            "      }",
            "      let containerPathStr = container.path.toString();",
            "      let count = tryGetValueFromMap(this._visitCounts, containerPathStr, null);",
            "      if (count.exists) {",
            "        this._visitCounts.set(containerPathStr, count.result + 1);",
            "      } else {",
            "        this._visitCounts.set(containerPathStr, 1);",
            "      }",
            "    }",
            "    RecordTurnIndexVisitToContainer(container) {",
            "      if (this._patch !== null) {",
            "        this._patch.SetTurnIndex(container, this.currentTurnIndex);",
            "        return;",
            "      }",
            "      let containerPathStr = container.path.toString();",
            "      this._turnIndices.set(containerPathStr, this.currentTurnIndex);",
            "    }",
            "    TurnsSinceForContainer(container) {",
            "      if (!container.turnIndexShouldBeCounted) {",
            "        this.story.Error(\"TURNS_SINCE() for target (\" + container.name + \" - on \" + container.debugMetadata + \") unknown. The story may need to be compiled with countAllVisits flag (-c).\");",
            "      }",
            "      if (this._patch !== null) {",
            "        let index = this._patch.TryGetTurnIndex(container, 0);",
            "        if (index.exists) {",
            "          return this.currentTurnIndex - index.result;",
            "        }",
            "      }",
            "      let containerPathStr = container.path.toString();",
            "      let index2 = tryGetValueFromMap(this._turnIndices, containerPathStr, 0);",
            "      if (index2.exists) {",
            "        return this.currentTurnIndex - index2.result;",
            "      } else {",
            "        return -1;",
            "      }",
            "    }",
            "    get callstackDepth() {",
            "      return this.callStack.depth;",
            "    }",
            "    get outputStream() {",
            "      return this._currentFlow.outputStream;",
            "    }",
            "    get currentChoices() {",
            "      // If we can continue generating text content rather than choices,",
            "      // then we reflect the choice list as being empty, since choices",
            "      // should always come at the end.",
            "      if (this.canContinue) return [];",
            "      return this._currentFlow.currentChoices;",
            "    }",
            "    get generatedChoices() {",
            "      return this._currentFlow.currentChoices;",
            "    }",
            "    get currentErrors() {",
            "      return this._currentErrors;",
            "    }",
            "    get currentWarnings() {",
            "      return this._currentWarnings;",
            "    }",
            "    get variablesState() {",
            "      return this._variablesState;",
            "    }",
            "    set variablesState(value) {",
            "      this._variablesState = value;",
            "    }",
            "    get callStack() {",
            "      return this._currentFlow.callStack;",
            "    }",
            "    get evaluationStack() {",
            "      return this._evaluationStack;",
            "    }",
            "    get currentTurnIndex() {",
            "      return this._currentTurnIndex;",
            "    }",
            "    set currentTurnIndex(value) {",
            "      this._currentTurnIndex = value;",
            "    }",
            "    get currentPathString() {",
            "      let pointer = this.currentPointer;",
            "      if (pointer.isNull) {",
            "        return null;",
            "      } else {",
            "        if (pointer.path === null) {",
            "          return throwNullException(\"pointer.path\");",
            "        }",
            "        return pointer.path.toString();",
            "      }",
            "    }",
            "    get currentPointer() {",
            "      return this.callStack.currentElement.currentPointer.copy();",
            "    }",
            "    set currentPointer(value) {",
            "      this.callStack.currentElement.currentPointer = value.copy();",
            "    }",
            "    get previousPointer() {",
            "      return this.callStack.currentThread.previousPointer.copy();",
            "    }",
            "    set previousPointer(value) {",
            "      this.callStack.currentThread.previousPointer = value.copy();",
            "    }",
            "    get canContinue() {",
            "      return !this.currentPointer.isNull && !this.hasError;",
            "    }",
            "    get hasError() {",
            "      return this.currentErrors != null && this.currentErrors.length > 0;",
            "    }",
            "    get hasWarning() {",
            "      return this.currentWarnings != null && this.currentWarnings.length > 0;",
            "    }",
            "    get currentText() {",
            "      if (this._outputStreamTextDirty) {",
            "        let sb = new StringBuilder();",
            "        let inTag = false;",
            "        for (let outputObj of this.outputStream) {",
            "          // var textContent = outputObj as StringValue;",
            "          let textContent = asOrNull(outputObj, StringValue);",
            "          if (!inTag && textContent !== null) {",
            "            sb.Append(textContent.value);",
            "          } else {",
            "            let controlCommand = asOrNull(outputObj, ControlCommand);",
            "            if (controlCommand !== null) {",
            "              if (controlCommand.commandType == ControlCommand.CommandType.BeginTag) {",
            "                inTag = true;",
            "              } else if (controlCommand.commandType == ControlCommand.CommandType.EndTag) {",
            "                inTag = false;",
            "              }",
            "            }",
            "          }",
            "        }",
            "        this._currentText = this.CleanOutputWhitespace(sb.toString());",
            "        this._outputStreamTextDirty = false;",
            "      }",
            "      return this._currentText;",
            "    }",
            "    CleanOutputWhitespace(str) {",
            "      let sb = new StringBuilder();",
            "      let currentWhitespaceStart = -1;",
            "      let startOfLine = 0;",
            "      for (let i = 0; i < str.length; i++) {",
            "        let c = str.charAt(i);",
            "        let isInlineWhitespace = c == \" \" || c == \"\\t\";",
            "        if (isInlineWhitespace && currentWhitespaceStart == -1) currentWhitespaceStart = i;",
            "        if (!isInlineWhitespace) {",
            "          if (c != \"\\n\" && currentWhitespaceStart > 0 && currentWhitespaceStart != startOfLine) {",
            "            sb.Append(\" \");",
            "          }",
            "          currentWhitespaceStart = -1;",
            "        }",
            "        if (c == \"\\n\") startOfLine = i + 1;",
            "        if (!isInlineWhitespace) sb.Append(c);",
            "      }",
            "      return sb.toString();",
            "    }",
            "    get currentTags() {",
            "      if (this._outputStreamTagsDirty) {",
            "        this._currentTags = [];",
            "        let inTag = false;",
            "        let sb = new StringBuilder();",
            "        for (let outputObj of this.outputStream) {",
            "          let controlCommand = asOrNull(outputObj, ControlCommand);",
            "          if (controlCommand != null) {",
            "            if (controlCommand.commandType == ControlCommand.CommandType.BeginTag) {",
            "              if (inTag && sb.Length > 0) {",
            "                let txt = this.CleanOutputWhitespace(sb.toString());",
            "                this._currentTags.push(txt);",
            "                sb.Clear();",
            "              }",
            "              inTag = true;",
            "            } else if (controlCommand.commandType == ControlCommand.CommandType.EndTag) {",
            "              if (sb.Length > 0) {",
            "                let txt = this.CleanOutputWhitespace(sb.toString());",
            "                this._currentTags.push(txt);",
            "                sb.Clear();",
            "              }",
            "              inTag = false;",
            "            }",
            "          } else if (inTag) {",
            "            let strVal = asOrNull(outputObj, StringValue);",
            "            if (strVal !== null) {",
            "              sb.Append(strVal.value);",
            "            }",
            "          } else {",
            "            let tag = asOrNull(outputObj, Tag$1);",
            "            if (tag != null && tag.text != null && tag.text.length > 0) {",
            "              this._currentTags.push(tag.text); // tag.text has whitespae already cleaned",
            "            }",
            "          }",
            "        }",
            "        if (sb.Length > 0) {",
            "          let txt = this.CleanOutputWhitespace(sb.toString());",
            "          this._currentTags.push(txt);",
            "          sb.Clear();",
            "        }",
            "        this._outputStreamTagsDirty = false;",
            "      }",
            "      return this._currentTags;",
            "    }",
            "    get currentFlowName() {",
            "      return this._currentFlow.name;",
            "    }",
            "    get currentFlowIsDefaultFlow() {",
            "      return this._currentFlow.name == this.kDefaultFlowName;",
            "    }",
            "    get aliveFlowNames() {",
            "      if (this._aliveFlowNamesDirty) {",
            "        this._aliveFlowNames = [];",
            "        if (this._namedFlows != null) {",
            "          for (let flowName of this._namedFlows.keys()) {",
            "            if (flowName != this.kDefaultFlowName) {",
            "              this._aliveFlowNames.push(flowName);",
            "            }",
            "          }",
            "        }",
            "        this._aliveFlowNamesDirty = false;",
            "      }",
            "      return this._aliveFlowNames;",
            "    }",
            "    get inExpressionEvaluation() {",
            "      return this.callStack.currentElement.inExpressionEvaluation;",
            "    }",
            "    set inExpressionEvaluation(value) {",
            "      this.callStack.currentElement.inExpressionEvaluation = value;",
            "    }",
            "    constructor(story) {",
            "      // Backward compatible changes since v8:",
            "      // v10: dynamic tags",
            "      // v9:  multi-flows",
            "      this.kInkSaveStateVersion = 10;",
            "      this.kMinCompatibleLoadVersion = 8;",
            "      this.onDidLoadState = null;",
            "      this._currentErrors = null;",
            "      this._currentWarnings = null;",
            "      this.divertedPointer = Pointer.Null;",
            "      this._currentTurnIndex = 0;",
            "      this.storySeed = 0;",
            "      this.previousRandom = 0;",
            "      this.didSafeExit = false;",
            "      this._currentText = null;",
            "      this._currentTags = null;",
            "      this._outputStreamTextDirty = true;",
            "      this._outputStreamTagsDirty = true;",
            "      this._patch = null;",
            "      this._aliveFlowNames = null;",
            "      this._namedFlows = null;",
            "      this.kDefaultFlowName = \"DEFAULT_FLOW\";",
            "      this._aliveFlowNamesDirty = true;",
            "      this.story = story;",
            "      this._currentFlow = new Flow(this.kDefaultFlowName, story);",
            "      this.OutputStreamDirty();",
            "      this._aliveFlowNamesDirty = true;",
            "      this._evaluationStack = [];",
            "      this._variablesState = new VariablesState(this.callStack, story.listDefinitions);",
            "      this._visitCounts = new Map();",
            "      this._turnIndices = new Map();",
            "      this.currentTurnIndex = -1;",
            "      let timeSeed = new Date().getTime();",
            "      this.storySeed = new PRNG(timeSeed).next() % 100;",
            "      this.previousRandom = 0;",
            "      this.GoToStart();",
            "    }",
            "    GoToStart() {",
            "      this.callStack.currentElement.currentPointer = Pointer.StartOf(this.story.mainContentContainer);",
            "    }",
            "    SwitchFlow_Internal(flowName) {",
            "      if (flowName === null) throw new Error(\"Must pass a non-null string to Story.SwitchFlow\");",
            "      if (this._namedFlows === null) {",
            "        this._namedFlows = new Map();",
            "        this._namedFlows.set(this.kDefaultFlowName, this._currentFlow);",
            "      }",
            "      if (flowName === this._currentFlow.name) {",
            "        return;",
            "      }",
            "      let flow;",
            "      let content = tryGetValueFromMap(this._namedFlows, flowName, null);",
            "      if (content.exists) {",
            "        flow = content.result;",
            "      } else {",
            "        flow = new Flow(flowName, this.story);",
            "        this._namedFlows.set(flowName, flow);",
            "        this._aliveFlowNamesDirty = true;",
            "      }",
            "      this._currentFlow = flow;",
            "      this.variablesState.callStack = this._currentFlow.callStack;",
            "      this.OutputStreamDirty();",
            "    }",
            "    SwitchToDefaultFlow_Internal() {",
            "      if (this._namedFlows === null) return;",
            "      this.SwitchFlow_Internal(this.kDefaultFlowName);",
            "    }",
            "    RemoveFlow_Internal(flowName) {",
            "      if (flowName === null) throw new Error(\"Must pass a non-null string to Story.DestroyFlow\");",
            "      if (flowName === this.kDefaultFlowName) throw new Error(\"Cannot destroy default flow\");",
            "      if (this._currentFlow.name === flowName) {",
            "        this.SwitchToDefaultFlow_Internal();",
            "      }",
            "      if (this._namedFlows === null) return throwNullException(\"this._namedFlows\");",
            "      this._namedFlows.delete(flowName);",
            "      this._aliveFlowNamesDirty = true;",
            "    }",
            "    CopyAndStartPatching() {",
            "      let copy = new StoryState(this.story);",
            "      copy._patch = new StatePatch(this._patch);",
            "      copy._currentFlow.name = this._currentFlow.name;",
            "      copy._currentFlow.callStack = new CallStack(this._currentFlow.callStack);",
            "      copy._currentFlow.currentChoices.push(...this._currentFlow.currentChoices);",
            "      copy._currentFlow.outputStream.push(...this._currentFlow.outputStream);",
            "      copy.OutputStreamDirty();",
            "      if (this._namedFlows !== null) {",
            "        copy._namedFlows = new Map();",
            "        for (let [namedFlowKey, namedFlowValue] of this._namedFlows) {",
            "          copy._namedFlows.set(namedFlowKey, namedFlowValue);",
            "          copy._aliveFlowNamesDirty = true;",
            "        }",
            "        copy._namedFlows.set(this._currentFlow.name, copy._currentFlow);",
            "      }",
            "      if (this.hasError) {",
            "        copy._currentErrors = [];",
            "        copy._currentErrors.push(...(this.currentErrors || []));",
            "      }",
            "      if (this.hasWarning) {",
            "        copy._currentWarnings = [];",
            "        copy._currentWarnings.push(...(this.currentWarnings || []));",
            "      }",
            "      copy.variablesState = this.variablesState;",
            "      copy.variablesState.callStack = copy.callStack;",
            "      copy.variablesState.patch = copy._patch;",
            "      copy.evaluationStack.push(...this.evaluationStack);",
            "      if (!this.divertedPointer.isNull) copy.divertedPointer = this.divertedPointer.copy();",
            "      copy.previousPointer = this.previousPointer.copy();",
            "      copy._visitCounts = this._visitCounts;",
            "      copy._turnIndices = this._turnIndices;",
            "      copy.currentTurnIndex = this.currentTurnIndex;",
            "      copy.storySeed = this.storySeed;",
            "      copy.previousRandom = this.previousRandom;",
            "      copy.didSafeExit = this.didSafeExit;",
            "      return copy;",
            "    }",
            "    RestoreAfterPatch() {",
            "      this.variablesState.callStack = this.callStack;",
            "      this.variablesState.patch = this._patch;",
            "    }",
            "    ApplyAnyPatch() {",
            "      if (this._patch === null) return;",
            "      this.variablesState.ApplyPatch();",
            "      for (let [key, value] of this._patch.visitCounts) this.ApplyCountChanges(key, value, true);",
            "      for (let [key, value] of this._patch.turnIndices) this.ApplyCountChanges(key, value, false);",
            "      this._patch = null;",
            "    }",
            "    ApplyCountChanges(container, newCount, isVisit) {",
            "      let counts = isVisit ? this._visitCounts : this._turnIndices;",
            "      counts.set(container.path.toString(), newCount);",
            "    }",
            "    WriteJson(writer) {",
            "      writer.WriteObjectStart();",
            "      writer.WritePropertyStart(\"flows\");",
            "      writer.WriteObjectStart();",
            "      // NOTE: Never pass `WriteJson` directly as an argument to `WriteProperty`.",
            "      // Call it inside a function to make sure `this` is correctly bound",
            "      // and passed down the call hierarchy.",
            "      if (this._namedFlows !== null) {",
            "        for (let [namedFlowKey, namedFlowValue] of this._namedFlows) {",
            "          writer.WriteProperty(namedFlowKey, w => namedFlowValue.WriteJson(w));",
            "        }",
            "      } else {",
            "        writer.WriteProperty(this._currentFlow.name, w => this._currentFlow.WriteJson(w));",
            "      }",
            "      writer.WriteObjectEnd();",
            "      writer.WritePropertyEnd();",
            "      writer.WriteProperty(\"currentFlowName\", this._currentFlow.name);",
            "      writer.WriteProperty(\"variablesState\", w => this.variablesState.WriteJson(w));",
            "      writer.WriteProperty(\"evalStack\", w => JsonSerialisation.WriteListRuntimeObjs(w, this.evaluationStack));",
            "      if (!this.divertedPointer.isNull) {",
            "        if (this.divertedPointer.path === null) {",
            "          return throwNullException(\"divertedPointer\");",
            "        }",
            "        writer.WriteProperty(\"currentDivertTarget\", this.divertedPointer.path.componentsString);",
            "      }",
            "      writer.WriteProperty(\"visitCounts\", w => JsonSerialisation.WriteIntDictionary(w, this._visitCounts));",
            "      writer.WriteProperty(\"turnIndices\", w => JsonSerialisation.WriteIntDictionary(w, this._turnIndices));",
            "      writer.WriteIntProperty(\"turnIdx\", this.currentTurnIndex);",
            "      writer.WriteIntProperty(\"storySeed\", this.storySeed);",
            "      writer.WriteIntProperty(\"previousRandom\", this.previousRandom);",
            "      writer.WriteIntProperty(\"inkSaveVersion\", this.kInkSaveStateVersion);",
            "      writer.WriteIntProperty(\"inkFormatVersion\", Story$1.inkVersionCurrent);",
            "      writer.WriteObjectEnd();",
            "    }",
            "    LoadJsonObj(value) {",
            "      let jObject = value;",
            "      let jSaveVersion = jObject[\"inkSaveVersion\"];",
            "      if (jSaveVersion == null) {",
            "        throw new Error(\"ink save format incorrect, can't load.\");",
            "      } else if (parseInt(jSaveVersion) < this.kMinCompatibleLoadVersion) {",
            "        throw new Error(\"Ink save format isn't compatible with the current version (saw '\" + jSaveVersion + \"', but minimum is \" + this.kMinCompatibleLoadVersion + \"), so can't load.\");",
            "      }",
            "      let flowsObj = jObject[\"flows\"];",
            "      if (flowsObj != null) {",
            "        let flowsObjDict = flowsObj;",
            "        // Single default flow",
            "        if (Object.keys(flowsObjDict).length === 1) {",
            "          this._namedFlows = null;",
            "        } else if (this._namedFlows === null) {",
            "          this._namedFlows = new Map();",
            "        } else {",
            "          this._namedFlows.clear();",
            "        }",
            "        let flowsObjDictEntries = Object.entries(flowsObjDict);",
            "        for (let [namedFlowObjKey, namedFlowObjValue] of flowsObjDictEntries) {",
            "          let name = namedFlowObjKey;",
            "          let flowObj = namedFlowObjValue;",
            "          let flow = new Flow(name, this.story, flowObj);",
            "          if (Object.keys(flowsObjDict).length === 1) {",
            "            this._currentFlow = new Flow(name, this.story, flowObj);",
            "          } else {",
            "            if (this._namedFlows === null) return throwNullException(\"this._namedFlows\");",
            "            this._namedFlows.set(name, flow);",
            "          }",
            "        }",
            "        if (this._namedFlows != null && this._namedFlows.size > 1) {",
            "          let currFlowName = jObject[\"currentFlowName\"];",
            "          // Adding a bang at the end, because we're trusting the save, as",
            "          // done in upstream.  If the save is corrupted, the execution",
            "          // is undefined.",
            "          this._currentFlow = this._namedFlows.get(currFlowName);",
            "        }",
            "      } else {",
            "        this._namedFlows = null;",
            "        this._currentFlow.name = this.kDefaultFlowName;",
            "        this._currentFlow.callStack.SetJsonToken(jObject[\"callstackThreads\"], this.story);",
            "        this._currentFlow.outputStream = JsonSerialisation.JArrayToRuntimeObjList(jObject[\"outputStream\"]);",
            "        this._currentFlow.currentChoices = JsonSerialisation.JArrayToRuntimeObjList(jObject[\"currentChoices\"]);",
            "        let jChoiceThreadsObj = jObject[\"choiceThreads\"];",
            "        this._currentFlow.LoadFlowChoiceThreads(jChoiceThreadsObj, this.story);",
            "      }",
            "      this.OutputStreamDirty();",
            "      this._aliveFlowNamesDirty = true;",
            "      this.variablesState.SetJsonToken(jObject[\"variablesState\"]);",
            "      this.variablesState.callStack = this._currentFlow.callStack;",
            "      this._evaluationStack = JsonSerialisation.JArrayToRuntimeObjList(jObject[\"evalStack\"]);",
            "      let currentDivertTargetPath = jObject[\"currentDivertTarget\"];",
            "      if (currentDivertTargetPath != null) {",
            "        let divertPath = new Path$1(currentDivertTargetPath.toString());",
            "        this.divertedPointer = this.story.PointerAtPath(divertPath);",
            "      }",
            "      this._visitCounts = JsonSerialisation.JObjectToIntDictionary(jObject[\"visitCounts\"]);",
            "      this._turnIndices = JsonSerialisation.JObjectToIntDictionary(jObject[\"turnIndices\"]);",
            "      this.currentTurnIndex = parseInt(jObject[\"turnIdx\"]);",
            "      this.storySeed = parseInt(jObject[\"storySeed\"]);",
            "      this.previousRandom = parseInt(jObject[\"previousRandom\"]);",
            "    }",
            "    ResetErrors() {",
            "      this._currentErrors = null;",
            "      this._currentWarnings = null;",
            "    }",
            "    ResetOutput() {",
            "      let objs = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;",
            "      this.outputStream.length = 0;",
            "      if (objs !== null) this.outputStream.push(...objs);",
            "      this.OutputStreamDirty();",
            "    }",
            "    PushToOutputStream(obj) {",
            "      // var text = obj as StringValue;",
            "      let text = asOrNull(obj, StringValue);",
            "      if (text !== null) {",
            "        let listText = this.TrySplittingHeadTailWhitespace(text);",
            "        if (listText !== null) {",
            "          for (let textObj of listText) {",
            "            this.PushToOutputStreamIndividual(textObj);",
            "          }",
            "          this.OutputStreamDirty();",
            "          return;",
            "        }",
            "      }",
            "      this.PushToOutputStreamIndividual(obj);",
            "      this.OutputStreamDirty();",
            "    }",
            "    PopFromOutputStream(count) {",
            "      this.outputStream.splice(this.outputStream.length - count, count);",
            "      this.OutputStreamDirty();",
            "    }",
            "    TrySplittingHeadTailWhitespace(single) {",
            "      let str = single.value;",
            "      if (str === null) {",
            "        return throwNullException(\"single.value\");",
            "      }",
            "      let headFirstNewlineIdx = -1;",
            "      let headLastNewlineIdx = -1;",
            "      for (let i = 0; i < str.length; i++) {",
            "        let c = str[i];",
            "        if (c == \"\\n\") {",
            "          if (headFirstNewlineIdx == -1) headFirstNewlineIdx = i;",
            "          headLastNewlineIdx = i;",
            "        } else if (c == \" \" || c == \"\\t\") continue;else break;",
            "      }",
            "      let tailLastNewlineIdx = -1;",
            "      let tailFirstNewlineIdx = -1;",
            "      for (let i = str.length - 1; i >= 0; i--) {",
            "        let c = str[i];",
            "        if (c == \"\\n\") {",
            "          if (tailLastNewlineIdx == -1) tailLastNewlineIdx = i;",
            "          tailFirstNewlineIdx = i;",
            "        } else if (c == \" \" || c == \"\\t\") continue;else break;",
            "      }",
            "      // No splitting to be done?",
            "      if (headFirstNewlineIdx == -1 && tailLastNewlineIdx == -1) return null;",
            "      let listTexts = [];",
            "      let innerStrStart = 0;",
            "      let innerStrEnd = str.length;",
            "      if (headFirstNewlineIdx != -1) {",
            "        if (headFirstNewlineIdx > 0) {",
            "          let leadingSpaces = new StringValue(str.substring(0, headFirstNewlineIdx));",
            "          listTexts.push(leadingSpaces);",
            "        }",
            "        listTexts.push(new StringValue(\"\\n\"));",
            "        innerStrStart = headLastNewlineIdx + 1;",
            "      }",
            "      if (tailLastNewlineIdx != -1) {",
            "        innerStrEnd = tailFirstNewlineIdx;",
            "      }",
            "      if (innerStrEnd > innerStrStart) {",
            "        let innerStrText = str.substring(innerStrStart, innerStrEnd);",
            "        listTexts.push(new StringValue(innerStrText));",
            "      }",
            "      if (tailLastNewlineIdx != -1 && tailFirstNewlineIdx > headLastNewlineIdx) {",
            "        listTexts.push(new StringValue(\"\\n\"));",
            "        if (tailLastNewlineIdx < str.length - 1) {",
            "          let numSpaces = str.length - tailLastNewlineIdx - 1;",
            "          let trailingSpaces = new StringValue(str.substring(tailLastNewlineIdx + 1, tailLastNewlineIdx + 1 + numSpaces));",
            "          listTexts.push(trailingSpaces);",
            "        }",
            "      }",
            "      return listTexts;",
            "    }",
            "    PushToOutputStreamIndividual(obj) {",
            "      let glue = asOrNull(obj, Glue);",
            "      let text = asOrNull(obj, StringValue);",
            "      let includeInOutput = true;",
            "      if (glue) {",
            "        this.TrimNewlinesFromOutputStream();",
            "        includeInOutput = true;",
            "      } else if (text) {",
            "        let functionTrimIndex = -1;",
            "        let currEl = this.callStack.currentElement;",
            "        if (currEl.type == PushPopType.Function) {",
            "          functionTrimIndex = currEl.functionStartInOutputStream;",
            "        }",
            "        let glueTrimIndex = -1;",
            "        for (let i = this.outputStream.length - 1; i >= 0; i--) {",
            "          let o = this.outputStream[i];",
            "          let c = o instanceof ControlCommand ? o : null;",
            "          let g = o instanceof Glue ? o : null;",
            "          if (g != null) {",
            "            glueTrimIndex = i;",
            "            break;",
            "          } else if (c != null && c.commandType == ControlCommand.CommandType.BeginString) {",
            "            if (i >= functionTrimIndex) {",
            "              functionTrimIndex = -1;",
            "            }",
            "            break;",
            "          }",
            "        }",
            "        let trimIndex = -1;",
            "        if (glueTrimIndex != -1 && functionTrimIndex != -1) trimIndex = Math.min(functionTrimIndex, glueTrimIndex);else if (glueTrimIndex != -1) trimIndex = glueTrimIndex;else trimIndex = functionTrimIndex;",
            "        if (trimIndex != -1) {",
            "          if (text.isNewline) {",
            "            includeInOutput = false;",
            "          } else if (text.isNonWhitespace) {",
            "            if (glueTrimIndex > -1) this.RemoveExistingGlue();",
            "            if (functionTrimIndex > -1) {",
            "              let callStackElements = this.callStack.elements;",
            "              for (let i = callStackElements.length - 1; i >= 0; i--) {",
            "                let el = callStackElements[i];",
            "                if (el.type == PushPopType.Function) {",
            "                  el.functionStartInOutputStream = -1;",
            "                } else {",
            "                  break;",
            "                }",
            "              }",
            "            }",
            "          }",
            "        } else if (text.isNewline) {",
            "          if (this.outputStreamEndsInNewline || !this.outputStreamContainsContent) includeInOutput = false;",
            "        }",
            "      }",
            "      if (includeInOutput) {",
            "        if (obj === null) {",
            "          return throwNullException(\"obj\");",
            "        }",
            "        this.outputStream.push(obj);",
            "        this.OutputStreamDirty();",
            "      }",
            "    }",
            "    TrimNewlinesFromOutputStream() {",
            "      let removeWhitespaceFrom = -1;",
            "      let i = this.outputStream.length - 1;",
            "      while (i >= 0) {",
            "        let obj = this.outputStream[i];",
            "        let cmd = asOrNull(obj, ControlCommand);",
            "        let txt = asOrNull(obj, StringValue);",
            "        if (cmd != null || txt != null && txt.isNonWhitespace) {",
            "          break;",
            "        } else if (txt != null && txt.isNewline) {",
            "          removeWhitespaceFrom = i;",
            "        }",
            "        i--;",
            "      }",
            "      // Remove the whitespace",
            "      if (removeWhitespaceFrom >= 0) {",
            "        i = removeWhitespaceFrom;",
            "        while (i < this.outputStream.length) {",
            "          let text = asOrNull(this.outputStream[i], StringValue);",
            "          if (text) {",
            "            this.outputStream.splice(i, 1);",
            "          } else {",
            "            i++;",
            "          }",
            "        }",
            "      }",
            "      this.OutputStreamDirty();",
            "    }",
            "    RemoveExistingGlue() {",
            "      for (let i = this.outputStream.length - 1; i >= 0; i--) {",
            "        let c = this.outputStream[i];",
            "        if (c instanceof Glue) {",
            "          this.outputStream.splice(i, 1);",
            "        } else if (c instanceof ControlCommand) {",
            "          break;",
            "        }",
            "      }",
            "      this.OutputStreamDirty();",
            "    }",
            "    get outputStreamEndsInNewline() {",
            "      if (this.outputStream.length > 0) {",
            "        for (let i = this.outputStream.length - 1; i >= 0; i--) {",
            "          let obj = this.outputStream[i];",
            "          if (obj instanceof ControlCommand) break;",
            "          let text = this.outputStream[i];",
            "          if (text instanceof StringValue) {",
            "            if (text.isNewline) return true;else if (text.isNonWhitespace) break;",
            "          }",
            "        }",
            "      }",
            "      return false;",
            "    }",
            "    get outputStreamContainsContent() {",
            "      for (let content of this.outputStream) {",
            "        if (content instanceof StringValue) return true;",
            "      }",
            "      return false;",
            "    }",
            "    get inStringEvaluation() {",
            "      for (let i = this.outputStream.length - 1; i >= 0; i--) {",
            "        let cmd = asOrNull(this.outputStream[i], ControlCommand);",
            "        if (cmd instanceof ControlCommand && cmd.commandType == ControlCommand.CommandType.BeginString) {",
            "          return true;",
            "        }",
            "      }",
            "      return false;",
            "    }",
            "    PushEvaluationStack(obj) {",
            "      // var listValue = obj as ListValue;",
            "      let listValue = asOrNull(obj, ListValue);",
            "      if (listValue) {",
            "        // Update origin when list is has something to indicate the list origin",
            "        let rawList = listValue.value;",
            "        if (rawList === null) {",
            "          return throwNullException(\"rawList\");",
            "        }",
            "        if (rawList.originNames != null) {",
            "          if (!rawList.origins) rawList.origins = [];",
            "          rawList.origins.length = 0;",
            "          for (let n of rawList.originNames) {",
            "            if (this.story.listDefinitions === null) return throwNullException(\"StoryState.story.listDefinitions\");",
            "            let def = this.story.listDefinitions.TryListGetDefinition(n, null);",
            "            if (def.result === null) return throwNullException(\"StoryState def.result\");",
            "            if (rawList.origins.indexOf(def.result) < 0) rawList.origins.push(def.result);",
            "          }",
            "        }",
            "      }",
            "      if (obj === null) {",
            "        return throwNullException(\"obj\");",
            "      }",
            "      this.evaluationStack.push(obj);",
            "    }",
            "    PopEvaluationStack(numberOfObjects) {",
            "      if (typeof numberOfObjects === \"undefined\") {",
            "        let obj = this.evaluationStack.pop();",
            "        return nullIfUndefined(obj);",
            "      } else {",
            "        if (numberOfObjects > this.evaluationStack.length) {",
            "          throw new Error(\"trying to pop too many objects\");",
            "        }",
            "        let popped = this.evaluationStack.splice(this.evaluationStack.length - numberOfObjects, numberOfObjects);",
            "        return nullIfUndefined(popped);",
            "      }",
            "    }",
            "    PeekEvaluationStack() {",
            "      return this.evaluationStack[this.evaluationStack.length - 1];",
            "    }",
            "    ForceEnd() {",
            "      this.callStack.Reset();",
            "      this._currentFlow.currentChoices.length = 0;",
            "      this.currentPointer = Pointer.Null;",
            "      this.previousPointer = Pointer.Null;",
            "      this.didSafeExit = true;",
            "    }",
            "    TrimWhitespaceFromFunctionEnd() {",
            "      Debug.Assert(this.callStack.currentElement.type == PushPopType.Function);",
            "      let functionStartPoint = this.callStack.currentElement.functionStartInOutputStream;",
            "      if (functionStartPoint == -1) {",
            "        functionStartPoint = 0;",
            "      }",
            "      for (let i = this.outputStream.length - 1; i >= functionStartPoint; i--) {",
            "        let obj = this.outputStream[i];",
            "        let txt = asOrNull(obj, StringValue);",
            "        let cmd = asOrNull(obj, ControlCommand);",
            "        if (txt == null) continue;",
            "        if (cmd) break;",
            "        if (txt.isNewline || txt.isInlineWhitespace) {",
            "          this.outputStream.splice(i, 1);",
            "          this.OutputStreamDirty();",
            "        } else {",
            "          break;",
            "        }",
            "      }",
            "    }",
            "    PopCallStack() {",
            "      let popType = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;",
            "      if (this.callStack.currentElement.type == PushPopType.Function) this.TrimWhitespaceFromFunctionEnd();",
            "      this.callStack.Pop(popType);",
            "    }",
            "    SetChosenPath(path, incrementingTurnIndex) {",
            "      // Changing direction, assume we need to clear current set of choices",
            "      this._currentFlow.currentChoices.length = 0;",
            "      let newPointer = this.story.PointerAtPath(path);",
            "      if (!newPointer.isNull && newPointer.index == -1) newPointer.index = 0;",
            "      this.currentPointer = newPointer;",
            "      if (incrementingTurnIndex) {",
            "        this.currentTurnIndex++;",
            "      }",
            "    }",
            "    StartFunctionEvaluationFromGame(funcContainer, args) {",
            "      this.callStack.Push(PushPopType.FunctionEvaluationFromGame, this.evaluationStack.length);",
            "      this.callStack.currentElement.currentPointer = Pointer.StartOf(funcContainer);",
            "      this.PassArgumentsToEvaluationStack(args);",
            "    }",
            "    PassArgumentsToEvaluationStack(args) {",
            "      if (args !== null) {",
            "        for (let i = 0; i < args.length; i++) {",
            "          if (!(typeof args[i] === \"number\" || typeof args[i] === \"string\" || typeof args[i] === \"boolean\" || args[i] instanceof InkList)) {",
            "            throw new Error(\"ink arguments when calling EvaluateFunction / ChoosePathStringWithParameters must be\" + \"number, string, bool or InkList. Argument was \" + (nullIfUndefined(arguments[i]) === null) ? \"null\" : arguments[i].constructor.name);",
            "          }",
            "          this.PushEvaluationStack(Value.Create(args[i]));",
            "        }",
            "      }",
            "    }",
            "    TryExitFunctionEvaluationFromGame() {",
            "      if (this.callStack.currentElement.type == PushPopType.FunctionEvaluationFromGame) {",
            "        this.currentPointer = Pointer.Null;",
            "        this.didSafeExit = true;",
            "        return true;",
            "      }",
            "      return false;",
            "    }",
            "    CompleteFunctionEvaluationFromGame() {",
            "      if (this.callStack.currentElement.type != PushPopType.FunctionEvaluationFromGame) {",
            "        throw new Error(\"Expected external function evaluation to be complete. Stack trace: \" + this.callStack.callStackTrace);",
            "      }",
            "      let originalEvaluationStackHeight = this.callStack.currentElement.evaluationStackHeightWhenPushed;",
            "      let returnedObj = null;",
            "      while (this.evaluationStack.length > originalEvaluationStackHeight) {",
            "        let poppedObj = this.PopEvaluationStack();",
            "        if (returnedObj === null) returnedObj = poppedObj;",
            "      }",
            "      this.PopCallStack(PushPopType.FunctionEvaluationFromGame);",
            "      if (returnedObj) {",
            "        if (returnedObj instanceof Void) return null;",
            "        // Some kind of value, if not void",
            "        // var returnVal = returnedObj as Runtime.Value;",
            "        let returnVal = asOrThrows(returnedObj, Value);",
            "        // DivertTargets get returned as the string of components",
            "        // (rather than a Path, which isn't public)",
            "        if (returnVal.valueType == ValueType.DivertTarget) {",
            "          return returnVal.valueObject.toString();",
            "        }",
            "        // Other types can just have their exact object type:",
            "        // int, float, string. VariablePointers get returned as strings.",
            "        return returnVal.valueObject;",
            "      }",
            "      return null;",
            "    }",
            "    AddError(message, isWarning) {",
            "      if (!isWarning) {",
            "        if (this._currentErrors == null) this._currentErrors = [];",
            "        this._currentErrors.push(message);",
            "      } else {",
            "        if (this._currentWarnings == null) this._currentWarnings = [];",
            "        this._currentWarnings.push(message);",
            "      }",
            "    }",
            "    OutputStreamDirty() {",
            "      this._outputStreamTextDirty = true;",
            "      this._outputStreamTagsDirty = true;",
            "    }",
            "  }",
            "",
            "  // This is simple replacement of the Stopwatch class from the .NET Framework.",
            "  // The original class can count time with much more accuracy than the Javascript version.",
            "  // It might be worth considering using `window.performance` in the browser",
            "  // or `process.hrtime()` in node.",
            "  class Stopwatch {",
            "    constructor() {",
            "      this.startTime = undefined;",
            "    }",
            "    get ElapsedMilliseconds() {",
            "      if (typeof this.startTime === \"undefined\") {",
            "        return 0;",
            "      }",
            "      return new Date().getTime() - this.startTime;",
            "    }",
            "    Start() {",
            "      this.startTime = new Date().getTime();",
            "    }",
            "    Stop() {",
            "      this.startTime = undefined;",
            "    }",
            "  }",
            "",
            "  // TODO: Unify with Compiler.",
            "  var ErrorType;",
            "  (function (ErrorType) {",
            "    ErrorType[ErrorType[\"Author\"] = 0] = \"Author\";",
            "    ErrorType[ErrorType[\"Warning\"] = 1] = \"Warning\";",
            "    ErrorType[ErrorType[\"Error\"] = 2] = \"Error\";",
            "  })(ErrorType || (ErrorType = {}));",
            "",
            "  if (!Number.isInteger) {",
            "    Number.isInteger = function isInteger(nVal) {",
            "      return typeof nVal === \"number\" && isFinite(nVal) && nVal > -9007199254740992 && nVal < 9007199254740992 && Math.floor(nVal) === nVal;",
            "    };",
            "  }",
            "  class Story$1 extends InkObject {",
            "    get currentChoices() {",
            "      let choices = [];",
            "      if (this._state === null) {",
            "        return throwNullException(\"this._state\");",
            "      }",
            "      for (let c of this._state.currentChoices) {",
            "        if (!c.isInvisibleDefault) {",
            "          c.index = choices.length;",
            "          choices.push(c);",
            "        }",
            "      }",
            "      return choices;",
            "    }",
            "    get currentText() {",
            "      this.IfAsyncWeCant(\"call currentText since it's a work in progress\");",
            "      return this.state.currentText;",
            "    }",
            "    get currentTags() {",
            "      this.IfAsyncWeCant(\"call currentTags since it's a work in progress\");",
            "      return this.state.currentTags;",
            "    }",
            "    get currentErrors() {",
            "      return this.state.currentErrors;",
            "    }",
            "    get currentWarnings() {",
            "      return this.state.currentWarnings;",
            "    }",
            "    get currentFlowName() {",
            "      return this.state.currentFlowName;",
            "    }",
            "    get currentFlowIsDefaultFlow() {",
            "      return this.state.currentFlowIsDefaultFlow;",
            "    }",
            "    get aliveFlowNames() {",
            "      return this.state.aliveFlowNames;",
            "    }",
            "    get hasError() {",
            "      return this.state.hasError;",
            "    }",
            "    get hasWarning() {",
            "      return this.state.hasWarning;",
            "    }",
            "    get variablesState() {",
            "      return this.state.variablesState;",
            "    }",
            "    get listDefinitions() {",
            "      return this._listDefinitions;",
            "    }",
            "    get state() {",
            "      return this._state;",
            "    }",
            "    // TODO: Implement Profiler",
            "    StartProfiling() {",
            "      /* */",
            "    }",
            "    EndProfiling() {",
            "      /* */",
            "    }",
            "    constructor() {",
            "      super();",
            "      this.inkVersionMinimumCompatible = 18;",
            "      this.onError = null;",
            "      this.onDidContinue = null;",
            "      this.onMakeChoice = null;",
            "      this.onEvaluateFunction = null;",
            "      this.onCompleteEvaluateFunction = null;",
            "      this.onChoosePathString = null;",
            "      this._prevContainers = [];",
            "      this.allowExternalFunctionFallbacks = false;",
            "      this._listDefinitions = null;",
            "      this._variableObservers = null;",
            "      this._hasValidatedExternals = false;",
            "      this._temporaryEvaluationContainer = null;",
            "      this._asyncContinueActive = false;",
            "      this._stateSnapshotAtLastNewline = null;",
            "      this._sawLookaheadUnsafeFunctionAfterNewline = false;",
            "      this._recursiveContinueCount = 0;",
            "      this._asyncSaving = false;",
            "      this._profiler = null; // TODO: Profiler",
            "      // Discrimination between constructors",
            "      let contentContainer;",
            "      let lists = null;",
            "      let json = null;",
            "      if (arguments[0] instanceof Container) {",
            "        contentContainer = arguments[0];",
            "        if (typeof arguments[1] !== \"undefined\") {",
            "          lists = arguments[1];",
            "        }",
            "        // ------ Story (Container contentContainer, List<Runtime.ListDefinition> lists = null)",
            "        this._mainContentContainer = contentContainer;",
            "        // ------",
            "      } else {",
            "        if (typeof arguments[0] === \"string\") {",
            "          let jsonString = arguments[0];",
            "          json = SimpleJson.TextToDictionary(jsonString);",
            "        } else {",
            "          json = arguments[0];",
            "        }",
            "      }",
            "      // ------ Story (Container contentContainer, List<Runtime.ListDefinition> lists = null)",
            "      if (lists != null) this._listDefinitions = new ListDefinitionsOrigin(lists);",
            "      this._externals = new Map();",
            "      // ------",
            "      // ------ Story(string jsonString) : this((Container)null)",
            "      if (json !== null) {",
            "        let rootObject = json;",
            "        let versionObj = rootObject[\"inkVersion\"];",
            "        if (versionObj == null) throw new Error(\"ink version number not found. Are you sure it's a valid .ink.json file?\");",
            "        let formatFromFile = parseInt(versionObj);",
            "        if (formatFromFile > Story$1.inkVersionCurrent) {",
            "          throw new Error(\"Version of ink used to build story was newer than the current version of the engine\");",
            "        } else if (formatFromFile < this.inkVersionMinimumCompatible) {",
            "          throw new Error(\"Version of ink used to build story is too old to be loaded by this version of the engine\");",
            "        } else if (formatFromFile != Story$1.inkVersionCurrent) {",
            "          console.warn(\"WARNING: Version of ink used to build story doesn't match current version of engine. Non-critical, but recommend synchronising.\");",
            "        }",
            "        let rootToken = rootObject[\"root\"];",
            "        if (rootToken == null) throw new Error(\"Root node for ink not found. Are you sure it's a valid .ink.json file?\");",
            "        let listDefsObj;",
            "        if (listDefsObj = rootObject[\"listDefs\"]) {",
            "          this._listDefinitions = JsonSerialisation.JTokenToListDefinitions(listDefsObj);",
            "        }",
            "        this._mainContentContainer = asOrThrows(JsonSerialisation.JTokenToRuntimeObject(rootToken), Container);",
            "        this.ResetState();",
            "      }",
            "      // ------",
            "    }",
            "    // Merge together `public string ToJson()` and `void ToJson(SimpleJson.Writer writer)`.",
            "    // Will only return a value if writer was not provided.",
            "    ToJson(writer) {",
            "      let shouldReturn = false;",
            "      if (!writer) {",
            "        shouldReturn = true;",
            "        writer = new SimpleJson.Writer();",
            "      }",
            "      writer.WriteObjectStart();",
            "      writer.WriteIntProperty(\"inkVersion\", Story$1.inkVersionCurrent);",
            "      writer.WriteProperty(\"root\", w => JsonSerialisation.WriteRuntimeContainer(w, this._mainContentContainer));",
            "      if (this._listDefinitions != null) {",
            "        writer.WritePropertyStart(\"listDefs\");",
            "        writer.WriteObjectStart();",
            "        for (let def of this._listDefinitions.lists) {",
            "          writer.WritePropertyStart(def.name);",
            "          writer.WriteObjectStart();",
            "          for (let [key, value] of def.items) {",
            "            let item = InkListItem.fromSerializedKey(key);",
            "            let val = value;",
            "            writer.WriteIntProperty(item.itemName, val);",
            "          }",
            "          writer.WriteObjectEnd();",
            "          writer.WritePropertyEnd();",
            "        }",
            "        writer.WriteObjectEnd();",
            "        writer.WritePropertyEnd();",
            "      }",
            "      writer.WriteObjectEnd();",
            "      if (shouldReturn) return writer.toString();",
            "    }",
            "    ResetState() {",
            "      this.IfAsyncWeCant(\"ResetState\");",
            "      this._state = new StoryState(this);",
            "      this._state.variablesState.ObserveVariableChange(this.VariableStateDidChangeEvent.bind(this));",
            "      this.ResetGlobals();",
            "    }",
            "    ResetErrors() {",
            "      if (this._state === null) {",
            "        return throwNullException(\"this._state\");",
            "      }",
            "      this._state.ResetErrors();",
            "    }",
            "    ResetCallstack() {",
            "      this.IfAsyncWeCant(\"ResetCallstack\");",
            "      if (this._state === null) {",
            "        return throwNullException(\"this._state\");",
            "      }",
            "      this._state.ForceEnd();",
            "    }",
            "    ResetGlobals() {",
            "      if (this._mainContentContainer.namedContent.get(\"global decl\")) {",
            "        let originalPointer = this.state.currentPointer.copy();",
            "        this.ChoosePath(new Path$1(\"global decl\"), false);",
            "        this.ContinueInternal();",
            "        this.state.currentPointer = originalPointer;",
            "      }",
            "      this.state.variablesState.SnapshotDefaultGlobals();",
            "    }",
            "    SwitchFlow(flowName) {",
            "      this.IfAsyncWeCant(\"switch flow\");",
            "      if (this._asyncSaving) {",
            "        throw new Error(\"Story is already in background saving mode, can't switch flow to \" + flowName);",
            "      }",
            "      this.state.SwitchFlow_Internal(flowName);",
            "    }",
            "    RemoveFlow(flowName) {",
            "      this.state.RemoveFlow_Internal(flowName);",
            "    }",
            "    SwitchToDefaultFlow() {",
            "      this.state.SwitchToDefaultFlow_Internal();",
            "    }",
            "    Continue() {",
            "      this.ContinueAsync(0);",
            "      return this.currentText;",
            "    }",
            "    get canContinue() {",
            "      return this.state.canContinue;",
            "    }",
            "    get asyncContinueComplete() {",
            "      return !this._asyncContinueActive;",
            "    }",
            "    ContinueAsync(millisecsLimitAsync) {",
            "      if (!this._hasValidatedExternals) this.ValidateExternalBindings();",
            "      this.ContinueInternal(millisecsLimitAsync);",
            "    }",
            "    ContinueInternal() {",
            "      let millisecsLimitAsync = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;",
            "      if (this._profiler != null) this._profiler.PreContinue();",
            "      let isAsyncTimeLimited = millisecsLimitAsync > 0;",
            "      this._recursiveContinueCount++;",
            "      if (!this._asyncContinueActive) {",
            "        this._asyncContinueActive = isAsyncTimeLimited;",
            "        if (!this.canContinue) {",
            "          throw new Error(\"Can't continue - should check canContinue before calling Continue\");",
            "        }",
            "        this._state.didSafeExit = false;",
            "        this._state.ResetOutput();",
            "        if (this._recursiveContinueCount == 1) this._state.variablesState.batchObservingVariableChanges = true;",
            "      }",
            "      let durationStopwatch = new Stopwatch();",
            "      durationStopwatch.Start();",
            "      let outputStreamEndsInNewline = false;",
            "      this._sawLookaheadUnsafeFunctionAfterNewline = false;",
            "      do {",
            "        try {",
            "          outputStreamEndsInNewline = this.ContinueSingleStep();",
            "        } catch (e) {",
            "          if (!(e instanceof StoryException)) throw e;",
            "          this.AddError(e.message, undefined, e.useEndLineNumber);",
            "          break;",
            "        }",
            "        if (outputStreamEndsInNewline) break;",
            "        if (this._asyncContinueActive && durationStopwatch.ElapsedMilliseconds > millisecsLimitAsync) {",
            "          break;",
            "        }",
            "      } while (this.canContinue);",
            "      durationStopwatch.Stop();",
            "      if (outputStreamEndsInNewline || !this.canContinue) {",
            "        if (this._stateSnapshotAtLastNewline !== null) {",
            "          this.RestoreStateSnapshot();",
            "        }",
            "        if (!this.canContinue) {",
            "          if (this.state.callStack.canPopThread) this.AddError(\"Thread available to pop, threads should always be flat by the end of evaluation?\");",
            "          if (this.state.generatedChoices.length == 0 && !this.state.didSafeExit && this._temporaryEvaluationContainer == null) {",
            "            if (this.state.callStack.CanPop(PushPopType.Tunnel)) this.AddError(\"unexpectedly reached end of content. Do you need a '->->' to return from a tunnel?\");else if (this.state.callStack.CanPop(PushPopType.Function)) this.AddError(\"unexpectedly reached end of content. Do you need a '~ return'?\");else if (!this.state.callStack.canPop) this.AddError(\"ran out of content. Do you need a '-> DONE' or '-> END'?\");else this.AddError(\"unexpectedly reached end of content for unknown reason. Please debug compiler!\");",
            "          }",
            "        }",
            "        this.state.didSafeExit = false;",
            "        this._sawLookaheadUnsafeFunctionAfterNewline = false;",
            "        if (this._recursiveContinueCount == 1) this._state.variablesState.batchObservingVariableChanges = false;",
            "        this._asyncContinueActive = false;",
            "        if (this.onDidContinue !== null) this.onDidContinue();",
            "      }",
            "      this._recursiveContinueCount--;",
            "      if (this._profiler != null) this._profiler.PostContinue();",
            "      // In the following code, we're masking a lot of non-null assertion,",
            "      // because testing for against `hasError` or `hasWarning` makes sure",
            "      // the arrays are present and contain at least one element.",
            "      if (this.state.hasError || this.state.hasWarning) {",
            "        if (this.onError !== null) {",
            "          if (this.state.hasError) {",
            "            for (let err of this.state.currentErrors) {",
            "              this.onError(err, ErrorType.Error);",
            "            }",
            "          }",
            "          if (this.state.hasWarning) {",
            "            for (let err of this.state.currentWarnings) {",
            "              this.onError(err, ErrorType.Warning);",
            "            }",
            "          }",
            "          this.ResetErrors();",
            "        } else {",
            "          let sb = new StringBuilder();",
            "          sb.Append(\"Ink had \");",
            "          if (this.state.hasError) {",
            "            sb.Append(`${this.state.currentErrors.length}`);",
            "            sb.Append(this.state.currentErrors.length == 1 ? \" error\" : \"errors\");",
            "            if (this.state.hasWarning) sb.Append(\" and \");",
            "          }",
            "          if (this.state.hasWarning) {",
            "            sb.Append(`${this.state.currentWarnings.length}`);",
            "            sb.Append(this.state.currentWarnings.length == 1 ? \" warning\" : \"warnings\");",
            "            if (this.state.hasWarning) sb.Append(\" and \");",
            "          }",
            "          sb.Append(\". It is strongly suggested that you assign an error handler to story.onError. The first issue was: \");",
            "          sb.Append(this.state.hasError ? this.state.currentErrors[0] : this.state.currentWarnings[0]);",
            "          throw new StoryException(sb.toString());",
            "        }",
            "      }",
            "    }",
            "    ContinueSingleStep() {",
            "      if (this._profiler != null) this._profiler.PreStep();",
            "      this.Step();",
            "      if (this._profiler != null) this._profiler.PostStep();",
            "      if (!this.canContinue && !this.state.callStack.elementIsEvaluateFromGame) {",
            "        this.TryFollowDefaultInvisibleChoice();",
            "      }",
            "      if (this._profiler != null) this._profiler.PreSnapshot();",
            "      if (!this.state.inStringEvaluation) {",
            "        if (this._stateSnapshotAtLastNewline !== null) {",
            "          if (this._stateSnapshotAtLastNewline.currentTags === null) {",
            "            return throwNullException(\"this._stateAtLastNewline.currentTags\");",
            "          }",
            "          if (this.state.currentTags === null) {",
            "            return throwNullException(\"this.state.currentTags\");",
            "          }",
            "          let change = this.CalculateNewlineOutputStateChange(this._stateSnapshotAtLastNewline.currentText, this.state.currentText, this._stateSnapshotAtLastNewline.currentTags.length, this.state.currentTags.length);",
            "          if (change == Story$1.OutputStateChange.ExtendedBeyondNewline || this._sawLookaheadUnsafeFunctionAfterNewline) {",
            "            this.RestoreStateSnapshot();",
            "            return true;",
            "          } else if (change == Story$1.OutputStateChange.NewlineRemoved) {",
            "            this.DiscardSnapshot();",
            "          }",
            "        }",
            "        if (this.state.outputStreamEndsInNewline) {",
            "          if (this.canContinue) {",
            "            if (this._stateSnapshotAtLastNewline == null) this.StateSnapshot();",
            "          } else {",
            "            this.DiscardSnapshot();",
            "          }",
            "        }",
            "      }",
            "      if (this._profiler != null) this._profiler.PostSnapshot();",
            "      return false;",
            "    }",
            "    CalculateNewlineOutputStateChange(prevText, currText, prevTagCount, currTagCount) {",
            "      if (prevText === null) {",
            "        return throwNullException(\"prevText\");",
            "      }",
            "      if (currText === null) {",
            "        return throwNullException(\"currText\");",
            "      }",
            "      let newlineStillExists = currText.length >= prevText.length && prevText.length > 0 && currText.charAt(prevText.length - 1) == \"\\n\";",
            "      if (prevTagCount == currTagCount && prevText.length == currText.length && newlineStillExists) return Story$1.OutputStateChange.NoChange;",
            "      if (!newlineStillExists) {",
            "        return Story$1.OutputStateChange.NewlineRemoved;",
            "      }",
            "      if (currTagCount > prevTagCount) return Story$1.OutputStateChange.ExtendedBeyondNewline;",
            "      for (let i = prevText.length; i < currText.length; i++) {",
            "        let c = currText.charAt(i);",
            "        if (c != \" \" && c != \"\\t\") {",
            "          return Story$1.OutputStateChange.ExtendedBeyondNewline;",
            "        }",
            "      }",
            "      return Story$1.OutputStateChange.NoChange;",
            "    }",
            "    ContinueMaximally() {",
            "      this.IfAsyncWeCant(\"ContinueMaximally\");",
            "      let sb = new StringBuilder();",
            "      while (this.canContinue) {",
            "        sb.Append(this.Continue());",
            "      }",
            "      return sb.toString();",
            "    }",
            "    ContentAtPath(path) {",
            "      return this.mainContentContainer.ContentAtPath(path);",
            "    }",
            "    KnotContainerWithName(name) {",
            "      let namedContainer = this.mainContentContainer.namedContent.get(name);",
            "      if (namedContainer instanceof Container) return namedContainer;else return null;",
            "    }",
            "    PointerAtPath(path) {",
            "      if (path.length == 0) return Pointer.Null;",
            "      let p = new Pointer();",
            "      let pathLengthToUse = path.length;",
            "      let result = null;",
            "      if (path.lastComponent === null) {",
            "        return throwNullException(\"path.lastComponent\");",
            "      }",
            "      if (path.lastComponent.isIndex) {",
            "        pathLengthToUse = path.length - 1;",
            "        result = this.mainContentContainer.ContentAtPath(path, undefined, pathLengthToUse);",
            "        p.container = result.container;",
            "        p.index = path.lastComponent.index;",
            "      } else {",
            "        result = this.mainContentContainer.ContentAtPath(path);",
            "        p.container = result.container;",
            "        p.index = -1;",
            "      }",
            "      if (result.obj == null || result.obj == this.mainContentContainer && pathLengthToUse > 0) {",
            "        this.Error(\"Failed to find content at path '\" + path + \"', and no approximation of it was possible.\");",
            "      } else if (result.approximate) this.Warning(\"Failed to find content at path '\" + path + \"', so it was approximated to: '\" + result.obj.path + \"'.\");",
            "      return p;",
            "    }",
            "    StateSnapshot() {",
            "      this._stateSnapshotAtLastNewline = this._state;",
            "      this._state = this._state.CopyAndStartPatching();",
            "    }",
            "    RestoreStateSnapshot() {",
            "      if (this._stateSnapshotAtLastNewline === null) {",
            "        throwNullException(\"_stateSnapshotAtLastNewline\");",
            "      }",
            "      this._stateSnapshotAtLastNewline.RestoreAfterPatch();",
            "      this._state = this._stateSnapshotAtLastNewline;",
            "      this._stateSnapshotAtLastNewline = null;",
            "      if (!this._asyncSaving) {",
            "        this._state.ApplyAnyPatch();",
            "      }",
            "    }",
            "    DiscardSnapshot() {",
            "      if (!this._asyncSaving) this._state.ApplyAnyPatch();",
            "      this._stateSnapshotAtLastNewline = null;",
            "    }",
            "    CopyStateForBackgroundThreadSave() {",
            "      this.IfAsyncWeCant(\"start saving on a background thread\");",
            "      if (this._asyncSaving) throw new Error(\"Story is already in background saving mode, can't call CopyStateForBackgroundThreadSave again!\");",
            "      let stateToSave = this._state;",
            "      this._state = this._state.CopyAndStartPatching();",
            "      this._asyncSaving = true;",
            "      return stateToSave;",
            "    }",
            "    BackgroundSaveComplete() {",
            "      if (this._stateSnapshotAtLastNewline === null) {",
            "        this._state.ApplyAnyPatch();",
            "      }",
            "      this._asyncSaving = false;",
            "    }",
            "    Step() {",
            "      let shouldAddToStream = true;",
            "      let pointer = this.state.currentPointer.copy();",
            "      if (pointer.isNull) {",
            "        return;",
            "      }",
            "      // Container containerToEnter = pointer.Resolve () as Container;",
            "      let containerToEnter = asOrNull(pointer.Resolve(), Container);",
            "      while (containerToEnter) {",
            "        this.VisitContainer(containerToEnter, true);",
            "        // No content? the most we can do is step past it",
            "        if (containerToEnter.content.length == 0) {",
            "          break;",
            "        }",
            "        pointer = Pointer.StartOf(containerToEnter);",
            "        // containerToEnter = pointer.Resolve() as Container;",
            "        containerToEnter = asOrNull(pointer.Resolve(), Container);",
            "      }",
            "      this.state.currentPointer = pointer.copy();",
            "      if (this._profiler != null) this._profiler.Step(this.state.callStack);",
            "      // Is the current content object:",
            "      //  - Normal content",
            "      //  - Or a logic/flow statement - if so, do it",
            "      // Stop flow if we hit a stack pop when we're unable to pop (e.g. return/done statement in knot",
            "      // that was diverted to rather than called as a function)",
            "      let currentContentObj = pointer.Resolve();",
            "      let isLogicOrFlowControl = this.PerformLogicAndFlowControl(currentContentObj);",
            "      // Has flow been forced to end by flow control above?",
            "      if (this.state.currentPointer.isNull) {",
            "        return;",
            "      }",
            "      if (isLogicOrFlowControl) {",
            "        shouldAddToStream = false;",
            "      }",
            "      // Choice with condition?",
            "      // var choicePoint = currentContentObj as ChoicePoint;",
            "      let choicePoint = asOrNull(currentContentObj, ChoicePoint);",
            "      if (choicePoint) {",
            "        let choice = this.ProcessChoice(choicePoint);",
            "        if (choice) {",
            "          this.state.generatedChoices.push(choice);",
            "        }",
            "        currentContentObj = null;",
            "        shouldAddToStream = false;",
            "      }",
            "      // If the container has no content, then it will be",
            "      // the \"content\" itself, but we skip over it.",
            "      if (currentContentObj instanceof Container) {",
            "        shouldAddToStream = false;",
            "      }",
            "      // Content to add to evaluation stack or the output stream",
            "      if (shouldAddToStream) {",
            "        // If we're pushing a variable pointer onto the evaluation stack, ensure that it's specific",
            "        // to our current (possibly temporary) context index. And make a copy of the pointer",
            "        // so that we're not editing the original runtime object.",
            "        // var varPointer = currentContentObj as VariablePointerValue;",
            "        let varPointer = asOrNull(currentContentObj, VariablePointerValue);",
            "        if (varPointer && varPointer.contextIndex == -1) {",
            "          // Create new object so we're not overwriting the story's own data",
            "          let contextIdx = this.state.callStack.ContextForVariableNamed(varPointer.variableName);",
            "          currentContentObj = new VariablePointerValue(varPointer.variableName, contextIdx);",
            "        }",
            "        // Expression evaluation content",
            "        if (this.state.inExpressionEvaluation) {",
            "          this.state.PushEvaluationStack(currentContentObj);",
            "        }",
            "        // Output stream content (i.e. not expression evaluation)",
            "        else {",
            "          this.state.PushToOutputStream(currentContentObj);",
            "        }",
            "      }",
            "      // Increment the content pointer, following diverts if necessary",
            "      this.NextContent();",
            "      // Starting a thread should be done after the increment to the content pointer,",
            "      // so that when returning from the thread, it returns to the content after this instruction.",
            "      // var controlCmd = currentContentObj as ;",
            "      let controlCmd = asOrNull(currentContentObj, ControlCommand);",
            "      if (controlCmd && controlCmd.commandType == ControlCommand.CommandType.StartThread) {",
            "        this.state.callStack.PushThread();",
            "      }",
            "    }",
            "    VisitContainer(container, atStart) {",
            "      if (!container.countingAtStartOnly || atStart) {",
            "        if (container.visitsShouldBeCounted) this.state.IncrementVisitCountForContainer(container);",
            "        if (container.turnIndexShouldBeCounted) this.state.RecordTurnIndexVisitToContainer(container);",
            "      }",
            "    }",
            "    VisitChangedContainersDueToDivert() {",
            "      let previousPointer = this.state.previousPointer.copy();",
            "      let pointer = this.state.currentPointer.copy();",
            "      if (pointer.isNull || pointer.index == -1) return;",
            "      this._prevContainers.length = 0;",
            "      if (!previousPointer.isNull) {",
            "        // Container prevAncestor = previousPointer.Resolve() as Container ?? previousPointer.container as Container;",
            "        let resolvedPreviousAncestor = previousPointer.Resolve();",
            "        let prevAncestor = asOrNull(resolvedPreviousAncestor, Container) || asOrNull(previousPointer.container, Container);",
            "        while (prevAncestor) {",
            "          this._prevContainers.push(prevAncestor);",
            "          // prevAncestor = prevAncestor.parent as Container;",
            "          prevAncestor = asOrNull(prevAncestor.parent, Container);",
            "        }",
            "      }",
            "      let currentChildOfContainer = pointer.Resolve();",
            "      if (currentChildOfContainer == null) return;",
            "      // Container currentContainerAncestor = currentChildOfContainer.parent as Container;",
            "      let currentContainerAncestor = asOrNull(currentChildOfContainer.parent, Container);",
            "      let allChildrenEnteredAtStart = true;",
            "      while (currentContainerAncestor && (this._prevContainers.indexOf(currentContainerAncestor) < 0 || currentContainerAncestor.countingAtStartOnly)) {",
            "        // Check whether this ancestor container is being entered at the start,",
            "        // by checking whether the child object is the first.",
            "        let enteringAtStart = currentContainerAncestor.content.length > 0 && currentChildOfContainer == currentContainerAncestor.content[0] && allChildrenEnteredAtStart;",
            "        if (!enteringAtStart) allChildrenEnteredAtStart = false;",
            "        // Mark a visit to this container",
            "        this.VisitContainer(currentContainerAncestor, enteringAtStart);",
            "        currentChildOfContainer = currentContainerAncestor;",
            "        // currentContainerAncestor = currentContainerAncestor.parent as Container;",
            "        currentContainerAncestor = asOrNull(currentContainerAncestor.parent, Container);",
            "      }",
            "    }",
            "    PopChoiceStringAndTags(tags) {",
            "      let choiceOnlyStrVal = asOrThrows(this.state.PopEvaluationStack(), StringValue);",
            "      while (this.state.evaluationStack.length > 0 && asOrNull(this.state.PeekEvaluationStack(), Tag$1) != null) {",
            "        let tag = asOrNull(this.state.PopEvaluationStack(), Tag$1);",
            "        if (tag) tags.push(tag.text);",
            "      }",
            "      return choiceOnlyStrVal.value;",
            "    }",
            "    ProcessChoice(choicePoint) {",
            "      let showChoice = true;",
            "      // Don't create choice if choice point doesn't pass conditional",
            "      if (choicePoint.hasCondition) {",
            "        let conditionValue = this.state.PopEvaluationStack();",
            "        if (!this.IsTruthy(conditionValue)) {",
            "          showChoice = false;",
            "        }",
            "      }",
            "      let startText = \"\";",
            "      let choiceOnlyText = \"\";",
            "      let tags = [];",
            "      if (choicePoint.hasChoiceOnlyContent) {",
            "        choiceOnlyText = this.PopChoiceStringAndTags(tags) || \"\";",
            "      }",
            "      if (choicePoint.hasStartContent) {",
            "        startText = this.PopChoiceStringAndTags(tags) || \"\";",
            "      }",
            "      // Don't create choice if player has already read this content",
            "      if (choicePoint.onceOnly) {",
            "        let visitCount = this.state.VisitCountForContainer(choicePoint.choiceTarget);",
            "        if (visitCount > 0) {",
            "          showChoice = false;",
            "        }",
            "      }",
            "      // We go through the full process of creating the choice above so",
            "      // that we consume the content for it, since otherwise it'll",
            "      // be shown on the output stream.",
            "      if (!showChoice) {",
            "        return null;",
            "      }",
            "      let choice = new Choice();",
            "      choice.targetPath = choicePoint.pathOnChoice;",
            "      choice.sourcePath = choicePoint.path.toString();",
            "      choice.isInvisibleDefault = choicePoint.isInvisibleDefault;",
            "      choice.threadAtGeneration = this.state.callStack.ForkThread();",
            "      choice.tags = tags.reverse(); //C# is a stack",
            "      choice.text = (startText + choiceOnlyText).replace(/^[ \\t]+|[ \\t]+$/g, \"\");",
            "      return choice;",
            "    }",
            "    IsTruthy(obj) {",
            "      let truthy = false;",
            "      if (obj instanceof Value) {",
            "        let val = obj;",
            "        if (val instanceof DivertTargetValue) {",
            "          let divTarget = val;",
            "          this.Error(\"Shouldn't use a divert target (to \" + divTarget.targetPath + \") as a conditional value. Did you intend a function call 'likeThis()' or a read count check 'likeThis'? (no arrows)\");",
            "          return false;",
            "        }",
            "        return val.isTruthy;",
            "      }",
            "      return truthy;",
            "    }",
            "    PerformLogicAndFlowControl(contentObj) {",
            "      if (contentObj == null) {",
            "        return false;",
            "      }",
            "      // Divert",
            "      if (contentObj instanceof Divert$1) {",
            "        let currentDivert = contentObj;",
            "        if (currentDivert.isConditional) {",
            "          let conditionValue = this.state.PopEvaluationStack();",
            "          // False conditional? Cancel divert",
            "          if (!this.IsTruthy(conditionValue)) return true;",
            "        }",
            "        if (currentDivert.hasVariableTarget) {",
            "          let varName = currentDivert.variableDivertName;",
            "          let varContents = this.state.variablesState.GetVariableWithName(varName);",
            "          if (varContents == null) {",
            "            this.Error(\"Tried to divert using a target from a variable that could not be found (\" + varName + \")\");",
            "          } else if (!(varContents instanceof DivertTargetValue)) {",
            "            // var intContent = varContents as IntValue;",
            "            let intContent = asOrNull(varContents, IntValue);",
            "            let errorMessage = \"Tried to divert to a target from a variable, but the variable (\" + varName + \") didn't contain a divert target, it \";",
            "            if (intContent instanceof IntValue && intContent.value == 0) {",
            "              errorMessage += \"was empty/null (the value 0).\";",
            "            } else {",
            "              errorMessage += \"contained '\" + varContents + \"'.\";",
            "            }",
            "            this.Error(errorMessage);",
            "          }",
            "          let target = asOrThrows(varContents, DivertTargetValue);",
            "          this.state.divertedPointer = this.PointerAtPath(target.targetPath);",
            "        } else if (currentDivert.isExternal) {",
            "          this.CallExternalFunction(currentDivert.targetPathString, currentDivert.externalArgs);",
            "          return true;",
            "        } else {",
            "          this.state.divertedPointer = currentDivert.targetPointer.copy();",
            "        }",
            "        if (currentDivert.pushesToStack) {",
            "          this.state.callStack.Push(currentDivert.stackPushType, undefined, this.state.outputStream.length);",
            "        }",
            "        if (this.state.divertedPointer.isNull && !currentDivert.isExternal) {",
            "          if (currentDivert && currentDivert.debugMetadata && currentDivert.debugMetadata.sourceName != null) {",
            "            this.Error(\"Divert target doesn't exist: \" + currentDivert.debugMetadata.sourceName);",
            "          } else {",
            "            this.Error(\"Divert resolution failed: \" + currentDivert);",
            "          }",
            "        }",
            "        return true;",
            "      }",
            "      // Start/end an expression evaluation? Or print out the result?",
            "      else if (contentObj instanceof ControlCommand) {",
            "        let evalCommand = contentObj;",
            "        switch (evalCommand.commandType) {",
            "          case ControlCommand.CommandType.EvalStart:",
            "            this.Assert(this.state.inExpressionEvaluation === false, \"Already in expression evaluation?\");",
            "            this.state.inExpressionEvaluation = true;",
            "            break;",
            "          case ControlCommand.CommandType.EvalEnd:",
            "            this.Assert(this.state.inExpressionEvaluation === true, \"Not in expression evaluation mode\");",
            "            this.state.inExpressionEvaluation = false;",
            "            break;",
            "          case ControlCommand.CommandType.EvalOutput:",
            "            // If the expression turned out to be empty, there may not be anything on the stack",
            "            if (this.state.evaluationStack.length > 0) {",
            "              let output = this.state.PopEvaluationStack();",
            "              // Functions may evaluate to Void, in which case we skip output",
            "              if (!(output instanceof Void)) {",
            "                // TODO: Should we really always blanket convert to string?",
            "                // It would be okay to have numbers in the output stream the",
            "                // only problem is when exporting text for viewing, it skips over numbers etc.",
            "                let text = new StringValue(output.toString());",
            "                this.state.PushToOutputStream(text);",
            "              }",
            "            }",
            "            break;",
            "          case ControlCommand.CommandType.NoOp:",
            "            break;",
            "          case ControlCommand.CommandType.Duplicate:",
            "            this.state.PushEvaluationStack(this.state.PeekEvaluationStack());",
            "            break;",
            "          case ControlCommand.CommandType.PopEvaluatedValue:",
            "            this.state.PopEvaluationStack();",
            "            break;",
            "          case ControlCommand.CommandType.PopFunction:",
            "          case ControlCommand.CommandType.PopTunnel:",
            "            let popType = evalCommand.commandType == ControlCommand.CommandType.PopFunction ? PushPopType.Function : PushPopType.Tunnel;",
            "            let overrideTunnelReturnTarget = null;",
            "            if (popType == PushPopType.Tunnel) {",
            "              let popped = this.state.PopEvaluationStack();",
            "              // overrideTunnelReturnTarget = popped as DivertTargetValue;",
            "              overrideTunnelReturnTarget = asOrNull(popped, DivertTargetValue);",
            "              if (overrideTunnelReturnTarget === null) {",
            "                this.Assert(popped instanceof Void, \"Expected void if ->-> doesn't override target\");",
            "              }",
            "            }",
            "            if (this.state.TryExitFunctionEvaluationFromGame()) {",
            "              break;",
            "            } else if (this.state.callStack.currentElement.type != popType || !this.state.callStack.canPop) {",
            "              let names = new Map();",
            "              names.set(PushPopType.Function, \"function return statement (~ return)\");",
            "              names.set(PushPopType.Tunnel, \"tunnel onwards statement (->->)\");",
            "              let expected = names.get(this.state.callStack.currentElement.type);",
            "              if (!this.state.callStack.canPop) {",
            "                expected = \"end of flow (-> END or choice)\";",
            "              }",
            "              let errorMsg = \"Found \" + names.get(popType) + \", when expected \" + expected;",
            "              this.Error(errorMsg);",
            "            } else {",
            "              this.state.PopCallStack();",
            "              if (overrideTunnelReturnTarget) this.state.divertedPointer = this.PointerAtPath(overrideTunnelReturnTarget.targetPath);",
            "            }",
            "            break;",
            "          case ControlCommand.CommandType.BeginString:",
            "            this.state.PushToOutputStream(evalCommand);",
            "            this.Assert(this.state.inExpressionEvaluation === true, \"Expected to be in an expression when evaluating a string\");",
            "            this.state.inExpressionEvaluation = false;",
            "            break;",
            "          // Leave it to story.currentText and story.currentTags to sort out the text from the tags",
            "          // This is mostly because we can't always rely on the existence of EndTag, and we don't want",
            "          // to try and flatten dynamic tags to strings every time \\n is pushed to output",
            "          case ControlCommand.CommandType.BeginTag:",
            "            this.state.PushToOutputStream(evalCommand);",
            "            break;",
            "          // EndTag has 2 modes:",
            "          //  - When in string evaluation (for choices)",
            "          //  - Normal",
            "          //",
            "          // The only way you could have an EndTag in the middle of",
            "          // string evaluation is if we're currently generating text for a",
            "          // choice, such as:",
            "          //",
            "          //   + choice # tag",
            "          //",
            "          // In the above case, the ink will be run twice:",
            "          //  - First, to generate the choice text. String evaluation",
            "          //    will be on, and the final string will be pushed to the",
            "          //    evaluation stack, ready to be popped to make a Choice",
            "          //    object.",
            "          //  - Second, when ink generates text after choosing the choice.",
            "          //    On this ocassion, it's not in string evaluation mode.",
            "          //",
            "          // On the writing side, we disallow manually putting tags within",
            "          // strings like this:",
            "          //",
            "          //   {\"hello # world\"}",
            "          //",
            "          // So we know that the tag must be being generated as part of",
            "          // choice content. Therefore, when the tag has been generated,",
            "          // we push it onto the evaluation stack in the exact same way",
            "          // as the string for the choice content.",
            "          case ControlCommand.CommandType.EndTag:",
            "            {",
            "              if (this.state.inStringEvaluation) {",
            "                let contentStackForTag = [];",
            "                let outputCountConsumed = 0;",
            "                for (let i = this.state.outputStream.length - 1; i >= 0; --i) {",
            "                  let obj = this.state.outputStream[i];",
            "                  outputCountConsumed++;",
            "                  // var command = obj as ControlCommand;",
            "                  let command = asOrNull(obj, ControlCommand);",
            "                  if (command != null) {",
            "                    if (command.commandType == ControlCommand.CommandType.BeginTag) {",
            "                      break;",
            "                    } else {",
            "                      this.Error(\"Unexpected ControlCommand while extracting tag from choice\");",
            "                      break;",
            "                    }",
            "                  }",
            "                  if (obj instanceof StringValue) {",
            "                    contentStackForTag.push(obj);",
            "                  }",
            "                }",
            "                // Consume the content that was produced for this string",
            "                this.state.PopFromOutputStream(outputCountConsumed);",
            "                // Build string out of the content we collected",
            "                let sb = new StringBuilder();",
            "                for (let strVal of contentStackForTag) {",
            "                  sb.Append(strVal.toString());",
            "                }",
            "                let choiceTag = new Tag$1(this.state.CleanOutputWhitespace(sb.toString()));",
            "                // Pushing to the evaluation stack means it gets picked up",
            "                // when a Choice is generated from the next Choice Point.",
            "                this.state.PushEvaluationStack(choiceTag);",
            "              } else {",
            "                // Otherwise! Simply push EndTag, so that in the output stream we",
            "                // have a structure of: [BeginTag, \"the tag content\", EndTag]",
            "                this.state.PushToOutputStream(evalCommand);",
            "              }",
            "              break;",
            "            }",
            "          case ControlCommand.CommandType.EndString:",
            "            {",
            "              let contentStackForString = [];",
            "              let contentToRetain = [];",
            "              let outputCountConsumed = 0;",
            "              for (let i = this.state.outputStream.length - 1; i >= 0; --i) {",
            "                let obj = this.state.outputStream[i];",
            "                outputCountConsumed++;",
            "                // var command = obj as ControlCommand;",
            "                let command = asOrNull(obj, ControlCommand);",
            "                if (command && command.commandType == ControlCommand.CommandType.BeginString) {",
            "                  break;",
            "                }",
            "                if (obj instanceof Tag$1) {",
            "                  contentToRetain.push(obj);",
            "                }",
            "                if (obj instanceof StringValue) {",
            "                  contentStackForString.push(obj);",
            "                }",
            "              }",
            "              // Consume the content that was produced for this string",
            "              this.state.PopFromOutputStream(outputCountConsumed);",
            "              // Rescue the tags that we want actually to keep on the output stack",
            "              // rather than consume as part of the string we're building.",
            "              // At the time of writing, this only applies to Tag objects generated",
            "              // by choices, which are pushed to the stack during string generation.",
            "              for (let rescuedTag of contentToRetain) this.state.PushToOutputStream(rescuedTag);",
            "              // The C# version uses a Stack for contentStackForString, but we're",
            "              // using a simple array, so we need to reverse it before using it",
            "              contentStackForString = contentStackForString.reverse();",
            "              // Build string out of the content we collected",
            "              let sb = new StringBuilder();",
            "              for (let c of contentStackForString) {",
            "                sb.Append(c.toString());",
            "              }",
            "              // Return to expression evaluation (from content mode)",
            "              this.state.inExpressionEvaluation = true;",
            "              this.state.PushEvaluationStack(new StringValue(sb.toString()));",
            "              break;",
            "            }",
            "          case ControlCommand.CommandType.ChoiceCount:",
            "            let choiceCount = this.state.generatedChoices.length;",
            "            this.state.PushEvaluationStack(new IntValue(choiceCount));",
            "            break;",
            "          case ControlCommand.CommandType.Turns:",
            "            this.state.PushEvaluationStack(new IntValue(this.state.currentTurnIndex + 1));",
            "            break;",
            "          case ControlCommand.CommandType.TurnsSince:",
            "          case ControlCommand.CommandType.ReadCount:",
            "            let target = this.state.PopEvaluationStack();",
            "            if (!(target instanceof DivertTargetValue)) {",
            "              let extraNote = \"\";",
            "              if (target instanceof IntValue) extraNote = \". Did you accidentally pass a read count ('knot_name') instead of a target ('-> knot_name')?\";",
            "              this.Error(\"TURNS_SINCE / READ_COUNT expected a divert target (knot, stitch, label name), but saw \" + target + extraNote);",
            "              break;",
            "            }",
            "            // var divertTarget = target as DivertTargetValue;",
            "            let divertTarget = asOrThrows(target, DivertTargetValue);",
            "            // var container = ContentAtPath (divertTarget.targetPath).correctObj as Container;",
            "            let container = asOrNull(this.ContentAtPath(divertTarget.targetPath).correctObj, Container);",
            "            let eitherCount;",
            "            if (container != null) {",
            "              if (evalCommand.commandType == ControlCommand.CommandType.TurnsSince) eitherCount = this.state.TurnsSinceForContainer(container);else eitherCount = this.state.VisitCountForContainer(container);",
            "            } else {",
            "              if (evalCommand.commandType == ControlCommand.CommandType.TurnsSince) eitherCount = -1;else eitherCount = 0;",
            "              this.Warning(\"Failed to find container for \" + evalCommand.toString() + \" lookup at \" + divertTarget.targetPath.toString());",
            "            }",
            "            this.state.PushEvaluationStack(new IntValue(eitherCount));",
            "            break;",
            "          case ControlCommand.CommandType.Random:",
            "            {",
            "              let maxInt = asOrNull(this.state.PopEvaluationStack(), IntValue);",
            "              let minInt = asOrNull(this.state.PopEvaluationStack(), IntValue);",
            "              if (minInt == null || minInt instanceof IntValue === false) return this.Error(\"Invalid value for minimum parameter of RANDOM(min, max)\");",
            "              if (maxInt == null || maxInt instanceof IntValue === false) return this.Error(\"Invalid value for maximum parameter of RANDOM(min, max)\");",
            "              // Originally a primitive type, but here, can be null.",
            "              // TODO: Replace by default value?",
            "              if (maxInt.value === null) {",
            "                return throwNullException(\"maxInt.value\");",
            "              }",
            "              if (minInt.value === null) {",
            "                return throwNullException(\"minInt.value\");",
            "              }",
            "              // This code is differs a bit from the reference implementation, since",
            "              // JavaScript has no true integers. Hence integer arithmetics and",
            "              // interger overflows don't apply here. A loss of precision can",
            "              // happen with big numbers however.",
            "              //",
            "              // The case where 'randomRange' is lower than zero is handled below,",
            "              // so there's no need to test against Number.MIN_SAFE_INTEGER.",
            "              let randomRange = maxInt.value - minInt.value + 1;",
            "              if (!isFinite(randomRange) || randomRange > Number.MAX_SAFE_INTEGER) {",
            "                randomRange = Number.MAX_SAFE_INTEGER;",
            "                this.Error(\"RANDOM was called with a range that exceeds the size that ink numbers can use.\");",
            "              }",
            "              if (randomRange <= 0) this.Error(\"RANDOM was called with minimum as \" + minInt.value + \" and maximum as \" + maxInt.value + \". The maximum must be larger\");",
            "              let resultSeed = this.state.storySeed + this.state.previousRandom;",
            "              let random = new PRNG(resultSeed);",
            "              let nextRandom = random.next();",
            "              let chosenValue = nextRandom % randomRange + minInt.value;",
            "              this.state.PushEvaluationStack(new IntValue(chosenValue));",
            "              // Next random number (rather than keeping the Random object around)",
            "              this.state.previousRandom = nextRandom;",
            "              break;",
            "            }",
            "          case ControlCommand.CommandType.SeedRandom:",
            "            let seed = asOrNull(this.state.PopEvaluationStack(), IntValue);",
            "            if (seed == null || seed instanceof IntValue === false) return this.Error(\"Invalid value passed to SEED_RANDOM\");",
            "            // Originally a primitive type, but here, can be null.",
            "            // TODO: Replace by default value?",
            "            if (seed.value === null) {",
            "              return throwNullException(\"minInt.value\");",
            "            }",
            "            this.state.storySeed = seed.value;",
            "            this.state.previousRandom = 0;",
            "            this.state.PushEvaluationStack(new Void());",
            "            break;",
            "          case ControlCommand.CommandType.VisitIndex:",
            "            let count = this.state.VisitCountForContainer(this.state.currentPointer.container) - 1; // index not count",
            "            this.state.PushEvaluationStack(new IntValue(count));",
            "            break;",
            "          case ControlCommand.CommandType.SequenceShuffleIndex:",
            "            let shuffleIndex = this.NextSequenceShuffleIndex();",
            "            this.state.PushEvaluationStack(new IntValue(shuffleIndex));",
            "            break;",
            "          case ControlCommand.CommandType.StartThread:",
            "            // Handled in main step function",
            "            break;",
            "          case ControlCommand.CommandType.Done:",
            "            // We may exist in the context of the initial",
            "            // act of creating the thread, or in the context of",
            "            // evaluating the content.",
            "            if (this.state.callStack.canPopThread) {",
            "              this.state.callStack.PopThread();",
            "            }",
            "            // In normal flow - allow safe exit without warning",
            "            else {",
            "              this.state.didSafeExit = true;",
            "              // Stop flow in current thread",
            "              this.state.currentPointer = Pointer.Null;",
            "            }",
            "            break;",
            "          // Force flow to end completely",
            "          case ControlCommand.CommandType.End:",
            "            this.state.ForceEnd();",
            "            break;",
            "          case ControlCommand.CommandType.ListFromInt:",
            "            // var intVal = state.PopEvaluationStack () as IntValue;",
            "            let intVal = asOrNull(this.state.PopEvaluationStack(), IntValue);",
            "            // var listNameVal = state.PopEvaluationStack () as StringValue;",
            "            let listNameVal = asOrThrows(this.state.PopEvaluationStack(), StringValue);",
            "            if (intVal === null) {",
            "              throw new StoryException(\"Passed non-integer when creating a list element from a numerical value.\");",
            "            }",
            "            let generatedListValue = null;",
            "            if (this.listDefinitions === null) {",
            "              return throwNullException(\"this.listDefinitions\");",
            "            }",
            "            let foundListDef = this.listDefinitions.TryListGetDefinition(listNameVal.value, null);",
            "            if (foundListDef.exists) {",
            "              // Originally a primitive type, but here, can be null.",
            "              // TODO: Replace by default value?",
            "              if (intVal.value === null) {",
            "                return throwNullException(\"minInt.value\");",
            "              }",
            "              let foundItem = foundListDef.result.TryGetItemWithValue(intVal.value, InkListItem.Null);",
            "              if (foundItem.exists) {",
            "                generatedListValue = new ListValue(foundItem.result, intVal.value);",
            "              }",
            "            } else {",
            "              throw new StoryException(\"Failed to find LIST called \" + listNameVal.value);",
            "            }",
            "            if (generatedListValue == null) generatedListValue = new ListValue();",
            "            this.state.PushEvaluationStack(generatedListValue);",
            "            break;",
            "          case ControlCommand.CommandType.ListRange:",
            "            let max = asOrNull(this.state.PopEvaluationStack(), Value);",
            "            let min = asOrNull(this.state.PopEvaluationStack(), Value);",
            "            // var targetList = state.PopEvaluationStack () as ListValue;",
            "            let targetList = asOrNull(this.state.PopEvaluationStack(), ListValue);",
            "            if (targetList === null || min === null || max === null) throw new StoryException(\"Expected list, minimum and maximum for LIST_RANGE\");",
            "            if (targetList.value === null) {",
            "              return throwNullException(\"targetList.value\");",
            "            }",
            "            let result = targetList.value.ListWithSubRange(min.valueObject, max.valueObject);",
            "            this.state.PushEvaluationStack(new ListValue(result));",
            "            break;",
            "          case ControlCommand.CommandType.ListRandom:",
            "            {",
            "              let listVal = this.state.PopEvaluationStack();",
            "              if (listVal === null) throw new StoryException(\"Expected list for LIST_RANDOM\");",
            "              let list = listVal.value;",
            "              let newList = null;",
            "              if (list === null) {",
            "                throw throwNullException(\"list\");",
            "              }",
            "              if (list.Count == 0) {",
            "                newList = new InkList();",
            "              } else {",
            "                // Generate a random index for the element to take",
            "                let resultSeed = this.state.storySeed + this.state.previousRandom;",
            "                let random = new PRNG(resultSeed);",
            "                let nextRandom = random.next();",
            "                let listItemIndex = nextRandom % list.Count;",
            "                // This bit is a little different from the original",
            "                // C# code, since iterators do not work in the same way.",
            "                // First, we iterate listItemIndex - 1 times, calling next().",
            "                // The listItemIndex-th time is made outside of the loop,",
            "                // in order to retrieve the value.",
            "                let listEnumerator = list.entries();",
            "                for (let i = 0; i <= listItemIndex - 1; i++) {",
            "                  listEnumerator.next();",
            "                }",
            "                let value = listEnumerator.next().value;",
            "                let randomItem = {",
            "                  Key: InkListItem.fromSerializedKey(value[0]),",
            "                  Value: value[1]",
            "                };",
            "                // Origin list is simply the origin of the one element",
            "                if (randomItem.Key.originName === null) {",
            "                  return throwNullException(\"randomItem.Key.originName\");",
            "                }",
            "                newList = new InkList(randomItem.Key.originName, this);",
            "                newList.Add(randomItem.Key, randomItem.Value);",
            "                this.state.previousRandom = nextRandom;",
            "              }",
            "              this.state.PushEvaluationStack(new ListValue(newList));",
            "              break;",
            "            }",
            "          default:",
            "            this.Error(\"unhandled ControlCommand: \" + evalCommand);",
            "            break;",
            "        }",
            "        return true;",
            "      }",
            "      // Variable assignment",
            "      else if (contentObj instanceof VariableAssignment$1) {",
            "        let varAss = contentObj;",
            "        let assignedVal = this.state.PopEvaluationStack();",
            "        this.state.variablesState.Assign(varAss, assignedVal);",
            "        return true;",
            "      }",
            "      // Variable reference",
            "      else if (contentObj instanceof VariableReference$1) {",
            "        let varRef = contentObj;",
            "        let foundValue = null;",
            "        // Explicit read count value",
            "        if (varRef.pathForCount != null) {",
            "          let container = varRef.containerForCount;",
            "          let count = this.state.VisitCountForContainer(container);",
            "          foundValue = new IntValue(count);",
            "        }",
            "        // Normal variable reference",
            "        else {",
            "          foundValue = this.state.variablesState.GetVariableWithName(varRef.name);",
            "          if (foundValue == null) {",
            "            this.Warning(\"Variable not found: '\" + varRef.name + \"'. Using default value of 0 (false). This can happen with temporary variables if the declaration hasn't yet been hit. Globals are always given a default value on load if a value doesn't exist in the save state.\");",
            "            foundValue = new IntValue(0);",
            "          }",
            "        }",
            "        this.state.PushEvaluationStack(foundValue);",
            "        return true;",
            "      }",
            "      // Native function call",
            "      else if (contentObj instanceof NativeFunctionCall) {",
            "        let func = contentObj;",
            "        let funcParams = this.state.PopEvaluationStack(func.numberOfParameters);",
            "        let result = func.Call(funcParams);",
            "        this.state.PushEvaluationStack(result);",
            "        return true;",
            "      }",
            "      // No control content, must be ordinary content",
            "      return false;",
            "    }",
            "    ChoosePathString(path) {",
            "      let resetCallstack = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;",
            "      let args = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [];",
            "      this.IfAsyncWeCant(\"call ChoosePathString right now\");",
            "      if (this.onChoosePathString !== null) this.onChoosePathString(path, args);",
            "      if (resetCallstack) {",
            "        this.ResetCallstack();",
            "      } else {",
            "        if (this.state.callStack.currentElement.type == PushPopType.Function) {",
            "          let funcDetail = \"\";",
            "          let container = this.state.callStack.currentElement.currentPointer.container;",
            "          if (container != null) {",
            "            funcDetail = \"(\" + container.path.toString() + \") \";",
            "          }",
            "          throw new Error(\"Story was running a function \" + funcDetail + \"when you called ChoosePathString(\" + path + \") - this is almost certainly not not what you want! Full stack trace: \\n\" + this.state.callStack.callStackTrace);",
            "        }",
            "      }",
            "      this.state.PassArgumentsToEvaluationStack(args);",
            "      this.ChoosePath(new Path$1(path));",
            "    }",
            "    IfAsyncWeCant(activityStr) {",
            "      if (this._asyncContinueActive) throw new Error(\"Can't \" + activityStr + \". Story is in the middle of a ContinueAsync(). Make more ContinueAsync() calls or a single Continue() call beforehand.\");",
            "    }",
            "    ChoosePath(p) {",
            "      let incrementingTurnIndex = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;",
            "      this.state.SetChosenPath(p, incrementingTurnIndex);",
            "      // Take a note of newly visited containers for read counts etc",
            "      this.VisitChangedContainersDueToDivert();",
            "    }",
            "    ChooseChoiceIndex(choiceIdx) {",
            "      choiceIdx = choiceIdx;",
            "      let choices = this.currentChoices;",
            "      this.Assert(choiceIdx >= 0 && choiceIdx < choices.length, \"choice out of range\");",
            "      let choiceToChoose = choices[choiceIdx];",
            "      if (this.onMakeChoice !== null) this.onMakeChoice(choiceToChoose);",
            "      if (choiceToChoose.threadAtGeneration === null) {",
            "        return throwNullException(\"choiceToChoose.threadAtGeneration\");",
            "      }",
            "      if (choiceToChoose.targetPath === null) {",
            "        return throwNullException(\"choiceToChoose.targetPath\");",
            "      }",
            "      this.state.callStack.currentThread = choiceToChoose.threadAtGeneration;",
            "      this.ChoosePath(choiceToChoose.targetPath);",
            "    }",
            "    HasFunction(functionName) {",
            "      try {",
            "        return this.KnotContainerWithName(functionName) != null;",
            "      } catch (e) {",
            "        return false;",
            "      }",
            "    }",
            "    EvaluateFunction(functionName) {",
            "      let args = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];",
            "      let returnTextOutput = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;",
            "      // EvaluateFunction behaves slightly differently than the C# version.",
            "      // In C#, you can pass a (second) parameter `out textOutput` to get the",
            "      // text outputted by the function. This is not possible in js. Instead,",
            "      // we maintain the regular signature (functionName, args), plus an",
            "      // optional third parameter returnTextOutput. If set to true, we will",
            "      // return both the textOutput and the returned value, as an object.",
            "      if (this.onEvaluateFunction !== null) this.onEvaluateFunction(functionName, args);",
            "      this.IfAsyncWeCant(\"evaluate a function\");",
            "      if (functionName == null) {",
            "        throw new Error(\"Function is null\");",
            "      } else if (functionName == \"\" || functionName.trim() == \"\") {",
            "        throw new Error(\"Function is empty or white space.\");",
            "      }",
            "      let funcContainer = this.KnotContainerWithName(functionName);",
            "      if (funcContainer == null) {",
            "        throw new Error(\"Function doesn't exist: '\" + functionName + \"'\");",
            "      }",
            "      let outputStreamBefore = [];",
            "      outputStreamBefore.push(...this.state.outputStream);",
            "      this._state.ResetOutput();",
            "      this.state.StartFunctionEvaluationFromGame(funcContainer, args);",
            "      // Evaluate the function, and collect the string output",
            "      let stringOutput = new StringBuilder();",
            "      while (this.canContinue) {",
            "        stringOutput.Append(this.Continue());",
            "      }",
            "      let textOutput = stringOutput.toString();",
            "      this._state.ResetOutput(outputStreamBefore);",
            "      let result = this.state.CompleteFunctionEvaluationFromGame();",
            "      if (this.onCompleteEvaluateFunction != null) this.onCompleteEvaluateFunction(functionName, args, textOutput, result);",
            "      return returnTextOutput ? {",
            "        returned: result,",
            "        output: textOutput",
            "      } : result;",
            "    }",
            "    EvaluateExpression(exprContainer) {",
            "      let startCallStackHeight = this.state.callStack.elements.length;",
            "      this.state.callStack.Push(PushPopType.Tunnel);",
            "      this._temporaryEvaluationContainer = exprContainer;",
            "      this.state.GoToStart();",
            "      let evalStackHeight = this.state.evaluationStack.length;",
            "      this.Continue();",
            "      this._temporaryEvaluationContainer = null;",
            "      // Should have fallen off the end of the Container, which should",
            "      // have auto-popped, but just in case we didn't for some reason,",
            "      // manually pop to restore the state (including currentPath).",
            "      if (this.state.callStack.elements.length > startCallStackHeight) {",
            "        this.state.PopCallStack();",
            "      }",
            "      let endStackHeight = this.state.evaluationStack.length;",
            "      if (endStackHeight > evalStackHeight) {",
            "        return this.state.PopEvaluationStack();",
            "      } else {",
            "        return null;",
            "      }",
            "    }",
            "    CallExternalFunction(funcName, numberOfArguments) {",
            "      if (funcName === null) {",
            "        return throwNullException(\"funcName\");",
            "      }",
            "      let funcDef = this._externals.get(funcName);",
            "      let fallbackFunctionContainer = null;",
            "      let foundExternal = typeof funcDef !== \"undefined\";",
            "      if (foundExternal && !funcDef.lookAheadSafe && this._stateSnapshotAtLastNewline !== null) {",
            "        this._sawLookaheadUnsafeFunctionAfterNewline = true;",
            "        return;",
            "      }",
            "      if (!foundExternal) {",
            "        if (this.allowExternalFunctionFallbacks) {",
            "          fallbackFunctionContainer = this.KnotContainerWithName(funcName);",
            "          this.Assert(fallbackFunctionContainer !== null, \"Trying to call EXTERNAL function '\" + funcName + \"' which has not been bound, and fallback ink function could not be found.\");",
            "          // Divert direct into fallback function and we're done",
            "          this.state.callStack.Push(PushPopType.Function, undefined, this.state.outputStream.length);",
            "          this.state.divertedPointer = Pointer.StartOf(fallbackFunctionContainer);",
            "          return;",
            "        } else {",
            "          this.Assert(false, \"Trying to call EXTERNAL function '\" + funcName + \"' which has not been bound (and ink fallbacks disabled).\");",
            "        }",
            "      }",
            "      // Pop arguments",
            "      let args = [];",
            "      for (let i = 0; i < numberOfArguments; ++i) {",
            "        // var poppedObj = state.PopEvaluationStack () as Value;",
            "        let poppedObj = asOrThrows(this.state.PopEvaluationStack(), Value);",
            "        let valueObj = poppedObj.valueObject;",
            "        args.push(valueObj);",
            "      }",
            "      // Reverse arguments from the order they were popped,",
            "      // so they're the right way round again.",
            "      args.reverse();",
            "      // Run the function!",
            "      let funcResult = funcDef.function(args);",
            "      // Convert return value (if any) to the a type that the ink engine can use",
            "      let returnObj = null;",
            "      if (funcResult != null) {",
            "        returnObj = Value.Create(funcResult);",
            "        this.Assert(returnObj !== null, \"Could not create ink value from returned object of type \" + typeof funcResult);",
            "      } else {",
            "        returnObj = new Void();",
            "      }",
            "      this.state.PushEvaluationStack(returnObj);",
            "    }",
            "    BindExternalFunctionGeneral(funcName, func) {",
            "      let lookaheadSafe = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;",
            "      this.IfAsyncWeCant(\"bind an external function\");",
            "      this.Assert(!this._externals.has(funcName), \"Function '\" + funcName + \"' has already been bound.\");",
            "      this._externals.set(funcName, {",
            "        function: func,",
            "        lookAheadSafe: lookaheadSafe",
            "      });",
            "    }",
            "    TryCoerce(value) {",
            "      // We're skipping type coercition in this implementation. First of, js",
            "      // is loosely typed, so it's not that important. Secondly, there is no",
            "      // clean way (AFAIK) for the user to describe what type of parameters",
            "      // they expect.",
            "      return value;",
            "    }",
            "    BindExternalFunction(funcName, func) {",
            "      let lookaheadSafe = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;",
            "      this.Assert(func != null, \"Can't bind a null function\");",
            "      this.BindExternalFunctionGeneral(funcName, args => {",
            "        this.Assert(args.length >= func.length, \"External function expected \" + func.length + \" arguments\");",
            "        let coercedArgs = [];",
            "        for (let i = 0, l = args.length; i < l; i++) {",
            "          coercedArgs[i] = this.TryCoerce(args[i]);",
            "        }",
            "        return func.apply(null, coercedArgs);",
            "      }, lookaheadSafe);",
            "    }",
            "    UnbindExternalFunction(funcName) {",
            "      this.IfAsyncWeCant(\"unbind an external a function\");",
            "      this.Assert(this._externals.has(funcName), \"Function '\" + funcName + \"' has not been bound.\");",
            "      this._externals.delete(funcName);",
            "    }",
            "    ValidateExternalBindings() {",
            "      let c = null;",
            "      let o = null;",
            "      let missingExternals = arguments[1] || new Set();",
            "      if (arguments[0] instanceof Container) {",
            "        c = arguments[0];",
            "      }",
            "      if (arguments[0] instanceof InkObject) {",
            "        o = arguments[0];",
            "      }",
            "      if (c === null && o === null) {",
            "        this.ValidateExternalBindings(this._mainContentContainer, missingExternals);",
            "        this._hasValidatedExternals = true;",
            "        // No problem! Validation complete",
            "        if (missingExternals.size == 0) {",
            "          this._hasValidatedExternals = true;",
            "        } else {",
            "          let message = \"Error: Missing function binding for external\";",
            "          message += missingExternals.size > 1 ? \"s\" : \"\";",
            "          message += \": '\";",
            "          message += Array.from(missingExternals).join(\"', '\");",
            "          message += \"' \";",
            "          message += this.allowExternalFunctionFallbacks ? \", and no fallback ink function found.\" : \" (ink fallbacks disabled)\";",
            "          this.Error(message);",
            "        }",
            "      } else if (c != null) {",
            "        for (let innerContent of c.content) {",
            "          let container = innerContent;",
            "          if (container == null || !container.hasValidName) this.ValidateExternalBindings(innerContent, missingExternals);",
            "        }",
            "        for (let [, value] of c.namedContent) {",
            "          this.ValidateExternalBindings(asOrNull(value, InkObject), missingExternals);",
            "        }",
            "      } else if (o != null) {",
            "        let divert = asOrNull(o, Divert$1);",
            "        if (divert && divert.isExternal) {",
            "          let name = divert.targetPathString;",
            "          if (name === null) {",
            "            return throwNullException(\"name\");",
            "          }",
            "          if (!this._externals.has(name)) {",
            "            if (this.allowExternalFunctionFallbacks) {",
            "              let fallbackFound = this.mainContentContainer.namedContent.has(name);",
            "              if (!fallbackFound) {",
            "                missingExternals.add(name);",
            "              }",
            "            } else {",
            "              missingExternals.add(name);",
            "            }",
            "          }",
            "        }",
            "      }",
            "    }",
            "    ObserveVariable(variableName, observer) {",
            "      this.IfAsyncWeCant(\"observe a new variable\");",
            "      if (this._variableObservers === null) this._variableObservers = new Map();",
            "      if (!this.state.variablesState.GlobalVariableExistsWithName(variableName)) throw new Error(\"Cannot observe variable '\" + variableName + \"' because it wasn't declared in the ink story.\");",
            "      if (this._variableObservers.has(variableName)) {",
            "        this._variableObservers.get(variableName).push(observer);",
            "      } else {",
            "        this._variableObservers.set(variableName, [observer]);",
            "      }",
            "    }",
            "    ObserveVariables(variableNames, observers) {",
            "      for (let i = 0, l = variableNames.length; i < l; i++) {",
            "        this.ObserveVariable(variableNames[i], observers[i]);",
            "      }",
            "    }",
            "    RemoveVariableObserver(observer, specificVariableName) {",
            "      // A couple of things to know about this method:",
            "      //",
            "      // 1. Since `RemoveVariableObserver` is exposed to the JavaScript world,",
            "      //    optionality is marked as `undefined` rather than `null`.",
            "      //    To keep things simple, null-checks are performed using regular",
            "      //    equality operators, where undefined == null.",
            "      //",
            "      // 2. Since C# delegates are translated to arrays of functions,",
            "      //    -= becomes a call to splice and null-checks are replaced by",
            "      //    emptiness-checks.",
            "      //",
            "      this.IfAsyncWeCant(\"remove a variable observer\");",
            "      if (this._variableObservers === null) return;",
            "      if (specificVariableName != null) {",
            "        if (this._variableObservers.has(specificVariableName)) {",
            "          if (observer != null) {",
            "            let variableObservers = this._variableObservers.get(specificVariableName);",
            "            if (variableObservers != null) {",
            "              variableObservers.splice(variableObservers.indexOf(observer), 1);",
            "              if (variableObservers.length === 0) {",
            "                this._variableObservers.delete(specificVariableName);",
            "              }",
            "            }",
            "          } else {",
            "            this._variableObservers.delete(specificVariableName);",
            "          }",
            "        }",
            "      } else if (observer != null) {",
            "        let keys = this._variableObservers.keys();",
            "        for (let varName of keys) {",
            "          let variableObservers = this._variableObservers.get(varName);",
            "          if (variableObservers != null) {",
            "            variableObservers.splice(variableObservers.indexOf(observer), 1);",
            "            if (variableObservers.length === 0) {",
            "              this._variableObservers.delete(varName);",
            "            }",
            "          }",
            "        }",
            "      }",
            "    }",
            "    VariableStateDidChangeEvent(variableName, newValueObj) {",
            "      if (this._variableObservers === null) return;",
            "      let observers = this._variableObservers.get(variableName);",
            "      if (typeof observers !== \"undefined\") {",
            "        if (!(newValueObj instanceof Value)) {",
            "          throw new Error(\"Tried to get the value of a variable that isn't a standard type\");",
            "        }",
            "        // var val = newValueObj as Value;",
            "        let val = asOrThrows(newValueObj, Value);",
            "        for (let observer of observers) {",
            "          observer(variableName, val.valueObject);",
            "        }",
            "      }",
            "    }",
            "    get globalTags() {",
            "      return this.TagsAtStartOfFlowContainerWithPathString(\"\");",
            "    }",
            "    TagsForContentAtPath(path) {",
            "      return this.TagsAtStartOfFlowContainerWithPathString(path);",
            "    }",
            "    TagsAtStartOfFlowContainerWithPathString(pathString) {",
            "      let path = new Path$1(pathString);",
            "      let flowContainer = this.ContentAtPath(path).container;",
            "      if (flowContainer === null) {",
            "        return throwNullException(\"flowContainer\");",
            "      }",
            "      while (true) {",
            "        let firstContent = flowContainer.content[0];",
            "        if (firstContent instanceof Container) flowContainer = firstContent;else break;",
            "      }",
            "      let inTag = false;",
            "      let tags = null;",
            "      for (let c of flowContainer.content) {",
            "        // var tag = c as Runtime.Tag;",
            "        let command = asOrNull(c, ControlCommand);",
            "        if (command != null) {",
            "          if (command.commandType == ControlCommand.CommandType.BeginTag) {",
            "            inTag = true;",
            "          } else if (command.commandType == ControlCommand.CommandType.EndTag) {",
            "            inTag = false;",
            "          }",
            "        } else if (inTag) {",
            "          let str = asOrNull(c, StringValue);",
            "          if (str !== null) {",
            "            if (tags === null) tags = [];",
            "            if (str.value !== null) tags.push(str.value);",
            "          } else {",
            "            this.Error(\"Tag contained non-text content. Only plain text is allowed when using globalTags or TagsAtContentPath. If you want to evaluate dynamic content, you need to use story.Continue().\");",
            "          }",
            "        } else {",
            "          break;",
            "        }",
            "      }",
            "      return tags;",
            "    }",
            "    BuildStringOfHierarchy() {",
            "      let sb = new StringBuilder();",
            "      this.mainContentContainer.BuildStringOfHierarchy(sb, 0, this.state.currentPointer.Resolve());",
            "      return sb.toString();",
            "    }",
            "    BuildStringOfContainer(container) {",
            "      let sb = new StringBuilder();",
            "      container.BuildStringOfHierarchy(sb, 0, this.state.currentPointer.Resolve());",
            "      return sb.toString();",
            "    }",
            "    NextContent() {",
            "      this.state.previousPointer = this.state.currentPointer.copy();",
            "      if (!this.state.divertedPointer.isNull) {",
            "        this.state.currentPointer = this.state.divertedPointer.copy();",
            "        this.state.divertedPointer = Pointer.Null;",
            "        this.VisitChangedContainersDueToDivert();",
            "        if (!this.state.currentPointer.isNull) {",
            "          return;",
            "        }",
            "      }",
            "      let successfulPointerIncrement = this.IncrementContentPointer();",
            "      if (!successfulPointerIncrement) {",
            "        let didPop = false;",
            "        if (this.state.callStack.CanPop(PushPopType.Function)) {",
            "          this.state.PopCallStack(PushPopType.Function);",
            "          if (this.state.inExpressionEvaluation) {",
            "            this.state.PushEvaluationStack(new Void());",
            "          }",
            "          didPop = true;",
            "        } else if (this.state.callStack.canPopThread) {",
            "          this.state.callStack.PopThread();",
            "          didPop = true;",
            "        } else {",
            "          this.state.TryExitFunctionEvaluationFromGame();",
            "        }",
            "        if (didPop && !this.state.currentPointer.isNull) {",
            "          this.NextContent();",
            "        }",
            "      }",
            "    }",
            "    IncrementContentPointer() {",
            "      let successfulIncrement = true;",
            "      let pointer = this.state.callStack.currentElement.currentPointer.copy();",
            "      pointer.index++;",
            "      if (pointer.container === null) {",
            "        return throwNullException(\"pointer.container\");",
            "      }",
            "      while (pointer.index >= pointer.container.content.length) {",
            "        successfulIncrement = false;",
            "        // Container nextAncestor = pointer.container.parent as Container;",
            "        let nextAncestor = asOrNull(pointer.container.parent, Container);",
            "        if (nextAncestor instanceof Container === false) {",
            "          break;",
            "        }",
            "        let indexInAncestor = nextAncestor.content.indexOf(pointer.container);",
            "        if (indexInAncestor == -1) {",
            "          break;",
            "        }",
            "        pointer = new Pointer(nextAncestor, indexInAncestor);",
            "        pointer.index++;",
            "        successfulIncrement = true;",
            "        if (pointer.container === null) {",
            "          return throwNullException(\"pointer.container\");",
            "        }",
            "      }",
            "      if (!successfulIncrement) pointer = Pointer.Null;",
            "      this.state.callStack.currentElement.currentPointer = pointer.copy();",
            "      return successfulIncrement;",
            "    }",
            "    TryFollowDefaultInvisibleChoice() {",
            "      let allChoices = this._state.currentChoices;",
            "      let invisibleChoices = allChoices.filter(c => c.isInvisibleDefault);",
            "      if (invisibleChoices.length == 0 || allChoices.length > invisibleChoices.length) return false;",
            "      let choice = invisibleChoices[0];",
            "      if (choice.targetPath === null) {",
            "        return throwNullException(\"choice.targetPath\");",
            "      }",
            "      if (choice.threadAtGeneration === null) {",
            "        return throwNullException(\"choice.threadAtGeneration\");",
            "      }",
            "      this.state.callStack.currentThread = choice.threadAtGeneration;",
            "      if (this._stateSnapshotAtLastNewline !== null) {",
            "        this.state.callStack.currentThread = this.state.callStack.ForkThread();",
            "      }",
            "      this.ChoosePath(choice.targetPath, false);",
            "      return true;",
            "    }",
            "    NextSequenceShuffleIndex() {",
            "      // var numElementsIntVal = state.PopEvaluationStack () as IntValue;",
            "      let numElementsIntVal = asOrNull(this.state.PopEvaluationStack(), IntValue);",
            "      if (!(numElementsIntVal instanceof IntValue)) {",
            "        this.Error(\"expected number of elements in sequence for shuffle index\");",
            "        return 0;",
            "      }",
            "      let seqContainer = this.state.currentPointer.container;",
            "      if (seqContainer === null) {",
            "        return throwNullException(\"seqContainer\");",
            "      }",
            "      // Originally a primitive type, but here, can be null.",
            "      // TODO: Replace by default value?",
            "      if (numElementsIntVal.value === null) {",
            "        return throwNullException(\"numElementsIntVal.value\");",
            "      }",
            "      let numElements = numElementsIntVal.value;",
            "      // var seqCountVal = state.PopEvaluationStack () as IntValue;",
            "      let seqCountVal = asOrThrows(this.state.PopEvaluationStack(), IntValue);",
            "      let seqCount = seqCountVal.value;",
            "      // Originally a primitive type, but here, can be null.",
            "      // TODO: Replace by default value?",
            "      if (seqCount === null) {",
            "        return throwNullException(\"seqCount\");",
            "      }",
            "      let loopIndex = seqCount / numElements;",
            "      let iterationIndex = seqCount % numElements;",
            "      let seqPathStr = seqContainer.path.toString();",
            "      let sequenceHash = 0;",
            "      for (let i = 0, l = seqPathStr.length; i < l; i++) {",
            "        sequenceHash += seqPathStr.charCodeAt(i) || 0;",
            "      }",
            "      let randomSeed = sequenceHash + loopIndex + this.state.storySeed;",
            "      let random = new PRNG(Math.floor(randomSeed));",
            "      let unpickedIndices = [];",
            "      for (let i = 0; i < numElements; ++i) {",
            "        unpickedIndices.push(i);",
            "      }",
            "      for (let i = 0; i <= iterationIndex; ++i) {",
            "        let chosen = random.next() % unpickedIndices.length;",
            "        let chosenIndex = unpickedIndices[chosen];",
            "        unpickedIndices.splice(chosen, 1);",
            "        if (i == iterationIndex) {",
            "          return chosenIndex;",
            "        }",
            "      }",
            "      throw new Error(\"Should never reach here\");",
            "    }",
            "    Error(message) {",
            "      let useEndLineNumber = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;",
            "      let e = new StoryException(message);",
            "      e.useEndLineNumber = useEndLineNumber;",
            "      throw e;",
            "    }",
            "    Warning(message) {",
            "      this.AddError(message, true);",
            "    }",
            "    AddError(message) {",
            "      let isWarning = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;",
            "      let useEndLineNumber = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;",
            "      let dm = this.currentDebugMetadata;",
            "      let errorTypeStr = isWarning ? \"WARNING\" : \"ERROR\";",
            "      if (dm != null) {",
            "        let lineNum = useEndLineNumber ? dm.endLineNumber : dm.startLineNumber;",
            "        message = \"RUNTIME \" + errorTypeStr + \": '\" + dm.fileName + \"' line \" + lineNum + \": \" + message;",
            "      } else if (!this.state.currentPointer.isNull) {",
            "        message = \"RUNTIME \" + errorTypeStr + \": (\" + this.state.currentPointer + \"): \" + message;",
            "      } else {",
            "        message = \"RUNTIME \" + errorTypeStr + \": \" + message;",
            "      }",
            "      this.state.AddError(message, isWarning);",
            "      // In a broken state don't need to know about any other errors.",
            "      if (!isWarning) this.state.ForceEnd();",
            "    }",
            "    Assert(condition) {",
            "      let message = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;",
            "      if (condition == false) {",
            "        if (message == null) {",
            "          message = \"Story assert\";",
            "        }",
            "        throw new Error(message + \" \" + this.currentDebugMetadata);",
            "      }",
            "    }",
            "    get currentDebugMetadata() {",
            "      let dm;",
            "      let pointer = this.state.currentPointer;",
            "      if (!pointer.isNull && pointer.Resolve() !== null) {",
            "        dm = pointer.Resolve().debugMetadata;",
            "        if (dm !== null) {",
            "          return dm;",
            "        }",
            "      }",
            "      for (let i = this.state.callStack.elements.length - 1; i >= 0; --i) {",
            "        pointer = this.state.callStack.elements[i].currentPointer;",
            "        if (!pointer.isNull && pointer.Resolve() !== null) {",
            "          dm = pointer.Resolve().debugMetadata;",
            "          if (dm !== null) {",
            "            return dm;",
            "          }",
            "        }",
            "      }",
            "      for (let i = this.state.outputStream.length - 1; i >= 0; --i) {",
            "        let outputObj = this.state.outputStream[i];",
            "        dm = outputObj.debugMetadata;",
            "        if (dm !== null) {",
            "          return dm;",
            "        }",
            "      }",
            "      return null;",
            "    }",
            "    get mainContentContainer() {",
            "      if (this._temporaryEvaluationContainer) {",
            "        return this._temporaryEvaluationContainer;",
            "      } else {",
            "        return this._mainContentContainer;",
            "      }",
            "    }",
            "  }",
            "  Story$1.inkVersionCurrent = 21;",
            "  (function (Story) {",
            "    (function (OutputStateChange) {",
            "      OutputStateChange[OutputStateChange[\"NoChange\"] = 0] = \"NoChange\";",
            "      OutputStateChange[OutputStateChange[\"ExtendedBeyondNewline\"] = 1] = \"ExtendedBeyondNewline\";",
            "      OutputStateChange[OutputStateChange[\"NewlineRemoved\"] = 2] = \"NewlineRemoved\";",
            "    })(Story.OutputStateChange || (Story.OutputStateChange = {}));",
            "  })(Story$1 || (Story$1 = {}));",
            "",
            "  class Story extends FlowBase {",
            "    get flowLevel() {",
            "      return FlowLevel.Story;",
            "    }",
            "    get hadError() {",
            "      return this._hadError;",
            "    }",
            "    get hadWarning() {",
            "      return this._hadWarning;",
            "    }",
            "    constructor(toplevelObjects) {",
            "      var _this;",
            "      let isInclude = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false; // Don't do anything much on construction, leave it lightweight until",
            "      // the ExportRuntime method is called.",
            "      super(null, toplevelObjects, null, false, isInclude);",
            "      _this = this;",
            "      this._errorHandler = null;",
            "      this._hadError = false;",
            "      this._hadWarning = false;",
            "      this._dontFlattenContainers = new Set();",
            "      this._listDefs = new Map();",
            "      this.constants = new Map();",
            "      this.externals = new Map();",
            "      // Build setting for exporting:",
            "      // When true, the visit count for *all* knots, stitches, choices,",
            "      // and gathers is counted. When false, only those that are direclty",
            "      // referenced by the ink are recorded. Use this flag to allow game-side",
            "      // querying of  arbitrary knots/stitches etc.",
            "      // Storing all counts is more robust and future proof (updates to the story file",
            "      // that reference previously uncounted visits are possible, but generates a much",
            "      // larger safe file, with a lot of potentially redundant counts.",
            "      this.countAllVisits = false;",
            "      this.ExportRuntime = function () {",
            "        let errorHandler = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;",
            "        var _a, _b;",
            "        _this._errorHandler = errorHandler;",
            "        // Find all constants before main export begins, so that VariableReferences know",
            "        // whether to generate a runtime variable reference or the literal value",
            "        _this.constants = new Map();",
            "        for (const constDecl of _this.FindAll(ConstantDeclaration)()) {",
            "          // Check for duplicate definitions",
            "          const existingDefinition = _this.constants.get(constDecl.constantName);",
            "          if (existingDefinition) {",
            "            if (!existingDefinition.Equals(constDecl.expression)) {",
            "              const errorMsg = `CONST '${constDecl.constantName}' has been redefined with a different value. Multiple definitions of the same CONST are valid so long as they contain the same value. Initial definition was on ${existingDefinition.debugMetadata}.`;",
            "              _this.Error(errorMsg, constDecl, false);",
            "            }",
            "          }",
            "          _this.constants.set(constDecl.constantName, constDecl.expression);",
            "        }",
            "        // List definitions are treated like constants too - they should be usable",
            "        // from other variable declarations.",
            "        _this._listDefs = new Map();",
            "        for (const listDef of _this.FindAll(ListDefinition)()) {",
            "          if ((_a = listDef.identifier) === null || _a === void 0 ? void 0 : _a.name) {",
            "            _this._listDefs.set((_b = listDef.identifier) === null || _b === void 0 ? void 0 : _b.name, listDef);",
            "          }",
            "        }",
            "        _this.externals = new Map();",
            "        // Resolution of weave point names has to come first, before any runtime code generation",
            "        // since names have to be ready before diverts start getting created.",
            "        // (It used to be done in the constructor for a weave, but didn't allow us to generate",
            "        // errors when name resolution failed.)",
            "        _this.ResolveWeavePointNaming();",
            "        // Get default implementation of runtimeObject, which calls ContainerBase's generation method",
            "        const rootContainer = _this.runtimeObject;",
            "        // Export initialisation of global variables",
            "        // TODO: We *could* add this as a declarative block to the story itself...",
            "        const variableInitialisation = new Container();",
            "        variableInitialisation.AddContent(ControlCommand.EvalStart());",
            "        // Global variables are those that are local to the story and marked as global",
            "        const runtimeLists = [];",
            "        for (const [key, value] of _this.variableDeclarations) {",
            "          if (value.isGlobalDeclaration) {",
            "            if (value.listDefinition) {",
            "              _this._listDefs.set(key, value.listDefinition);",
            "              variableInitialisation.AddContent(value.listDefinition.runtimeObject);",
            "              runtimeLists.push(value.listDefinition.runtimeListDefinition);",
            "            } else {",
            "              if (!value.expression) {",
            "                throw new Error();",
            "              }",
            "              value.expression.GenerateIntoContainer(variableInitialisation);",
            "            }",
            "            const runtimeVarAss = new VariableAssignment$1(key, true);",
            "            runtimeVarAss.isGlobal = true;",
            "            variableInitialisation.AddContent(runtimeVarAss);",
            "          }",
            "        }",
            "        variableInitialisation.AddContent(ControlCommand.EvalEnd());",
            "        variableInitialisation.AddContent(ControlCommand.End());",
            "        if (_this.variableDeclarations.size > 0) {",
            "          variableInitialisation.name = \"global decl\";",
            "          rootContainer.AddToNamedContentOnly(variableInitialisation);",
            "        }",
            "        // Signal that it's safe to exit without error, even if there are no choices generated",
            "        // (this only happens at the end of top level content that isn't in any particular knot)",
            "        rootContainer.AddContent(ControlCommand.Done());",
            "        // Replace runtimeObject with Story object instead of the Runtime.Container generated by Parsed.ContainerBase",
            "        const runtimeStory = new Story$1(rootContainer, runtimeLists);",
            "        _this.runtimeObject = runtimeStory;",
            "        if (_this.hadError) {",
            "          return null;",
            "        }",
            "        // Optimisation step - inline containers that can be",
            "        _this.FlattenContainersIn(rootContainer);",
            "        // Now that the story has been fulled parsed into a hierarchy,",
            "        // and the derived runtime hierarchy has been built, we can",
            "        // resolve referenced symbols such as variables and paths.",
            "        // e.g. for paths \" -> knotName --> stitchName\" into an INKPath (knotName.stitchName)",
            "        // We don't make any assumptions that the INKPath follows the same",
            "        // conventions as the script format, so we resolve to actual objects before",
            "        // translating into an INKPath. (This also allows us to choose whether",
            "        // we want the paths to be absolute)",
            "        _this.ResolveReferences(_this);",
            "        if (_this.hadError) {",
            "          return null;",
            "        }",
            "        runtimeStory.ResetState();",
            "        return runtimeStory;",
            "      };",
            "      this.ResolveList = listName => {",
            "        let list = this._listDefs.get(listName);",
            "        if (!list) {",
            "          return null;",
            "        }",
            "        return list;",
            "      };",
            "      this.ResolveListItem = function (listName, itemName) {",
            "        let source = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;",
            "        let listDef = null;",
            "        // Search a specific list if we know its name (i.e. the form listName.itemName)",
            "        if (listName) {",
            "          if (!(listDef = _this._listDefs.get(listName))) {",
            "            return null;",
            "          }",
            "          return listDef.ItemNamed(itemName);",
            "        } else {",
            "          // Otherwise, try to search all lists",
            "          let foundItem = null;",
            "          let originalFoundList = null;",
            "          for (const [, value] of _this._listDefs.entries()) {",
            "            const itemInThisList = value.ItemNamed(itemName);",
            "            if (itemInThisList) {",
            "              if (foundItem) {",
            "                _this.Error(`Ambiguous item name '${itemName}' found in multiple sets, including ${originalFoundList.identifier} and ${value.identifier}`, source, false);",
            "              } else {",
            "                foundItem = itemInThisList;",
            "                originalFoundList = value;",
            "              }",
            "            }",
            "          }",
            "          return foundItem;",
            "        }",
            "      };",
            "      this.FlattenContainersIn = container => {",
            "        // Need to create a collection to hold the inner containers",
            "        // because otherwise we'd end up modifying during iteration",
            "        const innerContainers = new Set();",
            "        if (container.content) {",
            "          for (const c of container.content) {",
            "            const innerContainer = asOrNull(c, Container);",
            "            if (innerContainer) {",
            "              innerContainers.add(innerContainer);",
            "            }",
            "          }",
            "        }",
            "        // Can't flatten the named inner containers, but we can at least",
            "        // iterate through their children",
            "        if (container.namedContent) {",
            "          for (const [, value] of container.namedContent) {",
            "            const namedInnerContainer = asOrNull(value, Container);",
            "            if (namedInnerContainer) {",
            "              innerContainers.add(namedInnerContainer);",
            "            }",
            "          }",
            "        }",
            "        for (const innerContainer of innerContainers) {",
            "          this.TryFlattenContainer(innerContainer);",
            "          this.FlattenContainersIn(innerContainer);",
            "        }",
            "      };",
            "      this.TryFlattenContainer = container => {",
            "        if (container.namedContent && container.namedContent.size > 0 || container.hasValidName || this._dontFlattenContainers.has(container)) {",
            "          return;",
            "        }",
            "        // Inline all the content in container into the parent",
            "        const parentContainer = asOrNull(container.parent, Container);",
            "        if (parentContainer) {",
            "          let contentIdx = parentContainer.content.indexOf(container);",
            "          parentContainer.content.splice(contentIdx, 1);",
            "          const dm = container.ownDebugMetadata;",
            "          if (container.content) {",
            "            for (const innerContent of container.content) {",
            "              innerContent.parent = null;",
            "              if (dm !== null && innerContent.ownDebugMetadata === null) {",
            "                innerContent.debugMetadata = dm;",
            "              }",
            "              parentContainer.InsertContent(innerContent, contentIdx);",
            "              contentIdx += 1;",
            "            }",
            "          }",
            "        }",
            "      };",
            "      this.Error = (message, source, isWarning) => {",
            "        let errorType = isWarning ? ErrorType$1.Warning : ErrorType$1.Error;",
            "        let sb = \"\";",
            "        if (source instanceof AuthorWarning) {",
            "          sb += \"TODO: \";",
            "          errorType = ErrorType$1.Author;",
            "        } else if (isWarning) {",
            "          sb += \"WARNING: \";",
            "        } else {",
            "          sb += \"ERROR: \";",
            "        }",
            "        if (source && source.debugMetadata !== null && source.debugMetadata.startLineNumber >= 1) {",
            "          if (source.debugMetadata.fileName != null) {",
            "            sb += `'${source.debugMetadata.fileName}' `;",
            "          }",
            "          sb += `line ${source.debugMetadata.startLineNumber}: `;",
            "        }",
            "        sb += message;",
            "        message = sb;",
            "        if (this._errorHandler !== null) {",
            "          this._errorHandler(message, errorType);",
            "        } else {",
            "          throw new Error(message);",
            "        }",
            "        this._hadError = errorType === ErrorType$1.Error;",
            "        this._hadWarning = errorType === ErrorType$1.Warning;",
            "      };",
            "      this.ResetError = () => {",
            "        this._hadError = false;",
            "        this._hadWarning = false;",
            "      };",
            "      this.IsExternal = namedFuncTarget => this.externals.has(namedFuncTarget);",
            "      this.AddExternal = decl => {",
            "        if (this.externals.has(decl.name)) {",
            "          this.Error(`Duplicate EXTERNAL definition of '${decl.name}'`, decl, false);",
            "        } else if (decl.name) {",
            "          this.externals.set(decl.name, decl);",
            "        }",
            "      };",
            "      this.DontFlattenContainer = container => {",
            "        this._dontFlattenContainers.add(container);",
            "      };",
            "      this.NameConflictError = (obj, name, existingObj, typeNameToPrint) => {",
            "        obj.Error(`${typeNameToPrint} '${name}': name has already been used for a ${existingObj.typeName.toLowerCase()} on ${existingObj.debugMetadata}`);",
            "      };",
            "      // Check given symbol type against everything that's of a higher priority in the ordered SymbolType enum (above).",
            "      // When the given symbol type level is reached, we early-out / return.",
            "      this.CheckForNamingCollisions = function (obj, identifier, symbolType) {",
            "        let typeNameOverride = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : \"\";",
            "        var _a;",
            "        const typeNameToPrint = typeNameOverride || obj.typeName;",
            "        if (Story.IsReservedKeyword(identifier === null || identifier === void 0 ? void 0 : identifier.name)) {",
            "          obj.Error(`'${identifier}' cannot be used for the name of a ${typeNameToPrint.toLowerCase()} because it's a reserved keyword`);",
            "          return;",
            "        } else if (FunctionCall.IsBuiltIn((identifier === null || identifier === void 0 ? void 0 : identifier.name) || \"\")) {",
            "          obj.Error(`'${identifier}' cannot be used for the name of a ${typeNameToPrint.toLowerCase()} because it's a built in function`);",
            "          return;",
            "        }",
            "        // Top level knots",
            "        const maybeKnotOrFunction = _this.ContentWithNameAtLevel((identifier === null || identifier === void 0 ? void 0 : identifier.name) || \"\", FlowLevel.Knot);",
            "        const knotOrFunction = asOrNull(maybeKnotOrFunction, FlowBase);",
            "        if (knotOrFunction && (knotOrFunction !== obj || symbolType === SymbolType.Arg)) {",
            "          _this.NameConflictError(obj, (identifier === null || identifier === void 0 ? void 0 : identifier.name) || \"\", knotOrFunction, typeNameToPrint);",
            "          return;",
            "        }",
            "        if (symbolType < SymbolType.List) {",
            "          return;",
            "        }",
            "        // Lists",
            "        for (const [key, value] of _this._listDefs) {",
            "          if ((identifier === null || identifier === void 0 ? void 0 : identifier.name) === key && obj !== value && value.variableAssignment !== obj) {",
            "            _this.NameConflictError(obj, identifier === null || identifier === void 0 ? void 0 : identifier.name, value, typeNameToPrint);",
            "          }",
            "          // We don't check for conflicts between individual elements in",
            "          // different lists because they are namespaced.",
            "          if (!(obj instanceof ListElementDefinition)) {",
            "            for (const item of value.itemDefinitions) {",
            "              if ((identifier === null || identifier === void 0 ? void 0 : identifier.name) === item.name) {",
            "                _this.NameConflictError(obj, (identifier === null || identifier === void 0 ? void 0 : identifier.name) || \"\", item, typeNameToPrint);",
            "              }",
            "            }",
            "          }",
            "        }",
            "        // Don't check for VAR->VAR conflicts because that's handled separately",
            "        // (necessary since checking looks up in a dictionary)",
            "        if (symbolType <= SymbolType.Var) {",
            "          return;",
            "        }",
            "        // Global variable collision",
            "        const varDecl = (identifier === null || identifier === void 0 ? void 0 : identifier.name) && _this.variableDeclarations.get(identifier === null || identifier === void 0 ? void 0 : identifier.name) || null;",
            "        if (varDecl && varDecl !== obj && varDecl.isGlobalDeclaration && varDecl.listDefinition == null) {",
            "          _this.NameConflictError(obj, (identifier === null || identifier === void 0 ? void 0 : identifier.name) || \"\", varDecl, typeNameToPrint);",
            "        }",
            "        if (symbolType < SymbolType.SubFlowAndWeave) {",
            "          return;",
            "        }",
            "        // Stitches, Choices and Gathers",
            "        const path = new Path(identifier);",
            "        const targetContent = path.ResolveFromContext(obj);",
            "        if (targetContent && targetContent !== obj) {",
            "          _this.NameConflictError(obj, (identifier === null || identifier === void 0 ? void 0 : identifier.name) || \"\", targetContent, typeNameToPrint);",
            "          return;",
            "        }",
            "        if (symbolType < SymbolType.Arg) {",
            "          return;",
            "        }",
            "        // Arguments to the current flow",
            "        if (symbolType !== SymbolType.Arg) {",
            "          let flow = asOrNull(obj, FlowBase);",
            "          if (!flow) {",
            "            flow = ClosestFlowBase(obj);",
            "          }",
            "          if (flow && flow.hasParameters && flow.args) {",
            "            for (const arg of flow.args) {",
            "              if (((_a = arg.identifier) === null || _a === void 0 ? void 0 : _a.name) === (identifier === null || identifier === void 0 ? void 0 : identifier.name)) {",
            "                obj.Error(`${typeNameToPrint} '${identifier}': name has already been used for a argument to ${flow.identifier} on ${flow.debugMetadata}`);",
            "                return;",
            "              }",
            "            }",
            "          }",
            "        }",
            "      };",
            "    }",
            "    get typeName() {",
            "      return \"Story\";",
            "    }",
            "    // Before this function is called, we have IncludedFile objects interspersed",
            "    // in our content wherever an include statement was.",
            "    // So that the include statement can be added in a sensible place (e.g. the",
            "    // top of the file) without side-effects of jumping into a knot that was",
            "    // defined in that include, we separate knots and stitches from anything",
            "    // else defined at the top scope of the included file.",
            "    //",
            "    // Algorithm: For each IncludedFile we find, split its contents into",
            "    // knots/stiches and any other content. Insert the normal content wherever",
            "    // the include statement was, and append the knots/stitches to the very",
            "    // end of the main story.",
            "    PreProcessTopLevelObjects(topLevelContent) {",
            "      super.PreProcessTopLevelObjects(topLevelContent);",
            "      const flowsFromOtherFiles = [];",
            "      // Inject included files",
            "      for (let obj of topLevelContent) {",
            "        if (obj instanceof IncludedFile) {",
            "          const file = obj;",
            "          // Remove the IncludedFile itself",
            "          const posOfObj = topLevelContent.indexOf(obj);",
            "          topLevelContent.splice(posOfObj, 1);",
            "          // When an included story fails to load, the include",
            "          // line itself is still valid, so we have to handle it here",
            "          if (file.includedStory) {",
            "            const nonFlowContent = [];",
            "            const subStory = file.includedStory;",
            "            // Allow empty file",
            "            if (subStory.content != null) {",
            "              for (const subStoryObj of subStory.content) {",
            "                if (subStoryObj instanceof FlowBase) {",
            "                  flowsFromOtherFiles.push(subStoryObj);",
            "                } else {",
            "                  nonFlowContent.push(subStoryObj);",
            "                }",
            "              }",
            "              // Add newline on the end of the include",
            "              nonFlowContent.push(new Text(\"\\n\"));",
            "              // Add contents of the file in its place",
            "              topLevelContent.splice(posOfObj, 0, ...nonFlowContent);",
            "              // Skip past the content of this sub story",
            "              // (since it will already have recursively included",
            "              //  any lines from other files)",
            "            }",
            "          }",
            "          // Include object has been removed, with possible content inserted,",
            "          // and position of 'i' will have been determined already.",
            "          continue;",
            "        }",
            "      }",
            "      // Add the flows we collected from the included files to the",
            "      // end of our list of our content",
            "      topLevelContent.splice(0, 0, ...flowsFromOtherFiles);",
            "    }",
            "  }",
            "  Story.IsReservedKeyword = name => {",
            "    switch (name) {",
            "      case \"true\":",
            "      case \"false\":",
            "      case \"not\":",
            "      case \"return\":",
            "      case \"else\":",
            "      case \"VAR\":",
            "      case \"CONST\":",
            "      case \"temp\":",
            "      case \"LIST\":",
            "      case \"function\":",
            "        return true;",
            "    }",
            "    return false;",
            "  };",
            "",
            "  class StringExpression extends Expression {",
            "    get isSingleString() {",
            "      if (this.content.length !== 1) {",
            "        return false;",
            "      }",
            "      const c = this.content[0];",
            "      if (!(c instanceof Text)) {",
            "        return false;",
            "      }",
            "      return true;",
            "    }",
            "    constructor(content) {",
            "      super();",
            "      this.GenerateIntoContainer = container => {",
            "        container.AddContent(ControlCommand.BeginString());",
            "        for (const c of this.content) {",
            "          container.AddContent(c.runtimeObject);",
            "        }",
            "        container.AddContent(ControlCommand.EndString());",
            "      };",
            "      this.toString = () => {",
            "        let sb = \"\";",
            "        for (const c of this.content) {",
            "          sb += c;",
            "        }",
            "        return sb;",
            "      };",
            "      this.AddContent(content);",
            "    }",
            "    get typeName() {",
            "      return \"String\";",
            "    }",
            "    // Equals override necessary in order to check for CONST multiple definition equality",
            "    Equals(obj) {",
            "      const otherStr = asOrNull(obj, StringExpression);",
            "      if (otherStr === null) {",
            "        return false;",
            "      }",
            "      // Can only compare direct equality on single strings rather than",
            "      // complex string expressions that contain dynamic logic",
            "      if (!this.isSingleString || !otherStr.isSingleString) {",
            "        return false;",
            "      }",
            "      const thisTxt = this.toString();",
            "      const otherTxt = otherStr.toString();",
            "      return thisTxt === otherTxt;",
            "    }",
            "  }",
            "",
            "  class Tag extends ParsedObject {",
            "    constructor(isStart) {",
            "      let inChoice = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;",
            "      super();",
            "      this.GenerateRuntimeObject = () => {",
            "        if (this.isStart) {",
            "          return ControlCommand.BeginTag();",
            "        } else {",
            "          return ControlCommand.EndTag();",
            "        }",
            "      };",
            "      this.toString = () => {",
            "        if (this.isStart) {",
            "          return \"#StartTag\";",
            "        } else {",
            "          return \"#EndTag\";",
            "        }",
            "      };",
            "      this.isStart = isStart;",
            "      this.inChoice = inChoice;",
            "    }",
            "    get typeName() {",
            "      return \"Tag\";",
            "    }",
            "  }",
            "",
            "  // This class replaces upstream's DefaultFileHandler. It doesn't perform any",
            "  // resolution and warns the user about providing a proper file handler when",
            "  // INCLUDE statements are parsed. Since the JavaScript parser can be executed in",
            "  // different environments, we let the user decide which FileHandler is best for",
            "  // their use-case. See PosixFileHandler and JsonFileHandler.",
            "  class DefaultFileHandler {",
            "    constructor(rootPath) {",
            "      this.rootPath = rootPath;",
            "      this.ResolveInkFilename = () => {",
            "        throw Error(\"Can't resolve filename because no FileHandler was provided when instantiating the parser / compiler.\");",
            "      };",
            "      this.LoadInkFileContents = () => {",
            "        throw Error(\"Can't load ink content because no FileHandler was provided when instantiating the parser / compiler.\");",
            "      };",
            "    }",
            "  }",
            "",
            "  class InkParser extends StringParser {",
            "    /**",
            "     * Begin base InkParser section.",
            "     */",
            "    get fileHandler() {",
            "      if (!this._fileHandler) {",
            "        throw new Error(\"No FileHandler defined\");",
            "      }",
            "      return this._fileHandler;",
            "    }",
            "    set fileHandler(value) {",
            "      this._fileHandler = value;",
            "    }",
            "    constructor(str) {",
            "      var _this;",
            "      let filename = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;",
            "      let externalErrorHandler = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;",
            "      let rootParser = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;",
            "      let fileHandler = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : null;",
            "      // Main entry point",
            "      // NOTE: This method is named Parse() in upstream.",
            "      super(str);",
            "      _this = this;",
            "      this.ParseStory = () => {",
            "        const topLevelContent = this.StatementsAtLevel(exports.StatementLevel.Top);",
            "        // Note we used to return null if there were any errors, but this would mean",
            "        // that include files would return completely empty rather than attempting to",
            "        // continue with errors. Returning an empty include files meant that anything",
            "        // that *did* compile successfully would otherwise be ignored, generating way",
            "        // more errors than necessary.",
            "        return new Story(topLevelContent, this._rootParser !== this);",
            "      };",
            "      this.SeparatedList = (mainRule, separatorRule) => {",
            "        const firstElement = this.Parse(mainRule);",
            "        if (firstElement === null) {",
            "          return null;",
            "        }",
            "        const allElements = [];",
            "        allElements.push(firstElement);",
            "        do {",
            "          const nextElementRuleId = this.BeginRule();",
            "          let sep = separatorRule();",
            "          if (sep === null) {",
            "            this.FailRule(nextElementRuleId);",
            "            break;",
            "          }",
            "          const nextElement = this.Parse(mainRule);",
            "          if (nextElement === null) {",
            "            this.FailRule(nextElementRuleId);",
            "            break;",
            "          }",
            "          this.SucceedRule(nextElementRuleId);",
            "          allElements.push(nextElement);",
            "        } while (true);",
            "        return allElements;",
            "      };",
            "      this.CreateDebugMetadata = (stateAtStart, stateAtEnd) => {",
            "        const md = new DebugMetadata();",
            "        md.startLineNumber = ((stateAtStart === null || stateAtStart === void 0 ? void 0 : stateAtStart.lineIndex) || 0) + 1;",
            "        md.endLineNumber = stateAtEnd.lineIndex + 1;",
            "        md.startCharacterNumber = ((stateAtStart === null || stateAtStart === void 0 ? void 0 : stateAtStart.characterInLineIndex) || 0) + 1;",
            "        md.endCharacterNumber = stateAtEnd.characterInLineIndex + 1;",
            "        md.fileName = this._filename;",
            "        return md;",
            "      };",
            "      this.RuleDidSucceed = (result, stateAtStart, stateAtEnd) => {",
            "        // Apply DebugMetadata based on the state at the start of the rule",
            "        // (i.e. use line number as it was at the start of the rule)",
            "        const parsedObj = asOrNull(result, ParsedObject);",
            "        if (parsedObj) {",
            "          parsedObj.debugMetadata = this.CreateDebugMetadata(stateAtStart, stateAtEnd);",
            "        }",
            "        // A list of objects that doesn't already have metadata?",
            "        const parsedListObjs = Array.isArray(result) ? result : null;",
            "        if (parsedListObjs !== null) {",
            "          for (const parsedListObj of parsedListObjs) {",
            "            const singleObj = asOrNull(parsedListObj, ParsedObject);",
            "            if (!singleObj) continue;",
            "            if (!parsedListObj.hasOwnDebugMetadata) {",
            "              parsedListObj.debugMetadata = this.CreateDebugMetadata(stateAtStart, stateAtEnd);",
            "            }",
            "          }",
            "        }",
            "        const id = asOrNull(result, Identifier);",
            "        if (id != null) {",
            "          id.debugMetadata = this.CreateDebugMetadata(stateAtStart, stateAtEnd);",
            "        }",
            "      };",
            "      this.OnStringParserError = function (message, index) {",
            "        let lineIndex = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;",
            "        let isWarning = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;",
            "        const warningType = isWarning ? \"WARNING:\" : \"ERROR:\";",
            "        let fullMessage = warningType;",
            "        if (_this._filename !== null) {",
            "          fullMessage += ` '${_this._filename}'`;",
            "        }",
            "        fullMessage += ` line ${lineIndex + 1}: ${message}`;",
            "        if (_this._externalErrorHandler !== null) {",
            "          _this._externalErrorHandler(fullMessage, isWarning ? ErrorType$1.Warning : ErrorType$1.Error);",
            "        } else {",
            "          throw new Error(fullMessage);",
            "        }",
            "      };",
            "      this.AuthorWarning = () => {",
            "        this.Whitespace();",
            "        const identifier = this.Parse(this.IdentifierWithMetadata);",
            "        if (identifier === null || identifier.name !== \"TODO\") {",
            "          return null;",
            "        }",
            "        this.Whitespace();",
            "        this.ParseString(\":\");",
            "        this.Whitespace();",
            "        const message = this.ParseUntilCharactersFromString(\"\\n\\r\");",
            "        if (message) {",
            "          return new AuthorWarning(message);",
            "        }",
            "        return null;",
            "      };",
            "      this.ExtendIdentifierCharacterRanges = identifierCharSet => {",
            "        const characterRanges = InkParser.ListAllCharacterRanges();",
            "        for (const charRange of characterRanges) {",
            "          identifierCharSet.AddCharacters(charRange.ToCharacterSet());",
            "        }",
            "      };",
            "      /**",
            "       * End CharacterRanges section.",
            "       */",
            "      /**",
            "       * Begin Choices section.",
            "       */",
            "      this._parsingChoice = false;",
            "      this.Choice = () => {",
            "        let onceOnlyChoice = true;",
            "        let bullets = this.Interleave(this.OptionalExclude(this.Whitespace), this.String(\"*\"));",
            "        if (!bullets) {",
            "          bullets = this.Interleave(this.OptionalExclude(this.Whitespace), this.String(\"+\"));",
            "          if (bullets === null) {",
            "            return null;",
            "          }",
            "          onceOnlyChoice = false;",
            "        }",
            "        // Optional name for the choice",
            "        const optionalName = this.Parse(this.BracketedName);",
            "        this.Whitespace();",
            "        // Optional condition for whether the choice should be shown to the player",
            "        const conditionExpr = this.Parse(this.ChoiceCondition);",
            "        this.Whitespace();",
            "        // Ordinarily we avoid parser state variables like these, since",
            "        // nesting would require us to store them in a stack. But since you should",
            "        // never be able to nest choices within choice content, it's fine here.",
            "        if (this._parsingChoice) {",
            "          throw new Error(\"Already parsing a choice - shouldn't have nested choices\");",
            "        }",
            "        this._parsingChoice = true;",
            "        let startContent = null;",
            "        const startTextAndLogic = this.Parse(this.MixedTextAndLogic);",
            "        if (startTextAndLogic) {",
            "          startContent = new ContentList(startTextAndLogic);",
            "        }",
            "        let optionOnlyContent = null;",
            "        let innerContent = null;",
            "        // Check for a the weave style format:",
            "        //   * \"Hello[.\"],\" he said.",
            "        const hasWeaveStyleInlineBrackets = this.ParseString(\"[\") !== null;",
            "        if (hasWeaveStyleInlineBrackets) {",
            "          this.EndTagIfNecessary(startContent);",
            "          const optionOnlyTextAndLogic = this.Parse(this.MixedTextAndLogic);",
            "          if (optionOnlyTextAndLogic !== null) {",
            "            optionOnlyContent = new ContentList(optionOnlyTextAndLogic);",
            "          }",
            "          this.Expect(this.String(\"]\"), \"closing ']' for weave-style option\");",
            "          this.EndTagIfNecessary(optionOnlyContent);",
            "          let innerTextAndLogic = this.Parse(this.MixedTextAndLogic);",
            "          if (innerTextAndLogic !== null) {",
            "            innerContent = new ContentList(innerTextAndLogic);",
            "          }",
            "        }",
            "        this.Whitespace();",
            "        this.EndTagIfNecessary(innerContent !== null && innerContent !== void 0 ? innerContent : startContent);",
            "        // Finally, now we know we're at the end of the main choice body, parse",
            "        // any diverts separately.",
            "        const diverts = this.Parse(this.MultiDivert);",
            "        this._parsingChoice = false;",
            "        this.Whitespace();",
            "        // Completely empty choice without even an empty divert?",
            "        const emptyContent = !startContent && !innerContent && !optionOnlyContent;",
            "        if (emptyContent && diverts === null) {",
            "          this.Warning(\"Choice is completely empty. Interpretting as a default fallback choice. Add a divert arrow to remove this warning: * ->\");",
            "        }",
            "        if (!startContent && hasWeaveStyleInlineBrackets && !optionOnlyContent) {",
            "          // * [] some text",
            "          this.Warning(\"Blank choice - if you intended a default fallback choice, use the `* ->` syntax\");",
            "        }",
            "        if (!innerContent) {",
            "          innerContent = new ContentList();",
            "        }",
            "        this.EndTagIfNecessary(innerContent);",
            "        // Normal diverts on the end of a choice - simply add to the normal content",
            "        if (diverts !== null) {",
            "          for (const divObj of diverts) {",
            "            // may be TunnelOnwards",
            "            const div = asOrNull(divObj, Divert);",
            "            // Empty divert serves no purpose other than to say",
            "            // \"this choice is intentionally left blank\"",
            "            // (as an invisible default choice)",
            "            if (div && div.isEmpty) {",
            "              continue;",
            "            }",
            "            innerContent.AddContent(divObj);",
            "          }",
            "        }",
            "        // Terminate main content with a newline since this is the end of the line",
            "        // Note that this will be redundant if the diverts above definitely take",
            "        // the flow away permanently.",
            "        innerContent.AddContent(new Text(\"\\n\"));",
            "        const choice = new Choice$1(startContent, optionOnlyContent, innerContent);",
            "        if (optionalName) choice.identifier = optionalName;",
            "        choice.indentationDepth = bullets.length;",
            "        choice.hasWeaveStyleInlineBrackets = hasWeaveStyleInlineBrackets;",
            "        choice.condition = conditionExpr;",
            "        choice.onceOnly = onceOnlyChoice;",
            "        choice.isInvisibleDefault = emptyContent;",
            "        return choice;",
            "      };",
            "      this.ChoiceCondition = () => {",
            "        const conditions = this.Interleave(this.ChoiceSingleCondition, this.ChoiceConditionsSpace);",
            "        if (conditions === null) {",
            "          return null;",
            "        } else if (conditions.length === 1) {",
            "          return conditions[0];",
            "        }",
            "        return new MultipleConditionExpression(conditions);",
            "      };",
            "      this.ChoiceConditionsSpace = () => {",
            "        // Both optional",
            "        // Newline includes initial end of line whitespace",
            "        this.Newline();",
            "        this.Whitespace();",
            "        return ParseSuccess;",
            "      };",
            "      this.ChoiceSingleCondition = () => {",
            "        if (this.ParseString(\"{\") === null) {",
            "          return null;",
            "        }",
            "        const condExpr = this.Expect(this.Expression, \"choice condition inside { }\");",
            "        this.DisallowIncrement(condExpr);",
            "        this.Expect(this.String(\"}\"), \"closing '}' for choice condition\");",
            "        return condExpr;",
            "      };",
            "      this.Gather = () => {",
            "        const gatherDashCountObj = this.Parse(this.GatherDashes);",
            "        if (gatherDashCountObj === null) {",
            "          return null;",
            "        }",
            "        const gatherDashCount = Number(gatherDashCountObj);",
            "        // Optional name for the gather",
            "        const optionalName = this.Parse(this.BracketedName);",
            "        const gather = new Gather(optionalName, gatherDashCount);",
            "        // Optional newline before gather's content begins",
            "        this.Newline();",
            "        return gather;",
            "      };",
            "      this.GatherDashes = () => {",
            "        this.Whitespace();",
            "        let gatherDashCount = 0;",
            "        while (this.ParseDashNotArrow() !== null) {",
            "          gatherDashCount += 1;",
            "          this.Whitespace();",
            "        }",
            "        if (gatherDashCount === 0) {",
            "          return null;",
            "        }",
            "        return gatherDashCount;",
            "      };",
            "      this.ParseDashNotArrow = () => {",
            "        const ruleId = this.BeginRule();",
            "        if (this.ParseString(\"->\") === null && this.ParseSingleCharacter() === \"-\") {",
            "          return this.SucceedRule(ruleId);",
            "        }",
            "        return this.FailRule(ruleId);",
            "      };",
            "      this.BracketedName = () => {",
            "        if (this.ParseString(\"(\") === null) {",
            "          return null;",
            "        }",
            "        this.Whitespace();",
            "        const name = this.Parse(this.IdentifierWithMetadata);",
            "        if (name === null) {",
            "          return null;",
            "        }",
            "        this.Whitespace();",
            "        this.Expect(this.String(\")\"), \"closing ')' for bracketed name\");",
            "        return name;",
            "      };",
            "      /**",
            "       * End Choices section.",
            "       */",
            "      /**",
            "       * Begin Conditional section.",
            "       */",
            "      this.InnerConditionalContent = initialQueryExpression => {",
            "        if (initialQueryExpression === undefined) {",
            "          const initialQueryExpression = this.Parse(this.ConditionExpression);",
            "          const conditional = this.Parse(() => this.InnerConditionalContent(initialQueryExpression));",
            "          if (conditional === null) {",
            "            return null;",
            "          }",
            "          return conditional;",
            "        }",
            "        let alternatives;",
            "        const canBeInline = initialQueryExpression !== null;",
            "        const isInline = this.Parse(this.Newline) === null;",
            "        if (isInline && !canBeInline) {",
            "          return null;",
            "        }",
            "        if (isInline) {",
            "          // Inline innards",
            "          alternatives = this.InlineConditionalBranches();",
            "        } else {",
            "          // Multiline innards",
            "          alternatives = this.MultilineConditionalBranches();",
            "          if (alternatives === null) {",
            "            // Allow single piece of content within multi-line expression, e.g.:",
            "            // { true:",
            "            //    Some content that isn't preceded by '-'",
            "            // }",
            "            if (initialQueryExpression) {",
            "              let soleContent = this.StatementsAtLevel(exports.StatementLevel.InnerBlock);",
            "              if (soleContent !== null) {",
            "                const soleBranch = new ConditionalSingleBranch(soleContent);",
            "                alternatives = [soleBranch];",
            "                // Also allow a final \"- else:\" clause",
            "                const elseBranch = this.Parse(this.SingleMultilineCondition);",
            "                if (elseBranch) {",
            "                  if (!elseBranch.isElse) {",
            "                    this.ErrorWithParsedObject(\"Expected an '- else:' clause here rather than an extra condition\", elseBranch);",
            "                    elseBranch.isElse = true;",
            "                  }",
            "                  alternatives.push(elseBranch);",
            "                }",
            "              }",
            "            }",
            "            // Still null?",
            "            if (alternatives === null) {",
            "              return null;",
            "            }",
            "          } else if (alternatives.length === 1 && alternatives[0].isElse && initialQueryExpression) {",
            "            // Empty true branch - didn't get parsed, but should insert one for semantic correctness,",
            "            // and to make sure that any evaluation stack values get tidied up correctly.",
            "            const emptyTrueBranch = new ConditionalSingleBranch(null);",
            "            emptyTrueBranch.isTrueBranch = true;",
            "            alternatives.unshift(emptyTrueBranch);",
            "          }",
            "          // Like a switch statement",
            "          // { initialQueryExpression:",
            "          //    ... match the expression",
            "          // }",
            "          if (initialQueryExpression) {",
            "            let earlierBranchesHaveOwnExpression = false;",
            "            for (let ii = 0; ii < alternatives.length; ++ii) {",
            "              const branch = alternatives[ii];",
            "              const isLast = ii === alternatives.length - 1;",
            "              // Matching equality with initial query expression",
            "              // We set this flag even for the \"else\" clause so that",
            "              // it knows to tidy up the evaluation stack at the end",
            "              // Match query",
            "              if (branch.ownExpression) {",
            "                branch.matchingEquality = true;",
            "                earlierBranchesHaveOwnExpression = true;",
            "              } else if (earlierBranchesHaveOwnExpression && isLast) {",
            "                // Else (final branch)",
            "                branch.matchingEquality = true;",
            "                branch.isElse = true;",
            "              } else {",
            "                // Binary condition:",
            "                // { trueOrFalse:",
            "                //    - when true",
            "                //    - when false",
            "                // }",
            "                if (!isLast && alternatives.length > 2) {",
            "                  this.ErrorWithParsedObject(\"Only final branch can be an 'else'. Did you miss a ':'?\", branch);",
            "                } else {",
            "                  if (ii === 0) {",
            "                    branch.isTrueBranch = true;",
            "                  } else {",
            "                    branch.isElse = true;",
            "                  }",
            "                }",
            "              }",
            "            }",
            "          } else {",
            "            // No initial query, so just a multi-line conditional. e.g.:",
            "            // {",
            "            //   - x > 3:  greater than three",
            "            //   - x == 3: equal to three",
            "            //   - x < 3:  less than three",
            "            // }",
            "            for (let ii = 0; ii < alternatives.length; ++ii) {",
            "              const alt = alternatives[ii];",
            "              const isLast = ii === alternatives.length - 1;",
            "              if (alt.ownExpression === null) {",
            "                if (isLast) {",
            "                  alt.isElse = true;",
            "                } else {",
            "                  if (alt.isElse) {",
            "                    // Do we ALSO have a valid \"else\" at the end? Let's report the error there.",
            "                    const finalClause = alternatives[alternatives.length - 1];",
            "                    if (finalClause.isElse) {",
            "                      this.ErrorWithParsedObject(\"Multiple 'else' cases. Can have a maximum of one, at the end.\", finalClause);",
            "                    } else {",
            "                      this.ErrorWithParsedObject(\"'else' case in conditional should always be the final one\", alt);",
            "                    }",
            "                  } else {",
            "                    this.ErrorWithParsedObject(\"Branch doesn't have condition. Are you missing a ':'? \", alt);",
            "                  }",
            "                }",
            "              }",
            "            }",
            "            if (alternatives.length === 1 && alternatives[0].ownExpression === null) {",
            "              this.ErrorWithParsedObject(\"Condition block with no conditions\", alternatives[0]);",
            "            }",
            "          }",
            "        }",
            "        // TODO: Come up with water-tight error conditions... it's quite a flexible system!",
            "        // e.g.",
            "        //   - inline conditionals must have exactly 1 or 2 alternatives",
            "        //   - multiline expression shouldn't have mixed existence of branch-conditions?",
            "        if (alternatives === null) {",
            "          return null;",
            "        }",
            "        for (const branch of alternatives) {",
            "          branch.isInline = isInline;",
            "        }",
            "        const cond = new Conditional(initialQueryExpression, alternatives);",
            "        return cond;",
            "      };",
            "      this.InlineConditionalBranches = () => {",
            "        const listOfLists = this.Interleave(this.MixedTextAndLogic, this.Exclude(this.String(\"|\")), null, false);",
            "        if (listOfLists === null || listOfLists.length === 0) {",
            "          return null;",
            "        }",
            "        const result = [];",
            "        if (listOfLists.length > 2) {",
            "          this.Error(\"Expected one or two alternatives separated by '|' in inline conditional\");",
            "        } else {",
            "          const trueBranch = new ConditionalSingleBranch(listOfLists[0]);",
            "          trueBranch.isTrueBranch = true;",
            "          result.push(trueBranch);",
            "          if (listOfLists.length > 1) {",
            "            const elseBranch = new ConditionalSingleBranch(listOfLists[1]);",
            "            elseBranch.isElse = true;",
            "            result.push(elseBranch);",
            "          }",
            "        }",
            "        return result;",
            "      };",
            "      this.MultilineConditionalBranches = () => {",
            "        this.MultilineWhitespace();",
            "        const multipleConditions = this.OneOrMore(this.SingleMultilineCondition);",
            "        if (multipleConditions === null) {",
            "          return null;",
            "        }",
            "        this.MultilineWhitespace();",
            "        return multipleConditions;",
            "      };",
            "      this.SingleMultilineCondition = () => {",
            "        this.Whitespace();",
            "        if (",
            "        // Make sure we're not accidentally parsing a divert",
            "        this.ParseString(\"->\") !== null || this.ParseString(\"-\") === null) {",
            "          return null;",
            "        }",
            "        this.Whitespace();",
            "        let expr = null;",
            "        const isElse = this.Parse(this.ElseExpression) !== null;",
            "        if (!isElse) {",
            "          expr = this.Parse(this.ConditionExpression);",
            "        }",
            "        let content = this.StatementsAtLevel(exports.StatementLevel.InnerBlock);",
            "        if (expr === null && content === null) {",
            "          this.Error(\"expected content for the conditional branch following '-'\");",
            "          // Recover",
            "          content = [new Text(\"\")];",
            "        }",
            "        // Allow additional multiline whitespace, if the statements were empty (valid)",
            "        // then their surrounding multiline whitespacce needs to be handled manually.",
            "        // e.g.",
            "        // { x:",
            "        //   - 1:    // intentionally left blank, but newline needs to be parsed",
            "        //   - 2: etc",
            "        // }",
            "        this.MultilineWhitespace();",
            "        const branch = new ConditionalSingleBranch(content);",
            "        branch.ownExpression = expr;",
            "        branch.isElse = isElse;",
            "        return branch;",
            "      };",
            "      this.ConditionExpression = () => {",
            "        const expr = this.Parse(this.Expression);",
            "        if (expr === null) {",
            "          return null;",
            "        }",
            "        this.DisallowIncrement(expr);",
            "        this.Whitespace();",
            "        if (this.ParseString(\":\") === null) {",
            "          return null;",
            "        }",
            "        return expr;",
            "      };",
            "      this.ElseExpression = () => {",
            "        if (this.ParseString(\"else\") === null) {",
            "          return null;",
            "        }",
            "        this.Whitespace();",
            "        if (this.ParseString(\":\") === null) {",
            "          return null;",
            "        }",
            "        return ParseSuccess;",
            "      };",
            "      /**",
            "       * End Conditional section.",
            "       */",
            "      /**",
            "       * Begin Content section.",
            "       */",
            "      this._nonTextPauseCharacters = null;",
            "      this._nonTextEndCharacters = null;",
            "      this._notTextEndCharactersChoice = null;",
            "      this._notTextEndCharactersString = null;",
            "      this.TrimEndWhitespace = (mixedTextAndLogicResults, terminateWithSpace) => {",
            "        // Trim whitespace from end",
            "        if (mixedTextAndLogicResults.length > 0) {",
            "          const lastObjIdx = mixedTextAndLogicResults.length - 1;",
            "          const lastObj = mixedTextAndLogicResults[lastObjIdx];",
            "          if (lastObj instanceof Text) {",
            "            const textObj = lastObj;",
            "            textObj.text = textObj.text.replace(new RegExp(/[ \\t]+$/g), \"\");",
            "            if (terminateWithSpace) {",
            "              textObj.text += \" \";",
            "            } else if (textObj.text.length === 0) {",
            "              // No content left at all? trim the whole object",
            "              mixedTextAndLogicResults.splice(lastObjIdx, 1);",
            "              // Recurse in case there's more whitespace",
            "              this.TrimEndWhitespace(mixedTextAndLogicResults, false);",
            "            }",
            "          }",
            "        }",
            "      };",
            "      this.LineOfMixedTextAndLogic = () => {",
            "        // Consume any whitespace at the start of the line",
            "        // (Except for escaped whitespace)",
            "        this.Parse(this.Whitespace);",
            "        let result = this.Parse(this.MixedTextAndLogic);",
            "        if (!result || !result.length) {",
            "          return null;",
            "        }",
            "        // Warn about accidentally writing \"return\" without \"~\"",
            "        const firstText = result[0];",
            "        if (firstText && firstText.text && firstText.text.startsWith(\"return\")) {",
            "          this.Warning(\"Do you need a '~' before 'return'? If not, perhaps use a glue: <> (since it's lowercase) or rewrite somehow?\");",
            "        }",
            "        if (result.length === 0) {",
            "          return null;",
            "        }",
            "        const lastObj = result[result.length - 1];",
            "        if (!(lastObj instanceof Divert)) {",
            "          this.TrimEndWhitespace(result, false);",
            "        }",
            "        this.EndTagIfNecessary(result);",
            "        // If the line doens't actually contain any normal text content",
            "        // but is in fact entirely a tag, then let's not append",
            "        // a newline, since we want the tag (or tags) to be associated",
            "        // with the line below rather than being completely independent.",
            "        let lineIsPureTag = result.length > 0 && result[0] instanceof Tag && result[0].isStart;",
            "        if (!lineIsPureTag) {",
            "          result.push(new Text(\"\\n\"));",
            "        }",
            "        this.Expect(this.EndOfLine, \"end of line\", this.SkipToNextLine);",
            "        return result;",
            "      };",
            "      this.MixedTextAndLogic = () => {",
            "        // Check for disallowed \"~\" within this context",
            "        const disallowedTilde = this.ParseObject(this.Spaced(this.String(\"~\")));",
            "        if (disallowedTilde !== null) {",
            "          this.Error(\"You shouldn't use a '~' here - tildas are for logic that's on its own line. To do inline logic, use { curly braces } instead\");",
            "        }",
            "        // Either, or both interleaved",
            "        let results = this.Interleave(this.Optional(this.ContentText), this.Optional(this.InlineLogicOrGlueOrStartTag));",
            "        // Terminating divert?",
            "        // (When parsing content for the text of a choice, diverts aren't allowed.",
            "        //  The divert on the end of the body of a choice is handled specially.)",
            "        if (!this._parsingChoice) {",
            "          const diverts = this.Parse(this.MultiDivert);",
            "          if (diverts !== null) {",
            "            // May not have had any results at all if there's *only* a divert!",
            "            if (results === null) {",
            "              results = [];",
            "            }",
            "            // End previously active tag if necessary",
            "            this.EndTagIfNecessary(results);",
            "            this.TrimEndWhitespace(results, true);",
            "            results.push(...diverts);",
            "          }",
            "        }",
            "        if (!results) {",
            "          return null;",
            "        }",
            "        return results;",
            "      };",
            "      this.ContentText = () => {",
            "        return this.ContentTextAllowingEscapeChar();",
            "      };",
            "      this.ContentTextAllowingEscapeChar = () => {",
            "        let sb = null;",
            "        do {",
            "          let str = this.Parse(this.ContentTextNoEscape);",
            "          const gotEscapeChar = this.ParseString(\"\\\\\") !== null;",
            "          if (gotEscapeChar || str !== null) {",
            "            if (sb === null) {",
            "              sb = \"\";",
            "            }",
            "            if (str !== null) {",
            "              sb += String(str);",
            "            }",
            "            if (gotEscapeChar) {",
            "              const c = this.ParseSingleCharacter();",
            "              sb += c;",
            "            }",
            "          } else {",
            "            break;",
            "          }",
            "        } while (true);",
            "        if (sb !== null) {",
            "          return new Text(sb);",
            "        }",
            "        return null;",
            "      };",
            "      // Content text is an unusual parse rule compared with most since it's",
            "      // less about saying \"this is is the small selection of stuff that we parse\"",
            "      // and more \"we parse ANYTHING except this small selection of stuff\".",
            "      this.ContentTextNoEscape = () => {",
            "        // Eat through text, pausing at the following characters, and",
            "        // attempt to parse the nonTextRule.",
            "        // \"-\": possible start of divert or start of gather",
            "        // \"<\": possible start of glue",
            "        if (this._nonTextPauseCharacters === null) {",
            "          this._nonTextPauseCharacters = new CharacterSet(\"-<\");",
            "        }",
            "        // If we hit any of these characters, we stop *immediately* without bothering to even check the nonTextRule",
            "        // \"{\" for start of logic",
            "        // \"|\" for mid logic branch",
            "        if (this._nonTextEndCharacters === null) {",
            "          this._nonTextEndCharacters = new CharacterSet(\"{}|\\n\\r\\\\#\");",
            "          this._notTextEndCharactersChoice = new CharacterSet(this._nonTextEndCharacters);",
            "          this._notTextEndCharactersChoice.AddCharacters(\"[]\");",
            "          this._notTextEndCharactersString = new CharacterSet(this._nonTextEndCharacters);",
            "          this._notTextEndCharactersString.AddCharacters('\"');",
            "        }",
            "        // When the ParseUntil pauses, check these rules in case they evaluate successfully",
            "        const nonTextRule = () => this.OneOf([this.ParseDivertArrow, this.ParseThreadArrow, this.EndOfLine, this.Glue]);",
            "        let endChars = null;",
            "        if (this.parsingStringExpression) {",
            "          endChars = this._notTextEndCharactersString;",
            "        } else if (this._parsingChoice) {",
            "          endChars = this._notTextEndCharactersChoice;",
            "        } else {",
            "          endChars = this._nonTextEndCharacters;",
            "        }",
            "        const pureTextContent = this.ParseUntil(nonTextRule, this._nonTextPauseCharacters, endChars);",
            "        if (pureTextContent !== null) {",
            "          return pureTextContent;",
            "        }",
            "        return null;",
            "      };",
            "      /**",
            "       * End Content section.",
            "       */",
            "      /**",
            "       * Begin Divert section.",
            "       */",
            "      this.MultiDivert = () => {",
            "        this.Whitespace();",
            "        let diverts = [];",
            "        // Try single thread first",
            "        const threadDivert = this.Parse(this.StartThread);",
            "        if (threadDivert) {",
            "          diverts = [threadDivert];",
            "          return diverts;",
            "        }",
            "        // Normal diverts and tunnels",
            "        const arrowsAndDiverts = this.Interleave(this.ParseDivertArrowOrTunnelOnwards, this.DivertIdentifierWithArguments);",
            "        if (!arrowsAndDiverts) {",
            "          return null;",
            "        }",
            "        diverts = [];",
            "        this.EndTagIfNecessary(diverts);",
            "        // Possible patterns:",
            "        //  ->                   -- explicit gather",
            "        //  ->->                 -- tunnel onwards",
            "        //  -> div               -- normal divert",
            "        //  ->-> div             -- tunnel onwards, followed by override divert",
            "        //  -> div ->            -- normal tunnel",
            "        //  -> div ->->          -- tunnel then tunnel continue",
            "        //  -> div -> div        -- tunnel then divert",
            "        //  -> div -> div ->     -- tunnel then tunnel",
            "        //  -> div -> div ->->",
            "        //  -> div -> div ->-> div    (etc)",
            "        // Look at the arrows and diverts",
            "        for (let ii = 0; ii < arrowsAndDiverts.length; ++ii) {",
            "          const isArrow = ii % 2 === 0;",
            "          // Arrow string",
            "          if (isArrow) {",
            "            // Tunnel onwards",
            "            if (arrowsAndDiverts[ii] === \"->->\") {",
            "              const tunnelOnwardsPlacementValid = ii === 0 || ii === arrowsAndDiverts.length - 1 || ii === arrowsAndDiverts.length - 2;",
            "              if (!tunnelOnwardsPlacementValid) {",
            "                this.Error(\"Tunnel onwards '->->' must only come at the begining or the start of a divert\");",
            "              }",
            "              const tunnelOnwards = new TunnelOnwards();",
            "              if (ii < arrowsAndDiverts.length - 1) {",
            "                const tunnelOnwardDivert = asOrNull(arrowsAndDiverts[ii + 1], Divert);",
            "                tunnelOnwards.divertAfter = tunnelOnwardDivert;",
            "              }",
            "              diverts.push(tunnelOnwards);",
            "              // Not allowed to do anything after a tunnel onwards.",
            "              // If we had anything left it would be caused in the above Error for",
            "              // the positioning of a ->->",
            "              break;",
            "            }",
            "          } else {",
            "            // Divert",
            "            const divert = arrowsAndDiverts[ii];",
            "            // More to come? (further arrows) Must be tunnelling.",
            "            if (ii < arrowsAndDiverts.length - 1) {",
            "              divert.isTunnel = true;",
            "            }",
            "            diverts.push(divert);",
            "          }",
            "        }",
            "        // Single -> (used for default choices)",
            "        if (diverts.length === 0 && arrowsAndDiverts.length === 1) {",
            "          const gatherDivert = new Divert(null);",
            "          gatherDivert.isEmpty = true;",
            "          diverts.push(gatherDivert);",
            "          if (!this._parsingChoice) {",
            "            this.Error(\"Empty diverts (->) are only valid on choices\");",
            "          }",
            "        }",
            "        return diverts;",
            "      };",
            "      this.StartThread = () => {",
            "        this.Whitespace();",
            "        if (this.ParseThreadArrow() === null) {",
            "          return null;",
            "        }",
            "        this.Whitespace();",
            "        const divert = this.Expect(this.DivertIdentifierWithArguments, \"target for new thread\", () => new Divert(null));",
            "        divert.isThread = true;",
            "        return divert;",
            "      };",
            "      this.DivertIdentifierWithArguments = () => {",
            "        this.Whitespace();",
            "        const targetComponents = this.Parse(this.DotSeparatedDivertPathComponents);",
            "        if (!targetComponents) {",
            "          return null;",
            "        }",
            "        this.Whitespace();",
            "        const optionalArguments = this.Parse(this.ExpressionFunctionCallArguments);",
            "        this.Whitespace();",
            "        const targetPath = new Path(targetComponents);",
            "        return new Divert(targetPath, optionalArguments);",
            "      };",
            "      this.SingleDivert = () => {",
            "        const diverts = this.Parse(this.MultiDivert);",
            "        if (!diverts) {",
            "          return null;",
            "        }",
            "        // Ideally we'd report errors if we get the",
            "        // wrong kind of divert, but unfortunately we",
            "        // have to hack around the fact that sequences use",
            "        // a very similar syntax.",
            "        // i.e. if you have a multi-divert at the start",
            "        // of a sequence, it initially tries to parse it",
            "        // as a divert target (part of an expression of",
            "        // a conditional) and gives errors. So instead",
            "        // we just have to blindly reject it as a single",
            "        // divert, and give a slightly less nice error",
            "        // when you DO use a multi divert as a divert taret.",
            "        if (diverts.length !== 1) {",
            "          return null;",
            "        }",
            "        const singleDivert = diverts[0];",
            "        if (singleDivert instanceof TunnelOnwards) {",
            "          return null;",
            "        }",
            "        const divert = diverts[0];",
            "        if (divert.isTunnel) {",
            "          return null;",
            "        }",
            "        return divert;",
            "      };",
            "      this.DotSeparatedDivertPathComponents = () => this.Interleave(this.Spaced(this.IdentifierWithMetadata), this.Exclude(this.String(\".\")));",
            "      this.ParseDivertArrowOrTunnelOnwards = () => {",
            "        let numArrows = 0;",
            "        while (this.ParseString(\"->\") !== null) {",
            "          numArrows += 1;",
            "        }",
            "        if (numArrows === 0) {",
            "          return null;",
            "        } else if (numArrows === 1) {",
            "          return \"->\";",
            "        } else if (numArrows === 2) {",
            "          return \"->->\";",
            "        }",
            "        this.Error(\"Unexpected number of arrows in divert. Should only have '->' or '->->'\");",
            "        return \"->->\";",
            "      };",
            "      this.ParseDivertArrow = () => this.ParseString(\"->\");",
            "      this.ParseThreadArrow = () => this.ParseString(\"<-\");",
            "      /**",
            "       * End Divert section.",
            "       */",
            "      /**",
            "       * Begin Expressions section.",
            "       */",
            "      this._binaryOperators = [];",
            "      this._maxBinaryOpLength = 0;",
            "      this.TempDeclarationOrAssignment = () => {",
            "        this.Whitespace();",
            "        const isNewDeclaration = this.ParseTempKeyword();",
            "        this.Whitespace();",
            "        let varIdentifier = null;",
            "        if (isNewDeclaration) {",
            "          varIdentifier = this.Expect(this.IdentifierWithMetadata, \"variable name\");",
            "        } else {",
            "          varIdentifier = this.Parse(this.IdentifierWithMetadata);",
            "        }",
            "        if (varIdentifier === null) {",
            "          return null;",
            "        }",
            "        this.Whitespace();",
            "        // += -=",
            "        const isIncrement = this.ParseString(\"+\") !== null;",
            "        const isDecrement = this.ParseString(\"-\") !== null;",
            "        if (isIncrement && isDecrement) {",
            "          this.Error(\"Unexpected sequence '+-'\");",
            "        }",
            "        if (this.ParseString(\"=\") === null) {",
            "          // Definitely in an assignment expression?",
            "          if (isNewDeclaration) {",
            "            this.Error(\"Expected '='\");",
            "          }",
            "          return null;",
            "        }",
            "        const assignedExpression = this.Expect(this.Expression, \"value expression to be assigned\");",
            "        if (isIncrement || isDecrement) {",
            "          const result = new IncDecExpression(varIdentifier, assignedExpression, isIncrement);",
            "          return result;",
            "        }",
            "        const result = new VariableAssignment({",
            "          variableIdentifier: varIdentifier,",
            "          assignedExpression,",
            "          isTemporaryNewDeclaration: isNewDeclaration",
            "        });",
            "        return result;",
            "      };",
            "      this.DisallowIncrement = expr => {",
            "        if (expr instanceof IncDecExpression) {",
            "          this.Error(\"Can't use increment/decrement here. It can only be used on a ~ line\");",
            "        }",
            "      };",
            "      this.ParseTempKeyword = () => {",
            "        const ruleId = this.BeginRule();",
            "        if (this.Parse(this.Identifier) === \"temp\") {",
            "          this.SucceedRule(ruleId);",
            "          return true;",
            "        }",
            "        this.FailRule(ruleId);",
            "        return false;",
            "      };",
            "      this.ReturnStatement = () => {",
            "        this.Whitespace();",
            "        const returnOrDone = this.Parse(this.Identifier);",
            "        if (returnOrDone !== \"return\") {",
            "          return null;",
            "        }",
            "        this.Whitespace();",
            "        const expr = this.Parse(this.Expression);",
            "        const returnObj = new ReturnType(expr);",
            "        return returnObj;",
            "      };",
            "      // Pratt Parser",
            "      // aka \"Top down operator precedence parser\"",
            "      // http://journal.stuffwithstuff.com/2011/03/19/pratt-parsers-expression-parsing-made-easy/",
            "      // Algorithm overview:",
            "      // The two types of precedence are handled in two different ways:",
            "      //   ((((a . b) . c) . d) . e)\t\t\t#1",
            "      //   (a . (b . (c . (d . e))))\t\t\t#2",
            "      // Where #1 is automatically handled by successive loops within the main 'while' in this function,",
            "      // so long as continuing operators have lower (or equal) precedence (e.g. imagine some series of \"*\"s then \"+\" above.",
            "      // ...and #2 is handled by recursion of the right hand term in the binary expression parser.",
            "      // (see link for advice on how to extend for postfix and mixfix operators)",
            "      this.Expression = function () {",
            "        let minimumPrecedence = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;",
            "        _this.Whitespace();",
            "        // First parse a unary expression e.g. \"-a\" or parethensised \"(1 + 2)\"",
            "        let expr = _this.ExpressionUnary();",
            "        if (expr === null) {",
            "          return null;",
            "        }",
            "        _this.Whitespace();",
            "        // Attempt to parse (possibly multiple) continuing infix expressions (e.g. 1 + 2 + 3)",
            "        while (true) {",
            "          const ruleId = _this.BeginRule();",
            "          // Operator",
            "          const infixOp = _this.ParseInfixOperator();",
            "          if (infixOp !== null && infixOp.precedence > minimumPrecedence) {",
            "            // Expect right hand side of operator",
            "            const expectationMessage = `right side of '${infixOp.type}' expression`;",
            "            const multiaryExpr = _this.Expect(() => _this.ExpressionInfixRight(expr, infixOp), expectationMessage);",
            "            if (multiaryExpr === null) {",
            "              // Fail for operator and right-hand side of multiary expression",
            "              _this.FailRule(ruleId);",
            "              return null;",
            "            }",
            "            expr = _this.SucceedRule(ruleId, multiaryExpr);",
            "            continue;",
            "          }",
            "          _this.FailRule(ruleId);",
            "          break;",
            "        }",
            "        _this.Whitespace();",
            "        return expr;",
            "      };",
            "      this.ExpressionUnary = () => {",
            "        // Divert target is a special case - it can't have any other operators",
            "        // applied to it, and we also want to check for it first so that we don't",
            "        // confuse \"->\" for subtraction.",
            "        const divertTarget = this.Parse(this.ExpressionDivertTarget);",
            "        if (divertTarget !== null) {",
            "          return divertTarget;",
            "        }",
            "        let prefixOp = this.OneOf([this.String(\"-\"), this.String(\"!\")]);",
            "        // Don't parse like the string rules above, in case its actually",
            "        // a variable that simply starts with \"not\", e.g. \"notable\".",
            "        // This rule uses the Identifier rule, which will scan as much text",
            "        // as possible before returning.",
            "        if (prefixOp === null) {",
            "          prefixOp = this.Parse(this.ExpressionNot);",
            "        }",
            "        this.Whitespace();",
            "        // - Since we allow numbers at the start of variable names, variable names are checked before literals",
            "        // - Function calls before variable names in case we see parentheses",
            "        let expr = this.OneOf([this.ExpressionList, this.ExpressionParen, this.ExpressionFunctionCall, this.ExpressionVariableName, this.ExpressionLiteral]);",
            "        // Only recurse immediately if we have one of the (usually optional) unary ops",
            "        if (expr === null && prefixOp !== null) {",
            "          expr = this.ExpressionUnary();",
            "        }",
            "        if (expr === null) {",
            "          return null;",
            "        } else if (prefixOp !== null) {",
            "          expr = UnaryExpression.WithInner(expr, prefixOp);",
            "        }",
            "        this.Whitespace();",
            "        const postfixOp = this.OneOf([this.String(\"++\"), this.String(\"--\")]);",
            "        if (postfixOp !== null) {",
            "          const isInc = postfixOp === \"++\";",
            "          if (!(expr instanceof VariableReference)) {",
            "            this.Error(`can only increment and decrement variables, but saw '${expr}'.`);",
            "            // Drop down and succeed without the increment after reporting error",
            "          } else {",
            "            const varRef = expr;",
            "            expr = new IncDecExpression(varRef.identifier, isInc);",
            "          }",
            "        }",
            "        return expr;",
            "      };",
            "      this.ExpressionNot = () => {",
            "        const id = this.Identifier();",
            "        if (id === \"not\") {",
            "          return id;",
            "        }",
            "        return null;",
            "      };",
            "      this.ExpressionLiteral = () => this.OneOf([this.ExpressionFloat, this.ExpressionInt, this.ExpressionBool, this.ExpressionString]);",
            "      this.ExpressionDivertTarget = () => {",
            "        this.Whitespace();",
            "        const divert = this.Parse(this.SingleDivert);",
            "        if (!divert || divert && divert.isThread) {",
            "          return null;",
            "        }",
            "        this.Whitespace();",
            "        return new DivertTarget(divert);",
            "      };",
            "      this.ExpressionInt = () => {",
            "        const intOrNull = this.ParseInt();",
            "        if (intOrNull === null) {",
            "          return null;",
            "        }",
            "        return new NumberExpression(intOrNull, \"int\");",
            "      };",
            "      this.ExpressionFloat = () => {",
            "        const floatOrNull = this.ParseFloat();",
            "        if (floatOrNull === null) {",
            "          return null;",
            "        }",
            "        return new NumberExpression(floatOrNull, \"float\");",
            "      };",
            "      this.ExpressionString = () => {",
            "        const openQuote = this.ParseString('\"');",
            "        if (openQuote === null) {",
            "          return null;",
            "        }",
            "        // Set custom parser state flag so that within the text parser,",
            "        // it knows to treat the quote character (\") as an end character",
            "        this.parsingStringExpression = true;",
            "        let textAndLogic = this.Parse(this.MixedTextAndLogic);",
            "        this.Expect(this.String('\"'), \"close quote for string expression\");",
            "        this.parsingStringExpression = false;",
            "        if (textAndLogic === null) {",
            "          textAndLogic = [new Text(\"\")];",
            "        } else if (textAndLogic.find(c => c instanceof Divert)) {",
            "          this.Error(\"String expressions cannot contain diverts (->)\");",
            "        }",
            "        return new StringExpression(textAndLogic);",
            "      };",
            "      this.ExpressionBool = () => {",
            "        const id = this.Parse(this.Identifier);",
            "        if (id === \"true\") {",
            "          return new NumberExpression(true, \"bool\");",
            "        } else if (id === \"false\") {",
            "          return new NumberExpression(false, \"bool\");",
            "        }",
            "        return null;",
            "      };",
            "      this.ExpressionFunctionCall = () => {",
            "        const iden = this.Parse(this.IdentifierWithMetadata);",
            "        if (iden === null) {",
            "          return null;",
            "        }",
            "        this.Whitespace();",
            "        const args = this.Parse(this.ExpressionFunctionCallArguments);",
            "        if (args === null) {",
            "          return null;",
            "        }",
            "        return new FunctionCall(iden, args);",
            "      };",
            "      this.ExpressionFunctionCallArguments = () => {",
            "        if (this.ParseString(\"(\") === null) {",
            "          return null;",
            "        }",
            "        // \"Exclude\" requires the rule to succeed, but causes actual comma string to be excluded from the list of results",
            "        const commas = this.Exclude(this.String(\",\"));",
            "        let args = this.Interleave(this.Expression, commas);",
            "        if (args === null) {",
            "          args = [];",
            "        }",
            "        this.Whitespace();",
            "        this.Expect(this.String(\")\"), \"closing ')' for function call\");",
            "        return args;",
            "      };",
            "      this.ExpressionVariableName = () => {",
            "        const path = this.Interleave(this.IdentifierWithMetadata, this.Exclude(this.Spaced(this.String(\".\"))));",
            "        if (path === null || Story.IsReservedKeyword(path[0].name)) {",
            "          return null;",
            "        }",
            "        return new VariableReference(path);",
            "      };",
            "      this.ExpressionParen = () => {",
            "        if (this.ParseString(\"(\") === null) {",
            "          return null;",
            "        }",
            "        const innerExpr = this.Parse(this.Expression);",
            "        if (innerExpr === null) {",
            "          return null;",
            "        }",
            "        this.Whitespace();",
            "        this.Expect(this.String(\")\"), \"closing parenthesis ')' for expression\");",
            "        return innerExpr;",
            "      };",
            "      this.ExpressionInfixRight = (left, op) => {",
            "        if (!left) {",
            "          return null;",
            "        }",
            "        this.Whitespace();",
            "        const right = this.Parse(() => this.Expression(op.precedence));",
            "        if (right) {",
            "          // We assume that the character we use for the operator's type is the same",
            "          // as that used internally by e.g. Runtime.Expression.Add, Runtime.Expression.Multiply etc",
            "          const expr = new BinaryExpression(left, right, op.type);",
            "          return expr;",
            "        }",
            "        return null;",
            "      };",
            "      this.ParseInfixOperator = () => {",
            "        for (const op of this._binaryOperators) {",
            "          const ruleId = this.BeginRule();",
            "          if (this.ParseString(op.type) !== null) {",
            "            if (op.requireWhitespace) {",
            "              if (this.Whitespace() === null) {",
            "                this.FailRule(ruleId);",
            "                continue;",
            "              }",
            "            }",
            "            return this.SucceedRule(ruleId, op);",
            "          }",
            "          this.FailRule(ruleId);",
            "        }",
            "        return null;",
            "      };",
            "      this.ExpressionList = () => {",
            "        this.Whitespace();",
            "        if (this.ParseString(\"(\") === null) {",
            "          return null;",
            "        }",
            "        this.Whitespace();",
            "        // When list has:",
            "        //  - 0 elements (null list) - this is okay, it's an empty list: \"()\"",
            "        //  - 1 element - it could be confused for a single non-list related",
            "        //    identifier expression in brackets, but this is a useless thing",
            "        //    to do, so we reserve that syntax for a list with one item.",
            "        //  - 2 or more elements - normal!",
            "        const memberNames = this.SeparatedList(this.ListMember, this.Spaced(this.String(\",\")));",
            "        this.Whitespace();",
            "        // May have failed to parse the inner list - the parentheses may",
            "        // be for a normal expression",
            "        if (this.ParseString(\")\") === null) {",
            "          return null;",
            "        }",
            "        return new List(memberNames);",
            "      };",
            "      this.ListMember = () => {",
            "        this.Whitespace();",
            "        let identifier = this.Parse(this.IdentifierWithMetadata);",
            "        if (identifier === null) {",
            "          return null;",
            "        }",
            "        const dot = this.ParseString(\".\");",
            "        if (dot !== null) {",
            "          const identifier2 = this.Expect(this.IdentifierWithMetadata, `element name within the set ${identifier}`);",
            "          identifier.name += `.${identifier2 === null || identifier2 === void 0 ? void 0 : identifier2.name}`;",
            "        }",
            "        this.Whitespace();",
            "        return identifier;",
            "      };",
            "      this.RegisterExpressionOperators = () => {",
            "        // These will be tried in order, so we need \"<=\" before \"<\"",
            "        // for correctness",
            "        this.RegisterBinaryOperator(\"&&\", 1);",
            "        this.RegisterBinaryOperator(\"||\", 1);",
            "        this.RegisterBinaryOperator(\"and\", 1, true);",
            "        this.RegisterBinaryOperator(\"or\", 1, true);",
            "        this.RegisterBinaryOperator(\"==\", 2);",
            "        this.RegisterBinaryOperator(\">=\", 2);",
            "        this.RegisterBinaryOperator(\"<=\", 2);",
            "        this.RegisterBinaryOperator(\"<\", 2);",
            "        this.RegisterBinaryOperator(\">\", 2);",
            "        this.RegisterBinaryOperator(\"!=\", 2);",
            "        // (apples, oranges) + cabbages has (oranges, cabbages) === true",
            "        this.RegisterBinaryOperator(\"?\", 3);",
            "        this.RegisterBinaryOperator(\"has\", 3, true);",
            "        this.RegisterBinaryOperator(\"!?\", 3);",
            "        this.RegisterBinaryOperator(\"hasnt\", 3, true);",
            "        this.RegisterBinaryOperator(\"^\", 3);",
            "        this.RegisterBinaryOperator(\"+\", 4);",
            "        this.RegisterBinaryOperator(\"-\", 5);",
            "        this.RegisterBinaryOperator(\"*\", 6);",
            "        this.RegisterBinaryOperator(\"/\", 7);",
            "        this.RegisterBinaryOperator(\"%\", 8);",
            "        this.RegisterBinaryOperator(\"mod\", 8, true);",
            "      };",
            "      this.RegisterBinaryOperator = function (op, precedence) {",
            "        let requireWhitespace = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;",
            "        const infix = new InfixOperator(op, precedence, requireWhitespace);",
            "        _this._binaryOperators.push(infix);",
            "        _this._maxBinaryOpLength = Math.max(_this._maxBinaryOpLength, op.length);",
            "      };",
            "      this._openFilenames = [];",
            "      this.IncludeStatement = () => {",
            "        this.Whitespace();",
            "        if (this.ParseString(\"INCLUDE\") === null) {",
            "          return null;",
            "        }",
            "        this.Whitespace();",
            "        let filename = this.Expect(() => this.ParseUntilCharactersFromString(\"\\n\\r\"), \"filename for include statement\");",
            "        filename = filename.replace(new RegExp(/[ \\t]+$/g), \"\");",
            "        // Working directory should already have been set up relative to the root ink file.",
            "        const fullFilename = this.fileHandler.ResolveInkFilename(filename);",
            "        if (this.FilenameIsAlreadyOpen(fullFilename)) {",
            "          this.Error(`Recursive INCLUDE detected: '${fullFilename}' is already open.`);",
            "          this.ParseUntilCharactersFromString(\"\\r\\n\");",
            "          return new IncludedFile(null);",
            "        } else {",
            "          this.AddOpenFilename(fullFilename);",
            "        }",
            "        let includedStory = null;",
            "        let includedString = \"\";",
            "        try {",
            "          includedString = this._rootParser.fileHandler.LoadInkFileContents(fullFilename);",
            "        } catch (err) {",
            "          this.Error(`Failed to load: '${filename}'.\\nError:${err}`);",
            "        }",
            "        if (includedString != null) {",
            "          const parser = new InkParser(includedString, filename, this._externalErrorHandler, this._rootParser, this.fileHandler);",
            "          includedStory = parser.ParseStory();",
            "        }",
            "        this.RemoveOpenFilename(fullFilename);",
            "        // Return valid IncludedFile object even if there were errors when parsing.",
            "        // We don't want to attempt to re-parse the include line as something else,",
            "        // and we want to include the bits that *are* valid, so we don't generate",
            "        // more errors than necessary.",
            "        return new IncludedFile(includedStory);",
            "      };",
            "      this.FilenameIsAlreadyOpen = fullFilename => this._rootParser._openFilenames.includes(fullFilename);",
            "      this.AddOpenFilename = fullFilename => {",
            "        this._rootParser._openFilenames.push(fullFilename);",
            "      };",
            "      this.RemoveOpenFilename = fullFilename => {",
            "        this._rootParser._openFilenames.splice(this._rootParser._openFilenames.indexOf(fullFilename), 1);",
            "      };",
            "      /**",
            "       * End Include section.",
            "       */",
            "      /**",
            "       * Begin Knot section.",
            "       */",
            "      this.KnotDefinition = () => {",
            "        const knotDecl = this.Parse(this.KnotDeclaration);",
            "        if (knotDecl === null) {",
            "          return null;",
            "        }",
            "        this.Expect(this.EndOfLine, \"end of line after knot name definition\", this.SkipToNextLine);",
            "        const innerKnotStatements = () => this.StatementsAtLevel(exports.StatementLevel.Knot);",
            "        const content = this.Expect(innerKnotStatements, \"at least one line within the knot\", this.KnotStitchNoContentRecoveryRule);",
            "        return new Knot(knotDecl.name, content, knotDecl.args, knotDecl.isFunction);",
            "      };",
            "      this.KnotDeclaration = () => {",
            "        this.Whitespace();",
            "        if (this.KnotTitleEquals() === null) {",
            "          return null;",
            "        }",
            "        this.Whitespace();",
            "        const identifier = this.Parse(this.IdentifierWithMetadata);",
            "        let knotName;",
            "        const isFunc = (identifier === null || identifier === void 0 ? void 0 : identifier.name) === \"function\";",
            "        if (isFunc) {",
            "          this.Expect(this.Whitespace, \"whitespace after the 'function' keyword\");",
            "          knotName = this.Parse(this.IdentifierWithMetadata);",
            "        } else {",
            "          knotName = identifier;",
            "        }",
            "        if (knotName === null) {",
            "          this.Error(`Expected the name of the ${isFunc ? \"function\" : \"knot\"}`);",
            "          knotName = new Identifier(\"\"); // prevent later null ref",
            "        }",
            "        this.Whitespace();",
            "        const parameterNames = this.Parse(this.BracketedKnotDeclArguments);",
            "        this.Whitespace();",
            "        // Optional equals after name",
            "        this.Parse(this.KnotTitleEquals);",
            "        return new FlowDecl(knotName, parameterNames, isFunc);",
            "      };",
            "      this.KnotTitleEquals = () => {",
            "        // 2+ \"=\" starts a knot",
            "        const multiEquals = this.ParseCharactersFromString(\"=\");",
            "        if (multiEquals === null || multiEquals.length <= 1) {",
            "          return null;",
            "        }",
            "        return multiEquals;",
            "      };",
            "      this.StitchDefinition = () => {",
            "        const decl = this.Parse(this.StitchDeclaration);",
            "        if (decl === null) {",
            "          return null;",
            "        }",
            "        this.Expect(this.EndOfLine, \"end of line after stitch name\", this.SkipToNextLine);",
            "        const innerStitchStatements = () => this.StatementsAtLevel(exports.StatementLevel.Stitch);",
            "        const content = this.Expect(innerStitchStatements, \"at least one line within the stitch\", this.KnotStitchNoContentRecoveryRule);",
            "        return new Stitch(decl.name, content, decl.args, decl.isFunction);",
            "      };",
            "      this.StitchDeclaration = () => {",
            "        this.Whitespace();",
            "        // Single \"=\" to define a stitch",
            "        if (this.ParseString(\"=\") === null) {",
            "          return null;",
            "        }",
            "        // If there's more than one \"=\", that's actually a knot definition (or divert), so this rule should fail",
            "        if (this.ParseString(\"=\") !== null) {",
            "          return null;",
            "        }",
            "        this.Whitespace();",
            "        // Stitches aren't allowed to be functions, but we parse it anyway and report the error later",
            "        const isFunc = this.ParseString(\"function\") !== null;",
            "        if (isFunc) {",
            "          this.Whitespace();",
            "        }",
            "        const stitchName = this.Parse(this.IdentifierWithMetadata);",
            "        if (stitchName === null) {",
            "          return null;",
            "        }",
            "        this.Whitespace();",
            "        const flowArgs = this.Parse(this.BracketedKnotDeclArguments);",
            "        this.Whitespace();",
            "        return new FlowDecl(stitchName, flowArgs, isFunc);",
            "      };",
            "      this.KnotStitchNoContentRecoveryRule = () => {",
            "        // Jump ahead to the next knot or the end of the file",
            "        this.ParseUntil(this.KnotDeclaration, new CharacterSet(\"=\"), null);",
            "        const recoveredFlowContent = [new Text(\"<ERROR IN FLOW>\")];",
            "        return recoveredFlowContent;",
            "      };",
            "      this.BracketedKnotDeclArguments = () => {",
            "        if (this.ParseString(\"(\") === null) {",
            "          return null;",
            "        }",
            "        let flowArguments = this.Interleave(this.Spaced(this.FlowDeclArgument), this.Exclude(this.String(\",\")));",
            "        this.Expect(this.String(\")\"), \"closing ')' for parameter list\");",
            "        // If no parameters, create an empty list so that this method is type safe and",
            "        // doesn't attempt to return the ParseSuccess object",
            "        if (flowArguments === null) {",
            "          flowArguments = [];",
            "        }",
            "        return flowArguments;",
            "      };",
            "      this.FlowDeclArgument = () => {",
            "        // Possible forms:",
            "        //  name",
            "        //  -> name      (variable divert target argument",
            "        //  ref name",
            "        //  ref -> name  (variable divert target by reference)",
            "        const firstIden = this.Parse(this.IdentifierWithMetadata);",
            "        this.Whitespace();",
            "        const divertArrow = this.ParseDivertArrow();",
            "        this.Whitespace();",
            "        const secondIden = this.Parse(this.IdentifierWithMetadata);",
            "        if (firstIden == null && secondIden === null) {",
            "          return null;",
            "        }",
            "        const flowArg = new Argument();",
            "        if (divertArrow !== null) {",
            "          flowArg.isDivertTarget = true;",
            "        }",
            "        // Passing by reference",
            "        if (firstIden !== null && firstIden.name === \"ref\") {",
            "          if (secondIden === null) {",
            "            this.Error(\"Expected an parameter name after 'ref'\");",
            "          }",
            "          flowArg.identifier = secondIden;",
            "          flowArg.isByReference = true;",
            "        } else {",
            "          // Simple argument name",
            "          if (flowArg.isDivertTarget) {",
            "            flowArg.identifier = secondIden;",
            "          } else {",
            "            flowArg.identifier = firstIden;",
            "          }",
            "          if (flowArg.identifier === null) {",
            "            this.Error(\"Expected an parameter name\");",
            "          }",
            "          flowArg.isByReference = false;",
            "        }",
            "        return flowArg;",
            "      };",
            "      this.ExternalDeclaration = () => {",
            "        this.Whitespace();",
            "        const external = this.Parse(this.IdentifierWithMetadata);",
            "        if (external === null || external.name != \"EXTERNAL\") {",
            "          return null;",
            "        }",
            "        this.Whitespace();",
            "        const funcIdentifier = this.Expect(this.IdentifierWithMetadata, \"name of external function\") || new Identifier(\"\");",
            "        this.Whitespace();",
            "        let parameterNames = this.Expect(this.BracketedKnotDeclArguments, `declaration of arguments for EXTERNAL, even if empty, i.e. 'EXTERNAL ${funcIdentifier}()'`);",
            "        if (parameterNames === null) {",
            "          parameterNames = [];",
            "        }",
            "        const argNames = parameterNames.map(arg => {",
            "          var _a;",
            "          return (_a = arg.identifier) === null || _a === void 0 ? void 0 : _a.name;",
            "        }).filter(filterUndef);",
            "        return new ExternalDeclaration(funcIdentifier, argNames);",
            "      };",
            "      /**",
            "       * End Knot section.",
            "       */",
            "      /**",
            "       * Start Logic section.",
            "       */",
            "      this._identifierCharSet = null;",
            "      this.LogicLine = () => {",
            "        this.Whitespace();",
            "        if (this.ParseString(\"~\") === null) {",
            "          return null;",
            "        }",
            "        this.Whitespace();",
            "        // Some example lines we need to be able to distinguish between:",
            "        // ~ temp x = 5  -- var decl + assign",
            "        // ~ temp x      -- var decl",
            "        // ~ x = 5       -- var assign",
            "        // ~ x           -- expr (not var decl or assign)",
            "        // ~ f()         -- expr",
            "        // We don't treat variable decl/assign as an expression since we don't want an assignment",
            "        // to have a return value, or to be used in compound expressions.",
            "        const afterTilde = () => this.OneOf([this.ReturnStatement, this.TempDeclarationOrAssignment, this.Expression]);",
            "        let result = this.Expect(afterTilde, \"expression after '~'\", this.SkipToNextLine);",
            "        // Prevent further errors, already reported expected expression and have skipped to next line.",
            "        if (result === null) {",
            "          return new ContentList();",
            "        }",
            "        // Parse all expressions, but tell the writer off if they did something useless like:",
            "        //  ~ 5 + 4",
            "        // And even:",
            "        //  ~ false && myFunction()",
            "        // ...since it's bad practice, and won't do what they expect if",
            "        // they're expecting C's lazy evaluation.",
            "        if (result instanceof Expression && !(result instanceof FunctionCall || result instanceof IncDecExpression)) {",
            "          this.Error(\"Logic following a '~' can't be that type of expression. It can only be something like:\\n\\t~ return\\n\\t~ var x = blah\\n\\t~ x++\\n\\t~ myFunction()\");",
            "        }",
            "        // Line is pure function call? e.g.",
            "        //  ~ f()",
            "        // Add extra pop to make sure we tidy up after ourselves.",
            "        // We no longer need anything on the evaluation stack.",
            "        const funCall = asOrNull(result, FunctionCall);",
            "        if (funCall) {",
            "          funCall.shouldPopReturnedValue = true;",
            "        }",
            "        // If the expression contains a function call, then it could produce a text side effect,",
            "        // in which case it needs a newline on the end. e.g.",
            "        //  ~ printMyName()",
            "        //  ~ x = 1 + returnAValueAndAlsoPrintStuff()",
            "        // If no text gets printed, then the extra newline will have to be culled later.",
            "        // Multiple newlines on the output will be removed, so there will be no \"leak\" for",
            "        // long running calculations. It's disappointingly messy though :-/",
            "        if (result.Find(FunctionCall)() !== null) {",
            "          result = new ContentList(result, new Text(\"\\n\"));",
            "        }",
            "        this.Expect(this.EndOfLine, \"end of line\", this.SkipToNextLine);",
            "        return result;",
            "      };",
            "      this.VariableDeclaration = () => {",
            "        this.Whitespace();",
            "        const id = this.Parse(this.Identifier);",
            "        if (id !== \"VAR\") {",
            "          return null;",
            "        }",
            "        this.Whitespace();",
            "        const varName = this.Expect(this.IdentifierWithMetadata, \"variable name\");",
            "        this.Whitespace();",
            "        this.Expect(this.String(\"=\"), \"the '=' for an assignment of a value, e.g. '= 5' (initial values are mandatory)\");",
            "        this.Whitespace();",
            "        const definition = this.Expect(this.Expression, \"initial value for \");",
            "        const expr = definition;",
            "        if (expr) {",
            "          const check = expr instanceof NumberExpression || expr instanceof StringExpression || expr instanceof DivertTarget || expr instanceof VariableReference || expr instanceof List;",
            "          if (!check) {",
            "            this.Error(\"initial value for a variable must be a number, constant, list or divert target\");",
            "          }",
            "          if (this.Parse(this.ListElementDefinitionSeparator) !== null) {",
            "            this.Error(\"Unexpected ','. If you're trying to declare a new list, use the LIST keyword, not VAR\");",
            "          } else if (expr instanceof StringExpression) {",
            "            // Ensure string expressions are simple",
            "            const strExpr = expr;",
            "            if (!strExpr.isSingleString) {",
            "              this.Error(\"Constant strings cannot contain any logic.\");",
            "            }",
            "          }",
            "          const result = new VariableAssignment({",
            "            assignedExpression: expr,",
            "            isGlobalDeclaration: true,",
            "            variableIdentifier: varName",
            "          });",
            "          return result;",
            "        }",
            "        return null;",
            "      };",
            "      this.ListDeclaration = () => {",
            "        this.Whitespace();",
            "        const id = this.Parse(this.Identifier);",
            "        if (id != \"LIST\") {",
            "          return null;",
            "        }",
            "        this.Whitespace();",
            "        const varName = this.Expect(this.IdentifierWithMetadata, \"list name\");",
            "        this.Whitespace();",
            "        this.Expect(this.String(\"=\"), \"the '=' for an assignment of the list definition\");",
            "        this.Whitespace();",
            "        const definition = this.Expect(this.ListDefinition, \"list item names\");",
            "        if (definition) {",
            "          definition.identifier = new Identifier(varName.name);",
            "          return new VariableAssignment({",
            "            variableIdentifier: varName,",
            "            listDef: definition",
            "          });",
            "        }",
            "        return null;",
            "      };",
            "      this.ListDefinition = () => {",
            "        this.AnyWhitespace();",
            "        const allElements = this.SeparatedList(this.ListElementDefinition, this.ListElementDefinitionSeparator);",
            "        if (allElements === null) {",
            "          return null;",
            "        }",
            "        return new ListDefinition(allElements);",
            "      };",
            "      this.ListElementDefinitionSeparator = () => {",
            "        this.AnyWhitespace();",
            "        if (this.ParseString(\",\") === null) {",
            "          return null;",
            "        }",
            "        this.AnyWhitespace();",
            "        return \",\";",
            "      };",
            "      this.ListElementDefinition = () => {",
            "        const inInitialList = this.ParseString(\"(\") !== null;",
            "        let needsToCloseParen = inInitialList;",
            "        this.Whitespace();",
            "        const name = this.Parse(this.IdentifierWithMetadata);",
            "        if (name === null) {",
            "          return null;",
            "        }",
            "        this.Whitespace();",
            "        if (inInitialList) {",
            "          if (this.ParseString(\")\") != null) {",
            "            needsToCloseParen = false;",
            "            this.Whitespace();",
            "          }",
            "        }",
            "        let elementValue = null;",
            "        if (this.ParseString(\"=\") !== null) {",
            "          this.Whitespace();",
            "          const elementValueNum = this.Expect(this.ExpressionInt, \"value to be assigned to list item\");",
            "          if (elementValueNum !== null) {",
            "            elementValue = elementValueNum.value;",
            "          }",
            "          if (needsToCloseParen) {",
            "            this.Whitespace();",
            "            if (this.ParseString(\")\") !== null) {",
            "              needsToCloseParen = false;",
            "            }",
            "          }",
            "        }",
            "        if (needsToCloseParen) {",
            "          this.Error(\"Expected closing ')'\");",
            "        }",
            "        return new ListElementDefinition(name, inInitialList, elementValue);",
            "      };",
            "      this.ConstDeclaration = () => {",
            "        this.Whitespace();",
            "        const id = this.Parse(this.Identifier);",
            "        if (id !== \"CONST\") {",
            "          return null;",
            "        }",
            "        this.Whitespace();",
            "        const varName = this.Expect(this.IdentifierWithMetadata, \"constant name\");",
            "        this.Whitespace();",
            "        this.Expect(this.String(\"=\"), \"the '=' for an assignment of a value, e.g. '= 5' (initial values are mandatory)\");",
            "        this.Whitespace();",
            "        const expr = this.Expect(this.Expression, \"initial value for \");",
            "        const check = expr instanceof NumberExpression || expr instanceof DivertTarget || expr instanceof StringExpression;",
            "        if (!check) {",
            "          this.Error(\"initial value for a constant must be a number or divert target\");",
            "        } else if (expr instanceof StringExpression) {",
            "          // Ensure string expressions are simple",
            "          const strExpr = expr;",
            "          if (!strExpr.isSingleString) {",
            "            this.Error(\"Constant strings cannot contain any logic.\");",
            "          }",
            "        }",
            "        const result = new ConstantDeclaration(varName, expr);",
            "        return result;",
            "      };",
            "      this.InlineLogicOrGlueOrStartTag = () => this.OneOf([this.InlineLogic, this.Glue, this.StartTag]);",
            "      this.Glue = () => {",
            "        // Don't want to parse whitespace, since it might be important",
            "        // surrounding the glue.",
            "        const glueStr = this.ParseString(\"<>\");",
            "        if (glueStr !== null) {",
            "          return new Glue$1(new Glue());",
            "        }",
            "        return null;",
            "      };",
            "      this.InlineLogic = () => {",
            "        if (this.ParseString(\"{\") === null) {",
            "          return null;",
            "        }",
            "        let wasParsingString = this.parsingStringExpression;",
            "        let wasTagActive = this.tagActive;",
            "        this.Whitespace();",
            "        const logic = this.Expect(this.InnerLogic, \"some kind of logic, conditional or sequence within braces: { ... }\");",
            "        if (logic === null) {",
            "          this.parsingStringExpression = wasParsingString;",
            "          return null;",
            "        }",
            "        this.DisallowIncrement(logic);",
            "        let contentList = asOrNull(logic, ContentList);",
            "        if (!contentList) {",
            "          contentList = new ContentList(logic);",
            "        }",
            "        this.Whitespace();",
            "        this.Expect(this.String(\"}\"), \"closing brace '}' for inline logic\");",
            "        // Allow nested strings and logic",
            "        this.parsingStringExpression = wasParsingString;",
            "        // Difference between:",
            "        //",
            "        //     1) A thing # {image}.jpg",
            "        //     2) A {red #red|blue #blue} sequence.",
            "        //",
            "        //  When logic ends in (1) we still want tag to continue.",
            "        //  When logic ends in (2) we want to auto-end the tag.",
            "        //  Side note: we simply disallow tags within strings.",
            "        if (!wasTagActive) this.EndTagIfNecessary(contentList);",
            "        return contentList;",
            "      };",
            "      this.InnerLogic = () => {",
            "        this.Whitespace();",
            "        // Explicitly try the combinations of inner logic",
            "        // that could potentially have conflicts first.",
            "        // Explicit sequence annotation?",
            "        const explicitSeqType = this.ParseObject(this.SequenceTypeAnnotation);",
            "        if (explicitSeqType !== null) {",
            "          const contentLists = this.Expect(this.InnerSequenceObjects, \"sequence elements (for cycle/stoping etc)\");",
            "          if (contentLists === null) {",
            "            return null;",
            "          }",
            "          return new Sequence(contentLists, explicitSeqType);",
            "        }",
            "        // Conditional with expression?",
            "        const initialQueryExpression = this.Parse(this.ConditionExpression);",
            "        if (initialQueryExpression) {",
            "          const conditional = this.Expect(() => this.InnerConditionalContent(initialQueryExpression), \"conditional content following query\");",
            "          return conditional;",
            "        }",
            "        // Now try to evaluate each of the \"full\" rules in turn",
            "        const rules = [",
            "        // Conditional still necessary, since you can have a multi-line conditional",
            "        // without an initial query expression:",
            "        // {",
            "        //   - true:  this is true",
            "        //   - false: this is false",
            "        // }",
            "        this.InnerConditionalContent, this.InnerSequence, this.InnerExpression];",
            "        this.tagActive;",
            "        // Adapted from \"OneOf\" structuring rule except that in",
            "        // order for the rule to succeed, it has to maximally",
            "        // cover the entire string within the { }. Used to",
            "        // differentiate between:",
            "        //  {myVar}                 -- Expression (try first)",
            "        //  {my content is jolly}   -- sequence with single element",
            "        for (const rule of rules) {",
            "          const ruleId = this.BeginRule();",
            "          const result = this.ParseObject(rule);",
            "          if (result) {",
            "            // Not yet at end?",
            "            if (this.Peek(this.Spaced(this.String(\"}\"))) === null) {",
            "              this.FailRule(ruleId);",
            "            } else {",
            "              // Full parse of content within braces",
            "              return this.SucceedRule(ruleId, result);",
            "            }",
            "          } else {",
            "            this.FailRule(ruleId);",
            "          }",
            "        }",
            "        return null;",
            "      };",
            "      this.InnerExpression = () => {",
            "        const expr = this.Parse(this.Expression);",
            "        if (expr) {",
            "          expr.outputWhenComplete = true;",
            "        }",
            "        return expr;",
            "      };",
            "      this.IdentifierWithMetadata = () => {",
            "        const id = this.Identifier();",
            "        if (id === null) {",
            "          return null;",
            "        }",
            "        return new Identifier(id);",
            "      };",
            "      // Note: we allow identifiers that start with a number,",
            "      // but not if they *only* comprise numbers",
            "      this.Identifier = () => {",
            "        // Parse remaining characters (if any)",
            "        const name = this.ParseCharactersFromCharSet(this.identifierCharSet);",
            "        if (name === null) {",
            "          return null;",
            "        }",
            "        // Reject if it's just a number",
            "        let isNumberCharsOnly = true;",
            "        for (let c of name) {",
            "          if (!(c >= \"0\" && c <= \"9\")) {",
            "            isNumberCharsOnly = false;",
            "            break;",
            "          }",
            "        }",
            "        if (isNumberCharsOnly) {",
            "          return null;",
            "        }",
            "        return name;",
            "      };",
            "      /**",
            "       * End Logic section.",
            "       */",
            "      /**",
            "       * Begin Sequences section.",
            "       */",
            "      this._sequenceTypeSymbols = new CharacterSet(\"!&~$\");",
            "      this.InnerSequence = () => {",
            "        this.Whitespace();",
            "        // Default sequence type",
            "        let seqType = SequenceType.Stopping;",
            "        // Optional explicit sequence type",
            "        const parsedSeqType = this.Parse(this.SequenceTypeAnnotation);",
            "        if (parsedSeqType !== null) {",
            "          seqType = parsedSeqType;",
            "        }",
            "        const contentLists = this.Parse(this.InnerSequenceObjects);",
            "        if (contentLists === null || contentLists.length <= 1) {",
            "          return null;",
            "        }",
            "        return new Sequence(contentLists, seqType);",
            "      };",
            "      this.SequenceTypeAnnotation = () => {",
            "        let annotation = this.Parse(this.SequenceTypeSymbolAnnotation);",
            "        if (annotation === null) {",
            "          annotation = this.Parse(this.SequenceTypeWordAnnotation);",
            "        }",
            "        if (annotation === null) {",
            "          return null;",
            "        }",
            "        switch (annotation) {",
            "          case SequenceType.Once:",
            "          case SequenceType.Cycle:",
            "          case SequenceType.Stopping:",
            "          case SequenceType.Shuffle:",
            "          case SequenceType.Shuffle | SequenceType.Stopping:",
            "          case SequenceType.Shuffle | SequenceType.Once:",
            "            break;",
            "          default:",
            "            this.Error(`Sequence type combination not supported: ${annotation}`);",
            "            return SequenceType.Stopping;",
            "        }",
            "        return annotation;",
            "      };",
            "      this.SequenceTypeSymbolAnnotation = () => {",
            "        if (this._sequenceTypeSymbols === null) {",
            "          this._sequenceTypeSymbols = new CharacterSet(\"!&~$ \");",
            "        }",
            "        let sequenceType = 0;",
            "        const sequenceAnnotations = this.ParseCharactersFromCharSet(this._sequenceTypeSymbols);",
            "        if (sequenceAnnotations === null) {",
            "          return null;",
            "        }",
            "        for (const symbolChar of sequenceAnnotations) {",
            "          switch (symbolChar) {",
            "            case \"!\":",
            "              sequenceType |= SequenceType.Once;",
            "              break;",
            "            case \"&\":",
            "              sequenceType |= SequenceType.Cycle;",
            "              break;",
            "            case \"~\":",
            "              sequenceType |= SequenceType.Shuffle;",
            "              break;",
            "            case \"$\":",
            "              sequenceType |= SequenceType.Stopping;",
            "              break;",
            "          }",
            "        }",
            "        if (sequenceType === 0) {",
            "          return null;",
            "        }",
            "        return sequenceType;",
            "      };",
            "      this.SequenceTypeWordAnnotation = () => {",
            "        const sequenceTypes = this.Interleave(this.SequenceTypeSingleWord, this.Exclude(this.Whitespace));",
            "        if (sequenceTypes === null || sequenceTypes.length === 0) {",
            "          return null;",
            "        }",
            "        if (this.ParseString(\":\") === null) {",
            "          return null;",
            "        }",
            "        let combinedSequenceType = 0;",
            "        for (const seqType of sequenceTypes) {",
            "          combinedSequenceType |= seqType;",
            "        }",
            "        return combinedSequenceType;",
            "      };",
            "      this.SequenceTypeSingleWord = () => {",
            "        let seqType = null;",
            "        const word = this.Parse(this.IdentifierWithMetadata);",
            "        if (word !== null) {",
            "          switch (word.name) {",
            "            case \"once\":",
            "              seqType = SequenceType.Once;",
            "              break;",
            "            case \"cycle\":",
            "              seqType = SequenceType.Cycle;",
            "              break;",
            "            case \"shuffle\":",
            "              seqType = SequenceType.Shuffle;",
            "              break;",
            "            case \"stopping\":",
            "              seqType = SequenceType.Stopping;",
            "              break;",
            "          }",
            "        }",
            "        if (seqType === null) {",
            "          return null;",
            "        }",
            "        return seqType;",
            "      };",
            "      this.InnerSequenceObjects = () => {",
            "        const multiline = this.Parse(this.Newline) !== null;",
            "        let result = null;",
            "        if (multiline) {",
            "          result = this.Parse(this.InnerMultilineSequenceObjects);",
            "        } else {",
            "          result = this.Parse(this.InnerInlineSequenceObjects);",
            "        }",
            "        return result;",
            "      };",
            "      this.InnerInlineSequenceObjects = () => {",
            "        const interleavedContentAndPipes = this.Interleave(this.Optional(this.MixedTextAndLogic), this.String(\"|\"), null, false);",
            "        if (interleavedContentAndPipes === null) {",
            "          return null;",
            "        }",
            "        const result = [];",
            "        // The content and pipes won't necessarily be perfectly interleaved in the sense that",
            "        // the content can be missing, but in that case it's intended that there's blank content.",
            "        let justHadContent = false;",
            "        for (const contentOrPipe of interleavedContentAndPipes) {",
            "          // Pipe/separator",
            "          if (contentOrPipe === \"|\") {",
            "            // Expected content, saw pipe - need blank content now",
            "            if (!justHadContent) {",
            "              // Add blank content",
            "              result.push(new ContentList());",
            "            }",
            "            justHadContent = false;",
            "          } else {",
            "            // Real content",
            "            const content = contentOrPipe;",
            "            if (content === null) {",
            "              this.Error(`Expected content, but got ${contentOrPipe} (this is an ink compiler bug!)`);",
            "            } else {",
            "              result.push(new ContentList(content));",
            "            }",
            "            justHadContent = true;",
            "          }",
            "        }",
            "        // Ended in a pipe? Need to insert final blank content",
            "        if (!justHadContent) {",
            "          result.push(new ContentList());",
            "        }",
            "        return result;",
            "      };",
            "      this.InnerMultilineSequenceObjects = () => {",
            "        this.MultilineWhitespace();",
            "        const contentLists = this.OneOrMore(this.SingleMultilineSequenceElement);",
            "        if (contentLists === null) {",
            "          return null;",
            "        }",
            "        return contentLists;",
            "      };",
            "      this.SingleMultilineSequenceElement = () => {",
            "        this.Whitespace();",
            "        // Make sure we're not accidentally parsing a divert",
            "        if (this.ParseString(\"->\") !== null) {",
            "          return null;",
            "        }",
            "        if (this.ParseString(\"-\") === null) {",
            "          return null;",
            "        }",
            "        this.Whitespace();",
            "        const content = this.StatementsAtLevel(exports.StatementLevel.InnerBlock);",
            "        if (content === null) {",
            "          this.MultilineWhitespace();",
            "        } else {",
            "          // Add newline at the start of each branch",
            "          content.unshift(new Text(\"\\n\"));",
            "        }",
            "        return new ContentList(content);",
            "      };",
            "      /**",
            "       * End Sequences section.",
            "       */",
            "      /**",
            "       * Begin Statements section.",
            "       */",
            "      this._statementRulesAtLevel = [];",
            "      this._statementBreakRulesAtLevel = [];",
            "      this.StatementsAtLevel = level => {",
            "        // Check for error: Should not be allowed gather dashes within an inner block",
            "        if (level === exports.StatementLevel.InnerBlock) {",
            "          const badGatherDashCount = this.Parse(this.GatherDashes);",
            "          if (badGatherDashCount !== null) {",
            "            this.Error(\"You can't use a gather (the dashes) within the { curly braces } context. For multi-line sequences and conditions, you should only use one dash.\");",
            "          }",
            "        }",
            "        return this.Interleave(this.Optional(this.MultilineWhitespace), () => this.StatementAtLevel(level), () => this.StatementsBreakForLevel(level));",
            "      };",
            "      this.StatementAtLevel = level => {",
            "        const rulesAtLevel = this._statementRulesAtLevel[level];",
            "        const statement = this.OneOf(rulesAtLevel);",
            "        // For some statements, allow them to parse, but create errors, since",
            "        // writers may think they can use the statement, so it's useful to have",
            "        // the error message.",
            "        if (level === exports.StatementLevel.Top) {",
            "          if (statement instanceof ReturnType) {",
            "            this.Error(\"should not have return statement outside of a knot\");",
            "          }",
            "        }",
            "        return statement;",
            "      };",
            "      this.StatementsBreakForLevel = level => {",
            "        this.Whitespace();",
            "        const breakRules = this._statementBreakRulesAtLevel[level];",
            "        const breakRuleResult = this.OneOf(breakRules);",
            "        if (breakRuleResult === null) {",
            "          return null;",
            "        }",
            "        return breakRuleResult;",
            "      };",
            "      this.GenerateStatementLevelRules = () => {",
            "        const levels = Object.values(exports.StatementLevel);",
            "        this._statementRulesAtLevel = \"f\".repeat(levels.length).split(\"f\").map(() => []);",
            "        this._statementBreakRulesAtLevel = \"f\".repeat(levels.length).split(\"f\").map(() => []);",
            "        for (const level of levels) {",
            "          const rulesAtLevel = [];",
            "          const breakingRules = [];",
            "          // Diverts can go anywhere",
            "          rulesAtLevel.push(this.Line(this.MultiDivert));",
            "          // Knots can only be parsed at Top/Global scope",
            "          if (level >= exports.StatementLevel.Top) {",
            "            rulesAtLevel.push(this.KnotDefinition);",
            "          }",
            "          rulesAtLevel.push(this.Line(this.Choice));",
            "          rulesAtLevel.push(this.Line(this.AuthorWarning));",
            "          // Gather lines would be confused with multi-line block separators, like",
            "          // within a multi-line if statement",
            "          if (level > exports.StatementLevel.InnerBlock) {",
            "            rulesAtLevel.push(this.Gather);",
            "          }",
            "          // Stitches (and gathers) can (currently) only go in Knots and top level",
            "          if (level >= exports.StatementLevel.Knot) {",
            "            rulesAtLevel.push(this.StitchDefinition);",
            "          }",
            "          // Global variable declarations can go anywhere",
            "          rulesAtLevel.push(this.Line(this.ListDeclaration));",
            "          rulesAtLevel.push(this.Line(this.VariableDeclaration));",
            "          rulesAtLevel.push(this.Line(this.ConstDeclaration));",
            "          rulesAtLevel.push(this.Line(this.ExternalDeclaration));",
            "          // Global include can go anywhere",
            "          rulesAtLevel.push(this.Line(this.IncludeStatement));",
            "          // Normal logic / text can go anywhere",
            "          rulesAtLevel.push(this.LogicLine);",
            "          rulesAtLevel.push(this.LineOfMixedTextAndLogic);",
            "          // --------",
            "          // Breaking rules",
            "          // Break current knot with a new knot",
            "          if (level <= exports.StatementLevel.Knot) {",
            "            breakingRules.push(this.KnotDeclaration);",
            "          }",
            "          // Break current stitch with a new stitch",
            "          if (level <= exports.StatementLevel.Stitch) {",
            "            breakingRules.push(this.StitchDeclaration);",
            "          }",
            "          // Breaking an inner block (like a multi-line condition statement)",
            "          if (level <= exports.StatementLevel.InnerBlock) {",
            "            breakingRules.push(this.ParseDashNotArrow);",
            "            breakingRules.push(this.String(\"}\"));",
            "          }",
            "          this._statementRulesAtLevel[level] = rulesAtLevel;",
            "          this._statementBreakRulesAtLevel[level] = breakingRules;",
            "        }",
            "      };",
            "      this.SkipToNextLine = () => {",
            "        this.ParseUntilCharactersFromString(\"\\n\\r\");",
            "        this.ParseNewline();",
            "        return ParseSuccess;",
            "      };",
            "      // Modifier to turn a rule into one that expects a newline on the end.",
            "      // e.g. anywhere you can use \"MixedTextAndLogic\" as a rule, you can use",
            "      // \"Line(MixedTextAndLogic)\" to specify that it expects a newline afterwards.",
            "      this.Line = inlineRule => () => {",
            "        const result = this.ParseObject(inlineRule);",
            "        if (result === null) {",
            "          return null;",
            "        }",
            "        this.Expect(this.EndOfLine, \"end of line\", this.SkipToNextLine);",
            "        return result;",
            "      };",
            "      /**",
            "       * End Statements section.",
            "       */",
            "      /**",
            "       * Begin Tags section.",
            "       */",
            "      this.StartTag = () => {",
            "        this.Whitespace();",
            "        if (this.ParseString(\"#\") === null) {",
            "          return null;",
            "        }",
            "        if (this.parsingStringExpression) {",
            "          this.Error(\"Tags aren't allowed inside of strings. Please use \\\\# if you want a hash symbol.\");",
            "        }",
            "        let result = null;",
            "        if (this.tagActive) {",
            "          let contentList = new ContentList();",
            "          contentList.AddContent(new Tag( /*isStart:*/false));",
            "          contentList.AddContent(new Tag( /*isStart:*/true));",
            "          result = contentList;",
            "        } else {",
            "          result = new Tag( /*isStart:*/true);",
            "        }",
            "        this.tagActive = true;",
            "        this.Whitespace();",
            "        return result;",
            "      };",
            "      /**",
            "       * End Tags section.",
            "       */",
            "      /**",
            "       * Begin Whitespace section.",
            "       */",
            "      this._inlineWhitespaceChars = new CharacterSet(\" \\t\");",
            "      // Handles both newline and endOfFile",
            "      this.EndOfLine = () => this.OneOf([this.Newline, this.EndOfFile]);",
            "      // Allow whitespace before the actual newline",
            "      this.Newline = () => {",
            "        this.Whitespace();",
            "        const gotNewline = this.ParseNewline() !== null;",
            "        // Optional \\r, definite \\n to support Windows (\\r\\n) and Mac/Unix (\\n)",
            "        if (!gotNewline) {",
            "          return null;",
            "        }",
            "        return ParseSuccess;",
            "      };",
            "      this.EndOfFile = () => {",
            "        this.Whitespace();",
            "        if (!this.endOfInput) return null;",
            "        return ParseSuccess;",
            "      };",
            "      // General purpose space, returns N-count newlines (fails if no newlines)",
            "      this.MultilineWhitespace = () => {",
            "        let newlines = this.OneOrMore(this.Newline);",
            "        if (newlines === null) {",
            "          return null;",
            "        }",
            "        // Use content field of Token to say how many newlines there were",
            "        // (in most circumstances it's unimportant)",
            "        const numNewlines = newlines.length;",
            "        if (numNewlines >= 1) {",
            "          return ParseSuccess;",
            "        }",
            "        return null;",
            "      };",
            "      this.Whitespace = () => {",
            "        const doneParsed = this.ParseCharactersFromCharSet(this._inlineWhitespaceChars);",
            "        if (doneParsed !== null) {",
            "          return ParseSuccess;",
            "        }",
            "        return null;",
            "      };",
            "      this.Spaced = rule => () => {",
            "        this.Whitespace();",
            "        const result = this.ParseObject(rule);",
            "        if (result === null) {",
            "          return null;",
            "        }",
            "        this.Whitespace();",
            "        return result;",
            "      };",
            "      this.AnyWhitespace = () => {",
            "        let anyWhitespace = false;",
            "        while (this.OneOf([this.Whitespace, this.MultilineWhitespace]) !== null) {",
            "          anyWhitespace = true;",
            "        }",
            "        return anyWhitespace ? ParseSuccess : null;",
            "      };",
            "      this.MultiSpaced = rule => () => {",
            "        this.AnyWhitespace();",
            "        const result = this.ParseObject(rule);",
            "        if (result === null) {",
            "          return null;",
            "        }",
            "        this.AnyWhitespace();",
            "        return result;",
            "      };",
            "      this._filename = null;",
            "      this._externalErrorHandler = null;",
            "      this._fileHandler = null;",
            "      this._filename = filename;",
            "      this.RegisterExpressionOperators();",
            "      this.GenerateStatementLevelRules();",
            "      this.errorHandler = this.OnStringParserError;",
            "      this._externalErrorHandler = externalErrorHandler;",
            "      if (fileHandler === null) {",
            "        this._fileHandler = new DefaultFileHandler();",
            "      } else {",
            "        this._fileHandler = fileHandler;",
            "      }",
            "      if (rootParser === null) {",
            "        this._rootParser = this;",
            "        this._openFilenames = [];",
            "        if (this._filename !== null) {",
            "          const fullRootInkPath = this.fileHandler.ResolveInkFilename(this._filename);",
            "          this._openFilenames.push(fullRootInkPath);",
            "        }",
            "      } else {",
            "        this._rootParser = rootParser;",
            "      }",
            "    }",
            "    PreProcessInputString(str) {",
            "      const commentEliminator = new CommentEliminator(str);",
            "      return commentEliminator.Process();",
            "    }",
            "    get parsingStringExpression() {",
            "      return this.GetFlag(Number(CustomFlags.ParsingString));",
            "    }",
            "    set parsingStringExpression(value) {",
            "      this.SetFlag(Number(CustomFlags.ParsingString), value);",
            "    }",
            "    get tagActive() {",
            "      return this.GetFlag(Number(CustomFlags.TagActive));",
            "    }",
            "    set tagActive(value) {",
            "      this.SetFlag(Number(CustomFlags.TagActive), value);",
            "    }",
            "    get identifierCharSet() {",
            "      if (this._identifierCharSet === null) {",
            "        (this._identifierCharSet = new CharacterSet()).AddRange(\"A\", \"Z\").AddRange(\"a\", \"z\").AddRange(\"0\", \"9\").Add(\"_\");",
            "        // Enable non-ASCII characters for story identifiers.",
            "        this.ExtendIdentifierCharacterRanges(this._identifierCharSet);",
            "      }",
            "      return this._identifierCharSet;",
            "    }",
            "    EndTagIfNecessary(outputContentList) {",
            "      if (this.tagActive) {",
            "        if (outputContentList != null) {",
            "          if (outputContentList instanceof ContentList) {",
            "            outputContentList.AddContent(new Tag( /*isStart:*/false));",
            "          } else {",
            "            outputContentList.push(new Tag( /*isStart:*/false));",
            "          }",
            "        }",
            "        this.tagActive = false;",
            "      }",
            "    }",
            "  }",
            "  /**",
            "   * End base InkParser section.",
            "   */",
            "  /**",
            "   * Begin CharacterRanges section.",
            "   */",
            "  InkParser.LatinBasic = CharacterRange.Define(\"\\u0041\", \"\\u007A\", new CharacterSet().AddRange(\"\\u005B\", \"\\u0060\"));",
            "  InkParser.LatinExtendedA = CharacterRange.Define(\"\\u0100\", \"\\u017F\"",
            "  // no excludes here",
            "  );",
            "  InkParser.LatinExtendedB = CharacterRange.Define(\"\\u0180\", \"\\u024F\"",
            "  // no excludes here",
            "  );",
            "  InkParser.Greek = CharacterRange.Define(\"\\u0370\", \"\\u03FF\", new CharacterSet().AddRange(\"\\u0378\", \"\\u0385\").AddCharacters(\"\\u0374\\u0375\\u0378\\u0387\\u038B\\u038D\\u03A2\"));",
            "  InkParser.Cyrillic = CharacterRange.Define(\"\\u0400\", \"\\u04FF\", new CharacterSet().AddRange(\"\\u0482\", \"\\u0489\"));",
            "  InkParser.Armenian = CharacterRange.Define(\"\\u0530\", \"\\u058F\", new CharacterSet().AddCharacters(\"\\u0530\").AddRange(\"\\u0557\", \"\\u0560\").AddRange(\"\\u0588\", \"\\u058E\"));",
            "  InkParser.Hebrew = CharacterRange.Define(\"\\u0590\", \"\\u05FF\", new CharacterSet());",
            "  InkParser.Arabic = CharacterRange.Define(\"\\u0600\", \"\\u06FF\", new CharacterSet());",
            "  InkParser.Korean = CharacterRange.Define(\"\\uAC00\", \"\\uD7AF\", new CharacterSet());",
            "  /// <summary>",
            "  /// Gets an array of <see cref=\"CharacterRange\" /> representing all of the currently supported",
            "  /// non-ASCII character ranges that can be used in identifier names.",
            "  /// </summary>",
            "  /// <returns>",
            "  /// An array of <see cref=\"CharacterRange\" /> representing all of the currently supported",
            "  /// non-ASCII character ranges that can be used in identifier names.",
            "  /// </returns>",
            "  InkParser.ListAllCharacterRanges = () => [InkParser.LatinBasic, InkParser.LatinExtendedA, InkParser.LatinExtendedB, InkParser.Arabic, InkParser.Armenian, InkParser.Cyrillic, InkParser.Greek, InkParser.Hebrew, InkParser.Korean];",
            "",
            "  class JsonFileHandler {",
            "    constructor(fileHierarchy) {",
            "      this.fileHierarchy = fileHierarchy;",
            "      this.ResolveInkFilename = filename => {",
            "        if (Object.keys(this.fileHierarchy).includes(filename)) return filename;",
            "        throw new Error(`Cannot locate ${filename}. Are you trying a relative import ? This is not yet implemented.`);",
            "      };",
            "      this.LoadInkFileContents = filename => {",
            "        if (Object.keys(this.fileHierarchy).includes(filename)) {",
            "          return this.fileHierarchy[filename];",
            "        } else {",
            "          throw new Error(`Cannot open ${filename}.`);",
            "        }",
            "      };",
            "    }",
            "  }",
            "",
            "  class Compiler {",
            "    get errors() {",
            "      return this._errors;",
            "    }",
            "    get warnings() {",
            "      return this._warnings;",
            "    }",
            "    get authorMessages() {",
            "      return this._authorMessages;",
            "    }",
            "    get inputString() {",
            "      return this._inputString;",
            "    }",
            "    get options() {",
            "      return this._options;",
            "    }",
            "    get parsedStory() {",
            "      if (!this._parsedStory) {",
            "        throw new Error();",
            "      }",
            "      return this._parsedStory;",
            "    }",
            "    get runtimeStory() {",
            "      if (!this._runtimeStory) {",
            "        throw new Error(\"Compilation failed.\");",
            "      }",
            "      return this._runtimeStory;",
            "    }",
            "    get parser() {",
            "      if (!this._parser) {",
            "        throw new Error();",
            "      }",
            "      return this._parser;",
            "    }",
            "    get debugSourceRanges() {",
            "      return this._debugSourceRanges;",
            "    }",
            "    constructor(inkSource) {",
            "      let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;",
            "      this._errors = [];",
            "      this._warnings = [];",
            "      this._authorMessages = [];",
            "      this._parsedStory = null;",
            "      this._runtimeStory = null;",
            "      this._parser = null;",
            "      this._debugSourceRanges = [];",
            "      this.Compile = () => {",
            "        this._parser = new InkParser(this.inputString, this.options.sourceFilename || null, this.OnError, null, this.options.fileHandler);",
            "        this._parsedStory = this.parser.ParseStory();",
            "        if (this.errors.length === 0) {",
            "          this.parsedStory.countAllVisits = this.options.countAllVisits;",
            "          this._runtimeStory = this.parsedStory.ExportRuntime(this.OnError);",
            "        } else {",
            "          this._runtimeStory = null;",
            "        }",
            "        return this.runtimeStory;",
            "      };",
            "      this.RetrieveDebugSourceForLatestContent = () => {",
            "        var _a;",
            "        for (const outputObj of this.runtimeStory.state.outputStream) {",
            "          const textContent = asOrNull(outputObj, StringValue);",
            "          if (textContent !== null) {",
            "            const range = new DebugSourceRange(((_a = textContent.value) === null || _a === void 0 ? void 0 : _a.length) || 0, textContent.debugMetadata, textContent.value || \"unknown\");",
            "            this.debugSourceRanges.push(range);",
            "          }",
            "        }",
            "      };",
            "      this.DebugMetadataForContentAtOffset = offset => {",
            "        let currOffset = 0;",
            "        let lastValidMetadata = null;",
            "        for (const range of this.debugSourceRanges) {",
            "          if (range.debugMetadata !== null) {",
            "            lastValidMetadata = range.debugMetadata;",
            "          }",
            "          if (offset >= currOffset && offset < currOffset + range.length) {",
            "            return lastValidMetadata;",
            "          }",
            "          currOffset += range.length;",
            "        }",
            "        return null;",
            "      };",
            "      this.OnError = (message, errorType) => {",
            "        switch (errorType) {",
            "          case ErrorType$1.Author:",
            "            this._authorMessages.push(message);",
            "            break;",
            "          case ErrorType$1.Warning:",
            "            this._warnings.push(message);",
            "            break;",
            "          case ErrorType$1.Error:",
            "            this._errors.push(message);",
            "            break;",
            "        }",
            "        if (this.options.errorHandler !== null) {",
            "          this.options.errorHandler(message, errorType);",
            "        }",
            "      };",
            "      this._inputString = inkSource;",
            "      this._options = options || new CompilerOptions();",
            "    }",
            "  }",
            "",
            "  exports.Compiler = Compiler;",
            "  exports.CompilerOptions = CompilerOptions;",
            "  exports.InkList = InkList;",
            "  exports.InkParser = InkParser;",
            "  exports.JsonFileHandler = JsonFileHandler;",
            "  exports.Story = Story$1;",
            "",
            "  Object.defineProperty(exports, '__esModule', { value: true });",
            "",
            "}));",
            "//# sourceMappingURL=ink-full.js.map",
            ""
          ],
          "parameterObjects": "",
          "useStrict": true,
          "eventsSheetExpanded": false
        }
      ],
      "parameters": [],
      "objectGroups": []
    },
    {
      "description": "Check if the story is already loaded.",
      "fullName": "Is loaded",
      "functionType": "Condition",
      "group": "Story",
      "name": "IsLoaded",
      "sentence": "Story _PARAM1_ is loaded",
      "events": [
        {
          "type": "BuiltinCommonInstructions::JsCode",
          "inlineCode": [
            "if (gdjs._InkJS.stories[eventsFunctionContext.getArgument(\"Story\")])",
            "    eventsFunctionContext.returnValue = true;",
            "else",
            "    eventsFunctionContext.returnValue = false;"
          ],
          "parameterObjects": "",
          "useStrict": true,
          "eventsSheetExpanded": false
        }
      ],
      "parameters": [
        {
          "description": "Story name",
          "name": "Story",
          "supplementaryInformation": "sceneStory",
          "type": "identifier"
        }
      ],
      "objectGroups": []
    },
    {
      "description": "The story flow can progress.",
      "fullName": "Can continue",
      "functionType": "Condition",
      "group": "Story",
      "name": "CanContinue",
      "sentence": "Story _PARAM1_ can continue",
      "events": [
        {
          "type": "BuiltinCommonInstructions::Standard",
          "conditions": [],
          "actions": [
            {
              "type": {
                "value": "SetReturnBoolean"
              },
              "parameters": [
                "False"
              ]
            }
          ]
        },
        {
          "type": "BuiltinCommonInstructions::Standard",
          "conditions": [
            {
              "type": {
                "value": "InkJS::IsLoaded"
              },
              "parameters": [
                "",
                "Story",
                ""
              ]
            }
          ],
          "actions": [],
          "events": [
            {
              "type": "BuiltinCommonInstructions::JsCode",
              "inlineCode": [
                "eventsFunctionContext.returnValue = gdjs._InkJS.stories[eventsFunctionContext.getArgument(\"Story\")].story.canContinue;",
                ""
              ],
              "parameterObjects": "",
              "useStrict": true,
              "eventsSheetExpanded": false
            }
          ]
        }
      ],
      "parameters": [
        {
          "description": "Story name",
          "name": "Story",
          "supplementaryInformation": "sceneStory",
          "type": "identifier"
        }
      ],
      "objectGroups": []
    },
    {
      "description": "The story reached its end.",
      "fullName": "Has ended",
      "functionType": "Condition",
      "group": "Story",
      "name": "HasEnded",
      "sentence": "The story _PARAM1_ ended",
      "events": [
        {
          "type": "BuiltinCommonInstructions::Standard",
          "conditions": [],
          "actions": [
            {
              "type": {
                "value": "SetReturnBoolean"
              },
              "parameters": [
                ""
              ]
            }
          ]
        },
        {
          "type": "BuiltinCommonInstructions::Standard",
          "conditions": [
            {
              "type": {
                "value": "InkJS::IsLoaded"
              },
              "parameters": [
                "",
                "Story",
                ""
              ]
            },
            {
              "type": {
                "inverted": true,
                "value": "InkJS::CanContinue"
              },
              "parameters": [
                "",
                "Story",
                ""
              ]
            },
            {
              "type": {
                "value": "InkJS::ChoiceCount"
              },
              "parameters": [
                "",
                "=",
                "0",
                "Story",
                ""
              ]
            }
          ],
          "actions": [
            {
              "type": {
                "value": "SetReturnBoolean"
              },
              "parameters": [
                "True"
              ]
            }
          ]
        }
      ],
      "parameters": [
        {
          "description": "Story name",
          "name": "Story",
          "supplementaryInformation": "sceneStory",
          "type": "identifier"
        }
      ],
      "objectGroups": []
    },
    {
      "description": "Create a story from an Ink JSON resource.",
      "fullName": "Load JSON Story",
      "functionType": "Action",
      "group": "Story",
      "name": "LoadStory",
      "sentence": "Load story _PARAM2_ in file _PARAM1_",
      "events": [
        {
          "type": "BuiltinCommonInstructions::JsCode",
          "inlineCode": [
            "try",
            "{",
            "    var json = runtimeScene",
            "                .getGame()",
            "                .getJsonManager()",
            "                .getLoadedJson(eventsFunctionContext.getArgument(\"Resource\"));",
            "",
            "    var story = new inkjs.Story(json);",
            "",
            "    gdjs._InkJS.stories[eventsFunctionContext.getArgument(\"Story\")] = new gdjs._InkJS.GDStory(story);",
            "}",
            "catch",
            "{",
            "    console.warn(\"Story failed to load (\"+eventsFunctionContext.getArgument(\"Story\")+\")\");",
            "}",
            ""
          ],
          "parameterObjects": "",
          "useStrict": true,
          "eventsSheetExpanded": false
        },
        {
          "type": "BuiltinCommonInstructions::Standard",
          "conditions": [],
          "actions": []
        }
      ],
      "parameters": [
        {
          "description": "JSON Resource",
          "name": "Resource",
          "type": "jsonResource"
        },
        {
          "description": "Story name",
          "name": "Story",
          "supplementaryInformation": "sceneStory",
          "type": "identifier"
        }
      ],
      "objectGroups": []
    },
    {
      "description": "Load the next story line.",
      "fullName": "Continue the story",
      "functionType": "Action",
      "group": "Story",
      "name": "ContinueStory",
      "sentence": "Continue the story _PARAM1_",
      "events": [
        {
          "type": "BuiltinCommonInstructions::Standard",
          "conditions": [
            {
              "type": {
                "value": "InkJS::IsLoaded"
              },
              "parameters": [
                "",
                "Story",
                ""
              ]
            }
          ],
          "actions": [],
          "events": [
            {
              "type": "BuiltinCommonInstructions::JsCode",
              "inlineCode": [
                "gdjs._InkJS.stories[eventsFunctionContext.getArgument(\"Story\")].Next();",
                ""
              ],
              "parameterObjects": "",
              "useStrict": true,
              "eventsSheetExpanded": false
            }
          ]
        }
      ],
      "parameters": [
        {
          "description": "Story name",
          "name": "Story",
          "supplementaryInformation": "sceneStory",
          "type": "identifier"
        }
      ],
      "objectGroups": []
    },
    {
      "description": "Validate a choice using its Ink index before continuing the story.",
      "fullName": "Validate a choice",
      "functionType": "Action",
      "group": "Story",
      "name": "ValidateChoice",
      "sentence": "Validate the choice index _PARAM2_ in story _PARAM1_",
      "events": [
        {
          "type": "BuiltinCommonInstructions::Standard",
          "conditions": [
            {
              "type": {
                "value": "InkJS::ChoiceCount"
              },
              "parameters": [
                "",
                ">",
                "0",
                "Story",
                ""
              ]
            },
            {
              "type": {
                "value": "CompareArgumentAsNumber"
              },
              "parameters": [
                "\"ChoiceIndex\"",
                ">=",
                "0"
              ]
            }
          ],
          "actions": [],
          "events": [
            {
              "type": "BuiltinCommonInstructions::JsCode",
              "inlineCode": [
                "let item = gdjs._InkJS.stories[eventsFunctionContext.getArgument(\"Story\")];",
                "let idx = eventsFunctionContext.getArgument(\"ChoiceIndex\");",
                "item.story.ChooseChoiceIndex(idx);",
                "item.SaveHistory();",
                ""
              ],
              "parameterObjects": "",
              "useStrict": true,
              "eventsSheetExpanded": false
            }
          ]
        }
      ],
      "parameters": [
        {
          "description": "Story name",
          "name": "Story",
          "supplementaryInformation": "sceneStory",
          "type": "identifier"
        },
        {
          "description": "Choice index",
          "name": "ChoiceIndex",
          "type": "expression"
        }
      ],
      "objectGroups": []
    },
    {
      "description": "Change the current story chapter.",
      "fullName": "Change story chapter",
      "functionType": "Action",
      "group": "History",
      "name": "ChangeChapter",
      "sentence": "Move the story _PARAM1_ to the chapter _PARAM2_",
      "events": [
        {
          "type": "BuiltinCommonInstructions::Standard",
          "conditions": [
            {
              "type": {
                "value": "InkJS::IsLoaded"
              },
              "parameters": [
                "",
                "Story",
                ""
              ]
            }
          ],
          "actions": [],
          "events": [
            {
              "type": "BuiltinCommonInstructions::JsCode",
              "inlineCode": [
                "let story = gdjs._InkJS.stories[eventsFunctionContext.getArgument(\"Story\")].story;",
                "story.ChoosePathString(eventsFunctionContext.getArgument(\"Chapter\"));",
                ""
              ],
              "parameterObjects": "",
              "useStrict": true,
              "eventsSheetExpanded": false
            }
          ]
        }
      ],
      "parameters": [
        {
          "description": "Story name",
          "name": "Story",
          "supplementaryInformation": "sceneStory",
          "type": "identifier"
        },
        {
          "description": "Chapter name",
          "longDescription": "In Ink, a chapter (or knot) is a large part of the story.\n\nYou can combine it with a subchapter (a stich) for reaching a specific part of the chapter. The format is \"knot.stich\".\n\nFor example:\n- castle\n- castle.hall\n\nare valid chapter names.",
          "name": "Chapter",
          "supplementaryInformation": "sceneChapter",
          "type": "identifier"
        }
      ],
      "objectGroups": []
    },
    {
      "description": "Load a previous state of an existing story from a JSON string.",
      "fullName": "Load story state from JSON",
      "functionType": "Action",
      "group": "Story",
      "name": "LoadFromJSON",
      "sentence": "Load story _PARAM1_ state from JSON text",
      "events": [
        {
          "type": "BuiltinCommonInstructions::Standard",
          "conditions": [
            {
              "type": {
                "value": "InkJS::IsLoaded"
              },
              "parameters": [
                "",
                "Story",
                ""
              ]
            }
          ],
          "actions": [],
          "events": [
            {
              "type": "BuiltinCommonInstructions::JsCode",
              "inlineCode": [
                "let story = gdjs._InkJS.stories[eventsFunctionContext.getArgument(\"Story\")].story;",
                "story.state.LoadJson(eventsFunctionContext.getArgument(\"JSON\"));",
                ""
              ],
              "parameterObjects": "",
              "useStrict": true,
              "eventsSheetExpanded": false
            }
          ]
        }
      ],
      "parameters": [
        {
          "description": "Story name",
          "name": "Story",
          "supplementaryInformation": "sceneStory",
          "type": "identifier"
        },
        {
          "description": "JSON text",
          "name": "JSON",
          "type": "string"
        }
      ],
      "objectGroups": []
    },
    {
      "description": "Export the current state of the story to a JSON string.",
      "fullName": "Story state to JSON",
      "functionType": "StringExpression",
      "group": "Story",
      "name": "ToJSON",
      "sentence": "",
      "events": [
        {
          "type": "BuiltinCommonInstructions::Standard",
          "conditions": [],
          "actions": [
            {
              "type": {
                "value": "SetReturnString"
              },
              "parameters": [
                "\"\""
              ]
            }
          ]
        },
        {
          "type": "BuiltinCommonInstructions::Standard",
          "conditions": [
            {
              "type": {
                "value": "InkJS::IsLoaded"
              },
              "parameters": [
                "",
                "Story",
                ""
              ]
            }
          ],
          "actions": [],
          "events": [
            {
              "type": "BuiltinCommonInstructions::JsCode",
              "inlineCode": [
                "let story = gdjs._InkJS.stories[eventsFunctionContext.getArgument(\"Story\")].story;",
                "eventsFunctionContext.returnValue = story.state.ToJson();",
                ""
              ],
              "parameterObjects": "",
              "useStrict": true,
              "eventsSheetExpanded": false
            }
          ]
        }
      ],
      "expressionType": {
        "type": "string"
      },
      "parameters": [
        {
          "description": "Story name",
          "name": "Story",
          "supplementaryInformation": "sceneStory",
          "type": "identifier"
        }
      ],
      "objectGroups": []
    },
    {
      "description": "current story chapter.",
      "fullName": "Current story chapter",
      "functionType": "ExpressionAndCondition",
      "group": "Story",
      "name": "CurrentChapter",
      "sentence": "current chapter of _PARAM1_ ",
      "events": [
        {
          "type": "BuiltinCommonInstructions::Standard",
          "conditions": [],
          "actions": [
            {
              "type": {
                "value": "SetReturnString"
              },
              "parameters": [
                "\"\""
              ]
            }
          ]
        },
        {
          "type": "BuiltinCommonInstructions::Standard",
          "conditions": [],
          "actions": [],
          "events": [
            {
              "type": "BuiltinCommonInstructions::JsCode",
              "inlineCode": [
                "eventsFunctionContext.returnValue = gdjs._InkJS.stories[eventsFunctionContext.getArgument(\"Story\")].story.state.currentPathString;",
                ""
              ],
              "parameterObjects": "",
              "useStrict": true,
              "eventsSheetExpanded": false
            }
          ]
        }
      ],
      "expressionType": {
        "type": "string"
      },
      "parameters": [
        {
          "description": "Story name",
          "name": "Story",
          "supplementaryInformation": "sceneStory",
          "type": "identifier"
        }
      ],
      "objectGroups": []
    },
    {
      "description": "the current story line.",
      "fullName": "Current Story Line",
      "functionType": "ExpressionAndCondition",
      "group": "Story",
      "name": "CurrentLine",
      "sentence": "Current line of story _PARAM1_",
      "events": [
        {
          "type": "BuiltinCommonInstructions::Standard",
          "conditions": [
            {
              "type": {
                "value": "InkJS::IsLoaded"
              },
              "parameters": [
                "",
                "Story",
                ""
              ]
            }
          ],
          "actions": [],
          "events": [
            {
              "type": "BuiltinCommonInstructions::JsCode",
              "inlineCode": [
                "eventsFunctionContext.returnValue = gdjs._InkJS.stories[eventsFunctionContext.getArgument(\"Story\")].currentText.trim();",
                ""
              ],
              "parameterObjects": "",
              "useStrict": true,
              "eventsSheetExpanded": false
            }
          ]
        }
      ],
      "expressionType": {
        "type": "string"
      },
      "parameters": [
        {
          "description": "Story name",
          "name": "Story",
          "supplementaryInformation": "sceneStory",
          "type": "identifier"
        }
      ],
      "objectGroups": []
    },
    {
      "description": "current choice count.",
      "fullName": "Current choices count",
      "functionType": "ExpressionAndCondition",
      "group": "Story",
      "name": "ChoiceCount",
      "sentence": "Current choice count of story _PARAM1_",
      "events": [
        {
          "type": "BuiltinCommonInstructions::Standard",
          "conditions": [],
          "actions": [
            {
              "type": {
                "value": "SetReturnNumber"
              },
              "parameters": [
                "0"
              ]
            }
          ]
        },
        {
          "type": "BuiltinCommonInstructions::Standard",
          "conditions": [
            {
              "type": {
                "value": "InkJS::IsLoaded"
              },
              "parameters": [
                "",
                "Story",
                ""
              ]
            }
          ],
          "actions": [],
          "events": [
            {
              "type": "BuiltinCommonInstructions::JsCode",
              "inlineCode": [
                "eventsFunctionContext.returnValue = gdjs._InkJS.stories[eventsFunctionContext.getArgument(\"Story\")].story.currentChoices.length;",
                ""
              ],
              "parameterObjects": "",
              "useStrict": true,
              "eventsSheetExpanded": false
            }
          ]
        }
      ],
      "expressionType": {
        "type": "expression"
      },
      "parameters": [
        {
          "description": "Story name",
          "name": "Story",
          "supplementaryInformation": "sceneStory",
          "type": "identifier"
        }
      ],
      "objectGroups": []
    },
    {
      "description": "Get the choice internal index.",
      "fullName": "Choice Index",
      "functionType": "Expression",
      "group": "Story",
      "name": "ChoiceInternalIndex",
      "sentence": "",
      "events": [
        {
          "type": "BuiltinCommonInstructions::Standard",
          "conditions": [],
          "actions": [
            {
              "type": {
                "value": "SetReturnNumber"
              },
              "parameters": [
                "-1"
              ]
            }
          ]
        },
        {
          "type": "BuiltinCommonInstructions::Standard",
          "conditions": [
            {
              "type": {
                "value": "InkJS::ChoiceCount"
              },
              "parameters": [
                "",
                ">",
                "0",
                "Story",
                ""
              ]
            },
            {
              "type": {
                "value": "CompareArgumentAsNumber"
              },
              "parameters": [
                "\"ChoiceIndex\"",
                ">=",
                "0"
              ]
            },
            {
              "type": {
                "value": "CompareArgumentAsNumber"
              },
              "parameters": [
                "\"ChoiceIndex\"",
                "<",
                "InkJS::ChoiceCount(Story)"
              ]
            }
          ],
          "actions": [],
          "events": [
            {
              "type": "BuiltinCommonInstructions::JsCode",
              "inlineCode": [
                "let story = gdjs._InkJS.stories[eventsFunctionContext.getArgument(\"Story\")].story;",
                "let idx = eventsFunctionContext.getArgument(\"ChoiceIndex\");",
                "",
                "eventsFunctionContext.returnValue = story.currentChoices[idx].index;",
                ""
              ],
              "parameterObjects": "",
              "useStrict": true,
              "eventsSheetExpanded": false
            }
          ]
        }
      ],
      "expressionType": {
        "type": "expression"
      },
      "parameters": [
        {
          "description": "Story name",
          "name": "Story",
          "supplementaryInformation": "sceneStory",
          "type": "identifier"
        },
        {
          "description": "Choice index",
          "name": "ChoiceIndex",
          "type": "expression"
        }
      ],
      "objectGroups": []
    },
    {
      "description": "Get the choice label.",
      "fullName": "Choice Label",
      "functionType": "StringExpression",
      "group": "Story",
      "name": "ChoiceLabel",
      "sentence": "",
      "events": [
        {
          "type": "BuiltinCommonInstructions::Standard",
          "conditions": [],
          "actions": [
            {
              "type": {
                "value": "SetReturnString"
              },
              "parameters": [
                "\"\""
              ]
            }
          ]
        },
        {
          "type": "BuiltinCommonInstructions::Standard",
          "conditions": [
            {
              "type": {
                "value": "InkJS::ChoiceCount"
              },
              "parameters": [
                "",
                ">",
                "0",
                "Story",
                ""
              ]
            },
            {
              "type": {
                "value": "CompareArgumentAsNumber"
              },
              "parameters": [
                "\"ChoiceIndex\"",
                ">=",
                "0"
              ]
            },
            {
              "type": {
                "value": "CompareArgumentAsNumber"
              },
              "parameters": [
                "\"ChoiceIndex\"",
                "<",
                "InkJS::ChoiceCount(Story)"
              ]
            }
          ],
          "actions": [],
          "events": [
            {
              "type": "BuiltinCommonInstructions::JsCode",
              "inlineCode": [
                "let story = gdjs._InkJS.stories[eventsFunctionContext.getArgument(\"Story\")].story;",
                "let idx = eventsFunctionContext.getArgument(\"ChoiceIndex\");",
                "",
                "eventsFunctionContext.returnValue = story.currentChoices[idx].text;",
                ""
              ],
              "parameterObjects": "",
              "useStrict": true,
              "eventsSheetExpanded": false
            }
          ]
        }
      ],
      "expressionType": {
        "type": "string"
      },
      "parameters": [
        {
          "description": "Story name",
          "name": "Story",
          "supplementaryInformation": "sceneStory",
          "type": "identifier"
        },
        {
          "description": "Choice index",
          "name": "ChoiceIndex",
          "type": "expression"
        }
      ],
      "objectGroups": []
    },
    {
      "description": "the chapter visit count of the story.",
      "fullName": "Story chapter visit count",
      "functionType": "ExpressionAndCondition",
      "group": "History",
      "name": "VisitCount",
      "sentence": "The chapter _PARAM2_ of story _PARAM1_ visit count",
      "events": [
        {
          "type": "BuiltinCommonInstructions::Standard",
          "conditions": [],
          "actions": [
            {
              "type": {
                "value": "SetReturnNumber"
              },
              "parameters": [
                "0"
              ]
            }
          ]
        },
        {
          "type": "BuiltinCommonInstructions::Standard",
          "conditions": [
            {
              "type": {
                "value": "InkJS::IsLoaded"
              },
              "parameters": [
                "",
                "Story",
                ""
              ]
            }
          ],
          "actions": [],
          "events": [
            {
              "type": "BuiltinCommonInstructions::JsCode",
              "inlineCode": [
                "let story = gdjs._InkJS.stories[eventsFunctionContext.getArgument(\"Story\")].story;",
                "eventsFunctionContext.returnValue = story.state.VisitCountAtPathString(eventsFunctionContext.getArgument(\"Chapter\"));",
                ""
              ],
              "parameterObjects": "",
              "useStrict": true,
              "eventsSheetExpanded": false
            }
          ]
        }
      ],
      "expressionType": {
        "type": "expression"
      },
      "parameters": [
        {
          "description": "Story name",
          "name": "Story",
          "supplementaryInformation": "sceneStory",
          "type": "identifier"
        },
        {
          "description": "Chapter name",
          "longDescription": "In Ink, a chapter (or knot) is a large part of the story.\nYou can combine it with a subchapter (a stich) for reaching a specific part of the chapter. The format is \"knot.stich\".\nFor example:\n- castle\n- castle.hall\nare valid chapter names.",
          "name": "Chapter",
          "supplementaryInformation": "sceneChapter",
          "type": "identifier"
        }
      ],
      "objectGroups": []
    },
    {
      "description": "Check if the current story contains global tags.",
      "fullName": "Has global tags",
      "functionType": "Condition",
      "group": "Tags",
      "name": "HasTagsGlobal",
      "sentence": "Story _PARAM1_ has global tags",
      "events": [
        {
          "type": "BuiltinCommonInstructions::Standard",
          "conditions": [],
          "actions": [
            {
              "type": {
                "value": "SetReturnBoolean"
              },
              "parameters": [
                ""
              ]
            }
          ]
        },
        {
          "type": "BuiltinCommonInstructions::Standard",
          "conditions": [
            {
              "type": {
                "value": "InkJS::GlobalTagCount"
              },
              "parameters": [
                "",
                ">",
                "0",
                "Story",
                ""
              ]
            }
          ],
          "actions": [
            {
              "type": {
                "value": "SetReturnBoolean"
              },
              "parameters": [
                "True"
              ]
            }
          ]
        }
      ],
      "parameters": [
        {
          "description": "Story name",
          "name": "Story",
          "supplementaryInformation": "sceneStory",
          "type": "identifier"
        }
      ],
      "objectGroups": []
    },
    {
      "description": "Check if the current story chapter contains tags.",
      "fullName": "Chapter has tags",
      "functionType": "Condition",
      "group": "Tags",
      "name": "HasTagsChapter",
      "sentence": "Chapter _PARAM2_ of story _PARAM1_ has tags",
      "events": [
        {
          "type": "BuiltinCommonInstructions::Standard",
          "conditions": [],
          "actions": [
            {
              "type": {
                "value": "SetReturnBoolean"
              },
              "parameters": [
                ""
              ]
            }
          ]
        },
        {
          "type": "BuiltinCommonInstructions::Standard",
          "conditions": [
            {
              "type": {
                "value": "InkJS::ChapterTagCount"
              },
              "parameters": [
                "",
                ">",
                "0",
                "Story",
                "Chapter",
                ""
              ]
            }
          ],
          "actions": [
            {
              "type": {
                "value": "SetReturnBoolean"
              },
              "parameters": [
                "True"
              ]
            }
          ]
        }
      ],
      "parameters": [
        {
          "description": "Story name",
          "name": "Story",
          "supplementaryInformation": "sceneStory",
          "type": "identifier"
        },
        {
          "description": "Chapter name",
          "longDescription": "In Ink, a chapter (or knot) is a large part of the story.\nYou can combine it with a subchapter (a stich) for reaching a specific part of the chapter. The format is \"knot.stich\".\nFor example:\n\n- castle\n- castle.hall\n\nare valid chapter names.",
          "name": "Chapter",
          "supplementaryInformation": "sceneChapter",
          "type": "identifier"
        }
      ],
      "objectGroups": []
    },
    {
      "description": "Check if the current story line contains tags.",
      "fullName": "Current line has tags",
      "functionType": "Condition",
      "group": "Tags",
      "name": "HasTagsCurrentLine",
      "sentence": "Current line of _PARAM1_ has tags",
      "events": [
        {
          "type": "BuiltinCommonInstructions::Standard",
          "conditions": [],
          "actions": [
            {
              "type": {
                "value": "SetReturnBoolean"
              },
              "parameters": [
                ""
              ]
            }
          ]
        },
        {
          "type": "BuiltinCommonInstructions::Standard",
          "conditions": [
            {
              "type": {
                "value": "InkJS::CurrentLineTagCount"
              },
              "parameters": [
                "",
                ">",
                "0",
                "Story",
                ""
              ]
            }
          ],
          "actions": [
            {
              "type": {
                "value": "SetReturnBoolean"
              },
              "parameters": [
                "True"
              ]
            }
          ]
        }
      ],
      "parameters": [
        {
          "description": "Story name",
          "name": "Story",
          "supplementaryInformation": "sceneStory",
          "type": "identifier"
        }
      ],
      "objectGroups": []
    },
    {
      "description": "Check if the choice contains tags.",
      "fullName": "Choice has tags",
      "functionType": "Condition",
      "group": "Tags",
      "name": "HasTagsChoice",
      "sentence": "Choice _PARAM2_ of story _PARAM1_ has tags",
      "events": [
        {
          "type": "BuiltinCommonInstructions::Standard",
          "conditions": [],
          "actions": [
            {
              "type": {
                "value": "SetReturnBoolean"
              },
              "parameters": [
                ""
              ]
            }
          ]
        },
        {
          "type": "BuiltinCommonInstructions::Standard",
          "conditions": [
            {
              "type": {
                "value": "InkJS::ChoiceTagCount"
              },
              "parameters": [
                "",
                ">",
                "0",
                "Story",
                "ChoiceIndex",
                ""
              ]
            }
          ],
          "actions": [
            {
              "type": {
                "value": "SetReturnBoolean"
              },
              "parameters": [
                "True"
              ]
            }
          ]
        }
      ],
      "parameters": [
        {
          "description": "Story name",
          "name": "Story",
          "supplementaryInformation": "sceneStory",
          "type": "identifier"
        },
        {
          "description": "Choice index",
          "name": "ChoiceIndex",
          "type": "expression"
        }
      ],
      "objectGroups": []
    },
    {
      "description": "Export the global tag list to an array variable.",
      "fullName": "Global tags to array",
      "functionType": "Action",
      "group": "Tags",
      "name": "GlobalTagsToArray",
      "sentence": "Put global tags of _PARAM1_ in array _PARAM2_",
      "events": [
        {
          "type": "BuiltinCommonInstructions::Standard",
          "conditions": [
            {
              "type": {
                "value": "InkJS::IsLoaded"
              },
              "parameters": [
                "",
                "Story",
                ""
              ]
            }
          ],
          "actions": [],
          "events": [
            {
              "type": "BuiltinCommonInstructions::JsCode",
              "inlineCode": [
                "eventsFunctionContext.getArgument(\"Variable\").fromJSObject(gdjs._InkJS.stories[eventsFunctionContext.getArgument(\"Story\")].story.globalTags);",
                ""
              ],
              "parameterObjects": "",
              "useStrict": true,
              "eventsSheetExpanded": false
            }
          ]
        }
      ],
      "parameters": [
        {
          "description": "Story name",
          "name": "Story",
          "supplementaryInformation": "sceneStory",
          "type": "identifier"
        },
        {
          "description": "Scene array variable",
          "name": "Variable",
          "type": "scenevar"
        }
      ],
      "objectGroups": []
    },
    {
      "description": "Export the chapter tag list to an array variable.",
      "fullName": "Chapter tags to array",
      "functionType": "Action",
      "group": "Tags",
      "name": "ChapterTagsToArray",
      "sentence": "Put the chapter _PARAM2_ of _PARAM1_ tags in array _PARAM3_",
      "events": [
        {
          "type": "BuiltinCommonInstructions::Standard",
          "conditions": [
            {
              "type": {
                "value": "InkJS::IsLoaded"
              },
              "parameters": [
                "",
                "Story",
                ""
              ]
            }
          ],
          "actions": [],
          "events": [
            {
              "type": "BuiltinCommonInstructions::JsCode",
              "inlineCode": [
                "eventsFunctionContext.getArgument(\"Variable\").fromJSObject(gdjs._InkJS.stories[eventsFunctionContext.getArgument(\"Story\")].story.TagsForContentAtPath(eventsFunctionContext.getArgument(\"Chapter\")));",
                ""
              ],
              "parameterObjects": "",
              "useStrict": true,
              "eventsSheetExpanded": false
            }
          ]
        }
      ],
      "parameters": [
        {
          "description": "Story name",
          "name": "Story",
          "supplementaryInformation": "sceneStory",
          "type": "identifier"
        },
        {
          "description": "Chapter name",
          "longDescription": "In Ink, a chapter (or knot) is a large part of the story.\n\nYou can combine it with a subchapter (a stich) for reaching a specific part of the chapter. The format is \"knot.stich\".\n\nFor example:\n- castle\n- castle.hall\n\nare valid chapter names.",
          "name": "Chapter",
          "supplementaryInformation": "sceneChapter",
          "type": "identifier"
        },
        {
          "description": "Scene array variable",
          "name": "Variable",
          "type": "scenevar"
        }
      ],
      "objectGroups": []
    },
    {
      "description": "Export the current line tag list to an array variable.",
      "fullName": "Current line tags to array",
      "functionType": "Action",
      "group": "Tags",
      "name": "CurrentLineTagToArray",
      "sentence": "Put current line of _PARAM1_ tags in array _PARAM2_",
      "events": [
        {
          "type": "BuiltinCommonInstructions::Standard",
          "conditions": [
            {
              "type": {
                "value": "InkJS::IsLoaded"
              },
              "parameters": [
                "",
                "Story",
                ""
              ]
            }
          ],
          "actions": [],
          "events": [
            {
              "type": "BuiltinCommonInstructions::JsCode",
              "inlineCode": [
                "eventsFunctionContext.getArgument(\"Variable\").fromJSObject(gdjs._InkJS.stories[eventsFunctionContext.getArgument(\"Story\")].story.currentTags);",
                ""
              ],
              "parameterObjects": "",
              "useStrict": true,
              "eventsSheetExpanded": false
            }
          ]
        }
      ],
      "parameters": [
        {
          "description": "Story name",
          "name": "Story",
          "supplementaryInformation": "sceneStory",
          "type": "identifier"
        },
        {
          "description": "Scene array variable",
          "name": "Variable",
          "type": "scenevar"
        }
      ],
      "objectGroups": []
    },
    {
      "description": "Export the choice tag list to an array variable.",
      "fullName": "Choice tags to array",
      "functionType": "Action",
      "group": "Tags",
      "name": "ChoiceTagToArray",
      "sentence": "Choice _PARAM2_ of story _PARAM1_ tags in array _PARAM3_",
      "events": [
        {
          "type": "BuiltinCommonInstructions::Standard",
          "conditions": [
            {
              "type": {
                "value": "InkJS::ChoiceCount"
              },
              "parameters": [
                "",
                ">",
                "0",
                "Story",
                ""
              ]
            },
            {
              "type": {
                "value": "CompareArgumentAsNumber"
              },
              "parameters": [
                "\"ChoiceIndex\"",
                ">=",
                "0"
              ]
            },
            {
              "type": {
                "value": "CompareArgumentAsNumber"
              },
              "parameters": [
                "\"ChoiceIndex\"",
                "<",
                "InkJS::ChoiceCount(Story)"
              ]
            }
          ],
          "actions": [],
          "events": [
            {
              "type": "BuiltinCommonInstructions::JsCode",
              "inlineCode": [
                "eventsFunctionContext.getArgument(\"Variable\").fromJSObject(gdjs._InkJS.stories[eventsFunctionContext.getArgument(\"Story\")].story.currentChoices[eventsFunctionContext.getArgument(\"ChoiceIndex\")].tags);",
                ""
              ],
              "parameterObjects": "",
              "useStrict": true,
              "eventsSheetExpanded": false
            }
          ]
        },
        {
          "type": "BuiltinCommonInstructions::Standard",
          "conditions": [],
          "actions": []
        }
      ],
      "parameters": [
        {
          "description": "Story name",
          "name": "Story",
          "supplementaryInformation": "sceneStory",
          "type": "identifier"
        },
        {
          "description": "Choice index",
          "name": "ChoiceIndex",
          "type": "expression"
        },
        {
          "description": "Scene array variable",
          "name": "Variable",
          "type": "scenevar"
        }
      ],
      "objectGroups": []
    },
    {
      "description": "global tag count.",
      "fullName": "Global tag count",
      "functionType": "ExpressionAndCondition",
      "group": "Tags",
      "name": "GlobalTagCount",
      "sentence": "Story _PARAM1_ global tag count",
      "events": [
        {
          "type": "BuiltinCommonInstructions::Standard",
          "conditions": [],
          "actions": [
            {
              "type": {
                "value": "SetReturnNumber"
              },
              "parameters": [
                "0"
              ]
            }
          ]
        },
        {
          "type": "BuiltinCommonInstructions::Standard",
          "conditions": [
            {
              "type": {
                "value": "InkJS::IsLoaded"
              },
              "parameters": [
                "",
                "Story",
                ""
              ]
            }
          ],
          "actions": [],
          "events": [
            {
              "type": "BuiltinCommonInstructions::JsCode",
              "inlineCode": [
                "eventsFunctionContext.returnValue = gdjs._InkJS.stories[eventsFunctionContext.getArgument(\"Story\")].story.globalTags.length;",
                ""
              ],
              "parameterObjects": "",
              "useStrict": true,
              "eventsSheetExpanded": false
            }
          ]
        }
      ],
      "expressionType": {
        "type": "expression"
      },
      "parameters": [
        {
          "description": "Story name",
          "name": "Story",
          "supplementaryInformation": "sceneStory",
          "type": "identifier"
        }
      ],
      "objectGroups": []
    },
    {
      "description": "chapter tag count.",
      "fullName": "Chapter tag count",
      "functionType": "ExpressionAndCondition",
      "group": "Tags",
      "name": "ChapterTagCount",
      "sentence": "Chapter _PARAM2_ of story _PARAM1_ tag count",
      "events": [
        {
          "type": "BuiltinCommonInstructions::Standard",
          "conditions": [],
          "actions": [
            {
              "type": {
                "value": "SetReturnNumber"
              },
              "parameters": [
                "0"
              ]
            }
          ]
        },
        {
          "type": "BuiltinCommonInstructions::Standard",
          "conditions": [
            {
              "type": {
                "value": "InkJS::IsLoaded"
              },
              "parameters": [
                "",
                "Story",
                ""
              ]
            }
          ],
          "actions": [],
          "events": [
            {
              "type": "BuiltinCommonInstructions::JsCode",
              "inlineCode": [
                "eventsFunctionContext.returnValue = gdjs._InkJS.stories[eventsFunctionContext.getArgument(\"Story\")].story.TagsForContentAtPath(eventsFunctionContext.getArgument(\"Chapter\")).length;",
                ""
              ],
              "parameterObjects": "",
              "useStrict": true,
              "eventsSheetExpanded": false
            }
          ]
        }
      ],
      "expressionType": {
        "type": "expression"
      },
      "parameters": [
        {
          "description": "Story name",
          "name": "Story",
          "supplementaryInformation": "sceneStory",
          "type": "identifier"
        },
        {
          "description": "Chapter name",
          "longDescription": "In Ink, a chapter (or knot) is a large part of the story.\n\nYou can combine it with a subchapter (a stich) for reaching a specific part of the chapter. The format is \"knot.stich\".\n\nFor example:\n- castle\n- castle.hall\n\nare valid chapter names.",
          "name": "Chapter",
          "supplementaryInformation": "sceneChapter",
          "type": "identifier"
        }
      ],
      "objectGroups": []
    },
    {
      "description": "current line tag count.",
      "fullName": "Current line tag count",
      "functionType": "ExpressionAndCondition",
      "group": "Tags",
      "name": "CurrentLineTagCount",
      "sentence": "Current line of _PARAM1_ tag count",
      "events": [
        {
          "type": "BuiltinCommonInstructions::Standard",
          "conditions": [],
          "actions": [
            {
              "type": {
                "value": "SetReturnNumber"
              },
              "parameters": [
                "0"
              ]
            }
          ]
        },
        {
          "type": "BuiltinCommonInstructions::Standard",
          "conditions": [
            {
              "type": {
                "value": "InkJS::IsLoaded"
              },
              "parameters": [
                "",
                "Story",
                ""
              ]
            }
          ],
          "actions": [],
          "events": [
            {
              "type": "BuiltinCommonInstructions::JsCode",
              "inlineCode": [
                "eventsFunctionContext.returnValue = gdjs._InkJS.stories[eventsFunctionContext.getArgument(\"Story\")].story.currentTags.length;",
                ""
              ],
              "parameterObjects": "",
              "useStrict": true,
              "eventsSheetExpanded": false
            }
          ]
        }
      ],
      "expressionType": {
        "type": "expression"
      },
      "parameters": [
        {
          "description": "Story name",
          "name": "Story",
          "supplementaryInformation": "sceneStory",
          "type": "identifier"
        }
      ],
      "objectGroups": []
    },
    {
      "description": "choice tag count.",
      "fullName": "Choice tag count",
      "functionType": "ExpressionAndCondition",
      "group": "Tags",
      "name": "ChoiceTagCount",
      "sentence": "Choice _PARAM2_ of story _PARAM1_ tag count",
      "events": [
        {
          "type": "BuiltinCommonInstructions::Standard",
          "conditions": [],
          "actions": [
            {
              "type": {
                "value": "SetReturnNumber"
              },
              "parameters": [
                "0"
              ]
            }
          ]
        },
        {
          "type": "BuiltinCommonInstructions::Standard",
          "conditions": [
            {
              "type": {
                "value": "InkJS::ChoiceCount"
              },
              "parameters": [
                "",
                ">",
                "0",
                "Story",
                ""
              ]
            },
            {
              "type": {
                "value": "CompareArgumentAsNumber"
              },
              "parameters": [
                "\"ChoiceIndex\"",
                ">=",
                "0"
              ]
            },
            {
              "type": {
                "value": "CompareArgumentAsNumber"
              },
              "parameters": [
                "\"ChoiceIndex\"",
                "<",
                "InkJS::ChoiceCount(Story)"
              ]
            }
          ],
          "actions": [],
          "events": [
            {
              "type": "BuiltinCommonInstructions::JsCode",
              "inlineCode": [
                "let story = gdjs._InkJS.stories[eventsFunctionContext.getArgument(\"Story\")].story;",
                "let idx = eventsFunctionContext.getArgument(\"ChoiceIndex\");",
                "",
                "eventsFunctionContext.returnValue = story.currentChoices[idx].tags.length;",
                ""
              ],
              "parameterObjects": "",
              "useStrict": true,
              "eventsSheetExpanded": false
            }
          ]
        }
      ],
      "expressionType": {
        "type": "expression"
      },
      "parameters": [
        {
          "description": "Story name",
          "name": "Story",
          "supplementaryInformation": "sceneStory",
          "type": "identifier"
        },
        {
          "description": "Choice index",
          "name": "ChoiceIndex",
          "type": "expression"
        }
      ],
      "objectGroups": []
    },
    {
      "description": "global tag.",
      "fullName": "Global tag value",
      "functionType": "ExpressionAndCondition",
      "group": "Tags",
      "name": "GlobalTag",
      "sentence": "Global tag of _PARAM1_ n_PARAM2_ value",
      "events": [
        {
          "type": "BuiltinCommonInstructions::Standard",
          "conditions": [],
          "actions": [
            {
              "type": {
                "value": "SetReturnString"
              },
              "parameters": [
                "\"\""
              ]
            }
          ]
        },
        {
          "type": "BuiltinCommonInstructions::Standard",
          "conditions": [
            {
              "type": {
                "value": "CompareArgumentAsNumber"
              },
              "parameters": [
                "\"TagIndex\"",
                ">=",
                "0"
              ]
            },
            {
              "type": {
                "value": "CompareArgumentAsNumber"
              },
              "parameters": [
                "\"TagIndex\"",
                "<",
                "InkJS::GlobalTagCount(Story)"
              ]
            }
          ],
          "actions": [],
          "events": [
            {
              "type": "BuiltinCommonInstructions::JsCode",
              "inlineCode": [
                "eventsFunctionContext.returnValue = gdjs._InkJS.stories[eventsFunctionContext.getArgument(\"Story\")].story.globalTags[eventsFunctionContext.getArgument(\"TagIndex\")];",
                ""
              ],
              "parameterObjects": "",
              "useStrict": true,
              "eventsSheetExpanded": false
            }
          ]
        }
      ],
      "expressionType": {
        "type": "string"
      },
      "parameters": [
        {
          "description": "Story name",
          "name": "Story",
          "supplementaryInformation": "sceneStory",
          "type": "identifier"
        },
        {
          "description": "Tag list index",
          "name": "TagIndex",
          "type": "expression"
        }
      ],
      "objectGroups": []
    },
    {
      "description": "chapter tag.",
      "fullName": "Chapter tag value",
      "functionType": "ExpressionAndCondition",
      "group": "Tags",
      "name": "ChapterTag",
      "sentence": "Chapter _PARAM2_ of _PARAM1_ tag n_PARAM3_ value",
      "events": [
        {
          "type": "BuiltinCommonInstructions::Standard",
          "conditions": [],
          "actions": [
            {
              "type": {
                "value": "SetReturnString"
              },
              "parameters": [
                "\"\""
              ]
            }
          ]
        },
        {
          "type": "BuiltinCommonInstructions::Standard",
          "conditions": [
            {
              "type": {
                "value": "CompareArgumentAsNumber"
              },
              "parameters": [
                "\"TagIndex\"",
                ">=",
                "0"
              ]
            },
            {
              "type": {
                "value": "CompareArgumentAsNumber"
              },
              "parameters": [
                "\"TagIndex\"",
                "<",
                "InkJS::ChapterTagCount(Story, Chapter)"
              ]
            }
          ],
          "actions": [],
          "events": [
            {
              "type": "BuiltinCommonInstructions::JsCode",
              "inlineCode": [
                "eventsFunctionContext.returnValue = gdjs._InkJS.stories[eventsFunctionContext.getArgument(\"Story\")].story.TagsForContentAtPath(eventsFunctionContext.getArgument(\"Chapter\"))[eventsFunctionContext.getArgument(\"TagIndex\")];",
                ""
              ],
              "parameterObjects": "",
              "useStrict": true,
              "eventsSheetExpanded": false
            }
          ]
        }
      ],
      "expressionType": {
        "type": "string"
      },
      "parameters": [
        {
          "description": "Story name",
          "name": "Story",
          "supplementaryInformation": "sceneStory",
          "type": "identifier"
        },
        {
          "description": "Chapter name",
          "longDescription": "In Ink, a chapter (or knot) is a large part of the story.\n\nYou can combine it with a subchapter (a stich) for reaching a specific part of the chapter. The format is \"knot.stich\".\n\nFor example:\n- castle\n- castle.hall\n\nare valid chapter names.",
          "name": "Chapter",
          "supplementaryInformation": "sceneChapter",
          "type": "identifier"
        },
        {
          "description": "Tag list index",
          "name": "TagIndex",
          "type": "expression"
        }
      ],
      "objectGroups": []
    },
    {
      "description": "current line tag.",
      "fullName": "Current line tag value",
      "functionType": "ExpressionAndCondition",
      "group": "Tags",
      "name": "CurrentLineTag",
      "sentence": "Current line of _PARAM1_ tag n_PARAM2_ value",
      "events": [
        {
          "type": "BuiltinCommonInstructions::Standard",
          "conditions": [],
          "actions": [
            {
              "type": {
                "value": "SetReturnString"
              },
              "parameters": [
                "\"\""
              ]
            }
          ]
        },
        {
          "type": "BuiltinCommonInstructions::Standard",
          "conditions": [
            {
              "type": {
                "value": "CompareArgumentAsNumber"
              },
              "parameters": [
                "\"TagIndex\"",
                ">=",
                "0"
              ]
            },
            {
              "type": {
                "value": "CompareArgumentAsNumber"
              },
              "parameters": [
                "\"TagIndex\"",
                "<",
                "InkJS::CurrentLineTagCount(Story)"
              ]
            }
          ],
          "actions": [],
          "events": [
            {
              "type": "BuiltinCommonInstructions::JsCode",
              "inlineCode": [
                "eventsFunctionContext.returnValue = gdjs._InkJS.stories[eventsFunctionContext.getArgument(\"Story\")].story.currentTags[eventsFunctionContext.getArgument(\"TagIndex\")];",
                ""
              ],
              "parameterObjects": "",
              "useStrict": true,
              "eventsSheetExpanded": false
            }
          ]
        }
      ],
      "expressionType": {
        "type": "string"
      },
      "parameters": [
        {
          "description": "Story name",
          "name": "Story",
          "supplementaryInformation": "sceneStory",
          "type": "identifier"
        },
        {
          "description": "Tag list index",
          "name": "TagIndex",
          "type": "expression"
        }
      ],
      "objectGroups": []
    },
    {
      "description": "choice tag.",
      "fullName": "Choice tag value",
      "functionType": "ExpressionAndCondition",
      "group": "Tags",
      "name": "ChoiceTag",
      "sentence": "Choice _PARAM2_ of story _PARAM1_ tag n_PARAM3_ value",
      "events": [
        {
          "type": "BuiltinCommonInstructions::Standard",
          "conditions": [],
          "actions": [
            {
              "type": {
                "value": "SetReturnString"
              },
              "parameters": [
                "\"\""
              ]
            }
          ]
        },
        {
          "type": "BuiltinCommonInstructions::Standard",
          "conditions": [
            {
              "type": {
                "value": "CompareArgumentAsNumber"
              },
              "parameters": [
                "\"TagIndex\"",
                ">=",
                "0"
              ]
            },
            {
              "type": {
                "value": "CompareArgumentAsNumber"
              },
              "parameters": [
                "\"TagIndex\"",
                "<",
                "InkJS::ChoiceTagCount(Story, ChoiceIndex)"
              ]
            }
          ],
          "actions": [],
          "events": [
            {
              "type": "BuiltinCommonInstructions::JsCode",
              "inlineCode": [
                "eventsFunctionContext.returnValue = gdjs._InkJS.stories[eventsFunctionContext.getArgument(\"Story\")].story.currentChoices[eventsFunctionContext.getArgument(\"ChoiceIndex\")].tags[eventsFunctionContext.getArgument(\"TagIndex\")];",
                ""
              ],
              "parameterObjects": "",
              "useStrict": true,
              "eventsSheetExpanded": false
            }
          ]
        }
      ],
      "expressionType": {
        "type": "string"
      },
      "parameters": [
        {
          "description": "Story name",
          "name": "Story",
          "supplementaryInformation": "sceneStory",
          "type": "identifier"
        },
        {
          "description": "Choice index",
          "name": "ChoiceIndex",
          "type": "expression"
        },
        {
          "description": "Tag list index",
          "name": "TagIndex",
          "type": "expression"
        }
      ],
      "objectGroups": []
    },
    {
      "description": "Check if the story variable exists.",
      "fullName": "Story variable exists",
      "functionType": "Condition",
      "group": "Variables",
      "name": "VariableExists",
      "sentence": "The variable _PARAM2_ in the story _PARAM1_ exists ",
      "events": [
        {
          "type": "BuiltinCommonInstructions::Standard",
          "conditions": [],
          "actions": [
            {
              "type": {
                "value": "SetReturnBoolean"
              },
              "parameters": [
                ""
              ]
            }
          ]
        },
        {
          "type": "BuiltinCommonInstructions::Standard",
          "conditions": [
            {
              "type": {
                "value": "InkJS::IsLoaded"
              },
              "parameters": [
                "",
                "Story",
                ""
              ]
            }
          ],
          "actions": [],
          "events": [
            {
              "type": "BuiltinCommonInstructions::JsCode",
              "inlineCode": [
                "let story = gdjs._InkJS.stories[eventsFunctionContext.getArgument(\"Story\")].story;",
                "",
                "if (story.variablesState[eventsFunctionContext.getArgument(\"Variable\")])",
                "    eventsFunctionContext.returnValue = true;",
                ""
              ],
              "parameterObjects": "",
              "useStrict": true,
              "eventsSheetExpanded": false
            }
          ]
        }
      ],
      "parameters": [
        {
          "description": "Story name",
          "name": "Story",
          "supplementaryInformation": "sceneStory",
          "type": "identifier"
        },
        {
          "description": "Variable name",
          "name": "Variable",
          "supplementaryInformation": "sceneStoryVariable",
          "type": "identifier"
        }
      ],
      "objectGroups": []
    },
    {
      "description": "A story variable observed has changed.",
      "fullName": "Story variable changed",
      "functionType": "Condition",
      "group": "Variables",
      "name": "VariableChanged",
      "sentence": "The variable _PARAM2_ in the story _PARAM1_ changed",
      "events": [
        {
          "type": "BuiltinCommonInstructions::Standard",
          "conditions": [],
          "actions": [
            {
              "type": {
                "value": "SetReturnBoolean"
              },
              "parameters": [
                ""
              ]
            }
          ]
        },
        {
          "type": "BuiltinCommonInstructions::Standard",
          "conditions": [
            {
              "type": {
                "value": "InkJS::IsLoaded"
              },
              "parameters": [
                "",
                "Story",
                ""
              ]
            }
          ],
          "actions": [],
          "events": [
            {
              "type": "BuiltinCommonInstructions::JsCode",
              "inlineCode": [
                "let story = gdjs._InkJS.stories[eventsFunctionContext.getArgument(\"Story\")];",
                "",
                "if (story.observers[eventsFunctionContext.getArgument(\"Variable\")])",
                "    eventsFunctionContext.returnValue = true;",
                "",
                ""
              ],
              "parameterObjects": "",
              "useStrict": true,
              "eventsSheetExpanded": false
            }
          ]
        }
      ],
      "parameters": [
        {
          "description": "Story name",
          "name": "Story",
          "supplementaryInformation": "sceneStory",
          "type": "identifier"
        },
        {
          "description": "Variable name",
          "name": "Variable",
          "supplementaryInformation": "sceneStoryVariable",
          "type": "identifier"
        }
      ],
      "objectGroups": []
    },
    {
      "description": "the story variable number.",
      "fullName": "Story variable number",
      "functionType": "ActionWithOperator",
      "getterName": "VariableNumber",
      "name": "ChangeVariableNumber",
      "sentence": "Read the story _PARAM1_ state of the variable number _PARAM2_ ",
      "events": [
        {
          "type": "BuiltinCommonInstructions::Standard",
          "conditions": [
            {
              "type": {
                "value": "InkJS::VariableExists"
              },
              "parameters": [
                "",
                "Story",
                "Variable",
                ""
              ]
            }
          ],
          "actions": [],
          "events": [
            {
              "type": "BuiltinCommonInstructions::JsCode",
              "inlineCode": [
                "let story = gdjs._InkJS.stories[eventsFunctionContext.getArgument(\"Story\")].story;",
                "",
                "eventsFunctionContext.returnValue = story.variablesState[eventsFunctionContext.getArgument(\"Variable\")];",
                ""
              ],
              "parameterObjects": "",
              "useStrict": true,
              "eventsSheetExpanded": false
            }
          ]
        }
      ],
      "parameters": [
        {
          "description": "Story name",
          "name": "Story",
          "supplementaryInformation": "sceneStory",
          "type": "identifier"
        },
        {
          "description": "Variable name",
          "name": "Variable",
          "supplementaryInformation": "sceneVariableNumber",
          "type": "identifier"
        },
        {
          "description": "",
          "name": "Value",
          "type": "objectList"
        }
      ],
      "objectGroups": []
    },
    {
      "description": "Change the story variable text.",
      "fullName": "Change story variable text",
      "functionType": "ActionWithOperator",
      "getterName": "VariableText",
      "name": "ChangeVariableText",
      "sentence": "Update the story _PARAM1_ state of the variable text _PARAM2_ ",
      "events": [
        {
          "type": "BuiltinCommonInstructions::Standard",
          "conditions": [
            {
              "type": {
                "value": "InkJS::VariableExists"
              },
              "parameters": [
                "",
                "Story",
                "Variable",
                ""
              ]
            }
          ],
          "actions": [],
          "events": [
            {
              "type": "BuiltinCommonInstructions::JsCode",
              "inlineCode": [
                "let story = gdjs._InkJS.stories[eventsFunctionContext.getArgument(\"Story\")].story;",
                "",
                "story.variablesState[eventsFunctionContext.getArgument(\"Variable\")] = eventsFunctionContext.getArgument(\"Value\");",
                ""
              ],
              "parameterObjects": "",
              "useStrict": true,
              "eventsSheetExpanded": false
            }
          ]
        }
      ],
      "parameters": [
        {
          "description": "Story name",
          "name": "Story",
          "supplementaryInformation": "sceneStory",
          "type": "identifier"
        },
        {
          "description": "Variable name",
          "name": "Variable",
          "supplementaryInformation": "sceneVariableNumber",
          "type": "identifier"
        }
      ],
      "objectGroups": []
    },
    {
      "description": "Change the story variable boolean.",
      "fullName": "Change story variable boolean",
      "functionType": "Action",
      "getterName": "VariableText",
      "name": "ChangeVariableBoolean",
      "sentence": "Update the story _PARAM1_ state of the variable boolean _PARAM2_ to _PARAM3_",
      "events": [
        {
          "type": "BuiltinCommonInstructions::Standard",
          "conditions": [
            {
              "type": {
                "value": "InkJS::VariableExists"
              },
              "parameters": [
                "",
                "Story",
                "Variable",
                ""
              ]
            }
          ],
          "actions": [],
          "events": [
            {
              "type": "BuiltinCommonInstructions::JsCode",
              "inlineCode": [
                "let story = gdjs._InkJS.stories[eventsFunctionContext.getArgument(\"Story\")].story;",
                "",
                "story.variablesState[eventsFunctionContext.getArgument(\"Variable\")] = eventsFunctionContext.getArgument(\"Value\");",
                ""
              ],
              "parameterObjects": "",
              "useStrict": true,
              "eventsSheetExpanded": false
            }
          ]
        }
      ],
      "parameters": [
        {
          "description": "Story name",
          "name": "Story",
          "supplementaryInformation": "sceneStory",
          "type": "identifier"
        },
        {
          "description": "Variable name",
          "name": "Variable",
          "supplementaryInformation": "sceneStoryVariable",
          "type": "identifier"
        },
        {
          "description": "Value",
          "name": "Value",
          "type": "trueorfalse"
        }
      ],
      "objectGroups": []
    },
    {
      "description": "Activate the observation of any change to the story variable.",
      "fullName": "Observe a story variable",
      "functionType": "Action",
      "group": "Variables",
      "name": "ObserveVariable",
      "sentence": "Observe the variable _PARAM2_ in the story _PARAM1_",
      "events": [
        {
          "type": "BuiltinCommonInstructions::Standard",
          "conditions": [
            {
              "type": {
                "value": "InkJS::IsLoaded"
              },
              "parameters": [
                "",
                "Story",
                ""
              ]
            }
          ],
          "actions": [],
          "events": [
            {
              "type": "BuiltinCommonInstructions::JsCode",
              "inlineCode": [
                "let story = gdjs._InkJS.stories[eventsFunctionContext.getArgument(\"Story\")];",
                "story.BindVariable(eventsFunctionContext.getArgument(\"Variable\"));",
                ""
              ],
              "parameterObjects": "",
              "useStrict": true,
              "eventsSheetExpanded": false
            }
          ]
        }
      ],
      "parameters": [
        {
          "description": "Story name",
          "name": "Story",
          "supplementaryInformation": "sceneStory",
          "type": "identifier"
        },
        {
          "description": "Variable name",
          "name": "Variable",
          "supplementaryInformation": "sceneStoryVariable",
          "type": "identifier"
        }
      ],
      "objectGroups": []
    },
    {
      "description": "Activate the observation of any change to the story variable and change the corresponding Scene variable.",
      "fullName": "Observe and connect a story variable",
      "functionType": "Action",
      "group": "Variables",
      "name": "ObserveAndConnectVariable",
      "sentence": "Observe the variable _PARAM2_ in the story _PARAM1_ and store it in _PARAM3_",
      "events": [
        {
          "type": "BuiltinCommonInstructions::Standard",
          "conditions": [
            {
              "type": {
                "value": "InkJS::IsLoaded"
              },
              "parameters": [
                "",
                "Story",
                ""
              ]
            }
          ],
          "actions": [],
          "events": [
            {
              "type": "BuiltinCommonInstructions::JsCode",
              "inlineCode": [
                "let story = gdjs._InkJS.stories[eventsFunctionContext.getArgument(\"Story\")];",
                "story.BindAndConnectVariable(eventsFunctionContext.getArgument(\"Variable\"), eventsFunctionContext.getArgument(\"SceneVariable\"));",
                ""
              ],
              "parameterObjects": "",
              "useStrict": true,
              "eventsSheetExpanded": false
            }
          ]
        },
        {
          "type": "BuiltinCommonInstructions::Standard",
          "conditions": [],
          "actions": []
        }
      ],
      "parameters": [
        {
          "description": "Story name",
          "name": "Story",
          "supplementaryInformation": "sceneStory",
          "type": "identifier"
        },
        {
          "description": "Variable name",
          "name": "Variable",
          "supplementaryInformation": "sceneStoryVariable",
          "type": "identifier"
        },
        {
          "description": "Scene variable",
          "name": "SceneVariable",
          "type": "scenevar"
        }
      ],
      "objectGroups": []
    },
    {
      "description": "the story variable value.",
      "fullName": "Story variable value",
      "functionType": "ExpressionAndCondition",
      "group": "Variables",
      "name": "VariableNumber",
      "sentence": "the story _PARAM1_ state of the variable _PARAM2_ value ",
      "events": [
        {
          "type": "BuiltinCommonInstructions::Standard",
          "conditions": [],
          "actions": [
            {
              "type": {
                "value": "SetReturnNumber"
              },
              "parameters": [
                "0"
              ]
            }
          ]
        },
        {
          "type": "BuiltinCommonInstructions::Standard",
          "conditions": [
            {
              "type": {
                "value": "InkJS::VariableExists"
              },
              "parameters": [
                "",
                "Story",
                "Variable",
                ""
              ]
            }
          ],
          "actions": [],
          "events": [
            {
              "type": "BuiltinCommonInstructions::JsCode",
              "inlineCode": [
                "let story = gdjs._InkJS.stories[eventsFunctionContext.getArgument(\"Story\")].story;",
                "",
                "eventsFunctionContext.returnValue = story.variablesState[eventsFunctionContext.getArgument(\"Variable\")];",
                ""
              ],
              "parameterObjects": "",
              "useStrict": true,
              "eventsSheetExpanded": false
            }
          ]
        }
      ],
      "expressionType": {
        "type": "expression"
      },
      "parameters": [
        {
          "description": "Story name",
          "name": "Story",
          "supplementaryInformation": "sceneStory",
          "type": "identifier"
        },
        {
          "description": "Variable name",
          "name": "Variable",
          "supplementaryInformation": "sceneStoryVariable",
          "type": "identifier"
        }
      ],
      "objectGroups": []
    },
    {
      "description": "the story variable text.",
      "fullName": "Story variable text",
      "functionType": "ExpressionAndCondition",
      "group": "Variables",
      "name": "VariableText",
      "sentence": "the story _PARAM1_ state of the variable _PARAM2_ text ",
      "events": [
        {
          "type": "BuiltinCommonInstructions::Standard",
          "conditions": [],
          "actions": [
            {
              "type": {
                "value": "SetReturnString"
              },
              "parameters": [
                "\"\""
              ]
            }
          ]
        },
        {
          "type": "BuiltinCommonInstructions::Standard",
          "conditions": [
            {
              "type": {
                "value": "InkJS::VariableExists"
              },
              "parameters": [
                "",
                "Story",
                "Variable",
                ""
              ]
            }
          ],
          "actions": [],
          "events": [
            {
              "type": "BuiltinCommonInstructions::JsCode",
              "inlineCode": [
                "let story = gdjs._InkJS.stories[eventsFunctionContext.getArgument(\"Story\")].story;",
                "",
                "eventsFunctionContext.returnValue = story.variablesState[eventsFunctionContext.getArgument(\"Variable\")];",
                ""
              ],
              "parameterObjects": "",
              "useStrict": true,
              "eventsSheetExpanded": false
            }
          ]
        }
      ],
      "expressionType": {
        "type": "string"
      },
      "parameters": [
        {
          "description": "Story name",
          "name": "Story",
          "supplementaryInformation": "sceneStory",
          "type": "identifier"
        },
        {
          "description": "Variable name",
          "name": "Variable",
          "supplementaryInformation": "sceneStoryVariable",
          "type": "identifier"
        }
      ],
      "objectGroups": []
    },
    {
      "description": "The story variable boolean is true.",
      "fullName": "Story variable boolean",
      "functionType": "Condition",
      "group": "Variables",
      "name": "VariableBoolean",
      "sentence": "The story _PARAM1_ state of the variable _PARAM2_ boolean is true",
      "events": [
        {
          "type": "BuiltinCommonInstructions::Standard",
          "conditions": [],
          "actions": [
            {
              "type": {
                "value": "SetReturnBoolean"
              },
              "parameters": [
                "\"\""
              ]
            }
          ]
        },
        {
          "type": "BuiltinCommonInstructions::Standard",
          "conditions": [
            {
              "type": {
                "value": "InkJS::VariableExists"
              },
              "parameters": [
                "",
                "Story",
                "Variable",
                ""
              ]
            }
          ],
          "actions": [],
          "events": [
            {
              "type": "BuiltinCommonInstructions::JsCode",
              "inlineCode": [
                "let story = gdjs._InkJS.stories[eventsFunctionContext.getArgument(\"Story\")].story;",
                "",
                "eventsFunctionContext.returnValue = story.variablesState[eventsFunctionContext.getArgument(\"Variable\")] != 0;",
                ""
              ],
              "parameterObjects": "",
              "useStrict": true,
              "eventsSheetExpanded": false
            }
          ]
        }
      ],
      "parameters": [
        {
          "description": "Story name",
          "name": "Story",
          "supplementaryInformation": "sceneStory",
          "type": "identifier"
        },
        {
          "description": "Variable name",
          "name": "Variable",
          "supplementaryInformation": "sceneStoryVariable",
          "type": "identifier"
        }
      ],
      "objectGroups": []
    },
    {
      "description": "Check if the story event is called by Ink.",
      "fullName": "Event is called",
      "functionType": "Condition",
      "group": "Functions",
      "name": "IsExternalFunctionCalled",
      "sentence": "The event _PARAM2_ of story _PARAM1_ is called",
      "events": [
        {
          "type": "BuiltinCommonInstructions::Standard",
          "conditions": [],
          "actions": [
            {
              "type": {
                "value": "SetReturnBoolean"
              },
              "parameters": [
                "False"
              ]
            }
          ]
        },
        {
          "type": "BuiltinCommonInstructions::Standard",
          "conditions": [
            {
              "type": {
                "value": "InkJS::IsLoaded"
              },
              "parameters": [
                "",
                "Story",
                ""
              ]
            }
          ],
          "actions": [],
          "events": [
            {
              "type": "BuiltinCommonInstructions::JsCode",
              "inlineCode": [
                "let story = gdjs._InkJS.stories[eventsFunctionContext.getArgument(\"Story\")];",
                "",
                "if (story.listeners[eventsFunctionContext.getArgument(\"EventName\")])",
                "    eventsFunctionContext.returnValue = true;",
                ""
              ],
              "parameterObjects": "",
              "useStrict": true,
              "eventsSheetExpanded": false
            }
          ]
        }
      ],
      "parameters": [
        {
          "description": "Story name",
          "name": "Story",
          "supplementaryInformation": "sceneStory",
          "type": "identifier"
        },
        {
          "description": "Ink event name",
          "name": "EventName",
          "supplementaryInformation": "sceneEventName",
          "type": "identifier"
        }
      ],
      "objectGroups": []
    },
    {
      "description": "Link an external Ink function to the game.",
      "fullName": "Link story event",
      "functionType": "Action",
      "group": "Functions",
      "name": "BindExternalFunction",
      "sentence": "Link story _PARAM1_ external event _PARAM2_ to the game",
      "events": [
        {
          "type": "BuiltinCommonInstructions::Standard",
          "conditions": [
            {
              "type": {
                "value": "InkJS::IsLoaded"
              },
              "parameters": [
                "",
                "Story",
                ""
              ]
            }
          ],
          "actions": [],
          "events": [
            {
              "type": "BuiltinCommonInstructions::JsCode",
              "inlineCode": [
                "let story = gdjs._InkJS.stories[eventsFunctionContext.getArgument(\"Story\")];",
                "story.BindExternalFunction(eventsFunctionContext.getArgument(\"EventName\"));",
                ""
              ],
              "parameterObjects": "",
              "useStrict": true,
              "eventsSheetExpanded": false
            }
          ]
        }
      ],
      "parameters": [
        {
          "description": "Story name",
          "name": "Story",
          "supplementaryInformation": "sceneStory",
          "type": "identifier"
        },
        {
          "description": "Ink event name",
          "name": "EventName",
          "supplementaryInformation": "sceneEventName",
          "type": "identifier"
        }
      ],
      "objectGroups": []
    },
    {
      "description": "Call an internal Ink function set inside the story.",
      "fullName": "Add parameter for Ink function",
      "functionType": "Action",
      "group": "Functions",
      "name": "AddInternalMethodParameter",
      "sentence": "Add a new parameter value _PARAM3_ for function _PARAM2_ in story _PARAM1_ ",
      "events": [
        {
          "type": "BuiltinCommonInstructions::Standard",
          "conditions": [
            {
              "type": {
                "value": "InkJS::IsLoaded"
              },
              "parameters": [
                "",
                "Story",
                ""
              ]
            }
          ],
          "actions": [],
          "events": [
            {
              "type": "BuiltinCommonInstructions::JsCode",
              "inlineCode": [
                "let story = gdjs._InkJS.stories[eventsFunctionContext.getArgument(\"Story\")];",
                "",
                "story.AddMethodParameter(eventsFunctionContext.getArgument(\"Method\"), eventsFunctionContext.getArgument(\"Value\"));",
                ""
              ],
              "parameterObjects": "",
              "useStrict": true,
              "eventsSheetExpanded": false
            }
          ]
        }
      ],
      "parameters": [
        {
          "description": "Story name",
          "name": "Story",
          "supplementaryInformation": "sceneStory",
          "type": "identifier"
        },
        {
          "description": "Internal Ink method name",
          "name": "Method",
          "supplementaryInformation": "sceneEventName",
          "type": "identifier"
        },
        {
          "description": "Parameter value",
          "name": "Value",
          "type": "string"
        }
      ],
      "objectGroups": []
    },
    {
      "description": "Call an internal Ink function set inside the story.",
      "fullName": "Call Ink function",
      "functionType": "Action",
      "group": "Functions",
      "name": "CallInternalMethod",
      "sentence": "Call _PARAM2_ event in story _PARAM1_ and save the result in _PARAM3_",
      "events": [
        {
          "type": "BuiltinCommonInstructions::Standard",
          "conditions": [
            {
              "type": {
                "value": "InkJS::IsLoaded"
              },
              "parameters": [
                "",
                "Story",
                ""
              ]
            }
          ],
          "actions": [],
          "events": [
            {
              "type": "BuiltinCommonInstructions::JsCode",
              "inlineCode": [
                "let story = gdjs._InkJS.stories[eventsFunctionContext.getArgument(\"Story\")];",
                "",
                "story.CallMethod(eventsFunctionContext.getArgument(\"Method\"), eventsFunctionContext.getArgument(\"ReturnVariable\"), null);",
                ""
              ],
              "parameterObjects": "",
              "useStrict": true,
              "eventsSheetExpanded": false
            }
          ]
        }
      ],
      "parameters": [
        {
          "description": "Story name",
          "name": "Story",
          "supplementaryInformation": "sceneStory",
          "type": "identifier"
        },
        {
          "description": "Internal Ink method name",
          "name": "Method",
          "supplementaryInformation": "sceneEventName",
          "type": "identifier"
        },
        {
          "description": "Save result in",
          "name": "ReturnVariable",
          "type": "scenevar"
        }
      ],
      "objectGroups": []
    },
    {
      "description": "Call an internal Ink function set inside the story and collect value and text output.",
      "fullName": "Call Ink function with story output",
      "functionType": "Action",
      "group": "Functions",
      "name": "CallInternalMethodWithStoryOutput",
      "sentence": "Call _PARAM2_ event in story _PARAM1_ and save the result in _PARAM3_ and the text output in _PARAM4_",
      "events": [
        {
          "type": "BuiltinCommonInstructions::Standard",
          "conditions": [
            {
              "type": {
                "value": "InkJS::IsLoaded"
              },
              "parameters": [
                "",
                "Story",
                ""
              ]
            }
          ],
          "actions": [],
          "events": [
            {
              "type": "BuiltinCommonInstructions::JsCode",
              "inlineCode": [
                "let story = gdjs._InkJS.stories[eventsFunctionContext.getArgument(\"Story\")];",
                "",
                "story.CallMethod(eventsFunctionContext.getArgument(\"Method\"), eventsFunctionContext.getArgument(\"ReturnVariable\"), eventsFunctionContext.getArgument(\"OutputVariable\"));",
                ""
              ],
              "parameterObjects": "",
              "useStrict": true,
              "eventsSheetExpanded": false
            }
          ]
        }
      ],
      "parameters": [
        {
          "description": "Story name",
          "name": "Story",
          "supplementaryInformation": "sceneStory",
          "type": "identifier"
        },
        {
          "description": "Internal Ink method name",
          "name": "Method",
          "supplementaryInformation": "sceneEventName",
          "type": "identifier"
        },
        {
          "description": "Save result in",
          "name": "ReturnVariable",
          "type": "scenevar"
        },
        {
          "description": "Save text output in",
          "name": "OutputVariable",
          "type": "scenevar"
        }
      ],
      "objectGroups": []
    },
    {
      "description": "the event parameter count.",
      "fullName": "Event parameter count",
      "functionType": "ExpressionAndCondition",
      "group": "Functions",
      "name": "ExternalFunctionParameterCount",
      "sentence": "the story _PARAM1_ event _PARAM2_ parameter count",
      "events": [
        {
          "type": "BuiltinCommonInstructions::Standard",
          "conditions": [],
          "actions": [
            {
              "type": {
                "value": "SetReturnNumber"
              },
              "parameters": [
                "0"
              ]
            }
          ]
        },
        {
          "type": "BuiltinCommonInstructions::Standard",
          "conditions": [
            {
              "type": {
                "value": "InkJS::IsExternalFunctionCalled"
              },
              "parameters": [
                "",
                "Story",
                "EventName",
                ""
              ]
            }
          ],
          "actions": [],
          "events": [
            {
              "type": "BuiltinCommonInstructions::JsCode",
              "inlineCode": [
                "let story = gdjs._InkJS.stories[eventsFunctionContext.getArgument(\"Story\")];",
                "",
                "eventsFunctionContext.returnValue = story.listeners[eventsFunctionContext.getArgument(\"EventName\")].length;",
                ""
              ],
              "parameterObjects": "",
              "useStrict": true,
              "eventsSheetExpanded": false
            }
          ]
        }
      ],
      "expressionType": {
        "type": "expression"
      },
      "parameters": [
        {
          "description": "Story name",
          "name": "Story",
          "supplementaryInformation": "sceneStory",
          "type": "identifier"
        },
        {
          "description": "Ink event name",
          "name": "EventName",
          "supplementaryInformation": "sceneEventName",
          "type": "identifier"
        }
      ],
      "objectGroups": []
    },
    {
      "description": "the event parameter value.",
      "fullName": "Event parameter value",
      "functionType": "ExpressionAndCondition",
      "group": "Functions",
      "name": "ExternalFunctionParameterNumber",
      "sentence": "story _PARAM1_ event _PARAM2_ parameter n_PARAM3_ value",
      "events": [
        {
          "type": "BuiltinCommonInstructions::Standard",
          "conditions": [],
          "actions": [
            {
              "type": {
                "value": "SetReturnNumber"
              },
              "parameters": [
                "0"
              ]
            }
          ]
        },
        {
          "type": "BuiltinCommonInstructions::Standard",
          "conditions": [
            {
              "type": {
                "value": "InkJS::IsExternalFunctionCalled"
              },
              "parameters": [
                "",
                "Story",
                "EventName",
                ""
              ]
            },
            {
              "type": {
                "value": "CompareArgumentAsNumber"
              },
              "parameters": [
                "\"ParameterIndex\"",
                ">=",
                "0"
              ]
            },
            {
              "type": {
                "value": "CompareArgumentAsNumber"
              },
              "parameters": [
                "\"ParameterIndex\"",
                "<",
                "InkJS::ExternalFunctionParameterCount(Story, EventName)"
              ]
            }
          ],
          "actions": [],
          "events": [
            {
              "type": "BuiltinCommonInstructions::JsCode",
              "inlineCode": [
                "let story = gdjs._InkJS.stories[eventsFunctionContext.getArgument(\"Story\")];",
                "",
                "eventsFunctionContext.returnValue = story.listeners[eventsFunctionContext.getArgument(\"EventName\")][eventsFunctionContext.getArgument(\"ParameterIndex\")];",
                ""
              ],
              "parameterObjects": "",
              "useStrict": true,
              "eventsSheetExpanded": false
            }
          ]
        }
      ],
      "expressionType": {
        "type": "expression"
      },
      "parameters": [
        {
          "description": "Story name",
          "name": "Story",
          "supplementaryInformation": "sceneStory",
          "type": "identifier"
        },
        {
          "description": "Ink event name",
          "name": "EventName",
          "supplementaryInformation": "sceneEventName",
          "type": "identifier"
        },
        {
          "description": "Parameter index",
          "name": "ParameterIndex",
          "type": "expression"
        }
      ],
      "objectGroups": []
    },
    {
      "description": "the event parameter text.",
      "fullName": "Event parameter text",
      "functionType": "ExpressionAndCondition",
      "group": "Functions",
      "name": "ExternalFunctionParameterText",
      "sentence": "story _PARAM1_ event _PARAM2_ parameter n_PARAM3_ text",
      "events": [
        {
          "type": "BuiltinCommonInstructions::Standard",
          "conditions": [],
          "actions": [
            {
              "type": {
                "value": "SetReturnNumber"
              },
              "parameters": [
                "0"
              ]
            }
          ]
        },
        {
          "type": "BuiltinCommonInstructions::Standard",
          "conditions": [
            {
              "type": {
                "value": "InkJS::IsExternalFunctionCalled"
              },
              "parameters": [
                "",
                "Story",
                "EventName",
                ""
              ]
            },
            {
              "type": {
                "value": "CompareArgumentAsNumber"
              },
              "parameters": [
                "\"ParameterIndex\"",
                ">=",
                "0"
              ]
            },
            {
              "type": {
                "value": "CompareArgumentAsNumber"
              },
              "parameters": [
                "\"ParameterIndex\"",
                "<",
                "InkJS::ExternalFunctionParameterCount(Story, EventName)"
              ]
            }
          ],
          "actions": [],
          "events": [
            {
              "type": "BuiltinCommonInstructions::JsCode",
              "inlineCode": [
                "let story = gdjs._InkJS.stories[eventsFunctionContext.getArgument(\"Story\")];",
                "",
                "eventsFunctionContext.returnValue = story.listeners[eventsFunctionContext.getArgument(\"EventName\")][eventsFunctionContext.getArgument(\"ParameterIndex\")];",
                ""
              ],
              "parameterObjects": "",
              "useStrict": true,
              "eventsSheetExpanded": false
            }
          ]
        }
      ],
      "expressionType": {
        "type": "string"
      },
      "parameters": [
        {
          "description": "Story name",
          "name": "Story",
          "supplementaryInformation": "sceneStory",
          "type": "identifier"
        },
        {
          "description": "Ink event name",
          "name": "EventName",
          "supplementaryInformation": "sceneEventName",
          "type": "identifier"
        },
        {
          "description": "Parameter index",
          "name": "ParameterIndex",
          "type": "expression"
        }
      ],
      "objectGroups": []
    },
    {
      "description": "the internal Ink function value.",
      "fullName": "Ink function result value",
      "functionType": "ExpressionAndCondition",
      "group": "Functions",
      "name": "EvaluateInternalMethodValue",
      "sentence": "Return value of _PARAM2_ event in story _PARAM1_ ",
      "events": [
        {
          "type": "BuiltinCommonInstructions::Standard",
          "conditions": [
            {
              "type": {
                "value": "InkJS::IsLoaded"
              },
              "parameters": [
                "",
                "Story",
                ""
              ]
            }
          ],
          "actions": [],
          "events": [
            {
              "type": "BuiltinCommonInstructions::JsCode",
              "inlineCode": [
                "let story = gdjs._InkJS.stories[eventsFunctionContext.getArgument(\"Story\")];",
                "",
                "eventsFunctionContext.returnValue = story.EvaluateMethod(eventsFunctionContext.getArgument(\"Method\"), false);",
                ""
              ],
              "parameterObjects": "",
              "useStrict": true,
              "eventsSheetExpanded": false
            }
          ]
        }
      ],
      "expressionType": {
        "type": "expression"
      },
      "parameters": [
        {
          "description": "Story name",
          "name": "Story",
          "supplementaryInformation": "sceneStory",
          "type": "identifier"
        },
        {
          "description": "Internal Ink method name",
          "name": "Method",
          "supplementaryInformation": "sceneEventName",
          "type": "identifier"
        }
      ],
      "objectGroups": []
    },
    {
      "description": "the internal Ink function text value.",
      "fullName": "Ink function text result",
      "functionType": "ExpressionAndCondition",
      "group": "Functions",
      "name": "EvaluateInternalMethodText",
      "sentence": "Return text value of _PARAM2_ event in story _PARAM1_ ",
      "events": [
        {
          "type": "BuiltinCommonInstructions::Standard",
          "conditions": [
            {
              "type": {
                "value": "InkJS::IsLoaded"
              },
              "parameters": [
                "",
                "Story",
                ""
              ]
            }
          ],
          "actions": [],
          "events": [
            {
              "type": "BuiltinCommonInstructions::JsCode",
              "inlineCode": [
                "let story = gdjs._InkJS.stories[eventsFunctionContext.getArgument(\"Story\")];",
                "",
                "eventsFunctionContext.returnValue = story.EvaluateMethod(eventsFunctionContext.getArgument(\"Method\"), false);",
                ""
              ],
              "parameterObjects": "",
              "useStrict": true,
              "eventsSheetExpanded": false
            }
          ]
        }
      ],
      "expressionType": {
        "type": "string"
      },
      "parameters": [
        {
          "description": "Story name",
          "name": "Story",
          "supplementaryInformation": "sceneStory",
          "type": "identifier"
        },
        {
          "description": "Internal Ink method name",
          "name": "Method",
          "supplementaryInformation": "sceneEventName",
          "type": "identifier"
        }
      ],
      "objectGroups": []
    },
    {
      "description": "the internal Ink function story output.",
      "fullName": "Ink function story output",
      "functionType": "ExpressionAndCondition",
      "group": "Functions",
      "name": "EvaluateInternalMethodOuput",
      "sentence": "Return output of _PARAM2_ event in story _PARAM1_ ",
      "events": [
        {
          "type": "BuiltinCommonInstructions::Standard",
          "conditions": [
            {
              "type": {
                "value": "InkJS::IsLoaded"
              },
              "parameters": [
                "",
                "Story",
                ""
              ]
            }
          ],
          "actions": [],
          "events": [
            {
              "type": "BuiltinCommonInstructions::JsCode",
              "inlineCode": [
                "let story = gdjs._InkJS.stories[eventsFunctionContext.getArgument(\"Story\")];",
                "",
                "eventsFunctionContext.returnValue = story.EvaluateMethod(eventsFunctionContext.getArgument(\"Method\"), true);",
                ""
              ],
              "parameterObjects": "",
              "useStrict": true,
              "eventsSheetExpanded": false
            }
          ]
        }
      ],
      "expressionType": {
        "type": "string"
      },
      "parameters": [
        {
          "description": "Story name",
          "name": "Story",
          "supplementaryInformation": "sceneStory",
          "type": "identifier"
        },
        {
          "description": "Internal Ink method name",
          "name": "Method",
          "supplementaryInformation": "sceneEventName",
          "type": "identifier"
        }
      ],
      "objectGroups": []
    },
    {
      "description": "Reset the story back to its initial state.",
      "fullName": "Reset story state",
      "functionType": "Action",
      "group": "History",
      "name": "ResetStory",
      "sentence": "Reset story _PARAM1_",
      "events": [
        {
          "type": "BuiltinCommonInstructions::Standard",
          "conditions": [
            {
              "type": {
                "value": "InkJS::IsLoaded"
              },
              "parameters": [
                "",
                "Story",
                ""
              ]
            }
          ],
          "actions": [],
          "events": [
            {
              "type": "BuiltinCommonInstructions::JsCode",
              "inlineCode": [
                "let item = gdjs._InkJS.stories[eventsFunctionContext.getArgument(\"Story\")];",
                "item.story.ResetState();",
                "item.SetHistory(null);"
              ],
              "parameterObjects": "",
              "useStrict": true,
              "eventsSheetExpanded": false
            }
          ]
        }
      ],
      "parameters": [
        {
          "description": "Story name",
          "name": "Story",
          "supplementaryInformation": "sceneStory",
          "type": "identifier"
        }
      ],
      "objectGroups": []
    },
    {
      "description": "Set a scene variable for saving the story choice history.",
      "fullName": "Activate story history",
      "functionType": "Action",
      "group": "History",
      "name": "ActivateHistory",
      "sentence": "Activate the history for story _PARAM1_ in array _PARAM2_",
      "events": [
        {
          "type": "BuiltinCommonInstructions::Standard",
          "conditions": [
            {
              "type": {
                "value": "InkJS::IsLoaded"
              },
              "parameters": [
                "",
                "Story",
                ""
              ]
            }
          ],
          "actions": [],
          "events": [
            {
              "type": "BuiltinCommonInstructions::JsCode",
              "inlineCode": [
                "let story = gdjs._InkJS.stories[eventsFunctionContext.getArgument(\"Story\")];",
                "story.SetHistory(eventsFunctionContext.getArgument(\"History\"), true);"
              ],
              "parameterObjects": "",
              "useStrict": true,
              "eventsSheetExpanded": false
            }
          ]
        }
      ],
      "parameters": [
        {
          "description": "Story name",
          "name": "Story",
          "supplementaryInformation": "sceneStory",
          "type": "identifier"
        },
        {
          "description": "History array",
          "name": "History",
          "type": "scenevar"
        }
      ],
      "objectGroups": []
    },
    {
      "description": "Load an already prepared scene variable for saving the story choice history.",
      "fullName": "Load story history",
      "functionType": "Action",
      "group": "History",
      "name": "LoadHistory",
      "sentence": "Load the history array _PARAM2_ in story _PARAM1_",
      "events": [
        {
          "type": "BuiltinCommonInstructions::Standard",
          "conditions": [
            {
              "type": {
                "value": "InkJS::IsLoaded"
              },
              "parameters": [
                "",
                "Story",
                ""
              ]
            }
          ],
          "actions": [],
          "events": [
            {
              "type": "BuiltinCommonInstructions::JsCode",
              "inlineCode": [
                "let story = gdjs._InkJS.stories[eventsFunctionContext.getArgument(\"Story\")];",
                "story.SetHistory(eventsFunctionContext.getArgument(\"History\"), false);"
              ],
              "parameterObjects": "",
              "useStrict": true,
              "eventsSheetExpanded": false
            }
          ]
        }
      ],
      "parameters": [
        {
          "description": "Story name",
          "name": "Story",
          "supplementaryInformation": "sceneStory",
          "type": "identifier"
        },
        {
          "description": "History array",
          "name": "History",
          "type": "scenevar"
        }
      ],
      "objectGroups": []
    },
    {
      "description": "Come back to the previous state of the story.",
      "fullName": "Rewind last choice",
      "functionType": "Action",
      "group": "History",
      "name": "RewindChoice",
      "sentence": "Rewind the last choice of _PARAM1_",
      "events": [
        {
          "type": "BuiltinCommonInstructions::Standard",
          "conditions": [
            {
              "type": {
                "value": "InkJS::IsLoaded"
              },
              "parameters": [
                "",
                "Story",
                ""
              ]
            }
          ],
          "actions": [],
          "events": [
            {
              "type": "BuiltinCommonInstructions::JsCode",
              "inlineCode": [
                "let story = gdjs._InkJS.stories[eventsFunctionContext.getArgument(\"Story\")];",
                "story.Rewind();"
              ],
              "parameterObjects": "",
              "useStrict": true,
              "eventsSheetExpanded": false
            }
          ]
        }
      ],
      "parameters": [
        {
          "description": "Story name",
          "name": "Story",
          "supplementaryInformation": "sceneStory",
          "type": "identifier"
        }
      ],
      "objectGroups": []
    },
    {
      "description": "Create a temporary snapshot of the story.",
      "fullName": "Create story snapshot",
      "functionType": "Action",
      "group": "History",
      "name": "CreateSnapshot",
      "sentence": "Create a snapshot of story _PARAM1_",
      "events": [
        {
          "type": "BuiltinCommonInstructions::Standard",
          "conditions": [
            {
              "type": {
                "value": "InkJS::IsLoaded"
              },
              "parameters": [
                "",
                "Story",
                ""
              ]
            }
          ],
          "actions": [],
          "events": [
            {
              "type": "BuiltinCommonInstructions::JsCode",
              "inlineCode": [
                "let story = gdjs._InkJS.stories[eventsFunctionContext.getArgument(\"Story\")].story;",
                "story.StateSnapshot();"
              ],
              "parameterObjects": "",
              "useStrict": true,
              "eventsSheetExpanded": false
            }
          ]
        }
      ],
      "parameters": [
        {
          "description": "Story name",
          "name": "Story",
          "supplementaryInformation": "sceneStory",
          "type": "identifier"
        }
      ],
      "objectGroups": []
    },
    {
      "description": "Restore the last snapshot of the story.",
      "fullName": "Restore story snapshot",
      "functionType": "Action",
      "group": "History",
      "name": "RestoreSnapshot",
      "sentence": "Restore the last snapshot of story _PARAM1_",
      "events": [
        {
          "type": "BuiltinCommonInstructions::Standard",
          "conditions": [
            {
              "type": {
                "value": "InkJS::IsLoaded"
              },
              "parameters": [
                "",
                "Story",
                ""
              ]
            }
          ],
          "actions": [],
          "events": [
            {
              "type": "BuiltinCommonInstructions::JsCode",
              "inlineCode": [
                "let story = gdjs._InkJS.stories[eventsFunctionContext.getArgument(\"Story\")].story;",
                "story.RestoreStateSnapshot();"
              ],
              "parameterObjects": "",
              "useStrict": true,
              "eventsSheetExpanded": false
            }
          ]
        }
      ],
      "parameters": [
        {
          "description": "Story name",
          "name": "Story",
          "supplementaryInformation": "sceneStory",
          "type": "identifier"
        }
      ],
      "objectGroups": []
    },
    {
      "description": "Discard the last snapshot of the story.",
      "fullName": "Discard story snapshot",
      "functionType": "Action",
      "group": "History",
      "name": "DiscardSnapshot",
      "sentence": "Discard the last snapshot of story _PARAM1_",
      "events": [
        {
          "type": "BuiltinCommonInstructions::Standard",
          "conditions": [
            {
              "type": {
                "value": "InkJS::IsLoaded"
              },
              "parameters": [
                "",
                "Story",
                ""
              ]
            }
          ],
          "actions": [],
          "events": [
            {
              "type": "BuiltinCommonInstructions::JsCode",
              "inlineCode": [
                "let story = gdjs._InkJS.stories[eventsFunctionContext.getArgument(\"Story\")].story;",
                "story.DiscardSnapshot();"
              ],
              "parameterObjects": "",
              "useStrict": true,
              "eventsSheetExpanded": false
            }
          ]
        }
      ],
      "parameters": [
        {
          "description": "Story name",
          "name": "Story",
          "supplementaryInformation": "sceneStory",
          "type": "identifier"
        }
      ],
      "objectGroups": []
    }
  ],
  "eventsBasedBehaviors": [],
  "eventsBasedObjects": []
}