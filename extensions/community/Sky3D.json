{
  "author": "",
  "category": "Visual effect",
  "extensionNamespace": "",
  "gdevelopVersion": ">=5.5.222",
  "fullName": "3D Sky and sun",
  "helpPath": "",
  "iconUrl": "data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0idXRmLTgiPz4NCjwhLS0gR2VuZXJhdG9yOiBBZG9iZSBJbGx1c3RyYXRvciAyMy4wLjMsIFNWRyBFeHBvcnQgUGx1Zy1JbiAuIFNWRyBWZXJzaW9uOiA2LjAwIEJ1aWxkIDApICAtLT4NCjxzdmcgdmVyc2lvbj0iMS4xIiBpZD0iSWNvbnMiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgeG1sbnM6eGxpbms9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmsiIHg9IjBweCIgeT0iMHB4Ig0KCSB2aWV3Qm94PSIwIDAgMzIgMzIiIHN0eWxlPSJlbmFibGUtYmFja2dyb3VuZDpuZXcgMCAwIDMyIDMyOyIgeG1sOnNwYWNlPSJwcmVzZXJ2ZSI+DQo8c3R5bGUgdHlwZT0idGV4dC9jc3MiPg0KCS5zdDB7ZmlsbDpub25lO3N0cm9rZTojMDAwMDAwO3N0cm9rZS13aWR0aDoyO3N0cm9rZS1saW5lY2FwOnJvdW5kO3N0cm9rZS1saW5lam9pbjpyb3VuZDtzdHJva2UtbWl0ZXJsaW1pdDoxMDt9DQo8L3N0eWxlPg0KPGNpcmNsZSBjbGFzcz0ic3QwIiBjeD0iMTYiIGN5PSIxNiIgcj0iOSIvPg0KPHBhdGggY2xhc3M9InN0MCIgZD0iTTIwLDFMMjAsMUwyMCwxYzAuMywzLjQsMy45LDUuNCw3LDRsMCwwbDAsMGMtMS40LDMuMSwwLjYsNi42LDQsN2wwLDBsMCwwYy0yLjgsMi0yLjgsNi4xLDAsOGwwLDBsMCwwDQoJYy0zLjQsMC4zLTUuNCwzLjktNCw3bDAsMGwwLDBjLTMuMS0xLjQtNi42LDAuNi03LDRsMCwwbDAsMGMtMi0yLjgtNi4xLTIuOC04LDBsMCwwbDAsMGMtMC4zLTMuNC0zLjktNS40LTctNGwwLDBsMCwwDQoJYzEuNC0zLjEtMC42LTYuNi00LTdsMCwwbDAsMGMyLjgtMiwyLjgtNi4xLDAtOGwwLDBsMCwwYzMuNC0wLjMsNS40LTMuOSw0LTdsMCwwbDAsMGMzLjEsMS40LDYuNi0wLjYsNy00bDAsMGwwLDANCglDMTMuOSwzLjgsMTguMSwzLjgsMjAsMXoiLz4NCjwvc3ZnPg0K",
  "name": "Sky3D",
  "previewIconUrl": "https://asset-resources.gdevelop.io/public-resources/Icons/Line Hero Pack/Master/SVG/Summer Holidays/512b9e875fbd9fe3ae1049df4ca9cdea12eeb439cfcd15c9e20ca654477ae532_Summer Holidays_holidays_vacation_summer_sun_sunny_hot.svg",
  "shortDescription": "Fully animated 3D sky with sun.",
  "version": "1.0.0",
  "description": [
    "Fully animated 3D sky with the sun. ",
    "You can adjust each parameter: the position of the sun, the brightness and the scattering of rays. ",
    "The color of the sky changes depending on the position of the sun: reddish at sunset and blue at the zenith."
  ],
  "tags": [
    "3D",
    "Skybox"
  ],
  "authorIds": [
    "l2OaORwcgyX7y4HQY2dHPmdTuDj2"
  ],
  "dependencies": [],
  "eventsFunctions": [
    {
      "fullName": "",
      "functionType": "Action",
      "name": "onFirstSceneLoaded",
      "sentence": "",
      "events": [
        {
          "type": "BuiltinCommonInstructions::JsCode",
          "inlineCode": [
            "/**",
            " * Based on \"A Practical Analytic Model for Daylight\"",
            " * aka The Preetham Model, the de facto standard analytic skydome model",
            " * https://www.researchgate.net/publication/220720443_A_Practical_Analytic_Model_for_Daylight",
            " *",
            " * First implemented by Simon Wallner",
            " * http://simonwallner.at/project/atmospheric-scattering/",
            " *",
            " * Improved by Martin Upitis",
            " * http://blenderartists.org/forum/showthread.php?245954-preethams-sky-impementation-HDR",
            " *",
            " * Three.js integration by zz85 http://twitter.com/blurspline",
            "*/",
            "",
            "class Sky extends THREE.Mesh {",
            "",
            "\tconstructor() {",
            "",
            "\t\tconst shader = Sky.SkyShader;",
            "",
            "\t\tconst material = new THREE.ShaderMaterial( {",
            "\t\t\tname: shader.name,",
            "\t\t\tuniforms: THREE.UniformsUtils.clone( shader.uniforms ),",
            "\t\t\tvertexShader: shader.vertexShader,",
            "\t\t\tfragmentShader: shader.fragmentShader,",
            "\t\t\tside: THREE.BackSide,",
            "\t\t\tdepthWrite: false",
            "\t\t} );",
            "",
            "\t\tsuper( new THREE.BoxGeometry( 1, 1, 1 ), material );",
            "",
            "\t\tthis.isSky = true;",
            "",
            "\t}",
            "",
            "}",
            "",
            "Sky.SkyShader = {",
            "",
            "\tname: 'SkyShader',",
            "",
            "\tuniforms: {",
            "\t\t'turbidity': { value: 2 },",
            "\t\t'rayleigh': { value: 1 },",
            "\t\t'mieCoefficient': { value: 0.005 },",
            "\t\t'mieDirectionalG': { value: 0.8 },",
            "\t\t'sunPosition': { value: new THREE.Vector3() },",
            "\t\t'up': { value: new THREE.Vector3( 0, 0, 1 ) }",
            "\t},",
            "",
            "\tvertexShader: /* glsl */`",
            "\t\tuniform vec3 sunPosition;",
            "\t\tuniform float rayleigh;",
            "\t\tuniform float turbidity;",
            "\t\tuniform float mieCoefficient;",
            "\t\tuniform vec3 up;",
            "",
            "\t\tvarying vec3 vWorldPosition;",
            "\t\tvarying vec3 vSunDirection;",
            "\t\tvarying float vSunfade;",
            "\t\tvarying vec3 vBetaR;",
            "\t\tvarying vec3 vBetaM;",
            "\t\tvarying float vSunE;",
            "",
            "\t\t// constants for atmospheric scattering",
            "\t\tconst float e = 2.71828182845904523536028747135266249775724709369995957;",
            "\t\tconst float pi = 3.141592653589793238462643383279502884197169;",
            "",
            "\t\t// wavelength of used primaries, according to preetham",
            "\t\tconst vec3 lambda = vec3( 680E-9, 550E-9, 450E-9 );",
            "\t\t// this pre-calcuation replaces older TotalRayleigh(vec3 lambda) function:",
            "\t\t// (8.0 * pow(pi, 3.0) * pow(pow(n, 2.0) - 1.0, 2.0) * (6.0 + 3.0 * pn)) / (3.0 * N * pow(lambda, vec3(4.0)) * (6.0 - 7.0 * pn))",
            "\t\tconst vec3 totalRayleigh = vec3( 5.804542996261093E-6, 1.3562911419845635E-5, 3.0265902468824876E-5 );",
            "",
            "\t\t// mie stuff",
            "\t\t// K coefficient for the primaries",
            "\t\tconst float v = 4.0;",
            "\t\tconst vec3 K = vec3( 0.686, 0.678, 0.666 );",
            "\t\t// MieConst = pi * pow( ( 2.0 * pi ) / lambda, vec3( v - 2.0 ) ) * K",
            "\t\tconst vec3 MieConst = vec3( 1.8399918514433978E14, 2.7798023919660528E14, 4.0790479543861094E14 );",
            "",
            "\t\t// earth shadow hack",
            "\t\t// cutoffAngle = pi / 1.95;",
            "\t\tconst float cutoffAngle = 1.6110731556870734;",
            "\t\tconst float steepness = 1.5;",
            "\t\tconst float EE = 1000.0;",
            "",
            "\t\tfloat sunIntensity( float zenithAngleCos ) {",
            "\t\t\tzenithAngleCos = clamp( zenithAngleCos, -1.0, 1.0 );",
            "\t\t\treturn EE * max( 0.0, 1.0 - pow( e, -( ( cutoffAngle - acos( zenithAngleCos ) ) / steepness ) ) );",
            "\t\t}",
            "",
            "\t\tvec3 totalMie( float T ) {",
            "\t\t\tfloat c = ( 0.2 * T ) * 10E-18;",
            "\t\t\treturn 0.434 * c * MieConst;",
            "\t\t}",
            "",
            "\t\tvoid main() {",
            "",
            "\t\t\tvec4 worldPosition = modelMatrix * vec4( position, 1.0 );",
            "\t\t\tvWorldPosition = worldPosition.xyz;",
            "",
            "\t\t\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );",
            "\t\t\tgl_Position.z = gl_Position.w; // set z to camera.far",
            "",
            "\t\t\tvSunDirection = normalize( sunPosition );",
            "",
            "\t\t\tvSunE = sunIntensity( dot( vSunDirection, up ) );",
            "",
            "\t\t\tvSunfade = 1.0 - clamp( 1.0 - exp( ( sunPosition.y / 450000.0 ) ), 0.0, 1.0 );",
            "",
            "\t\t\tfloat rayleighCoefficient = rayleigh - ( 1.0 * ( 1.0 - vSunfade ) );",
            "",
            "\t\t\t// extinction (absorbtion + out scattering)",
            "\t\t\t// rayleigh coefficients",
            "\t\t\tvBetaR = totalRayleigh * rayleighCoefficient;",
            "",
            "\t\t\t// mie coefficients",
            "\t\t\tvBetaM = totalMie( turbidity ) * mieCoefficient;",
            "",
            "\t\t}`,",
            "",
            "\tfragmentShader: /* glsl */`",
            "\t\tvarying vec3 vWorldPosition;",
            "\t\tvarying vec3 vSunDirection;",
            "\t\tvarying float vSunfade;",
            "\t\tvarying vec3 vBetaR;",
            "\t\tvarying vec3 vBetaM;",
            "\t\tvarying float vSunE;",
            "",
            "\t\tuniform float mieDirectionalG;",
            "\t\tuniform vec3 up;",
            "",
            "\t\t// constants for atmospheric scattering",
            "\t\tconst float pi = 3.141592653589793238462643383279502884197169;",
            "",
            "\t\tconst float n = 1.0003; // refractive index of air",
            "\t\tconst float N = 2.545E25; // number of molecules per unit volume for air at 288.15K and 1013mb (sea level -45 celsius)",
            "",
            "\t\t// optical length at zenith for molecules",
            "\t\tconst float rayleighZenithLength = 8.4E3;",
            "\t\tconst float mieZenithLength = 1.25E3;",
            "\t\t// 66 arc seconds -> degrees, and the cosine of that",
            "\t\tconst float sunAngularDiameterCos = 0.999956676946448443553574619906976478926848692873900859324;",
            "",
            "\t\t// 3.0 / ( 16.0 * pi )",
            "\t\tconst float THREE_OVER_SIXTEENPI = 0.05968310365946075;",
            "\t\t// 1.0 / ( 4.0 * pi )",
            "\t\tconst float ONE_OVER_FOURPI = 0.07957747154594767;",
            "",
            "\t\tfloat rayleighPhase( float cosTheta ) {",
            "\t\t\treturn THREE_OVER_SIXTEENPI * ( 1.0 + pow( cosTheta, 2.0 ) );",
            "\t\t}",
            "",
            "\t\tfloat hgPhase( float cosTheta, float g ) {",
            "\t\t\tfloat g2 = pow( g, 2.0 );",
            "\t\t\tfloat inverse = 1.0 / pow( 1.0 - 2.0 * g * cosTheta + g2, 1.5 );",
            "\t\t\treturn ONE_OVER_FOURPI * ( ( 1.0 - g2 ) * inverse );",
            "\t\t}",
            "",
            "\t\tvoid main() {",
            "",
            "\t\t\tvec3 direction = normalize( vWorldPosition - cameraPosition );",
            "",
            "\t\t\t// optical length",
            "\t\t\t// cutoff angle at 90 to avoid singularity in next formula.",
            "\t\t\tfloat zenithAngle = acos( max( 0.0, dot( up, direction ) ) );",
            "\t\t\tfloat inverse = 1.0 / ( cos( zenithAngle ) + 0.15 * pow( 93.885 - ( ( zenithAngle * 180.0 ) / pi ), -1.253 ) );",
            "\t\t\tfloat sR = rayleighZenithLength * inverse;",
            "\t\t\tfloat sM = mieZenithLength * inverse;",
            "",
            "\t\t\t// combined extinction factor",
            "\t\t\tvec3 Fex = exp( -( vBetaR * sR + vBetaM * sM ) );",
            "",
            "\t\t\t// in scattering",
            "\t\t\tfloat cosTheta = dot( direction, vSunDirection );",
            "",
            "\t\t\tfloat rPhase = rayleighPhase( cosTheta * 0.5 + 0.5 );",
            "\t\t\tvec3 betaRTheta = vBetaR * rPhase;",
            "",
            "\t\t\tfloat mPhase = hgPhase( cosTheta, mieDirectionalG );",
            "\t\t\tvec3 betaMTheta = vBetaM * mPhase;",
            "",
            "\t\t\tvec3 Lin = pow( vSunE * ( ( betaRTheta + betaMTheta ) / ( vBetaR + vBetaM ) ) * ( 1.0 - Fex ), vec3( 1.5 ) );",
            "\t\t\tLin *= mix( vec3( 1.0 ), pow( vSunE * ( ( betaRTheta + betaMTheta ) / ( vBetaR + vBetaM ) ) * Fex, vec3( 1.0 / 2.0 ) ), clamp( pow( 1.0 - dot( up, vSunDirection ), 5.0 ), 0.0, 1.0 ) );",
            "",
            "\t\t\t// nightsky",
            "\t\t\tfloat theta = acos( direction.y ); // elevation --> y-axis, [-pi/2, pi/2]",
            "\t\t\tfloat phi = atan( direction.z, direction.x ); // azimuth --> x-axis [-pi/2, pi/2]",
            "\t\t\tvec2 uv = vec2( phi, theta ) / vec2( 2.0 * pi, pi ) + vec2( 0.5, 0.0 );",
            "\t\t\tvec3 L0 = vec3( 0.1 ) * Fex;",
            "",
            "\t\t\t// composition + solar disc",
            "\t\t\tfloat sundisk = smoothstep( sunAngularDiameterCos, sunAngularDiameterCos + 0.00002, cosTheta );",
            "\t\t\tL0 += ( vSunE * 19000.0 * Fex ) * sundisk;",
            "",
            "\t\t\tvec3 texColor = ( Lin + L0 ) * 0.04 + vec3( 0.0, 0.0003, 0.00075 );",
            "",
            "\t\t\tvec3 retColor = pow( texColor, vec3( 1.0 / ( 1.2 + ( 1.2 * vSunfade ) ) ) );",
            "",
            "\t\t\tgl_FragColor = vec4( retColor, 1.0 );",
            "",
            "\t\t\t#include <tonemapping_fragment>",
            "\t\t\t#include <colorspace_fragment>",
            "",
            "\t\t}`",
            "",
            "};",
            "",
            "gdjs.__Sky3DExtension = { Sky };",
            "gdjs.__Sky3DExtension.skyInfo = gdjs.__Sky3DExtension.skyInfo || new Map();",
            ""
          ],
          "parameterObjects": "",
          "useStrict": true,
          "eventsSheetExpanded": true
        }
      ],
      "parameters": [],
      "objectGroups": []
    },
    {
      "description": "Create sky and sun.",
      "fullName": "Create sky",
      "functionType": "Action",
      "name": "Create_Sky",
      "sentence": "Create Sky - Turbidity _PARAM1_ Rayleigh _PARAM2_ Mie Coefficient _PARAM3_ Mie Directional _PARAM4_ Elevation _PARAM5_ Azimuth _PARAM6_ Exposure _PARAM7_ on Layer _PARAM8_",
      "events": [
        {
          "type": "BuiltinCommonInstructions::JsCode",
          "inlineCode": [
            "const layer = eventsFunctionContext.getArgument('layer');",
            "",
            "if (!gdjs.__Sky3DExtension.skyInfo.has(layer)){",
            "\tconst renderer = runtimeScene.getGame().getRenderer().getThreeRenderer();",
            "\tconst scene = runtimeScene.getLayer(layer).getRenderer().getThreeScene();",
            "",
            "\trenderer.toneMapping = THREE.ACESFilmicToneMapping;",
            "\tvar sky = new gdjs.__Sky3DExtension.Sky();",
            "\tsky.scale.setScalar( 450000 );",
            "\tscene.add( sky );",
            "",
            "\tvar sun = new THREE.Vector3();",
            "",
            "\tconst effectController = {",
            "\t\tturbidity: eventsFunctionContext.getArgument('turbidity'),",
            "\t\trayleigh: eventsFunctionContext.getArgument('rayleigh'),",
            "\t\tmieCoefficient: eventsFunctionContext.getArgument('mieCoefficient') / 1000,",
            "\t\tmieDirectionalG: eventsFunctionContext.getArgument('mieDirectionalG'),",
            "\t\televation: eventsFunctionContext.getArgument('elevation'),",
            "\t\tazimuth: eventsFunctionContext.getArgument('azimuth'),",
            "\t\texposure: eventsFunctionContext.getArgument('exposure')",
            "\t};",
            "",
            "\tconst uniforms = sky.material.uniforms;",
            "\tuniforms[ 'turbidity' ].value = effectController.turbidity;",
            "\tuniforms[ 'rayleigh' ].value = effectController.rayleigh;",
            "\tuniforms[ 'mieCoefficient' ].value = effectController.mieCoefficient;",
            "\tuniforms[ 'mieDirectionalG' ].value = effectController.mieDirectionalG;",
            "",
            "\tconst phi = THREE.MathUtils.degToRad( 90 - effectController.elevation );",
            "\tconst theta = THREE.MathUtils.degToRad( effectController.azimuth );",
            "",
            "\tconst x = Math.cos(theta) * Math.sin(phi);",
            "\tconst y = Math.sin(theta) * Math.sin(phi);",
            "\tconst z = Math.cos(phi);",
            "",
            "\tsun.set(x, y, z);",
            "",
            "\tuniforms[ 'sunPosition' ].value.copy( sun );",
            "\trenderer.toneMappingExposure  = effectController.exposure;",
            "",
            "\tgdjs.__Sky3DExtension.skyInfo.set(layer, { sky });",
            "}",
            ""
          ],
          "parameterObjects": "",
          "useStrict": true,
          "eventsSheetExpanded": true
        }
      ],
      "parameters": [
        {
          "description": "Turbidity (0-20, default 10)",
          "name": "turbidity",
          "type": "expression"
        },
        {
          "description": "Rayleigh (0-4, default 3)",
          "name": "rayleigh",
          "type": "expression"
        },
        {
          "description": "Mie coefficient (0-100, default 1)",
          "name": "mieCoefficient",
          "type": "expression"
        },
        {
          "description": "Mie Directional (0-1, default 0.965)",
          "name": "mieDirectionalG",
          "type": "expression"
        },
        {
          "description": "Elevation (0-360, default 10)",
          "name": "elevation",
          "type": "expression"
        },
        {
          "description": "Azimuth (0-360, default 0)",
          "name": "azimuth",
          "type": "expression"
        },
        {
          "description": "Exposure (0-1, default 0.5)",
          "name": "exposure",
          "type": "expression"
        },
        {
          "description": "Layer",
          "name": "layer",
          "type": "layer"
        }
      ],
      "objectGroups": []
    },
    {
      "description": "Set sky parameters.",
      "fullName": "Set sky parameters",
      "functionType": "Action",
      "name": "Edit_Sky",
      "sentence": "Set Sky parameters - Turbidity _PARAM1_ Rayleigh _PARAM2_ Mie Coefficient _PARAM3_ Mie Directional _PARAM4_ Elevation _PARAM5_ Azimuth _PARAM6_ Exposure _PARAM7_ on Layer _PARAM8_",
      "events": [
        {
          "type": "BuiltinCommonInstructions::JsCode",
          "inlineCode": [
            "const layer = eventsFunctionContext.getArgument('layer');",
            "",
            "if (gdjs.__Sky3DExtension.skyInfo.has(layer)){",
            "\tconst renderer = runtimeScene.getGame().getRenderer().getThreeRenderer();",
            "",
            "\tvar sky = gdjs.__Sky3DExtension.skyInfo.get(layer).sky;",
            "\tvar sun = new THREE.Vector3();",
            "",
            "\tconst effectController = {",
            "\t\tturbidity: eventsFunctionContext.getArgument('turbidity'),",
            "\t\trayleigh: eventsFunctionContext.getArgument('rayleigh'),",
            "\t\tmieCoefficient: eventsFunctionContext.getArgument('mieCoefficient') / 1000,",
            "\t\tmieDirectionalG: eventsFunctionContext.getArgument('mieDirectionalG'),",
            "\t\televation: eventsFunctionContext.getArgument('elevation'),",
            "\t\tazimuth: eventsFunctionContext.getArgument('azimuth'),",
            "\t\texposure: eventsFunctionContext.getArgument('exposure')",
            "\t};",
            "",
            "\tconst uniforms = sky.material.uniforms;",
            "\tuniforms[ 'turbidity' ].value = effectController.turbidity;",
            "\tuniforms[ 'rayleigh' ].value = effectController.rayleigh;",
            "\tuniforms[ 'mieCoefficient' ].value = effectController.mieCoefficient;",
            "\tuniforms[ 'mieDirectionalG' ].value = effectController.mieDirectionalG;",
            "",
            "\tconst phi = THREE.MathUtils.degToRad( 90 - effectController.elevation );",
            "\tconst theta = THREE.MathUtils.degToRad( effectController.azimuth );",
            "",
            "\tconst x = Math.cos(theta) * Math.sin(phi);",
            "\tconst y = Math.sin(theta) * Math.sin(phi);",
            "\tconst z = Math.cos(phi);",
            "",
            "\tsun.set(x, y, z);",
            "",
            "\tuniforms[ 'sunPosition' ].value.copy( sun );",
            "\trenderer.toneMappingExposure  = effectController.exposure;",
            "",
            "}",
            ""
          ],
          "parameterObjects": "",
          "useStrict": true,
          "eventsSheetExpanded": true
        }
      ],
      "parameters": [
        {
          "description": "Turbidity (0-20, default 10)",
          "name": "turbidity",
          "type": "expression"
        },
        {
          "description": "Rayleigh (0-4, default 3)",
          "name": "rayleigh",
          "type": "expression"
        },
        {
          "description": "Mie coefficient (0-100, default 1)",
          "name": "mieCoefficient",
          "type": "expression"
        },
        {
          "description": "Mie Directional (0-1, default 0.965)",
          "name": "mieDirectionalG",
          "type": "expression"
        },
        {
          "description": "Elevation (0-360, default 10)",
          "name": "elevation",
          "type": "expression"
        },
        {
          "description": "Azimuth (0-360, default 0)",
          "name": "azimuth",
          "type": "expression"
        },
        {
          "description": "Exposure (0-1, default 0.5)",
          "name": "exposure",
          "type": "expression"
        },
        {
          "description": "Layer",
          "name": "layer",
          "type": "layer"
        }
      ],
      "objectGroups": []
    }
  ],
  "eventsBasedBehaviors": [],
  "eventsBasedObjects": []
}