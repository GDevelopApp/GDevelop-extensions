{
  "author": "",
  "category": "Third-party",
  "extensionNamespace": "",
  "fullName": "1SatOrdinals and BSV",
  "gdevelopVersion": "",
  "helpPath": "https://github.com/AwesomeKalin/gdevelop-1satordinal-bsv",
  "iconUrl": "data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0idXRmLTgiPz4NCjwhLS0gR2VuZXJhdG9yOiBBZG9iZSBJbGx1c3RyYXRvciAyMy4wLjMsIFNWRyBFeHBvcnQgUGx1Zy1JbiAuIFNWRyBWZXJzaW9uOiA2LjAwIEJ1aWxkIDApICAtLT4NCjxzdmcgdmVyc2lvbj0iMS4xIiBpZD0iSWNvbnMiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgeG1sbnM6eGxpbms9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmsiIHg9IjBweCIgeT0iMHB4Ig0KCSB2aWV3Qm94PSIwIDAgMzIgMzIiIHN0eWxlPSJlbmFibGUtYmFja2dyb3VuZDpuZXcgMCAwIDMyIDMyOyIgeG1sOnNwYWNlPSJwcmVzZXJ2ZSI+DQo8c3R5bGUgdHlwZT0idGV4dC9jc3MiPg0KCS5zdDB7ZmlsbDpub25lO3N0cm9rZTojMDAwMDAwO3N0cm9rZS13aWR0aDoyO3N0cm9rZS1saW5lY2FwOnJvdW5kO3N0cm9rZS1saW5lam9pbjpyb3VuZDtzdHJva2UtbWl0ZXJsaW1pdDoxMDt9DQo8L3N0eWxlPg0KPGc+DQoJPHBhdGggZD0iTTE2LjUsMTVoLTFjLTAuMywwLTAuNS0wLjItMC41LTAuNXMwLjItMC41LDAuNS0wLjVIMTdjMC42LDAsMS0wLjQsMS0xcy0wLjQtMS0xLTFjMC0wLjYtMC40LTEtMS0xcy0xLDAuNC0xLDF2MC4xDQoJCWMtMS4xLDAuMi0yLDEuMi0yLDIuNGMwLDEuNCwxLjEsMi41LDIuNSwyLjVoMWMwLjMsMCwwLjUsMC4yLDAuNSwwLjVTMTYuOCwxOCwxNi41LDE4SDE1Yy0wLjYsMC0xLDAuNC0xLDFzMC40LDEsMSwxDQoJCWMwLDAuNiwwLjQsMSwxLDFzMS0wLjQsMS0xdi0wLjFjMS4xLTAuMiwyLTEuMiwyLTIuNEMxOSwxNi4xLDE3LjksMTUsMTYuNSwxNXoiLz4NCgk8cGF0aCBkPSJNMjkuNiwxMi43Yy0wLjEtMC41LTAuNi0wLjgtMS4xLTAuOGMtMS4yLDAuMi0yLjQtMC40LTMtMS41Yy0wLjYtMS0wLjUtMi40LDAuMi0zLjNjMC4zLTAuNCwwLjMtMS0wLjEtMS4zDQoJCUMyNCw0LjMsMjIuMSwzLjIsMjAsMi42Yy0wLjUtMC4xLTEsMC4xLTEuMiwwLjZDMTguMyw0LjMsMTcuMiw1LDE2LDVzLTIuMy0wLjctMi44LTEuOEMxMywyLjcsMTIuNSwyLjQsMTIsMi42DQoJCUM5LjksMy4yLDgsNC4zLDYuNCw1LjlDNiw2LjIsNiw2LjgsNi4zLDcuMmMwLjcsMSwwLjgsMi4zLDAuMiwzLjNjLTAuNiwxLTEuOCwxLjYtMywxLjVjLTAuNS0wLjEtMSwwLjMtMS4xLDAuOA0KCQlDMi4xLDEzLjgsMiwxNC45LDIsMTZzMC4xLDIuMiwwLjQsMy4zQzIuNSwxOS44LDMsMjAuMSwzLjUsMjBjMS4yLTAuMiwyLjQsMC40LDMsMS41YzAuNiwxLDAuNSwyLjQtMC4yLDMuMw0KCQljLTAuMywwLjQtMC4zLDEsMC4xLDEuM2MxLjYsMS41LDMuNiwyLjcsNS43LDMuM2MwLjUsMC4xLDEtMC4xLDEuMi0wLjZjMC41LTEuMSwxLjYtMS44LDIuOC0xLjhzMi4zLDAuNywyLjgsMS44DQoJCWMwLjIsMC40LDAuNSwwLjYsMC45LDAuNmMwLjEsMCwwLjIsMCwwLjMsMGMyLjEtMC42LDQuMS0xLjgsNS43LTMuM2MwLjQtMC40LDAuNC0wLjksMC4xLTEuM2MtMC43LTEtMC44LTIuMy0wLjItMy4zDQoJCWMwLjYtMSwxLjgtMS42LDMtMS41YzAuNSwwLjEsMS0wLjMsMS4xLTAuOGMwLjMtMS4xLDAuNC0yLjIsMC40LTMuM1MyOS45LDEzLjgsMjkuNiwxMi43eiBNMTYsMjRjLTQuNCwwLTgtMy42LTgtOHMzLjYtOCw4LTgNCgkJczgsMy42LDgsOFMyMC40LDI0LDE2LDI0eiIvPg0KPC9nPg0KPC9zdmc+DQo=",
  "name": "OneSatOrdinalsBSV",
  "previewIconUrl": "https://asset-resources.gdevelop.io/public-resources/Icons/Glyphster Pack/Master/SVG/Business and Finance/9ab2ee949a7cf27aaf3e1ffe6f90e753e289614d5ab58eee2386ecc0face81ff_Business and Finance_money_engine_gear.svg",
  "shortDescription": "Adds easy management of 1SatOrdinals and BSV in your GDevelop game.",
  "version": "1.0.0",
  "description": [
    "Allows you to integrate 1SatOrdinals and BSV into your GDevelop game, as well as a few extra utilities, such as signing messages. Here is a full list of functionality:",
    "",
    "- Checking is a wallet has a specific ordinal",
    "- Generating Private Keys",
    "- Converting Private Keys to Public Keys and Addresses",
    "- Converting Public Keys to Addresses",
    "- Getting wallet balance",
    "- Getting token balance",
    "- Sending BSV, Tokens and Ordinals",
    "- Getting BSV's Price in USD",
    "- Getting ordinals",
    "- Signatures",
    "- Getting stuff in collections",
    "- Checking if user has ordinal in collection",
    "- Setting sprites and resources to ordinals",
    "- Marketplace, both everything with an OrdLock and just from specific collections"
  ],
  "tags": [
    "ordinals",
    "nfts",
    "nft",
    "ordinal",
    "token",
    "bsv",
    "bitcoin sv",
    "bitcoin",
    "tokens",
    "bsv20",
    "bsv21"
  ],
  "authorIds": [
    "Vu2ZkG9HyRchkjTdpXr4E3Fux7Q2"
  ],
  "dependencies": [],
  "globalVariables": [],
  "sceneVariables": [
    {
      "name": "MarketFeeAddress",
      "type": "string",
      "value": "0"
    },
    {
      "name": "MarketFeePercent",
      "type": "number",
      "value": 0
    }
  ],
  "eventsFunctions": [
    {
      "async": true,
      "description": "Checks if the specified address has a specific ordinal.",
      "fullName": "Check if address has an ordinal",
      "functionType": "Action",
      "name": "Address_Ordinal_Check_Action",
      "sentence": "Check if _PARAM1_ has _PARAM2_",
      "events": [
        {
          "type": "BuiltinCommonInstructions::JsCode",
          "inlineCode": [
            "const address = eventsFunctionContext.getArgument('address');",
            "const origin = eventsFunctionContext.getArgument('origin');",
            "/** @type {gdjs.Variable} */",
            "const variable = eventsFunctionContext.getArgument('returnvar');",
            "",
            "return new gdjs.PromiseTask(window.ord.checkIfUserHasOrdinal(address, origin).then((result) => {",
            "    variable.setValue(result);",
            "    eventsFunctionContext.task.resolve();",
            "}));"
          ],
          "parameterObjects": "",
          "useStrict": true,
          "eventsSheetExpanded": true
        }
      ],
      "parameters": [
        {
          "description": "Address",
          "name": "address",
          "type": "string"
        },
        {
          "description": "Ordinal origin",
          "name": "origin",
          "type": "string"
        },
        {
          "description": "Variable to store result in",
          "name": "returnvar",
          "type": "variable"
        }
      ],
      "objectGroups": []
    },
    {
      "description": "Generates a private key in the Wallet Import Format.",
      "fullName": "Generate a WIF",
      "functionType": "StringExpression",
      "name": "Generate_WIF",
      "sentence": "Generate a Private Key in WIF Format",
      "events": [
        {
          "type": "BuiltinCommonInstructions::JsCode",
          "inlineCode": "eventsFunctionContext.returnValue = window.ord.generatePrivateKey();",
          "parameterObjects": "",
          "useStrict": true,
          "eventsSheetExpanded": false
        }
      ],
      "expressionType": {
        "type": "string"
      },
      "parameters": [],
      "objectGroups": []
    },
    {
      "description": "Returns a signature, in base64, with the specified private key. Useful for authentication and proving ownership over an address.",
      "fullName": "Create a signature with a private key",
      "functionType": "StringExpression",
      "name": "Create_Signature",
      "sentence": "",
      "events": [
        {
          "type": "BuiltinCommonInstructions::JsCode",
          "inlineCode": [
            "const message = eventsFunctionContext.getArgument('Message');",
            "const privKey = eventsFunctionContext.getArgument('PrivKey');",
            "",
            "eventsFunctionContext.returnValue = window.ord.createSignature(message, privKey);"
          ],
          "parameterObjects": "",
          "useStrict": true,
          "eventsSheetExpanded": false
        }
      ],
      "expressionType": {
        "type": "string"
      },
      "parameters": [
        {
          "description": "Data that you want signed",
          "name": "Message",
          "type": "string"
        },
        {
          "description": "Private Key that will be used to sign the message",
          "name": "PrivKey",
          "type": "string"
        }
      ],
      "objectGroups": []
    },
    {
      "description": "Allows you to verify whether a signature is created by a specific address, given its public key and the message. Returns 1 if true and 0 if false.",
      "fullName": "Verify a signature using a public key",
      "functionType": "Expression",
      "name": "Verify_Signature",
      "sentence": "",
      "events": [
        {
          "type": "BuiltinCommonInstructions::JsCode",
          "inlineCode": [
            "const message = eventsFunctionContext.getArgument('Message');",
            "const pubKey = eventsFunctionContext.getArgument('PublicKey');",
            "const sig = eventsFunctionContext.getArgument('Sig');",
            "",
            "eventsFunctionContext.returnValue = window.ord.verifySignature(message, sig, pubKey);"
          ],
          "parameterObjects": "",
          "useStrict": true,
          "eventsSheetExpanded": false
        }
      ],
      "expressionType": {
        "type": "expression"
      },
      "parameters": [
        {
          "description": "The message used to create the signature",
          "name": "Message",
          "type": "string"
        },
        {
          "description": "Public Key that corresponds to the Private Key that created the signature",
          "name": "PublicKey",
          "type": "string"
        },
        {
          "description": "Signature, in base64",
          "name": "Sig",
          "type": "string"
        }
      ],
      "objectGroups": []
    },
    {
      "description": "Replaces the image contained by a resource by a new one, from an ordinal outpoint. This will update all sprites displaying the resource.",
      "fullName": "Load Ordinal into an image resource",
      "functionType": "Action",
      "name": "Load_Ordinal_Into_Image_Resource_Action",
      "sentence": "Load Ordinal _PARAM1_ into resource _PARAM2_",
      "events": [
        {
          "type": "BuiltinCommonInstructions::JsCode",
          "inlineCode": [
            "runtimeScene",
            "    .getGame()",
            "    .getImageManager()",
            "    .getPIXITexture(eventsFunctionContext.getArgument(\"Resource\"))",
            "    .baseTexture = PIXI.BaseTexture.from(`https://ordfs.network/content/${eventsFunctionContext.getArgument(\"Ordinal\")}`);",
            ""
          ],
          "parameterObjects": "",
          "useStrict": true,
          "eventsSheetExpanded": false
        }
      ],
      "parameters": [
        {
          "description": "The URL to load the new image for the resource from",
          "name": "URL",
          "type": "string"
        },
        {
          "description": "The resource to modify",
          "name": "Resource",
          "type": "imageResource"
        }
      ],
      "objectGroups": []
    },
    {
      "async": true,
      "description": "Checks if an address has any ordinal in a specific collection.",
      "fullName": "Checks if an address has an ordinal in a collection",
      "functionType": "Action",
      "name": "Does_Address_Have_Ord_In_Collection_Action",
      "sentence": "Does _PARAM1_ have an ordinal in _PARAM2_ and return result to _PARAM3_",
      "events": [
        {
          "type": "BuiltinCommonInstructions::JsCode",
          "inlineCode": [
            "const address = eventsFunctionContext.getArgument('Address');",
            "const collection = eventsFunctionContext.getArgument('CollectionID');",
            "/** @type {gdjs.Variable} */",
            "const returnTo = eventsFunctionContext.getArgument('ReturnTo');",
            "",
            "return new gdjs.PromiseTask(window.ord.checkIfAddressHasOrdInCollection(address, collection).then((result) => {",
            "    returnTo.setBoolean(result);",
            "    eventsFunctionContext.task.resolve();",
            "}));"
          ],
          "parameterObjects": "",
          "useStrict": true,
          "eventsSheetExpanded": false
        }
      ],
      "parameters": [
        {
          "description": "Address that you wish to check",
          "name": "Address",
          "type": "string"
        },
        {
          "description": "Collection that you wish to check",
          "name": "CollectionID",
          "type": "string"
        },
        {
          "description": "Variable that you wish to return the result to",
          "name": "ReturnTo",
          "type": "variable"
        }
      ],
      "objectGroups": []
    },
    {
      "async": true,
      "description": "Allows you to get all ordinals in a collection, also allowing you to filter out those on sale. May cause issues with incredibly large collections. Returns the outpoints.",
      "fullName": "Get the ordinals in a collection",
      "functionType": "Action",
      "name": "Get_Ordinals_In_Collection_Action",
      "sentence": "Get _PARAM1_ ordinals in _PARAM2_ and return to _PARAM3_",
      "events": [
        {
          "type": "BuiltinCommonInstructions::JsCode",
          "inlineCode": [
            "const limit = eventsFunctionContext.getArgument('Limit');",
            "const collection = eventsFunctionContext.getArgument('CollectionID');",
            "/** @type {gdjs.Variable} */",
            "const returnTo = eventsFunctionContext.getArgument('ReturnTo');",
            "const offset = eventsFunctionContext.getArgument('Offset');",
            "const itemsOrMarket = eventsFunctionContext.getArgument('GetAll');",
            "",
            "let itemsOrMarketString = 'items';",
            "if (!itemsOrMarket) itemsOrMarketString = 'market';",
            "",
            "return new gdjs.PromiseTask(window.ord.getCollectionOrdinals(collection, limit, offset, itemsOrMarketString).then((outpoints) => {",
            "    returnTo.fromJSObject(outpoints);",
            "    eventsFunctionContext.task.resolve();",
            "}));"
          ],
          "parameterObjects": "",
          "useStrict": true,
          "eventsSheetExpanded": false
        }
      ],
      "parameters": [
        {
          "description": "Maximum amount of ordinal outpoints that can be returned",
          "name": "Limit",
          "type": "expression"
        },
        {
          "description": "The Collection ID of the collection you wish to get ordinals from",
          "name": "CollectionID",
          "type": "string"
        },
        {
          "description": "Array Variable to return outpoints to",
          "name": "ReturnTo",
          "type": "variable"
        },
        {
          "description": "Offset of owned ordinals. Useful for Pageination",
          "name": "Offset",
          "type": "expression"
        },
        {
          "defaultValue": "yes",
          "description": "Get all ordinals (Yes) or just those for sale (No), still limited by the specified limit",
          "name": "GetAll",
          "optional": true,
          "type": "yesorno"
        }
      ],
      "objectGroups": []
    },
    {
      "description": "Loads the specified ordinal into the specified sprite. This will only affect the sprite in question and only until the image in it is changed through its animation or another action, unless you also modify the resource.",
      "fullName": "Load Ordinal into a Sprite",
      "functionType": "Action",
      "name": "Load_Ordinal_Into_Sprite_Action",
      "sentence": "Load _PARAM1_ into _PARAM2_ (and into the corresponding resource: _PARAM3_)",
      "events": [
        {
          "type": "BuiltinCommonInstructions::JsCode",
          "inlineCode": [
            "if (eventsFunctionContext.getArgument(\"ChangeResource\")) {",
            "    const texture = PIXI.BaseTexture.from(`https://ordfs.network/content/${eventsFunctionContext.getArgument(\"Ordinal\")}`);",
            "    for (const obj of objects) obj.getRendererObject().texture.baseTexture = texture;",
            "} else {",
            "    const texture = PIXI.Texture.from(`https://ordfs.network/content/${eventsFunctionContext.getArgument(\"Ordinal\")}`);",
            "    for (const obj of objects) obj.getRendererObject().texture = texture;",
            "}",
            ""
          ],
          "parameterObjects": "Object",
          "useStrict": true,
          "eventsSheetExpanded": false
        }
      ],
      "parameters": [
        {
          "description": "The Ordinal's Outpoint that you wish to load",
          "name": "Ordinal",
          "type": "string"
        },
        {
          "description": "The sprite you wish to modify",
          "name": "Object",
          "supplementaryInformation": "Sprite",
          "type": "objectList"
        },
        {
          "description": "Modify the resource?",
          "longDescription": "If yes, modifies the image contained in the resource of the sprite's current frame instead of just the sprite's displayed image. This makes the changes affect all other sprites that also display this resource, and allows the change to persist after changing animations or the current frame.",
          "name": "ChangeResource",
          "type": "yesorno"
        }
      ],
      "objectGroups": []
    },
    {
      "fullName": "",
      "functionType": "Action",
      "name": "onFirstSceneLoaded",
      "sentence": "",
      "events": [
        {
          "type": "BuiltinCommonInstructions::JsCode",
          "inlineCode": "!function(){\"use strict\";class t{static zeros=[\"\",\"0\",\"00\",\"000\",\"0000\",\"00000\",\"000000\",\"0000000\",\"00000000\",\"000000000\",\"0000000000\",\"00000000000\",\"000000000000\",\"0000000000000\",\"00000000000000\",\"000000000000000\",\"0000000000000000\",\"00000000000000000\",\"000000000000000000\",\"0000000000000000000\",\"00000000000000000000\",\"000000000000000000000\",\"0000000000000000000000\",\"00000000000000000000000\",\"000000000000000000000000\",\"0000000000000000000000000\"];static groupSizes=[0,0,25,16,12,11,10,9,8,8,7,7,7,7,6,6,6,6,6,6,6,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5];static groupBases=[0,0,33554432,43046721,16777216,48828125,60466176,40353607,16777216,43046721,1e7,19487171,35831808,62748517,7529536,11390625,16777216,24137569,34012224,47045881,64e6,4084101,5153632,6436343,7962624,9765625,11881376,14348907,17210368,20511149,243e5,28629151,33554432,39135393,45435424,52521875,60466176];static wordSize=26;negative;words;length;red;static isBN(e){return e instanceof t||null!==e&&\"object\"==typeof e&&e.constructor.wordSize===t.wordSize&&Array.isArray(e.words)}static max(t,e){return t.cmp(e)>0?t:e}static min(t,e){return t.cmp(e)<0?t:e}constructor(t=0,e=10,r=\"be\"){if(this.negative=0,this.words=[],this.length=0,this.red=null,null!==t){if(\"le\"!==e&&\"be\"!==e||(r=e,e=10),\"number\"==typeof t)return void this.initNumber(t,e,r);if(\"object\"==typeof t)return void this.initArray(t,r);\"hex\"===e&&(e=16),this.assert(e===(0|e)&&e>=2&&e<=36);let i=0;(t=t.toString().replace(/\\s+/g,\"\")).startsWith(\"-\")&&(i++,this.negative=1),i<t.length&&(16===e?this.parseHex(t,i,r):(this.parseBase(t,e,i),\"le\"===r&&this.initArray(this.toArray(),r)))}}assert(t,e=\"Assertion failed\"){if(!t)throw new Error(e)}initNumber(t,e,r){return t<0&&(this.negative=1,t=-t),t<67108864?(this.words=[67108863&t],this.length=1):t<4503599627370496?(this.words=[67108863&t,t/67108864&67108863],this.length=2):(this.assert(t<=9007199254740991,\"The number is larger than 2 ^ 53 (unsafe)\"),this.words=[67108863&t,t/67108864&67108863,1],this.length=3),\"le\"!==r||this.initArray(this.toArray(),r),this}initArray(t,e){if(this.assert(\"number\"==typeof t.length,\"The number must have a length\"),t.length<=0)return this.words=[0],this.length=1,this;this.length=Math.ceil(t.length/3),this.words=new Array(this.length);let r,i,s=0;for(;s<this.length;s++)this.words[s]=0;let n=0;if(\"be\"===e)for(s=t.length-1,r=0;s>=0;s-=3)i=t[s]|t[s-1]<<8|t[s-2]<<16,this.words[r]|=i<<n&67108863,this.words[r+1]=i>>>26-n&67108863,n+=24,n>=26&&(n-=26,r++);else if(\"le\"===e)for(s=0,r=0;s<t.length;s+=3)i=t[s]|t[s+1]<<8|t[s+2]<<16,this.words[r]|=i<<n&67108863,this.words[r+1]=i>>>26-n&67108863,n+=24,n>=26&&(n-=26,r++);return this.strip()}parseHex4Bits(t,e){const r=t.charCodeAt(e);if(r>=48&&r<=57)return r-48;if(r>=65&&r<=70)return r-55;if(r>=97&&r<=102)return r-87;throw new Error(\"Invalid character in \"+t)}parseHexByte(t,e,r){let i=this.parseHex4Bits(t,r);return r-1>=e&&(i|=this.parseHex4Bits(t,r-1)<<4),i}parseHex(t,e,r){this.length=Math.ceil((t.length-e)/6),this.words=new Array(this.length).fill(0);let i=0,s=0;const n=r=>{const n=this.parseHexByte(t,e,r)<<i;this.words[s]|=67108863&n,i>=18?(i-=18,s+=1,this.words[s]|=n>>>26):i+=8};if(\"be\"===r)for(let r=t.length-1;r>=e;r-=2)n(r);else{for(let r=(t.length-e)%2==0?e+1:e;r<t.length;r+=2)n(r)}return this.strip()}parseBaseWord(t,e,r,i){let s=0,n=0;const a=Math.min(t.length,r);for(let r=e;r<a;r++){const e=t.charCodeAt(r)-48;s*=i,n=e>=49?e-49+10:e>=17?e-17+10:e,this.assert(e>=0&&n<i,\"Invalid character\"),s+=n}return s}parseBase(t,e,r){this.words=[0],this.length=1;let i=0,s=1;for(;s<=67108863;s*=e)i++;i--,s=s/e|0;const n=t.length-r,a=n%i,o=Math.min(n,n-a)+r;let c=0,h=r;for(;h<o;h+=i)c=this.parseBaseWord(t,h,h+i,e),this.imuln(s),this.words[0]+c<67108864?this.words[0]+=c:this._iaddn(c);if(0!==a){let r=1;for(c=this.parseBaseWord(t,h,t.length,e),h=0;h<a;h++)r*=e;this.imuln(r),this.words[0]+c<67108864?this.words[0]+=c:this._iaddn(c)}return this.strip()}copy(t){t.words=new Array(this.length);for(let e=0;e<this.length;e++)t.words[e]=this.words[e];t.length=this.length,t.negative=this.negative,t.red=this.red}static move(t,e){t.words=e.words,t.length=e.length,t.negative=e.negative,t.red=e.red}clone(){const e=new t;return this.copy(e),e}expand(t){for(;this.length<t;)this.words[this.length++]=0;return this}strip(){for(;this.length>1&&0===this.words[this.length-1];)this.length--;return this.normSign()}normSign(){return 1===this.length&&0===this.words[0]&&(this.negative=0),this}inspect(){return(null!==this.red?\"<BN-R: \":\"<BN: \")+this.toString(16)+\">\"}toString(t=10,e=1){if(16===t||\"hex\"===t)return this.toHexString(e);if(t===(0|t)&&t>=2&&t<=36)return this.toBaseString(t,e);throw new Error(\"Base should be between 2 and 36\")}toHexString(e){let r=\"\",i=0,s=0;for(let e=0;e<this.length;e++){const n=this.words[e],a=(16777215&(n<<i|s)).toString(16);s=n>>>24-i&16777215,i+=2,i>=26&&(i-=26,e--),r=0!==s||e!==this.length-1?t.zeros[6-a.length]+a+r:a+r}if(0!==s&&(r=s.toString(16)+r),0===e&&\"0\"===r)return\"\";for(;r.length%e!=0&&0!==e;)r=\"0\"+r;return 0!==this.negative&&(r=\"-\"+r),r}toBaseString(e,r){const i=t.groupSizes[e],s=t.groupBases[e];let n=\"\",a=this.clone();for(a.negative=0;!a.isZero();){const r=a.modrn(s).toString(e);a=a.idivn(s),n=a.isZero()?r+n:t.zeros[i-r.length]+r+n}for(this.isZero()&&(n=\"0\"+n);n.length%r!=0;)n=\"0\"+n;return 0!==this.negative&&(n=\"-\"+n),n}toNumber(){let t=this.words[0];if(2===this.length)t+=67108864*this.words[1];else if(3===this.length&&1===this.words[2])t+=4503599627370496+67108864*this.words[1];else if(this.length>2)throw new Error(\"Number can only safely store up to 53 bits\");return 0!==this.negative?-t:t}toJSON(){return this.toString(16)}toArrayLikeLE(t,e){let r=0,i=0;for(let e=0,s=0;e<this.length;e++){const n=this.words[e]<<s|i;t[r++]=255&n,r<t.length&&(t[r++]=n>>8&255),r<t.length&&(t[r++]=n>>16&255),6===s?(r<t.length&&(t[r++]=n>>24&255),i=0,s=0):(i=n>>>24,s+=2)}if(r<t.length)for(t[r++]=i;r<t.length;)t[r++]=0}toArrayLikeBE(t,e){let r=t.length-1,i=0;for(let e=0,s=0;e<this.length;e++){const n=this.words[e]<<s|i;t[r--]=255&n,r>=0&&(t[r--]=n>>8&255),r>=0&&(t[r--]=n>>16&255),6===s?(r>=0&&(t[r--]=n>>24&255),i=0,s=0):(i=n>>>24,s+=2)}if(r>=0)for(t[r--]=i;r>=0;)t[r--]=0}toArray(t=\"be\",e){this.strip();const r=this.byteLength(),i=e??Math.max(1,r);this.assert(r<=i,\"byte array longer than desired length\"),this.assert(i>0,\"Requested array length <= 0\");const s=new Array(i);return\"le\"===t?this.toArrayLikeLE(s,r):this.toArrayLikeBE(s,r),s}countWordBits(t){if(\"function\"==typeof Math.clz32)return 32-Math.clz32(t);let e=t,r=0;return e>=4096&&(r+=13,e>>>=13),e>=64&&(r+=7,e>>>=7),e>=8&&(r+=4,e>>>=4),e>=2&&(r+=2,e>>>=2),r+e}zeroWordBits(t){if(0===t)return 26;let e=t,r=0;return 8191&e||(r+=13,e>>>=13),127&e||(r+=7,e>>>=7),15&e||(r+=4,e>>>=4),3&e||(r+=2,e>>>=2),1&e||r++,r}bitLength(){const t=this.words[this.length-1],e=this.countWordBits(t);return 26*(this.length-1)+e}static toBitArray(t){const e=new Array(t.bitLength());for(let r=0;r<e.length;r++){const i=r/26|0,s=r%26;e[r]=t.words[i]>>>s&1}return e}toBitArray(){return t.toBitArray(this)}zeroBits(){if(this.isZero())return 0;let t=0;for(let e=0;e<this.length;e++){const r=this.zeroWordBits(this.words[e]);if(t+=r,26!==r)break}return t}byteLength(){return Math.ceil(this.bitLength()/8)}toTwos(t){return 0!==this.negative?this.abs().inotn(t).iaddn(1):this.clone()}fromTwos(t){return this.testn(t-1)?this.notn(t).iaddn(1).ineg():this.clone()}isNeg(){return 0!==this.negative}neg(){return this.clone().ineg()}ineg(){return this.isZero()||(this.negative^=1),this}iuor(t){for(;this.length<t.length;)this.words[this.length++]=0;for(let e=0;e<t.length;e++)this.words[e]=this.words[e]|t.words[e];return this.strip()}ior(t){return this.assert(!(this.negative|t.negative)),this.iuor(t)}or(t){return this.length>t.length?this.clone().ior(t):t.clone().ior(this)}uor(t){return this.length>t.length?this.clone().iuor(t):t.clone().iuor(this)}iuand(t){const e=Math.min(this.length,t.length);for(let r=0;r<e;r++)this.words[r]=this.words[r]&t.words[r];return this.length=e,this.strip()}iand(t){return this.assert(!(this.negative|t.negative)),this.iuand(t)}and(t){return this.length>t.length?this.clone().iand(t):t.clone().iand(this)}uand(t){return this.length>t.length?this.clone().iuand(t):t.clone().iuand(this)}iuxor(t){if(this.length>t.length)for(let e=0;e<t.length;e++)this.words[e]=this.words[e]^t.words[e];else{for(let e=0;e<this.length;e++)this.words[e]=this.words[e]^t.words[e];for(let e=this.length;e<t.length;e++)this.words[e]=t.words[e];this.length=t.length}return this.strip()}ixor(t){return this.assert(!(this.negative|t.negative),\"Neither number can be negative\"),this.iuxor(t)}xor(t){return this.length>t.length?this.clone().ixor(t):t.clone().ixor(this)}uxor(t){return this.length>t.length?this.clone().iuxor(t):t.clone().iuxor(this)}inotn(t){this.assert(\"number\"==typeof t&&t>=0,\"The width needs to be a number greater than zero\");let e=0|Math.ceil(t/26);const r=t%26;this.expand(e),r>0&&e--;let i=0;for(;i<e;i++)this.words[i]=67108863&~this.words[i];return r>0&&(this.words[i]=~this.words[i]&67108863>>26-r),this.strip()}notn(t){return this.clone().inotn(t)}setn(t,e){this.assert(\"number\"==typeof t&&t>=0);const r=t/26|0,i=t%26;return this.expand(r+1),this.words[r]=1===e||!0===e?this.words[r]|1<<i:this.words[r]&~(1<<i),this.strip()}iadd(t){let e,r,i;if(0!==this.negative&&0===t.negative)return this.negative=0,e=this.isub(t),this.negative^=1,this.normSign();if(0===this.negative&&0!==t.negative)return t.negative=0,e=this.isub(t),t.negative=1,e.normSign();this.length>t.length?(r=this,i=t):(r=t,i=this);let s=0,n=0;for(;n<i.length;n++)e=(0|r.words[n])+(0|i.words[n])+s,this.words[n]=67108863&e,s=e>>>26;for(;0!==s&&n<r.length;n++)e=(0|r.words[n])+s,this.words[n]=67108863&e,s=e>>>26;if(this.length=r.length,0!==s)this.words[this.length]=s,this.length++;else if(r!==this)for(;n<r.length;n++)this.words[n]=r.words[n];return this}add(t){let e;return 0!==t.negative&&0===this.negative?(t.negative=0,e=this.sub(t),t.negative^=1,e):0===t.negative&&0!==this.negative?(this.negative=0,e=t.sub(this),this.negative=1,e):this.length>t.length?this.clone().iadd(t):t.clone().iadd(this)}isub(t){let e;if(0!==t.negative)return t.negative=0,e=this.iadd(t),t.negative=1,e.normSign();if(0!==this.negative)return this.negative=0,this.iadd(t),this.negative=1,this.normSign();const r=this.cmp(t);if(0===r)return this.negative=0,this.length=1,this.words[0]=0,this;let i,s;r>0?(i=this,s=t):(i=t,s=this);let n=0,a=0;for(;a<s.length;a++)e=(0|i.words[a])-(0|s.words[a])+n,n=e>>26,this.words[a]=67108863&e;for(;0!==n&&a<i.length;a++)e=(0|i.words[a])+n,n=e>>26,this.words[a]=67108863&e;if(0===n&&a<i.length&&i!==this)for(;a<i.length;a++)this.words[a]=i.words[a];return this.length=Math.max(this.length,a),i!==this&&(this.negative=1),this.strip()}sub(t){return this.clone().isub(t)}smallMulTo(t,e,r){r.negative=e.negative^t.negative;let i=t.length+e.length|0;r.length=i,i=i-1|0;let s=0|t.words[0],n=0|e.words[0],a=s*n;const o=67108863&a;let c=a/67108864|0;r.words[0]=o;let h=1;for(;h<i;h++){let i=c>>>26,o=67108863&c;const d=Math.min(h,e.length-1);for(let r=Math.max(0,h-t.length+1);r<=d;r++){const c=h-r|0;s=0|t.words[c],n=0|e.words[r],a=s*n+o,i+=a/67108864|0,o=67108863&a}r.words[h]=0|o,c=0|i}return 0!==c?r.words[h]=0|c:r.length--,r.strip()}comb10MulTo(t,e,r){const i=t.words,s=e.words,n=r.words;let a,o,c,h=0;const d=0|i[0],u=8191&d,f=d>>>13,l=0|i[1],b=8191&l,p=l>>>13,g=0|i[2],m=8191&g,w=g>>>13,y=0|i[3],v=8191&y,P=y>>>13,O=0|i[4],E=8191&O,k=O>>>13,_=0|i[5],x=8191&_,I=_>>>13,S=0|i[6],A=8191&S,M=S>>>13,T=0|i[7],N=8191&T,F=T>>>13,B=0|i[8],R=8191&B,U=B>>>13,L=0|i[9],D=8191&L,C=L>>>13,H=0|s[0],q=8191&H,V=H>>>13,$=0|s[1],K=8191&$,j=$>>>13,X=0|s[2],Y=8191&X,z=X>>>13,W=0|s[3],G=8191&W,Z=W>>>13,J=0|s[4],Q=8191&J,tt=J>>>13,et=0|s[5],rt=8191&et,it=et>>>13,st=0|s[6],nt=8191&st,at=st>>>13,ot=0|s[7],ct=8191&ot,ht=ot>>>13,dt=0|s[8],ut=8191&dt,ft=dt>>>13,lt=0|s[9],bt=8191&lt,pt=lt>>>13;r.negative=t.negative^e.negative,r.length=19,a=Math.imul(u,q),o=Math.imul(u,V),o=o+Math.imul(f,q)|0,c=Math.imul(f,V);let gt=(h+a|0)+((8191&o)<<13)|0;h=(c+(o>>>13)|0)+(gt>>>26)|0,gt&=67108863,a=Math.imul(b,q),o=Math.imul(b,V),o=o+Math.imul(p,q)|0,c=Math.imul(p,V),a=a+Math.imul(u,K)|0,o=o+Math.imul(u,j)|0,o=o+Math.imul(f,K)|0,c=c+Math.imul(f,j)|0;let mt=(h+a|0)+((8191&o)<<13)|0;h=(c+(o>>>13)|0)+(mt>>>26)|0,mt&=67108863,a=Math.imul(m,q),o=Math.imul(m,V),o=o+Math.imul(w,q)|0,c=Math.imul(w,V),a=a+Math.imul(b,K)|0,o=o+Math.imul(b,j)|0,o=o+Math.imul(p,K)|0,c=c+Math.imul(p,j)|0,a=a+Math.imul(u,Y)|0,o=o+Math.imul(u,z)|0,o=o+Math.imul(f,Y)|0,c=c+Math.imul(f,z)|0;let wt=(h+a|0)+((8191&o)<<13)|0;h=(c+(o>>>13)|0)+(wt>>>26)|0,wt&=67108863,a=Math.imul(v,q),o=Math.imul(v,V),o=o+Math.imul(P,q)|0,c=Math.imul(P,V),a=a+Math.imul(m,K)|0,o=o+Math.imul(m,j)|0,o=o+Math.imul(w,K)|0,c=c+Math.imul(w,j)|0,a=a+Math.imul(b,Y)|0,o=o+Math.imul(b,z)|0,o=o+Math.imul(p,Y)|0,c=c+Math.imul(p,z)|0,a=a+Math.imul(u,G)|0,o=o+Math.imul(u,Z)|0,o=o+Math.imul(f,G)|0,c=c+Math.imul(f,Z)|0;let yt=(h+a|0)+((8191&o)<<13)|0;h=(c+(o>>>13)|0)+(yt>>>26)|0,yt&=67108863,a=Math.imul(E,q),o=Math.imul(E,V),o=o+Math.imul(k,q)|0,c=Math.imul(k,V),a=a+Math.imul(v,K)|0,o=o+Math.imul(v,j)|0,o=o+Math.imul(P,K)|0,c=c+Math.imul(P,j)|0,a=a+Math.imul(m,Y)|0,o=o+Math.imul(m,z)|0,o=o+Math.imul(w,Y)|0,c=c+Math.imul(w,z)|0,a=a+Math.imul(b,G)|0,o=o+Math.imul(b,Z)|0,o=o+Math.imul(p,G)|0,c=c+Math.imul(p,Z)|0,a=a+Math.imul(u,Q)|0,o=o+Math.imul(u,tt)|0,o=o+Math.imul(f,Q)|0,c=c+Math.imul(f,tt)|0;let vt=(h+a|0)+((8191&o)<<13)|0;h=(c+(o>>>13)|0)+(vt>>>26)|0,vt&=67108863,a=Math.imul(x,q),o=Math.imul(x,V),o=o+Math.imul(I,q)|0,c=Math.imul(I,V),a=a+Math.imul(E,K)|0,o=o+Math.imul(E,j)|0,o=o+Math.imul(k,K)|0,c=c+Math.imul(k,j)|0,a=a+Math.imul(v,Y)|0,o=o+Math.imul(v,z)|0,o=o+Math.imul(P,Y)|0,c=c+Math.imul(P,z)|0,a=a+Math.imul(m,G)|0,o=o+Math.imul(m,Z)|0,o=o+Math.imul(w,G)|0,c=c+Math.imul(w,Z)|0,a=a+Math.imul(b,Q)|0,o=o+Math.imul(b,tt)|0,o=o+Math.imul(p,Q)|0,c=c+Math.imul(p,tt)|0,a=a+Math.imul(u,rt)|0,o=o+Math.imul(u,it)|0,o=o+Math.imul(f,rt)|0,c=c+Math.imul(f,it)|0;let Pt=(h+a|0)+((8191&o)<<13)|0;h=(c+(o>>>13)|0)+(Pt>>>26)|0,Pt&=67108863,a=Math.imul(A,q),o=Math.imul(A,V),o=o+Math.imul(M,q)|0,c=Math.imul(M,V),a=a+Math.imul(x,K)|0,o=o+Math.imul(x,j)|0,o=o+Math.imul(I,K)|0,c=c+Math.imul(I,j)|0,a=a+Math.imul(E,Y)|0,o=o+Math.imul(E,z)|0,o=o+Math.imul(k,Y)|0,c=c+Math.imul(k,z)|0,a=a+Math.imul(v,G)|0,o=o+Math.imul(v,Z)|0,o=o+Math.imul(P,G)|0,c=c+Math.imul(P,Z)|0,a=a+Math.imul(m,Q)|0,o=o+Math.imul(m,tt)|0,o=o+Math.imul(w,Q)|0,c=c+Math.imul(w,tt)|0,a=a+Math.imul(b,rt)|0,o=o+Math.imul(b,it)|0,o=o+Math.imul(p,rt)|0,c=c+Math.imul(p,it)|0,a=a+Math.imul(u,nt)|0,o=o+Math.imul(u,at)|0,o=o+Math.imul(f,nt)|0,c=c+Math.imul(f,at)|0;let Ot=(h+a|0)+((8191&o)<<13)|0;h=(c+(o>>>13)|0)+(Ot>>>26)|0,Ot&=67108863,a=Math.imul(N,q),o=Math.imul(N,V),o=o+Math.imul(F,q)|0,c=Math.imul(F,V),a=a+Math.imul(A,K)|0,o=o+Math.imul(A,j)|0,o=o+Math.imul(M,K)|0,c=c+Math.imul(M,j)|0,a=a+Math.imul(x,Y)|0,o=o+Math.imul(x,z)|0,o=o+Math.imul(I,Y)|0,c=c+Math.imul(I,z)|0,a=a+Math.imul(E,G)|0,o=o+Math.imul(E,Z)|0,o=o+Math.imul(k,G)|0,c=c+Math.imul(k,Z)|0,a=a+Math.imul(v,Q)|0,o=o+Math.imul(v,tt)|0,o=o+Math.imul(P,Q)|0,c=c+Math.imul(P,tt)|0,a=a+Math.imul(m,rt)|0,o=o+Math.imul(m,it)|0,o=o+Math.imul(w,rt)|0,c=c+Math.imul(w,it)|0,a=a+Math.imul(b,nt)|0,o=o+Math.imul(b,at)|0,o=o+Math.imul(p,nt)|0,c=c+Math.imul(p,at)|0,a=a+Math.imul(u,ct)|0,o=o+Math.imul(u,ht)|0,o=o+Math.imul(f,ct)|0,c=c+Math.imul(f,ht)|0;let Et=(h+a|0)+((8191&o)<<13)|0;h=(c+(o>>>13)|0)+(Et>>>26)|0,Et&=67108863,a=Math.imul(R,q),o=Math.imul(R,V),o=o+Math.imul(U,q)|0,c=Math.imul(U,V),a=a+Math.imul(N,K)|0,o=o+Math.imul(N,j)|0,o=o+Math.imul(F,K)|0,c=c+Math.imul(F,j)|0,a=a+Math.imul(A,Y)|0,o=o+Math.imul(A,z)|0,o=o+Math.imul(M,Y)|0,c=c+Math.imul(M,z)|0,a=a+Math.imul(x,G)|0,o=o+Math.imul(x,Z)|0,o=o+Math.imul(I,G)|0,c=c+Math.imul(I,Z)|0,a=a+Math.imul(E,Q)|0,o=o+Math.imul(E,tt)|0,o=o+Math.imul(k,Q)|0,c=c+Math.imul(k,tt)|0,a=a+Math.imul(v,rt)|0,o=o+Math.imul(v,it)|0,o=o+Math.imul(P,rt)|0,c=c+Math.imul(P,it)|0,a=a+Math.imul(m,nt)|0,o=o+Math.imul(m,at)|0,o=o+Math.imul(w,nt)|0,c=c+Math.imul(w,at)|0,a=a+Math.imul(b,ct)|0,o=o+Math.imul(b,ht)|0,o=o+Math.imul(p,ct)|0,c=c+Math.imul(p,ht)|0,a=a+Math.imul(u,ut)|0,o=o+Math.imul(u,ft)|0,o=o+Math.imul(f,ut)|0,c=c+Math.imul(f,ft)|0;let kt=(h+a|0)+((8191&o)<<13)|0;h=(c+(o>>>13)|0)+(kt>>>26)|0,kt&=67108863,a=Math.imul(D,q),o=Math.imul(D,V),o=o+Math.imul(C,q)|0,c=Math.imul(C,V),a=a+Math.imul(R,K)|0,o=o+Math.imul(R,j)|0,o=o+Math.imul(U,K)|0,c=c+Math.imul(U,j)|0,a=a+Math.imul(N,Y)|0,o=o+Math.imul(N,z)|0,o=o+Math.imul(F,Y)|0,c=c+Math.imul(F,z)|0,a=a+Math.imul(A,G)|0,o=o+Math.imul(A,Z)|0,o=o+Math.imul(M,G)|0,c=c+Math.imul(M,Z)|0,a=a+Math.imul(x,Q)|0,o=o+Math.imul(x,tt)|0,o=o+Math.imul(I,Q)|0,c=c+Math.imul(I,tt)|0,a=a+Math.imul(E,rt)|0,o=o+Math.imul(E,it)|0,o=o+Math.imul(k,rt)|0,c=c+Math.imul(k,it)|0,a=a+Math.imul(v,nt)|0,o=o+Math.imul(v,at)|0,o=o+Math.imul(P,nt)|0,c=c+Math.imul(P,at)|0,a=a+Math.imul(m,ct)|0,o=o+Math.imul(m,ht)|0,o=o+Math.imul(w,ct)|0,c=c+Math.imul(w,ht)|0,a=a+Math.imul(b,ut)|0,o=o+Math.imul(b,ft)|0,o=o+Math.imul(p,ut)|0,c=c+Math.imul(p,ft)|0,a=a+Math.imul(u,bt)|0,o=o+Math.imul(u,pt)|0,o=o+Math.imul(f,bt)|0,c=c+Math.imul(f,pt)|0;let _t=(h+a|0)+((8191&o)<<13)|0;h=(c+(o>>>13)|0)+(_t>>>26)|0,_t&=67108863,a=Math.imul(D,K),o=Math.imul(D,j),o=o+Math.imul(C,K)|0,c=Math.imul(C,j),a=a+Math.imul(R,Y)|0,o=o+Math.imul(R,z)|0,o=o+Math.imul(U,Y)|0,c=c+Math.imul(U,z)|0,a=a+Math.imul(N,G)|0,o=o+Math.imul(N,Z)|0,o=o+Math.imul(F,G)|0,c=c+Math.imul(F,Z)|0,a=a+Math.imul(A,Q)|0,o=o+Math.imul(A,tt)|0,o=o+Math.imul(M,Q)|0,c=c+Math.imul(M,tt)|0,a=a+Math.imul(x,rt)|0,o=o+Math.imul(x,it)|0,o=o+Math.imul(I,rt)|0,c=c+Math.imul(I,it)|0,a=a+Math.imul(E,nt)|0,o=o+Math.imul(E,at)|0,o=o+Math.imul(k,nt)|0,c=c+Math.imul(k,at)|0,a=a+Math.imul(v,ct)|0,o=o+Math.imul(v,ht)|0,o=o+Math.imul(P,ct)|0,c=c+Math.imul(P,ht)|0,a=a+Math.imul(m,ut)|0,o=o+Math.imul(m,ft)|0,o=o+Math.imul(w,ut)|0,c=c+Math.imul(w,ft)|0,a=a+Math.imul(b,bt)|0,o=o+Math.imul(b,pt)|0,o=o+Math.imul(p,bt)|0,c=c+Math.imul(p,pt)|0;let xt=(h+a|0)+((8191&o)<<13)|0;h=(c+(o>>>13)|0)+(xt>>>26)|0,xt&=67108863,a=Math.imul(D,Y),o=Math.imul(D,z),o=o+Math.imul(C,Y)|0,c=Math.imul(C,z),a=a+Math.imul(R,G)|0,o=o+Math.imul(R,Z)|0,o=o+Math.imul(U,G)|0,c=c+Math.imul(U,Z)|0,a=a+Math.imul(N,Q)|0,o=o+Math.imul(N,tt)|0,o=o+Math.imul(F,Q)|0,c=c+Math.imul(F,tt)|0,a=a+Math.imul(A,rt)|0,o=o+Math.imul(A,it)|0,o=o+Math.imul(M,rt)|0,c=c+Math.imul(M,it)|0,a=a+Math.imul(x,nt)|0,o=o+Math.imul(x,at)|0,o=o+Math.imul(I,nt)|0,c=c+Math.imul(I,at)|0,a=a+Math.imul(E,ct)|0,o=o+Math.imul(E,ht)|0,o=o+Math.imul(k,ct)|0,c=c+Math.imul(k,ht)|0,a=a+Math.imul(v,ut)|0,o=o+Math.imul(v,ft)|0,o=o+Math.imul(P,ut)|0,c=c+Math.imul(P,ft)|0,a=a+Math.imul(m,bt)|0,o=o+Math.imul(m,pt)|0,o=o+Math.imul(w,bt)|0,c=c+Math.imul(w,pt)|0;let It=(h+a|0)+((8191&o)<<13)|0;h=(c+(o>>>13)|0)+(It>>>26)|0,It&=67108863,a=Math.imul(D,G),o=Math.imul(D,Z),o=o+Math.imul(C,G)|0,c=Math.imul(C,Z),a=a+Math.imul(R,Q)|0,o=o+Math.imul(R,tt)|0,o=o+Math.imul(U,Q)|0,c=c+Math.imul(U,tt)|0,a=a+Math.imul(N,rt)|0,o=o+Math.imul(N,it)|0,o=o+Math.imul(F,rt)|0,c=c+Math.imul(F,it)|0,a=a+Math.imul(A,nt)|0,o=o+Math.imul(A,at)|0,o=o+Math.imul(M,nt)|0,c=c+Math.imul(M,at)|0,a=a+Math.imul(x,ct)|0,o=o+Math.imul(x,ht)|0,o=o+Math.imul(I,ct)|0,c=c+Math.imul(I,ht)|0,a=a+Math.imul(E,ut)|0,o=o+Math.imul(E,ft)|0,o=o+Math.imul(k,ut)|0,c=c+Math.imul(k,ft)|0,a=a+Math.imul(v,bt)|0,o=o+Math.imul(v,pt)|0,o=o+Math.imul(P,bt)|0,c=c+Math.imul(P,pt)|0;let St=(h+a|0)+((8191&o)<<13)|0;h=(c+(o>>>13)|0)+(St>>>26)|0,St&=67108863,a=Math.imul(D,Q),o=Math.imul(D,tt),o=o+Math.imul(C,Q)|0,c=Math.imul(C,tt),a=a+Math.imul(R,rt)|0,o=o+Math.imul(R,it)|0,o=o+Math.imul(U,rt)|0,c=c+Math.imul(U,it)|0,a=a+Math.imul(N,nt)|0,o=o+Math.imul(N,at)|0,o=o+Math.imul(F,nt)|0,c=c+Math.imul(F,at)|0,a=a+Math.imul(A,ct)|0,o=o+Math.imul(A,ht)|0,o=o+Math.imul(M,ct)|0,c=c+Math.imul(M,ht)|0,a=a+Math.imul(x,ut)|0,o=o+Math.imul(x,ft)|0,o=o+Math.imul(I,ut)|0,c=c+Math.imul(I,ft)|0,a=a+Math.imul(E,bt)|0,o=o+Math.imul(E,pt)|0,o=o+Math.imul(k,bt)|0,c=c+Math.imul(k,pt)|0;let At=(h+a|0)+((8191&o)<<13)|0;h=(c+(o>>>13)|0)+(At>>>26)|0,At&=67108863,a=Math.imul(D,rt),o=Math.imul(D,it),o=o+Math.imul(C,rt)|0,c=Math.imul(C,it),a=a+Math.imul(R,nt)|0,o=o+Math.imul(R,at)|0,o=o+Math.imul(U,nt)|0,c=c+Math.imul(U,at)|0,a=a+Math.imul(N,ct)|0,o=o+Math.imul(N,ht)|0,o=o+Math.imul(F,ct)|0,c=c+Math.imul(F,ht)|0,a=a+Math.imul(A,ut)|0,o=o+Math.imul(A,ft)|0,o=o+Math.imul(M,ut)|0,c=c+Math.imul(M,ft)|0,a=a+Math.imul(x,bt)|0,o=o+Math.imul(x,pt)|0,o=o+Math.imul(I,bt)|0,c=c+Math.imul(I,pt)|0;let Mt=(h+a|0)+((8191&o)<<13)|0;h=(c+(o>>>13)|0)+(Mt>>>26)|0,Mt&=67108863,a=Math.imul(D,nt),o=Math.imul(D,at),o=o+Math.imul(C,nt)|0,c=Math.imul(C,at),a=a+Math.imul(R,ct)|0,o=o+Math.imul(R,ht)|0,o=o+Math.imul(U,ct)|0,c=c+Math.imul(U,ht)|0,a=a+Math.imul(N,ut)|0,o=o+Math.imul(N,ft)|0,o=o+Math.imul(F,ut)|0,c=c+Math.imul(F,ft)|0,a=a+Math.imul(A,bt)|0,o=o+Math.imul(A,pt)|0,o=o+Math.imul(M,bt)|0,c=c+Math.imul(M,pt)|0;let Tt=(h+a|0)+((8191&o)<<13)|0;h=(c+(o>>>13)|0)+(Tt>>>26)|0,Tt&=67108863,a=Math.imul(D,ct),o=Math.imul(D,ht),o=o+Math.imul(C,ct)|0,c=Math.imul(C,ht),a=a+Math.imul(R,ut)|0,o=o+Math.imul(R,ft)|0,o=o+Math.imul(U,ut)|0,c=c+Math.imul(U,ft)|0,a=a+Math.imul(N,bt)|0,o=o+Math.imul(N,pt)|0,o=o+Math.imul(F,bt)|0,c=c+Math.imul(F,pt)|0;let Nt=(h+a|0)+((8191&o)<<13)|0;h=(c+(o>>>13)|0)+(Nt>>>26)|0,Nt&=67108863,a=Math.imul(D,ut),o=Math.imul(D,ft),o=o+Math.imul(C,ut)|0,c=Math.imul(C,ft),a=a+Math.imul(R,bt)|0,o=o+Math.imul(R,pt)|0,o=o+Math.imul(U,bt)|0,c=c+Math.imul(U,pt)|0;let Ft=(h+a|0)+((8191&o)<<13)|0;h=(c+(o>>>13)|0)+(Ft>>>26)|0,Ft&=67108863,a=Math.imul(D,bt),o=Math.imul(D,pt),o=o+Math.imul(C,bt)|0,c=Math.imul(C,pt);let Bt=(h+a|0)+((8191&o)<<13)|0;return h=(c+(o>>>13)|0)+(Bt>>>26)|0,Bt&=67108863,n[0]=gt,n[1]=mt,n[2]=wt,n[3]=yt,n[4]=vt,n[5]=Pt,n[6]=Ot,n[7]=Et,n[8]=kt,n[9]=_t,n[10]=xt,n[11]=It,n[12]=St,n[13]=At,n[14]=Mt,n[15]=Tt,n[16]=Nt,n[17]=Ft,n[18]=Bt,0!==h&&(n[19]=h,r.length++),r}bigMulTo(t,e,r){r.negative=e.negative^t.negative,r.length=t.length+e.length;let i=0,s=0,n=0;for(;n<r.length-1;n++){let a=s;s=0;let o=67108863&i;const c=Math.min(n,e.length-1);for(let r=Math.max(0,n-t.length+1);r<=c;r++){const i=n-r,c=(0|t.words[i])*(0|e.words[r]);let h=67108863&c;a=a+(c/67108864|0)|0,h=h+o|0,o=67108863&h,a=a+(h>>>26)|0,s+=a>>>26,a&=67108863}r.words[n]=o,i=a,a=s}return 0!==i?r.words[n]=i:r.length--,r.strip()}mulTo(t,e){let r;const i=this.length+t.length;return r=10===this.length&&10===t.length?this.comb10MulTo(this,t,e):i<63?this.smallMulTo(this,t,e):this.bigMulTo(this,t,e),r}mul(e){const r=new t;return r.words=new Array(this.length+e.length),this.mulTo(e,r)}imul(t){return this.clone().mulTo(t,this)}imuln(t){const e=t<0;e&&(t=-t),this.assert(\"number\"==typeof t),this.assert(t<67108864);let r=0,i=0;for(;i<this.length;i++){const e=(0|this.words[i])*t,s=(67108863&e)+(67108863&r);r>>=26,r+=e/67108864|0,r+=s>>>26,this.words[i]=67108863&s}return 0!==r&&(this.words[i]=r,this.length++),e?this.ineg():this}muln(t){return this.clone().imuln(t)}sqr(){return this.mul(this)}isqr(){return this.imul(this.clone())}pow(e){const r=t.toBitArray(e);if(0===r.length)return new t(1);let i=this,s=0;for(;s<r.length&&0===r[s];s++,i=i.sqr());if(++s<r.length)for(let t=i.sqr();s<r.length;s++,t=t.sqr())0!==r[s]&&(i=i.mul(t));return i}iushln(t){this.assert(\"number\"==typeof t&&t>=0);const e=t%26,r=(t-e)/26,i=67108863>>>26-e<<26-e;let s;if(0!==e){let t=0;for(s=0;s<this.length;s++){const r=this.words[s]&i,n=(0|this.words[s])-r<<e;this.words[s]=n|t,t=r>>>26-e}0!==t&&(this.words[s]=t,this.length++)}if(0!==r){for(s=this.length-1;s>=0;s--)this.words[s+r]=this.words[s];for(s=0;s<r;s++)this.words[s]=0;this.length+=r}return this.strip()}ishln(t){return this.assert(0===this.negative),this.iushln(t)}iushrn(t,e,r){let i;this.assert(\"number\"==typeof t&&t>=0),i=\"number\"==typeof e&&0!==e?(e-e%26)/26:0;const s=t%26,n=Math.min((t-s)/26,this.length),a=67108863^67108863>>>s<<s,o=r;i-=n,i=Math.max(0,i);let c=0;if(void 0!==o){for(;c<n;c++)o.words[c]=this.words[c];o.length=n}if(0===n);else if(this.length>n)for(this.length-=n,c=0;c<this.length;c++)this.words[c]=this.words[c+n];else this.words[0]=0,this.length=1;let h=0;for(c=this.length-1;c>=0&&(0!==h||c>=i);c--){const t=0|this.words[c];this.words[c]=h<<26-s|t>>>s,h=t&a}return null!=o&&0!==h&&(o.words[o.length++]=h),0===this.length&&(this.words[0]=0,this.length=1),this.strip()}ishrn(t,e,r){return this.assert(0===this.negative),this.iushrn(t,e,r)}shln(t){return this.clone().ishln(t)}ushln(t){return this.clone().iushln(t)}shrn(t){return this.clone().ishrn(t)}ushrn(t){return this.clone().iushrn(t)}testn(t){this.assert(\"number\"==typeof t&&t>=0);const e=t%26,r=(t-e)/26,i=1<<e;if(this.length<=r)return!1;const s=this.words[r];return Boolean(s&i)}imaskn(t){this.assert(\"number\"==typeof t&&t>=0);const e=t%26;let r=(t-e)/26;if(this.assert(0===this.negative,\"imaskn works only with positive numbers\"),this.length<=r)return this;if(0!==e&&r++,this.length=Math.min(r,this.length),0!==e){const t=67108863^67108863>>>e<<e;this.words[this.length-1]&=t}return this.strip()}maskn(t){return this.clone().imaskn(t)}iaddn(t){return this.assert(\"number\"==typeof t),this.assert(t<67108864,\"num is too large\"),t<0?this.isubn(-t):0!==this.negative?1===this.length&&(0|this.words[0])<=t?(this.words[0]=t-(0|this.words[0]),this.negative=0,this):(this.negative=0,this.isubn(t),this.negative=1,this):this._iaddn(t)}_iaddn(t){this.words[0]+=t;let e=0;for(;e<this.length&&this.words[e]>=67108864;e++)this.words[e]-=67108864,e===this.length-1?this.words[e+1]=1:this.words[e+1]++;return this.length=Math.max(this.length,e+1),this}isubn(t){if(this.assert(\"number\"==typeof t),this.assert(t<67108864),t<0)return this.iaddn(-t);if(0!==this.negative)return this.negative=0,this.iaddn(t),this.negative=1,this;if(this.words[0]-=t,1===this.length&&this.words[0]<0)this.words[0]=-this.words[0],this.negative=1;else for(let t=0;t<this.length&&this.words[t]<0;t++)this.words[t]+=67108864,this.words[t+1]-=1;return this.strip()}addn(t){return this.clone().iaddn(t)}subn(t){return this.clone().isubn(t)}iabs(){return this.negative=0,this}abs(){return this.clone().iabs()}_ishlnsubmul(t,e,r){const i=t.length+r;let s,n;this.expand(i);let a=0;for(s=0;s<t.length;s++){n=(0|this.words[s+r])+a;const i=(0|t.words[s])*e;n-=67108863&i,a=(n>>26)-(i/67108864|0),this.words[s+r]=67108863&n}for(;s<this.length-r;s++)n=(0|this.words[s+r])+a,a=n>>26,this.words[s+r]=67108863&n;if(0===a)return this.strip();for(this.assert(-1===a,\"carry must be -1\"),a=0,s=0;s<this.length;s++)n=-(0|this.words[s])+a,a=n>>26,this.words[s]=67108863&n;return this.negative=1,this.strip()}wordDiv(e,r){let i=this.length-e.length,s=this.clone(),n=e,a=0|n.words[n.length-1];i=26-this.countWordBits(a),0!==i&&(n=n.ushln(i),s.iushln(i),a=0|n.words[n.length-1]);const o=s.length-n.length;let c;if(\"mod\"!==r){c=new t,c.length=o+1,c.words=new Array(c.length);for(let t=0;t<c.length;t++)c.words[t]=0}const h=s.clone()._ishlnsubmul(n,1,o);0===h.negative&&(s=h,void 0!==c&&(c.words[o]=1));for(let t=o-1;t>=0;t--){let e=67108864*(0|s.words[n.length+t])+(0|s.words[n.length+t-1]);for(e=Math.min(e/a|0,67108863),s._ishlnsubmul(n,e,t);0!==s.negative;)e--,s.negative=0,s._ishlnsubmul(n,1,t),s.isZero()||(s.negative^=1);void 0!==c&&(c.words[t]=e)}return void 0!==c&&c.strip(),s.strip(),\"div\"!==r&&0!==i&&s.iushrn(i),{div:c??null,mod:s}}divmod(e,r,i){if(this.assert(!e.isZero()),this.isZero())return{div:new t(0),mod:new t(0)};let s,n,a;return 0!==this.negative&&0===e.negative?(a=this.neg().divmod(e,r),\"mod\"!==r&&(s=a.div.neg()),\"div\"!==r&&(n=a.mod.neg(),!0===i&&0!==n.negative&&n.iadd(e)),{div:s,mod:n}):0===this.negative&&0!==e.negative?(a=this.divmod(e.neg(),r),\"mod\"!==r&&(s=a.div.neg()),{div:s,mod:a.mod}):this.negative&e.negative?(a=this.neg().divmod(e.neg(),r),\"div\"!==r&&(n=a.mod.neg(),!0===i&&0!==n.negative&&n.isub(e)),{div:a.div,mod:n}):e.length>this.length||this.cmp(e)<0?{div:new t(0),mod:this}:1===e.length?\"div\"===r?{div:this.divn(e.words[0]),mod:null}:\"mod\"===r?{div:null,mod:new t(this.modrn(e.words[0]))}:{div:this.divn(e.words[0]),mod:new t(this.modrn(e.words[0]))}:this.wordDiv(e,r)}div(t){return this.divmod(t,\"div\",!1).div}mod(t){return this.divmod(t,\"mod\",!1).mod}umod(t){return this.divmod(t,\"mod\",!0).mod}divRound(t){const e=this.divmod(t);if(e.mod.isZero())return e.div;const r=0!==e.div.negative?e.mod.isub(t):e.mod,i=t.ushrn(1),s=t.andln(1),n=r.cmp(i);return n<0||1===s&&0===n?e.div:0!==e.div.negative?e.div.isubn(1):e.div.iaddn(1)}modrn(t){const e=t<0;e&&(t=-t),this.assert(t<=67108863);const r=(1<<26)%t;let i=0;for(let e=this.length-1;e>=0;e--)i=(r*i+(0|this.words[e]))%t;return e?-i:i}idivn(t){const e=t<0;e&&(t=-t),this.assert(t<=67108863);let r=0;for(let e=this.length-1;e>=0;e--){const i=(0|this.words[e])+67108864*r;this.words[e]=i/t|0,r=i%t}return this.strip(),e?this.ineg():this}divn(t){return this.clone().idivn(t)}egcd(e){this.assert(0===e.negative,\"p must not be negative\"),this.assert(!e.isZero(),\"p must not be zero\");let r=this;const i=e.clone();r=0!==r.negative?r.umod(e):r.clone();const s=new t(1),n=new t(0),a=new t(0),o=new t(1);let c=0;for(;r.isEven()&&i.isEven();)r.iushrn(1),i.iushrn(1),++c;const h=i.clone(),d=r.clone();for(;!r.isZero();){let t=0,e=1;for(;!(r.words[0]&e)&&t<26;++t,e<<=1);if(t>0)for(r.iushrn(t);t-- >0;)(s.isOdd()||n.isOdd())&&(s.iadd(h),n.isub(d)),s.iushrn(1),n.iushrn(1);let c=0,u=1;for(;!(i.words[0]&u)&&c<26;++c,u<<=1);if(c>0)for(i.iushrn(c);c-- >0;)(a.isOdd()||o.isOdd())&&(a.iadd(h),o.isub(d)),a.iushrn(1),o.iushrn(1);r.cmp(i)>=0?(r.isub(i),s.isub(a),n.isub(o)):(i.isub(r),a.isub(s),o.isub(n))}return{a:a,b:o,gcd:i.iushln(c)}}_invmp(e){this.assert(0===e.negative,\"p must not be negative\"),this.assert(!e.isZero(),\"p must not be zero\");let r=this;const i=e.clone();r=0!==r.negative?r.umod(e):r.clone();const s=new t(1),n=new t(0),a=i.clone();for(;r.cmpn(1)>0&&i.cmpn(1)>0;){let t=0,e=1;for(;!(r.words[0]&e)&&t<26;++t,e<<=1);if(t>0)for(r.iushrn(t);t-- >0;)s.isOdd()&&s.iadd(a),s.iushrn(1);let o=0,c=1;for(;!(i.words[0]&c)&&o<26;++o,c<<=1);if(o>0)for(i.iushrn(o);o-- >0;)n.isOdd()&&n.iadd(a),n.iushrn(1);r.cmp(i)>=0?(r.isub(i),s.isub(n)):(i.isub(r),n.isub(s))}let o;return o=0===r.cmpn(1)?s:n,o.cmpn(0)<0&&o.iadd(e),o}gcd(t){if(this.isZero())return t.abs();if(t.isZero())return this.abs();let e=this.clone(),r=t.clone();e.negative=0,r.negative=0;let i=0;for(;e.isEven()&&r.isEven();i++)e.iushrn(1),r.iushrn(1);for(;;){for(;e.isEven();)e.iushrn(1);for(;r.isEven();)r.iushrn(1);const t=e.cmp(r);if(t<0){const t=e;e=r,r=t}else if(0===t||0===r.cmpn(1))break;e.isub(r)}return r.iushln(i)}invm(t){return this.egcd(t).a.umod(t)}isEven(){return!(1&this.words[0])}isOdd(){return!(1&~this.words[0])}andln(t){return this.words[0]&t}bincn(t){this.assert(\"number\"==typeof t);const e=t%26,r=(t-e)/26,i=1<<e;if(this.length<=r)return this.expand(r+1),this.words[r]|=i,this;let s=i,n=r;for(;0!==s&&n<this.length;n++){let t=0|this.words[n];t+=s,s=t>>>26,t&=67108863,this.words[n]=t}return 0!==s&&(this.words[n]=s,this.length++),this}isZero(){return 1===this.length&&0===this.words[0]}cmpn(t){const e=t<0;if(0!==this.negative&&!e)return-1;if(0===this.negative&&e)return 1;let r;if(this.strip(),this.length>1)r=1;else{e&&(t=-t),this.assert(t<=67108863,\"Number is too big\");const i=0|this.words[0];r=i===t?0:i<t?-1:1}return 0!==this.negative?0|-r:r}cmp(t){if(0!==this.negative&&0===t.negative)return-1;if(0===this.negative&&0!==t.negative)return 1;const e=this.ucmp(t);return 0!==this.negative?0|-e:e}ucmp(t){if(this.length>t.length)return 1;if(this.length<t.length)return-1;let e=0;for(let r=this.length-1;r>=0;r--){const i=0|this.words[r],s=0|t.words[r];if(i!==s){i<s?e=-1:i>s&&(e=1);break}}return e}gtn(t){return 1===this.cmpn(t)}gt(t){return 1===this.cmp(t)}gten(t){return this.cmpn(t)>=0}gte(t){return this.cmp(t)>=0}ltn(t){return-1===this.cmpn(t)}lt(t){return-1===this.cmp(t)}lten(t){return this.cmpn(t)<=0}lte(t){return this.cmp(t)<=0}eqn(t){return 0===this.cmpn(t)}eq(t){return 0===this.cmp(t)}toRed(t){return this.assert(null==this.red,\"Already a number in reduction context\"),this.assert(0===this.negative,\"red works only with positives\"),t.convertTo(this).forceRed(t)}fromRed(){return this.assert(this.red,\"fromRed works only with numbers in reduction context\"),this.red.convertFrom(this)}forceRed(t){return this.red=t,this}redAdd(t){return this.assert(this.red,\"redAdd works only with red numbers\"),this.red.add(this,t)}redIAdd(t){return this.assert(this.red,\"redIAdd works only with red numbers\"),this.red.iadd(this,t)}redSub(t){return this.assert(this.red,\"redSub works only with red numbers\"),this.red.sub(this,t)}redISub(t){return this.assert(this.red,\"redISub works only with red numbers\"),this.red.isub(this,t)}redShl(t){return this.assert(this.red,\"redShl works only with red numbers\"),this.red.shl(this,t)}redMul(t){return this.assert(this.red,\"redMul works only with red numbers\"),this.red.verify2(this,t),this.red.mul(this,t)}redIMul(t){return this.assert(this.red,\"redMul works only with red numbers\"),this.red.verify2(this,t),this.red.imul(this,t)}redSqr(){return this.assert(this.red,\"redSqr works only with red numbers\"),this.red.verify1(this),this.red.sqr(this)}redISqr(){return this.assert(this.red,\"redISqr works only with red numbers\"),this.red.verify1(this),this.red.isqr(this)}redSqrt(){return this.assert(this.red,\"redSqrt works only with red numbers\"),this.red.verify1(this),this.red.sqrt(this)}redInvm(){return this.assert(this.red,\"redInvm works only with red numbers\"),this.red.verify1(this),this.red.invm(this)}redNeg(){return this.assert(this.red,\"redNeg works only with red numbers\"),this.red.verify1(this),this.red.neg(this)}redPow(t){return this.assert(null!=this.red&&null==t.red,\"redPow(normalNum)\"),this.red.verify1(this),this.red.pow(this,t)}static fromHex(e,r){return\"big\"===r?new t(e,16):new t(e,16,\"le\")}toHex(t=0){return this.toString(\"hex\",2*t)}static fromJSON(e){return new t(e)}static fromNumber(e){return new t(e)}static fromString(e,r){return new t(e,r)}static fromSm(e,r=\"big\"){let i=e;return 0===e.length?new t(0):(\"little\"===r&&(i=[...i],i=i.reverse()),128&i[0]?(i=[...i],i[0]=127&i[0],new t(i).neg()):new t(i))}toSm(t=\"big\"){let e;return-1===this.cmpn(0)?(e=this.neg().toArray(),128&e[0]?e=[128,...e]:e[0]=128|e[0]):(e=this.toArray(),128&e[0]&&(e=[0,...e])),1===e.length&&0===e[0]&&(e=[]),\"little\"===t&&(e=e.reverse()),e}static fromBits(e,r=!1){if(e=2147483648&e?e-4294967296:e,r&&8388608&e)throw new Error(\"negative bit set\");const i=e>>24,s=8388607&e;let n=[s>>24&255,s>>16&255,s>>8&255,255&s];if(i<=3)n=n.slice(1,1+i);else for(let t=0;t<i-3;t++)n.push(0);return 8388608&e?new t(n).neg():new t(n)}toBits(){let t;for(t=this.ltn(0)?this.neg().toArray(\"be\"):this.toArray(\"be\");t.length<4;)t.unshift(0);if(t.every((t=>0===t)))return 0;for(;0===t[0];)t.shift();let e=t.length,r=t.slice(0,3).reduce(((t,e)=>256*t+e),0);8388608&r&&(t.unshift(0),e+=1,r>>>=8);let i=e<<24|r;return this.ltn(0)&&(i|=8388608),i>>>0}static fromScriptNum(e,r,i){if(void 0===i&&(i=Number.MAX_SAFE_INTEGER),e.length>i)throw new Error(\"script number overflow\");if(!0===r&&e.length>0&&!(127&e[e.length-1]||!(e.length<=1)&&128&e[e.length-2]))throw new Error(\"non-minimally encoded script number\");return t.fromSm(e,\"little\")}toScriptNum(){return this.toSm(\"little\")}}class e{name;p;k;n;tmp;constructor(e,r){this.name=e,this.p=new t(r,16),this.n=this.p.bitLength(),this.k=new t(1).iushln(this.n).isub(this.p),this.tmp=this._tmp()}_tmp(){const e=new t;return e.words=new Array(Math.ceil(this.n/13)),e}ireduce(t){let e,r=t;do{this.split(r,this.tmp),r=this.imulK(r),r=r.iadd(this.tmp),e=r.bitLength()}while(e>this.n);const i=e<this.n?-1:r.ucmp(this.p);return 0===i?(r.words[0]=0,r.length=1):i>0?r.isub(this.p):(r.strip,r.strip()),r}split(t,e){t.iushrn(this.n,0,e)}imulK(t){return t.imul(this.k)}}class r extends e{constructor(){super(\"k256\",\"ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f\")}split(t,e){const r=4194303,i=Math.min(t.length,9);let s=0;for(;s<i;s++)e.words[s]=t.words[s];if(e.length=i,t.length<=9)return t.words[0]=0,void(t.length=1);let n=t.words[9];for(e.words[e.length++]=n&r,s=10;s<t.length;s++){const e=0|t.words[s];t.words[s-10]=(e&r)<<4|n>>>22,n=e}n>>>=22,t.words[s-10]=n,0===n&&t.length>10?t.length-=10:t.length-=9}imulK(t){t.words[t.length]=0,t.words[t.length+1]=0,t.length+=2;let e=0;for(let r=0;r<t.length;r++){const i=0|t.words[r];e+=977*i,t.words[r]=67108863&e,e=64*i+(e/67108864|0)}return 0===t.words[t.length-1]&&(t.length--,0===t.words[t.length-1]&&t.length--),t}}class i{prime;m;constructor(t){if(\"k256\"===t){const t=new r;this.m=t.p,this.prime=t}else this.assert(t.gtn(1),\"modulus must be greater than 1\"),this.m=t,this.prime=null}assert(t,e=\"Assertion failed\"){if(!t)throw new Error(e)}verify1(t){this.assert(0===t.negative,\"red works only with positives\"),this.assert(t.red,\"red works only with red numbers\")}verify2(t,e){this.assert(!(t.negative|e.negative),\"red works only with positives\"),this.assert(null!=t.red&&t.red===e.red,\"red works only with red numbers\")}imod(e){return null!=this.prime?this.prime.ireduce(e).forceRed(this):(t.move(e,e.umod(this.m).forceRed(this)),e)}neg(t){return t.isZero()?t.clone():this.m.sub(t).forceRed(this)}add(t,e){this.verify2(t,e);const r=t.add(e);return r.cmp(this.m)>=0&&r.isub(this.m),r.forceRed(this)}iadd(t,e){this.verify2(t,e);const r=t.iadd(e);return r.cmp(this.m)>=0&&r.isub(this.m),r}sub(t,e){this.verify2(t,e);const r=t.sub(e);return r.cmpn(0)<0&&r.iadd(this.m),r.forceRed(this)}isub(t,e){this.verify2(t,e);const r=t.isub(e);return r.cmpn(0)<0&&r.iadd(this.m),r}shl(t,e){return this.verify1(t),this.imod(t.ushln(e))}imul(t,e){return this.verify2(t,e),this.imod(t.imul(e))}mul(t,e){return this.verify2(t,e),this.imod(t.mul(e))}isqr(t){return this.imul(t,t.clone())}sqr(t){return this.mul(t,t)}sqrt(e){if(e.isZero())return e.clone();const r=this.m.andln(3);if(this.assert(r%2==1),3===r){const r=this.m.add(new t(1)).iushrn(2);return this.pow(e,r)}const i=this.m.subn(1);let s=0;for(;!i.isZero()&&0===i.andln(1);)s++,i.iushrn(1);this.assert(!i.isZero());const n=new t(1).toRed(this),a=n.redNeg(),o=this.m.subn(1).iushrn(1),c=this.m.bitLength(),h=new t(2*c*c).toRed(this);for(;0!==this.pow(h,o).cmp(a);)h.redIAdd(a);let d=this.pow(h,i),u=this.pow(e,i.addn(1).iushrn(1)),f=this.pow(e,i),l=s;for(;0!==f.cmp(n);){let e=f,r=0;for(;0!==e.cmp(n);r++)e=e.redSqr();this.assert(r<l);const i=this.pow(d,new t(1).iushln(l-r-1));u=u.redMul(i),d=i.redSqr(),f=f.redMul(d),l=r}return u}invm(t){const e=t._invmp(this.m);return 0!==e.negative?(e.negative=0,this.imod(e).redNeg()):this.imod(e)}pow(e,r){if(r.isZero())return new t(1).toRed(this);if(0===r.cmpn(1))return e.clone();const i=new Array(16);i[0]=new t(1).toRed(this),i[1]=e;let s=2;for(;s<i.length;s++)i[s]=this.mul(i[s-1],e);let n=i[0],a=0,o=0,c=r.bitLength()%26;for(0===c&&(c=26),s=r.length-1;s>=0;s--){const t=r.words[s];for(let e=c-1;e>=0;e--){const r=t>>e&1;n!==i[0]&&(n=this.sqr(n)),0!==r||0!==a?(a<<=1,a|=r,o++,(4===o||0===s&&0===e)&&(n=this.mul(n,i[a]),o=0,a=0)):o=0}c=26}return n}convertTo(t){const e=t.umod(this.m);return e===t?e.clone():e}convertFrom(t){const e=t.clone();return e.red=null,e}}class s extends i{shift;r;r2;rinv;minv;constructor(e){super(e),this.shift=this.m.bitLength(),this.shift%26!=0&&(this.shift+=26-this.shift%26),this.r=new t(1).iushln(this.shift),this.r2=this.imod(this.r.sqr()),this.rinv=this.r._invmp(this.m),this.minv=this.rinv.mul(this.r).isubn(1).div(this.m),this.minv=this.minv.umod(this.r),this.minv=this.r.sub(this.minv)}convertTo(t){return this.imod(t.ushln(this.shift))}convertFrom(t){const e=this.imod(t.mul(this.rinv));return e.red=null,e}imul(t,e){if(t.isZero()||e.isZero())return t.words[0]=0,t.length=1,t;const r=t.imul(e),i=r.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m),s=r.isub(i).iushrn(this.shift);let n=s;return s.cmp(this.m)>=0?n=s.isub(this.m):s.cmpn(0)<0&&(n=s.iadd(this.m)),n.forceRed(this)}mul(e,r){if(e.isZero()||r.isZero())return new t(0).forceRed(this);const i=e.mul(r),s=i.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m),n=i.isub(s).iushrn(this.shift);let a=n;return n.cmp(this.m)>=0?a=n.isub(this.m):n.cmpn(0)<0&&(a=n.iadd(this.m)),a.forceRed(this)}invm(t){return this.imod(t._invmp(this.m).mul(this.r2)).forceRed(this)}}class n{curve;type;precomputed;constructor(t){this.curve=new ct,this.type=t,this.precomputed=null}}class a extends n{x;y;z;zOne;constructor(e,r,i){super(\"jacobian\"),null===e&&null===r&&null===i?(this.x=this.curve.one,this.y=this.curve.one,this.z=new t(0)):(t.isBN(e)||(e=new t(e,16)),this.x=e,t.isBN(r)||(r=new t(r,16)),this.y=r,t.isBN(i)||(i=new t(i,16)),this.z=i),null==this.x.red&&(this.x=this.x.toRed(this.curve.red)),null==this.y.red&&(this.y=this.y.toRed(this.curve.red)),null==this.z.red&&(this.z=this.z.toRed(this.curve.red)),this.zOne=this.z===this.curve.one}toP(){if(this.isInfinity())return new at(null,null);const t=this.z.redInvm(),e=t.redSqr(),r=this.x.redMul(e),i=this.y.redMul(e).redMul(t);return new at(r,i)}neg(){return new a(this.x,this.y.redNeg(),this.z)}add(t){if(this.isInfinity())return t;if(t.isInfinity())return this;const e=t.z.redSqr(),r=this.z.redSqr(),i=this.x.redMul(e),s=t.x.redMul(r),n=this.y.redMul(e.redMul(t.z)),o=t.y.redMul(r.redMul(this.z)),c=i.redSub(s),h=n.redSub(o);if(0===c.cmpn(0))return 0!==h.cmpn(0)?new a(null,null,null):this.dbl();const d=c.redSqr(),u=d.redMul(c),f=i.redMul(d),l=h.redSqr().redIAdd(u).redISub(f).redISub(f),b=h.redMul(f.redISub(l)).redISub(n.redMul(u)),p=this.z.redMul(t.z).redMul(c);return new a(l,b,p)}mixedAdd(t){if(this.isInfinity())return t.toJ();if(t.isInfinity())return this;if(null===t.x||null===t.y)throw new Error(\"Point coordinates cannot be null\");const e=this.z.redSqr(),r=this.x,i=t.x.redMul(e),s=this.y,n=t.y.redMul(e).redMul(this.z),o=r.redSub(i),c=s.redSub(n);if(0===o.cmpn(0))return 0!==c.cmpn(0)?new a(null,null,null):this.dbl();const h=o.redSqr(),d=h.redMul(o),u=r.redMul(h),f=c.redSqr().redIAdd(d).redISub(u).redISub(u),l=c.redMul(u.redISub(f)).redISub(s.redMul(d)),b=this.z.redMul(o);return new a(f,l,b)}dblp(t){if(0===t)return this;if(this.isInfinity())return this;if(void 0===t)return this.dbl();let e=this;for(let r=0;r<t;r++)e=e.dbl();return e}dbl(){if(this.isInfinity())return this;let t,e,r;if(this.zOne){const i=this.x.redSqr(),s=this.y.redSqr(),n=s.redSqr();let a=this.x.redAdd(s).redSqr().redISub(i).redISub(n);a=a.redIAdd(a);const o=i.redAdd(i).redIAdd(i),c=o.redSqr().redISub(a).redISub(a);let h=n.redIAdd(n);h=h.redIAdd(h),h=h.redIAdd(h),t=c,e=o.redMul(a.redISub(c)).redISub(h),r=this.y.redAdd(this.y)}else{const i=this.x.redSqr(),s=this.y.redSqr(),n=s.redSqr();let a=this.x.redAdd(s).redSqr().redISub(i).redISub(n);a=a.redIAdd(a);const o=i.redAdd(i).redIAdd(i),c=o.redSqr();let h=n.redIAdd(n);h=h.redIAdd(h),h=h.redIAdd(h),t=c.redISub(a).redISub(a),e=o.redMul(a.redISub(t)).redISub(h),r=this.y.redMul(this.z),r=r.redIAdd(r)}return new a(t,e,r)}eq(t){if(\"affine\"===t.type)return this.eq(t.toJ());if(this===t)return!0;const e=this.z.redSqr(),r=t.z.redSqr();if(0!==this.x.redMul(r).redISub(t.x.redMul(e)).cmpn(0))return!1;const i=e.redMul(this.z),s=r.redMul(t.z);return 0===this.y.redMul(s).redISub(t.y.redMul(i)).cmpn(0)}eqXToP(t){const e=this.z.redSqr(),r=t.toRed(this.curve?.red).redMul(e);if(0===this.x.cmp(r))return!0;const i=t.clone();if(null===this.curve||null==this.curve.redN)throw new Error(\"Curve or redN is not initialized.\");const s=this.curve.redN.redMul(e);for(;i.cmp(this.curve.p)<0;){if(i.iadd(this.curve.n),i.cmp(this.curve.p)>=0)return!1;if(r.redIAdd(s),0===this.x.cmp(r))return!0}return!1}inspect(){return this.isInfinity()?\"<EC JPoint Infinity>\":\"<EC JPoint x: \"+this.x.toString(16,2)+\" y: \"+this.y.toString(16,2)+\" z: \"+this.z.toString(16,2)+\">\"}isInfinity(){return 0===this.z.cmpn(0)}}const o=(t,e=\"Hash assertion failed\")=>{if(!t)throw new Error(e)};class c{pending;pendingTotal;blockSize;outSize;endian;_delta8;_delta32;padLength;hmacStrength;constructor(t,e,r,i){this.pending=null,this.pendingTotal=0,this.blockSize=t,this.outSize=e,this.hmacStrength=r,this.padLength=i/8,this.endian=\"big\",this._delta8=this.blockSize/8,this._delta32=this.blockSize/32}_update(t,e){throw new Error(\"Not implemented\")}_digest(){throw new Error(\"Not implemented\")}_digestHex(){throw new Error(\"Not implemented\")}update(t,e){if(t=d(t,e),null==this.pending?this.pending=t:this.pending=this.pending.concat(t),this.pendingTotal+=t.length,this.pending.length>=this._delta8){const e=(t=this.pending).length%this._delta8;this.pending=t.slice(t.length-e,t.length),0===this.pending.length&&(this.pending=null),t=function(t,e,r,i){const s=r-e;o(s%4==0);const n=new Array(s/4);for(let r=0,s=e;r<n.length;r++,s+=4){let e;e=\"big\"===i?t[s]<<24|t[s+1]<<16|t[s+2]<<8|t[s+3]:t[s+3]<<24|t[s+2]<<16|t[s+1]<<8|t[s],n[r]=e>>>0}return n}(t,0,t.length-e,this.endian);for(let e=0;e<t.length;e+=this._delta32)this._update(t,e)}return this}digest(){return this.update(this._pad()),o(null===this.pending),this._digest()}digestHex(){return this.update(this._pad()),o(null===this.pending),this._digestHex()}_pad(){let t=this.pendingTotal;const e=this._delta8,r=e-(t+this.padLength)%e,i=new Array(r+this.padLength);let s,n;for(i[0]=128,s=1;s<r;s++)i[s]=0;if(t<<=3,\"big\"===this.endian){for(n=8;n<this.padLength;n++)i[s++]=0;i[s++]=0,i[s++]=0,i[s++]=0,i[s++]=0,i[s++]=t>>>24&255,i[s++]=t>>>16&255,i[s++]=t>>>8&255,i[s++]=255&t}else for(i[s++]=255&t,i[s++]=t>>>8&255,i[s++]=t>>>16&255,i[s++]=t>>>24&255,i[s++]=0,i[s++]=0,i[s++]=0,i[s++]=0,n=8;n<this.padLength;n++)i[s++]=0;return i}}function h(t,e){return 55296==(64512&t.charCodeAt(e))&&(!(e<0||e+1>=t.length)&&56320==(64512&t.charCodeAt(e+1)))}function d(t,e){if(Array.isArray(t))return t.slice();if(!t)return[];const r=[];if(\"string\"==typeof t)if(\"hex\"!==e){let e=0;for(let i=0;i<t.length;i++){let s=t.charCodeAt(i);s<128?r[e++]=s:s<2048?(r[e++]=s>>6|192,r[e++]=63&s|128):h(t,i)?(s=65536+((1023&s)<<10)+(1023&t.charCodeAt(++i)),r[e++]=s>>18|240,r[e++]=s>>12&63|128,r[e++]=s>>6&63|128,r[e++]=63&s|128):(r[e++]=s>>12|224,r[e++]=s>>6&63|128,r[e++]=63&s|128)}}else{(t=t.replace(/[^a-z0-9]+/gi,\"\")).length%2!=0&&(t=\"0\"+t);for(let e=0;e<t.length;e+=2)r.push(parseInt(t[e]+t[e+1],16))}else for(let e=0;e<t.length;e++)r[e]=0|t[e];return r}function u(t){return(t>>>24|t>>>8&65280|t<<8&16711680|(255&t)<<24)>>>0}function f(t,e){let r=\"\";for(let i=0;i<t.length;i++){let s=t[i];\"little\"===e&&(s=u(s)),r+=l(s.toString(16))}return r}function l(t){return 7===t.length?\"0\"+t:6===t.length?\"00\"+t:5===t.length?\"000\"+t:4===t.length?\"0000\"+t:3===t.length?\"00000\"+t:2===t.length?\"000000\"+t:1===t.length?\"0000000\"+t:t}function b(t,e){const r=new Array(4*t.length);for(let i=0,s=0;i<t.length;i++,s+=4){const n=t[i];\"big\"===e?(r[s]=n>>>24,r[s+1]=n>>>16&255,r[s+2]=n>>>8&255,r[s+3]=255&n):(r[s+3]=n>>>24,r[s+2]=n>>>16&255,r[s+1]=n>>>8&255,r[s]=255&n)}return r}function p(t,e){return t>>>e|t<<32-e}function g(t,e){return t<<e|t>>>32-e}function m(t,e){return t+e>>>0}function w(t,e,r){return t+e+r>>>0}function y(t,e,r,i){return t+e+r+i>>>0}function v(t,e,r,i,s){return t+e+r+i+s>>>0}function P(t,e,r,i){return 0===t?O(e,r,i):1===t||3===t?function(t,e,r){return t^e^r}(e,r,i):2===t?E(e,r,i):void 0}function O(t,e,r){return t&e^~t&r}function E(t,e,r){return t&e^t&r^e&r}function k(t){return p(t,2)^p(t,13)^p(t,22)}function _(t){return p(t,6)^p(t,11)^p(t,25)}function x(t){return p(t,7)^p(t,18)^t>>>3}function I(t){return p(t,17)^p(t,19)^t>>>10}const S=[0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,7,4,13,1,10,6,15,3,12,0,9,5,2,14,11,8,3,10,14,4,9,15,8,1,2,7,0,6,13,11,5,12,1,9,11,10,0,8,12,4,13,3,7,15,14,5,6,2,4,0,5,9,7,12,2,10,14,1,3,8,11,6,15,13],A=[5,14,7,0,9,2,11,4,13,6,15,8,1,10,3,12,6,11,3,7,0,13,5,10,14,15,8,12,4,9,1,2,15,5,1,3,7,14,6,9,11,8,12,2,10,0,4,13,8,6,4,1,3,11,15,0,5,12,2,13,9,7,10,14,12,15,10,4,1,5,8,7,6,2,13,14,0,3,9,11],M=[11,14,15,12,5,8,7,9,11,13,14,15,6,7,9,8,7,6,8,13,11,9,7,15,7,12,15,9,11,7,13,12,11,13,6,7,14,9,13,15,14,8,13,6,5,12,7,5,11,12,14,15,14,15,9,8,9,14,5,6,8,6,5,12,9,15,5,11,6,8,13,12,5,12,13,14,11,8,5,6],T=[8,9,9,11,13,15,15,5,7,7,8,11,14,14,12,6,9,13,15,7,12,8,9,11,7,7,12,7,6,15,13,11,9,7,15,11,8,6,6,14,12,13,5,14,13,13,7,5,15,5,8,11,14,14,6,14,6,9,12,9,12,5,15,8,8,5,12,9,12,5,14,6,8,13,6,5,15,13,11,11];function N(t,e,r,i){return t<=15?e^r^i:t<=31?e&r|~e&i:t<=47?(e|~r)^i:t<=63?e&i|r&~i:e^(r|~i)}function F(t){return t<=15?0:t<=31?1518500249:t<=47?1859775393:t<=63?2400959708:2840853838}function B(t){return t<=15?1352829926:t<=31?1548603684:t<=47?1836072691:t<=63?2053994217:0}class R extends c{h;constructor(){super(512,160,192,64),this.endian=\"little\",this.h=[1732584193,4023233417,2562383102,271733878,3285377520],this.endian=\"little\"}_update(t,e){let r,i=this.h[0],s=this.h[1],n=this.h[2],a=this.h[3],o=this.h[4],c=i,h=s,d=n,u=a,f=o;for(let l=0;l<80;l++)r=m(g(y(i,N(l,s,n,a),t[S[l]+e],F(l)),M[l]),o),i=o,o=a,a=g(n,10),n=s,s=r,r=m(g(y(c,N(79-l,h,d,u),t[A[l]+e],B(l)),T[l]),f),c=f,f=u,u=g(d,10),d=h,h=r;r=w(this.h[1],n,u),this.h[1]=w(this.h[2],a,f),this.h[2]=w(this.h[3],o,c),this.h[3]=w(this.h[4],i,h),this.h[4]=w(this.h[0],s,d),this.h[0]=r}_digest(){return b(this.h,\"little\")}_digestHex(){return f(this.h,\"little\")}}class U extends c{h;W;k;constructor(){super(512,256,192,64),this.h=[1779033703,3144134277,1013904242,2773480762,1359893119,2600822924,528734635,1541459225],this.k=[1116352408,1899447441,3049323471,3921009573,961987163,1508970993,2453635748,2870763221,3624381080,310598401,607225278,1426881987,1925078388,2162078206,2614888103,3248222580,3835390401,4022224774,264347078,604807628,770255983,1249150122,1555081692,1996064986,2554220882,2821834349,2952996808,3210313671,3336571891,3584528711,113926993,338241895,666307205,773529912,1294757372,1396182291,1695183700,1986661051,2177026350,2456956037,2730485921,2820302411,3259730800,3345764771,3516065817,3600352804,4094571909,275423344,430227734,506948616,659060556,883997877,958139571,1322822218,1537002063,1747873779,1955562222,2024104815,2227730452,2361852424,2428436474,2756734187,3204031479,3329325298],this.W=new Array(64)}_update(t,e){const r=this.W;let i;for(void 0===e&&(e=0),i=0;i<16;i++)r[i]=t[e+i];for(;i<r.length;i++)r[i]=y(I(r[i-2]),r[i-7],x(r[i-15]),r[i-16]);let s=this.h[0],n=this.h[1],a=this.h[2],c=this.h[3],h=this.h[4],d=this.h[5],u=this.h[6],f=this.h[7];for(o(this.k.length===r.length),i=0;i<r.length;i++){const t=v(f,_(h),O(h,d,u),this.k[i],r[i]),e=m(k(s),E(s,n,a));f=u,u=d,d=h,h=m(c,t),c=a,a=n,n=s,s=m(t,e)}this.h[0]=m(this.h[0],s),this.h[1]=m(this.h[1],n),this.h[2]=m(this.h[2],a),this.h[3]=m(this.h[3],c),this.h[4]=m(this.h[4],h),this.h[5]=m(this.h[5],d),this.h[6]=m(this.h[6],u),this.h[7]=m(this.h[7],f)}_digest(){return b(this.h,\"big\")}_digestHex(){return f(this.h,\"big\")}}class L extends c{h;W;k;constructor(){super(512,160,80,64),this.k=[1518500249,1859775393,2400959708,3395469782],this.h=[1732584193,4023233417,2562383102,271733878,3285377520],this.W=new Array(80)}_update(t,e){const r=this.W;let i;for(void 0===e&&(e=0),i=0;i<16;i++)r[i]=t[e+i];for(;i<r.length;i++)r[i]=g(r[i-3]^r[i-8]^r[i-14]^r[i-16],1);let s=this.h[0],n=this.h[1],a=this.h[2],o=this.h[3],c=this.h[4];for(i=0;i<r.length;i++){const t=~~(i/20),e=v(g(s,5),P(t,n,a,o),c,r[i],this.k[t]);c=o,o=a,a=g(n,30),n=s,s=e}this.h[0]=m(this.h[0],s),this.h[1]=m(this.h[1],n),this.h[2]=m(this.h[2],a),this.h[3]=m(this.h[3],o),this.h[4]=m(this.h[4],c)}_digest(){return b(this.h,\"big\")}_digestHex(){return f(this.h,\"big\")}}class D{inner;outer;blockSize=64;outSize=32;constructor(t){let e;for((t=d(t,\"hex\")).length>this.blockSize&&(t=(new U).update(t).digest()),o(t.length<=this.blockSize),e=t.length;e<this.blockSize;e++)t.push(0);for(e=0;e<t.length;e++)t[e]^=54;for(this.inner=(new U).update(t),e=0;e<t.length;e++)t[e]^=106;this.outer=(new U).update(t)}update(t,e){return this.inner.update(t,e),this}digest(){return this.outer.update(this.inner.digest()),this.outer.digest()}digestHex(){return this.outer.update(this.inner.digest()),this.outer.digestHex()}}const C=(t,e)=>(new U).update(t,e).digest(),H=(t,e)=>{const r=(new U).update(t,e).digest();return(new U).update(r).digest()},q=(t,e)=>{const r=(new U).update(t,e).digest();return(new R).update(r).digest()},V=(t,e,r)=>new D(t).update(e,r).digest(),$=t=>t.length%2==1?\"0\"+t:t,K=t=>{let e=\"\";for(const r of t)e+=$(r.toString(16));return e},j=(t,e)=>{if(Array.isArray(t))return t.slice();if(void 0===t)return[];if(\"string\"!=typeof t)return Array.from(t,(t=>0|t));switch(e){case\"hex\":return X(t);case\"base64\":return Y(t);default:return function(t){const e=[];for(let r=0;r<t.length;r++){const i=t.codePointAt(r);if(void 0===i)throw new Error(`Index out of range: ${r}`);let s=i;s>65535?r++:s>=55296&&s<=57343&&(s=65533),s<=127?e.push(s):s<=2047?e.push(192|s>>6,128|63&s):s<=65535?e.push(224|s>>12,128|s>>6&63,128|63&s):e.push(240|s>>18,128|s>>12&63,128|s>>6&63,128|63&s)}return e}(t)}},X=t=>{(t=t.replace(/[^a-z0-9]+/gi,\"\")).length%2!=0&&(t=\"0\"+t);const e=[];for(let r=0;r<t.length;r+=2)e.push(parseInt(t[r]+t[r+1],16));return e},Y=t=>{const e=[];let r=0,i=0;for(const s of t.replace(/=+$/,\"\"))r=r<<6|\"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\".indexOf(s),i+=6,i>=8&&(i-=8,e.push(r>>i&255),r&=(1<<i)-1);return e};const z=t=>{let e=\"\",r=0;for(let i=0;i<t.length;i++){const s=t[i];if(r>0)r--;else if(s<=127)e+=String.fromCharCode(s);else if(s>=192&&s<=223){r=1;const n=(31&s)<<6|63&t[i+1];e+=String.fromCharCode(n)}else if(s>=224&&s<=239){r=2;const n=(15&s)<<12|(63&t[i+1])<<6|63&t[i+2];e+=String.fromCharCode(n)}else if(s>=240&&s<=247){r=3;const n=(7&s)<<18|(63&t[i+1])<<12|(63&t[i+2])<<6|63&t[i+3],a=55296+(n-65536>>10),o=56320+(n-65536&1023);e+=String.fromCharCode(a,o)}}return e},W=(t,e)=>{switch(e){case\"hex\":return K(t);case\"utf8\":return z(t);default:return t}};function G(t){const e=\"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\";let r,i=\"\";for(r=0;r<t.length;r+=3){const s=t[r],n=r+1<t.length?t[r+1]:0,a=r+2<t.length?t[r+2]:0,o=(3&s)<<4|n>>4,c=(15&n)<<2|a>>6,h=63&a;i+=e.charAt(s>>2)+e.charAt(o),i+=r+1<t.length?e.charAt(c):\"=\",i+=r+2<t.length?e.charAt(h):\"=\"}return i}const Z=\"123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz\",J=t=>{if(\"\"===t||\"string\"!=typeof t)throw new Error(`Expected base58 string but got “${t}”`);const e=t.match(/[IOl0]/gmu);if(null!==e)throw new Error(`Invalid base58 character “${e.join(\"\")}”`);const r=t.match(/^1+/gmu),i=null!==r?r[0].length:0,s=(t.length-i)*(Math.log(58)/Math.log(256))+1>>>0,n=new Uint8Array([...new Uint8Array(i),...(t.match(/./gmu)??[]).map((t=>Z.indexOf(t))).reduce(((t,e)=>(t=t.map((t=>{const r=58*t+e;return e=r>>8,r})),t)),new Uint8Array(s)).reverse().filter((a=!1,t=>a=a||t))]);var a;return[...n]},Q=t=>{const e=Array(256).fill(-1);for(let t=0;t<58;++t)e[Z.charCodeAt(t)]=t;const r=[];for(const i of t){let t=i;for(let i=0;i<r.length;++i){const s=(e[r[i]]<<8)+t;r[i]=Z.charCodeAt(s%58),t=s/58|0}for(;0!==t;)r.push(Z.charCodeAt(t%58)),t=t/58|0}for(const e of t){if(0!==e)break;r.push(\"1\".charCodeAt(0))}return r.reverse(),String.fromCharCode(...r)},tt=(t,e=[0])=>{let r=H([...e,...t]);return r=[...e,...t,...r.slice(0,4)],Q(r)},et=(t,e,r=1)=>{const i=J(t);let s=i.slice(0,r),n=i.slice(r,-4),a=[...s,...n];return a=H(a),i.slice(-4).forEach(((t,e)=>{if(t!==a[e])throw new Error(\"Invalid checksum\")})),\"hex\"===e&&(s=K(s),n=K(n)),{prefix:s,data:n}};class rt{bufs;constructor(t){this.bufs=void 0!==t?t:[]}getLength(){let t=0;for(const e of this.bufs)t+=e.length;return t}toArray(){const t=this.getLength(),e=new Array(t);let r=0;for(const t of this.bufs)for(const i of t)e[r++]=i;return e}write(t){return this.bufs.push(t),this}writeReverse(t){const e=new Array(t.length);for(let r=0;r<e.length;r++)e[r]=t[t.length-1-r];return this.bufs.push(e),this}writeUInt8(t){const e=new Array(1);return e[0]=t,this.write(e),this}writeInt8(t){const e=new Array(1);return e[0]=255&t,this.write(e),this}writeUInt16BE(t){return this.bufs.push([t>>8&255,255&t]),this}writeInt16BE(t){return this.writeUInt16BE(65535&t)}writeUInt16LE(t){return this.bufs.push([255&t,t>>8&255]),this}writeInt16LE(t){return this.writeUInt16LE(65535&t)}writeUInt32BE(t){return this.bufs.push([t>>24&255,t>>16&255,t>>8&255,255&t]),this}writeInt32BE(t){return this.writeUInt32BE(t>>>0)}writeUInt32LE(t){return this.bufs.push([255&t,t>>8&255,t>>16&255,t>>24&255]),this}writeInt32LE(t){return this.writeUInt32LE(t>>>0)}writeUInt64BEBn(t){const e=t.toArray(\"be\",8);return this.write(e),this}writeUInt64LEBn(t){const e=t.toArray(\"be\",8);return this.writeReverse(e),this}writeUInt64LE(e){const r=new t(e).toArray(\"be\",8);return this.writeReverse(r),this}writeVarIntNum(t){const e=rt.varIntNum(t);return this.write(e),this}writeVarIntBn(t){const e=rt.varIntBn(t);return this.write(e),this}static varIntNum(t){let e;if(t<253)e=[t];else if(t<65536)e=[253,255&t,t>>8&255];else if(t<4294967296)e=[254,255&t,t>>8&255,t>>16&255,t>>24&255];else{const r=4294967295&t,i=4294967295&Math.floor(t/4294967296);e=[255,255&r,r>>8&255,r>>16&255,r>>24&255,255&i,i>>8&255,i>>16&255,i>>24&255]}return e}static varIntBn(e){let r;if(e.ltn(253)){r=[e.toNumber()]}else if(e.ltn(65536)){const t=e.toNumber();r=[253,255&t,t>>8&255]}else if(e.lt(new t(4294967296))){const t=e.toNumber();r=[254,255&t,t>>8&255,t>>16&255,t>>24&255]}else{const t=new rt;t.writeUInt8(255),t.writeUInt64LEBn(e),r=t.toArray()}return r}}class it{bin;pos;constructor(t=[],e=0){this.bin=t,this.pos=e}eof(){return this.pos>=this.bin.length}read(t=this.bin.length){const e=this.pos,r=this.pos+t;return this.pos=r,this.bin.slice(e,r)}readReverse(t=this.bin.length){const e=new Array(t);for(let r=0;r<t;r++)e[r]=this.bin[this.pos+t-1-r];return this.pos+=t,e}readUInt8(){const t=this.bin[this.pos];return this.pos+=1,t}readInt8(){const t=this.bin[this.pos];return this.pos+=1,128&t?t-256:t}readUInt16BE(){const t=this.bin[this.pos]<<8|this.bin[this.pos+1];return this.pos+=2,t}readInt16BE(){const t=this.readUInt16BE();return 32768&t?t-65536:t}readUInt16LE(){const t=this.bin[this.pos]|this.bin[this.pos+1]<<8;return this.pos+=2,t}readInt16LE(){const t=this.readUInt16LE();return 32768&t?t-65536:t}readUInt32BE(){const t=16777216*this.bin[this.pos]+(this.bin[this.pos+1]<<16|this.bin[this.pos+2]<<8|this.bin[this.pos+3]);return this.pos+=4,t}readInt32BE(){const t=this.readUInt32BE();return 2147483648&t?t-4294967296:t}readUInt32LE(){const t=(this.bin[this.pos]|this.bin[this.pos+1]<<8|this.bin[this.pos+2]<<16|this.bin[this.pos+3]<<24)>>>0;return this.pos+=4,t}readInt32LE(){const t=this.readUInt32LE();return 2147483648&t?t-4294967296:t}readUInt64BEBn(){const e=this.bin.slice(this.pos,this.pos+8),r=new t(e);return this.pos=this.pos+8,r}readUInt64LEBn(){const e=this.readReverse(8);return new t(e)}readVarIntNum(){const e=this.readUInt8();let r;switch(e){case 253:return this.readUInt16LE();case 254:return this.readUInt32LE();case 255:if(r=this.readUInt64LEBn(),r.lte(new t(2).pow(new t(53))))return r.toNumber();throw new Error(\"number too large to retain precision - use readVarIntBn\");default:return e}}readVarInt(){switch(this.bin[this.pos]){case 253:return this.read(3);case 254:return this.read(5);case 255:return this.read(9);default:return this.read(1)}}readVarIntBn(){const e=this.readUInt8();switch(e){case 253:return new t(this.readUInt16LE());case 254:return new t(this.readUInt32LE());case 255:return this.readUInt64LEBn();default:return new t(e)}}}const st=t=>{if(0===t.length)return t;const e=t[t.length-1];if(127&e)return t;if(1===t.length)return[];if(128&t[t.length-2])return t;for(let r=t.length-1;r>0;r--)if(0!==t[r-1])return 128&t[r-1]?(t[r]=e,t.slice(0,r+1)):(t[r-1]|=e,t.slice(0,r));return[]};var nt=Object.freeze({__proto__:null,Reader:it,Writer:rt,encode:W,fromBase58:J,fromBase58Check:et,minimallyEncode:st,toArray:j,toBase58:Q,toBase58Check:tt,toBase64:G,toHex:K,toUTF8:z,zero2:$});class at extends n{static red=new i(\"k256\");static a=new t(0).toRed(at.red);static b=new t(7).toRed(at.red);static zero=new t(0).toRed(at.red);x;y;inf;static fromDER(t){const e=32;if((4===t[0]||6===t[0]||7===t[0])&&t.length-1==64){if(6===t[0]){if(t[t.length-1]%2!=0)throw new Error(\"Point string value is wrong length\")}else if(7===t[0]&&t[t.length-1]%2!=1)throw new Error(\"Point string value is wrong length\");return new at(t.slice(1,33),t.slice(33,65))}if((2===t[0]||3===t[0])&&t.length-1===e)return at.fromX(t.slice(1,33),3===t[0]);throw new Error(\"Unknown point format\")}static fromString(t){const e=j(t,\"hex\");return at.fromDER(e)}static redSqrtOptimized(t){const e=at.red.m.addn(1).iushrn(2);return t.redPow(e)}static fromX(e,r){if(\"function\"==typeof BigInt){function s(t,e){return(t%e+e)%e}function n(t,e,r){let i=BigInt(1);for(t=s(t,r);e>BigInt(0);)(e&BigInt(1))===BigInt(1)&&(i=s(i*t,r)),e>>=BigInt(1),t=s(t*t,r);return i}function a(t,e){const r=n(t,e+BigInt(1)>>BigInt(2),e);return s(r*r,e)===s(t,e)?r:null}const o=BigInt(\"0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEFFFFFC2F\"),c=BigInt(7);let h;if(e instanceof t)h=BigInt(\"0x\"+e.toString(16));else if(\"string\"==typeof e)h=BigInt(\"0x\"+e);else if(Array.isArray(e))h=BigInt(\"0x\"+K(e).padStart(64,\"0\"));else{if(\"number\"!=typeof e)throw new Error(\"Invalid x-coordinate type\");h=BigInt(e)}h=s(h,o);let d=a(s(n(h,BigInt(3),o)+c,o),o);if(null===d)throw new Error(\"Invalid point\");const u=d%BigInt(2)===BigInt(1);(r&&!u||!r&&u)&&(d=o-d);const f=new t(h.toString(16),16),l=new t(d.toString(16),16);return new at(f,l)}{const b=new i(\"k256\"),p=new t(0).toRed(b),g=new t(7).toRed(b),m=new t(0).toRed(b);t.isBN(e)||(e=new t(e,16)),null==e.red&&(e=e.toRed(b));const w=e.redSqr().redMul(e).redIAdd(e.redMul(p)).redIAdd(g);let y=w.redSqrt();if(0!==y.redSqr().redSub(w).cmp(m))throw new Error(\"invalid point\");const v=y.fromRed().isOdd();return(r&&!v||!r&&v)&&(y=y.redNeg()),new at(e,y)}}static fromJSON(t,e){\"string\"==typeof t&&(t=JSON.parse(t));const r=new at(t[0],t[1],e);if(\"object\"!=typeof t[2])return r;const i=t=>new at(t[0],t[1],e),s=t[2];return r.precomputed={beta:null,doubles:\"object\"==typeof s.doubles&&null!==s.doubles?{step:s.doubles.step,points:[r].concat(s.doubles.points.map(i))}:void 0,naf:\"object\"==typeof s.naf&&null!==s.naf?{wnd:s.naf.wnd,points:[r].concat(s.naf.points.map(i))}:void 0},r}constructor(e,r,i=!0){super(\"affine\"),this.precomputed=null,null===e&&null===r?(this.x=null,this.y=null,this.inf=!0):(t.isBN(e)||(e=new t(e,16)),this.x=e,t.isBN(r)||(r=new t(r,16)),this.y=r,i&&(this.x.forceRed(this.curve.red),this.y.forceRed(this.curve.red)),null===this.x.red&&(this.x=this.x.toRed(this.curve.red)),null===this.y.red&&(this.y=this.y.toRed(this.curve.red)),this.inf=!1)}validate(){return this.curve.validate(this)}encode(t=!0,e){const r=this.curve.p.byteLength(),i=this.getX().toArray(\"be\",r);let s;return s=t?[this.getY().isEven()?2:3].concat(i):[4].concat(i,this.getY().toArray(\"be\",r)),\"hex\"!==e?s:K(s)}toString(){return this.encode(!0,\"hex\")}toJSON(){return null==this.precomputed?[this.x,this.y]:[this.x,this.y,\"object\"==typeof this.precomputed&&null!==this.precomputed?{doubles:null!=this.precomputed.doubles?{step:this.precomputed.doubles.step,points:this.precomputed.doubles.points.slice(1)}:void 0,naf:null!=this.precomputed.naf?{wnd:this.precomputed.naf.wnd,points:this.precomputed.naf.points.slice(1)}:void 0}:void 0]}inspect(){return this.isInfinity()?\"<EC Point Infinity>\":\"<EC Point x: \"+(this.x?.fromRed()?.toString(16,2)??\"undefined\")+\" y: \"+(this.y?.fromRed()?.toString(16,2)??\"undefined\")+\">\"}isInfinity(){return this.inf}add(e){if(this.inf)return e;if(e.inf)return this;if(this.eq(e))return this.dbl();if(this.neg().eq(e))return new at(new t(0),new t(0));if(0===this.x?.cmp(e.x??new t(0)))return new at(new t(0),new t(0));let r=this.y?.redSub(e.y??new t(0))??new t(0);0!==r.cmpn(0)&&(r=r.redMul(this.x?.redSub(e.x??new t(0)).redInvm()??new t(1)));const i=r?.redSqr().redISub(this.x??new t(0)).redISub(e.x??new t(0)),s=(r??new t(1)).redMul((this.x??new t(0)).redSub(i??new t(0))).redISub(this.y??new t(0));return new at(i??new t(0),s??new t(0))}dbl(){if(this.inf)return this;const e=(this.y??new t(0)).redAdd(this.y??new t(0));if(0===e.cmpn(0))return new at(new t(0),new t(0));const r=this.curve.a,i=(this.x??new t(0)).redSqr(),s=e.redInvm(),n=i.redAdd(i).redIAdd(i).redIAdd(r).redMul(s),a=n.redSqr().redISub((this.x??new t(0)).redAdd(this.x??new t(0))),o=n.redMul((this.x??new t(0)).redSub(a)).redISub(this.y??new t(0));return new at(a,o)}getX(){return(this.x??new t(0)).fromRed()}getY(){return(this.y??new t(0)).fromRed()}mul(e){return t.isBN(e)||(e=new t(e,16)),this.isInfinity()?this:this._hasDoubles(e)?this._fixedNafMul(e):this._endoWnafMulAdd([this],[e])}mulAdd(t,e,r){const i=[this,e],s=[t,r];return this._endoWnafMulAdd(i,s)}jmulAdd(t,e,r){const i=[this,e],s=[t,r];return this._endoWnafMulAdd(i,s,!0)}eq(e){return this===e||this.inf===e.inf&&(this.inf||0===(this.x??new t(0)).cmp(e.x??new t(0))&&0===(this.y??new t(0)).cmp(e.y??new t(0)))}neg(e){if(this.inf)return this;const r=new at(this.x,(this.y??new t(0)).redNeg());if(!0===e&&null!=this.precomputed){const t=this.precomputed,e=t=>t.neg();r.precomputed={naf:null!=t.naf?{wnd:t.naf.wnd,points:t.naf.points.map(e)}:void 0,doubles:null!=t.doubles?{step:t.doubles.step,points:t.doubles.points.map((t=>t.neg()))}:void 0,beta:void 0}}return r}dblp(t){let e=this;for(let r=0;r<t;r++)e=e.dbl();return e}toJ(){if(this.inf)return new a(null,null,null);return new a(this.x,this.y,this.curve.one)}_getBeta(){if(\"object\"!=typeof this.curve.endo)return;const e=this.precomputed;if(\"object\"==typeof e&&null!==e&&\"object\"==typeof e.beta&&null!==e.beta)return e.beta;const r=new at((this.x??new t(0)).redMul(this.curve.endo.beta),this.y);if(null!=e){const t=this.curve,i=e=>{if(null===e.x)throw new Error(\"p.x is null\");if(void 0===t.endo||null===t.endo)throw new Error(\"curve.endo is undefined\");return new at(e.x.redMul(t.endo.beta),e.y)};e.beta=r,r.precomputed={beta:null,naf:null!=e.naf?{wnd:e.naf.wnd,points:e.naf.points.map(i)}:void 0,doubles:null!=e.doubles?{step:e.doubles.step,points:e.doubles.points.map(i)}:void 0}}return r}_fixedNafMul(t){if(\"object\"!=typeof this.precomputed||null===this.precomputed)throw new Error(\"_fixedNafMul requires precomputed values for the point\");const e=this._getDoubles(),r=this.curve.getNAF(t,1,this.curve._bitLength);let i=(1<<e.step+1)-(e.step%2==0?2:1);i/=3;const s=[];for(let t=0;t<r.length;t+=e.step){let i=0;for(let s=t+e.step-1;s>=t;s--)i=(i<<1)+r[s];s.push(i)}let n=new a(null,null,null),o=new a(null,null,null);for(let t=i;t>0;t--){for(let r=0;r<s.length;r++){const i=s[r];i===t?o=o.mixedAdd(e.points[r]):i===-t&&(o=o.mixedAdd(e.points[r].neg()))}n=n.add(o)}return n.toP()}_wnafMulAdd(e,r,i,s,n){const o=this.curve._wnafT1.map((t=>t.toNumber())),c=this.curve._wnafT2.map((()=>[])),h=this.curve._wnafT3.map((()=>[]));let d=0;for(let t=0;t<s;t++){const i=r[t]._getNAFPoints(e);o[t]=i.wnd,c[t]=i.points}for(let e=s-1;e>=1;e-=2){const s=e-1,n=e;if(1!==o[s]||1!==o[n]){h[s]=this.curve.getNAF(i[s],o[s],this.curve._bitLength),h[n]=this.curve.getNAF(i[n],o[n],this.curve._bitLength),d=Math.max(h[s].length,d),d=Math.max(h[n].length,d);continue}const a=[r[s],null,null,r[n]];0===(r[s].y??new t(0)).cmp(r[n].y??new t(0))?(a[1]=r[s].add(r[n]),a[2]=r[s].toJ().mixedAdd(r[n].neg())):0===(r[s].y??new t(0)).cmp((r[n].y??new t(0)).redNeg())?(a[1]=r[s].toJ().mixedAdd(r[n]),a[2]=r[s].add(r[n].neg())):(a[1]=r[s].toJ().mixedAdd(r[n]),a[2]=r[s].toJ().mixedAdd(r[n].neg()));const u=[-3,-1,-5,-7,0,7,5,1,3],f=this.curve.getJSF(i[s],i[n]);d=Math.max(f[0].length,d),h[s]=new Array(d),h[n]=new Array(d);for(let t=0;t<d;t++){const e=0|f[0][t],r=0|f[1][t];h[s][t]=u[3*(e+1)+(r+1)],h[n][t]=0,c[s]=a}}let u=new a(null,null,null);const f=this.curve._wnafT4;for(let e=d;e>=0;e--){let r=0;for(;e>=0;){let i=!0;for(let r=0;r<s;r++)f[r]=new t(\"number\"==typeof h[r][e]?h[r][e]:0),f[r].isZero()||(i=!1);if(!i)break;r++,e--}if(e>=0&&r++,u=u.dblp(r),e<0)break;const i=new t(1),n=new t(2);for(let t=0;t<s;t++){const e=f[t];let r;0!==e.cmpn(0)&&(r=e.isNeg()?c[t][e.neg().sub(i).div(n).toNumber()].neg():c[t][e.sub(i).div(n).toNumber()],u=\"affine\"===r.type?u.mixedAdd(r):u.add(r))}}for(let t=0;t<s;t++)c[t]=[];return!0===n?u:u.toP()}_endoWnafMulAdd(e,r,i){const s=new Array(2*e.length),n=new Array(2*e.length);let a;for(a=0;a<e.length;a++){const i=this.curve._endoSplit(r[a]);let o=e[a],c=o._getBeta()??new at(new t(0),new t(0));0!==i.k1.negative&&(i.k1.ineg(),o=o.neg(!0)),0!==i.k2.negative&&(i.k2.ineg(),c=c.neg(!0)),s[2*a]=o,s[2*a+1]=c,n[2*a]=i.k1,n[2*a+1]=i.k2}const o=this._wnafMulAdd(1,s,n,2*a,i);for(let t=0;t<2*a;t++)s[t]=null,n[t]=null;return o}_hasDoubles(t){if(null==this.precomputed)return!1;const e=this.precomputed.doubles;return\"object\"==typeof e&&e.points.length>=Math.ceil((t.bitLength()+1)/e.step)}_getDoubles(t,e){if(\"object\"==typeof this.precomputed&&null!==this.precomputed&&\"object\"==typeof this.precomputed.doubles&&null!==this.precomputed.doubles)return this.precomputed.doubles;const r=[this];let i=this;for(let s=0;s<(e??0);s+=t??1){for(let e=0;e<(t??1);e++)i=i.dbl();r.push(i)}return{step:t??1,points:r}}_getNAFPoints(t){if(\"object\"==typeof this.precomputed&&null!==this.precomputed&&\"object\"==typeof this.precomputed.naf&&null!==this.precomputed.naf)return this.precomputed.naf;const e=[this],r=(1<<t)-1,i=1===r?null:this.dbl();for(let t=1;t<r;t++)null!==i&&(e[t]=e[t-1].add(i));return{wnd:t,points:e}}}let ot;class ct{p;red;redN;zero;one;two;g;n;a;b;tinv;zeroA;threeA;endo;_endoWnafT1;_endoWnafT2;_wnafT1;_wnafT2;_wnafT3;_wnafT4;_bitLength;static assert(t,e=\"Elliptic curve assertion failed\"){if(!t)throw new Error(e)}getNAF(t,e,r){const i=new Array(Math.max(t.bitLength(),r)+1);i.fill(0);const s=1<<e+1,n=t.clone();for(let t=0;t<i.length;t++){let e;const r=n.andln(s-1);n.isOdd()?(e=r>(s>>1)-1?(s>>1)-r:r,n.isubn(e)):e=0,i[t]=e,n.iushrn(1)}return i}getJSF(t,e){const r=[[],[]];t=t.clone(),e=e.clone();let i=0,s=0;for(;t.cmpn(-i)>0||e.cmpn(-s)>0;){let n,a,o=t.andln(3)+i&3,c=e.andln(3)+s&3;if(3===o&&(o=-1),3===c&&(c=-1),1&o){const e=t.andln(7)+i&7;n=3!==e&&5!==e||2!==c?o:-o}else n=0;if(r[0].push(n),1&c){const t=e.andln(7)+s&7;a=3!==t&&5!==t||2!==o?c:-c}else a=0;r[1].push(a),2*i===n+1&&(i=1-i),2*s===a+1&&(s=1-s),t.iushrn(1),e.iushrn(1)}return r}static cachedProperty(t,e,r){const i=\"_\"+e;t.prototype[e]=function(){return void 0!==this[i]?this[i]:this[i]=r.call(this)}}static parseBytes(t){return\"string\"==typeof t?j(t,\"hex\"):t}static intFromLE(e){return new t(e,\"hex\",\"le\")}constructor(){if(void 0!==ot)return ot;ot=this;const e={prime:\"k256\",p:\"ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f\",a:\"0\",b:\"7\",n:\"ffffffff ffffffff ffffffff fffffffe baaedce6 af48a03b bfd25e8c d0364141\",h:\"1\",beta:\"7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee\",lambda:\"5363ad4cc05c30e0a5261c028812645a122e22ea20816678df02967c1b23bd72\",basis:[{a:\"3086d221a7d46bcde86c90e49284eb15\",b:\"-e4437ed6010e88286f547fa90abfe4c3\"},{a:\"114ca50f7a8e2f3f657c1108d9d44cfd8\",b:\"3086d221a7d46bcde86c90e49284eb15\"}],gRed:!1,g:[\"79be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798\",\"483ada7726a3c4655da4fbfc0e1108a8fd17b448a68554199c47d08ffb10d4b8\",{doubles:{step:4,points:[[\"e60fce93b59e9ec53011aabc21c23e97b2a31369b87a5ae9c44ee89e2a6dec0a\",\"f7e3507399e595929db99f34f57937101296891e44d23f0be1f32cce69616821\"],[\"8282263212c609d9ea2a6e3e172de238d8c39cabd5ac1ca10646e23fd5f51508\",\"11f8a8098557dfe45e8256e830b60ace62d613ac2f7b17bed31b6eaff6e26caf\"],[\"175e159f728b865a72f99cc6c6fc846de0b93833fd2222ed73fce5b551e5b739\",\"d3506e0d9e3c79eba4ef97a51ff71f5eacb5955add24345c6efa6ffee9fed695\"],[\"363d90d447b00c9c99ceac05b6262ee053441c7e55552ffe526bad8f83ff4640\",\"4e273adfc732221953b445397f3363145b9a89008199ecb62003c7f3bee9de9\"],[\"8b4b5f165df3c2be8c6244b5b745638843e4a781a15bcd1b69f79a55dffdf80c\",\"4aad0a6f68d308b4b3fbd7813ab0da04f9e336546162ee56b3eff0c65fd4fd36\"],[\"723cbaa6e5db996d6bf771c00bd548c7b700dbffa6c0e77bcb6115925232fcda\",\"96e867b5595cc498a921137488824d6e2660a0653779494801dc069d9eb39f5f\"],[\"eebfa4d493bebf98ba5feec812c2d3b50947961237a919839a533eca0e7dd7fa\",\"5d9a8ca3970ef0f269ee7edaf178089d9ae4cdc3a711f712ddfd4fdae1de8999\"],[\"100f44da696e71672791d0a09b7bde459f1215a29b3c03bfefd7835b39a48db0\",\"cdd9e13192a00b772ec8f3300c090666b7ff4a18ff5195ac0fbd5cd62bc65a09\"],[\"e1031be262c7ed1b1dc9227a4a04c017a77f8d4464f3b3852c8acde6e534fd2d\",\"9d7061928940405e6bb6a4176597535af292dd419e1ced79a44f18f29456a00d\"],[\"feea6cae46d55b530ac2839f143bd7ec5cf8b266a41d6af52d5e688d9094696d\",\"e57c6b6c97dce1bab06e4e12bf3ecd5c981c8957cc41442d3155debf18090088\"],[\"da67a91d91049cdcb367be4be6ffca3cfeed657d808583de33fa978bc1ec6cb1\",\"9bacaa35481642bc41f463f7ec9780e5dec7adc508f740a17e9ea8e27a68be1d\"],[\"53904faa0b334cdda6e000935ef22151ec08d0f7bb11069f57545ccc1a37b7c0\",\"5bc087d0bc80106d88c9eccac20d3c1c13999981e14434699dcb096b022771c8\"],[\"8e7bcd0bd35983a7719cca7764ca906779b53a043a9b8bcaeff959f43ad86047\",\"10b7770b2a3da4b3940310420ca9514579e88e2e47fd68b3ea10047e8460372a\"],[\"385eed34c1cdff21e6d0818689b81bde71a7f4f18397e6690a841e1599c43862\",\"283bebc3e8ea23f56701de19e9ebf4576b304eec2086dc8cc0458fe5542e5453\"],[\"6f9d9b803ecf191637c73a4413dfa180fddf84a5947fbc9c606ed86c3fac3a7\",\"7c80c68e603059ba69b8e2a30e45c4d47ea4dd2f5c281002d86890603a842160\"],[\"3322d401243c4e2582a2147c104d6ecbf774d163db0f5e5313b7e0e742d0e6bd\",\"56e70797e9664ef5bfb019bc4ddaf9b72805f63ea2873af624f3a2e96c28b2a0\"],[\"85672c7d2de0b7da2bd1770d89665868741b3f9af7643397721d74d28134ab83\",\"7c481b9b5b43b2eb6374049bfa62c2e5e77f17fcc5298f44c8e3094f790313a6\"],[\"948bf809b1988a46b06c9f1919413b10f9226c60f668832ffd959af60c82a0a\",\"53a562856dcb6646dc6b74c5d1c3418c6d4dff08c97cd2bed4cb7f88d8c8e589\"],[\"6260ce7f461801c34f067ce0f02873a8f1b0e44dfc69752accecd819f38fd8e8\",\"bc2da82b6fa5b571a7f09049776a1ef7ecd292238051c198c1a84e95b2b4ae17\"],[\"e5037de0afc1d8d43d8348414bbf4103043ec8f575bfdc432953cc8d2037fa2d\",\"4571534baa94d3b5f9f98d09fb990bddbd5f5b03ec481f10e0e5dc841d755bda\"],[\"e06372b0f4a207adf5ea905e8f1771b4e7e8dbd1c6a6c5b725866a0ae4fce725\",\"7a908974bce18cfe12a27bb2ad5a488cd7484a7787104870b27034f94eee31dd\"],[\"213c7a715cd5d45358d0bbf9dc0ce02204b10bdde2a3f58540ad6908d0559754\",\"4b6dad0b5ae462507013ad06245ba190bb4850f5f36a7eeddff2c27534b458f2\"],[\"4e7c272a7af4b34e8dbb9352a5419a87e2838c70adc62cddf0cc3a3b08fbd53c\",\"17749c766c9d0b18e16fd09f6def681b530b9614bff7dd33e0b3941817dcaae6\"],[\"fea74e3dbe778b1b10f238ad61686aa5c76e3db2be43057632427e2840fb27b6\",\"6e0568db9b0b13297cf674deccb6af93126b596b973f7b77701d3db7f23cb96f\"],[\"76e64113f677cf0e10a2570d599968d31544e179b760432952c02a4417bdde39\",\"c90ddf8dee4e95cf577066d70681f0d35e2a33d2b56d2032b4b1752d1901ac01\"],[\"c738c56b03b2abe1e8281baa743f8f9a8f7cc643df26cbee3ab150242bcbb891\",\"893fb578951ad2537f718f2eacbfbbbb82314eef7880cfe917e735d9699a84c3\"],[\"d895626548b65b81e264c7637c972877d1d72e5f3a925014372e9f6588f6c14b\",\"febfaa38f2bc7eae728ec60818c340eb03428d632bb067e179363ed75d7d991f\"],[\"b8da94032a957518eb0f6433571e8761ceffc73693e84edd49150a564f676e03\",\"2804dfa44805a1e4d7c99cc9762808b092cc584d95ff3b511488e4e74efdf6e7\"],[\"e80fea14441fb33a7d8adab9475d7fab2019effb5156a792f1a11778e3c0df5d\",\"eed1de7f638e00771e89768ca3ca94472d155e80af322ea9fcb4291b6ac9ec78\"],[\"a301697bdfcd704313ba48e51d567543f2a182031efd6915ddc07bbcc4e16070\",\"7370f91cfb67e4f5081809fa25d40f9b1735dbf7c0a11a130c0d1a041e177ea1\"],[\"90ad85b389d6b936463f9d0512678de208cc330b11307fffab7ac63e3fb04ed4\",\"e507a3620a38261affdcbd9427222b839aefabe1582894d991d4d48cb6ef150\"],[\"8f68b9d2f63b5f339239c1ad981f162ee88c5678723ea3351b7b444c9ec4c0da\",\"662a9f2dba063986de1d90c2b6be215dbbea2cfe95510bfdf23cbf79501fff82\"],[\"e4f3fb0176af85d65ff99ff9198c36091f48e86503681e3e6686fd5053231e11\",\"1e63633ad0ef4f1c1661a6d0ea02b7286cc7e74ec951d1c9822c38576feb73bc\"],[\"8c00fa9b18ebf331eb961537a45a4266c7034f2f0d4e1d0716fb6eae20eae29e\",\"efa47267fea521a1a9dc343a3736c974c2fadafa81e36c54e7d2a4c66702414b\"],[\"e7a26ce69dd4829f3e10cec0a9e98ed3143d084f308b92c0997fddfc60cb3e41\",\"2a758e300fa7984b471b006a1aafbb18d0a6b2c0420e83e20e8a9421cf2cfd51\"],[\"b6459e0ee3662ec8d23540c223bcbdc571cbcb967d79424f3cf29eb3de6b80ef\",\"67c876d06f3e06de1dadf16e5661db3c4b3ae6d48e35b2ff30bf0b61a71ba45\"],[\"d68a80c8280bb840793234aa118f06231d6f1fc67e73c5a5deda0f5b496943e8\",\"db8ba9fff4b586d00c4b1f9177b0e28b5b0e7b8f7845295a294c84266b133120\"],[\"324aed7df65c804252dc0270907a30b09612aeb973449cea4095980fc28d3d5d\",\"648a365774b61f2ff130c0c35aec1f4f19213b0c7e332843967224af96ab7c84\"],[\"4df9c14919cde61f6d51dfdbe5fee5dceec4143ba8d1ca888e8bd373fd054c96\",\"35ec51092d8728050974c23a1d85d4b5d506cdc288490192ebac06cad10d5d\"],[\"9c3919a84a474870faed8a9c1cc66021523489054d7f0308cbfc99c8ac1f98cd\",\"ddb84f0f4a4ddd57584f044bf260e641905326f76c64c8e6be7e5e03d4fc599d\"],[\"6057170b1dd12fdf8de05f281d8e06bb91e1493a8b91d4cc5a21382120a959e5\",\"9a1af0b26a6a4807add9a2daf71df262465152bc3ee24c65e899be932385a2a8\"],[\"a576df8e23a08411421439a4518da31880cef0fba7d4df12b1a6973eecb94266\",\"40a6bf20e76640b2c92b97afe58cd82c432e10a7f514d9f3ee8be11ae1b28ec8\"],[\"7778a78c28dec3e30a05fe9629de8c38bb30d1f5cf9a3a208f763889be58ad71\",\"34626d9ab5a5b22ff7098e12f2ff580087b38411ff24ac563b513fc1fd9f43ac\"],[\"928955ee637a84463729fd30e7afd2ed5f96274e5ad7e5cb09eda9c06d903ac\",\"c25621003d3f42a827b78a13093a95eeac3d26efa8a8d83fc5180e935bcd091f\"],[\"85d0fef3ec6db109399064f3a0e3b2855645b4a907ad354527aae75163d82751\",\"1f03648413a38c0be29d496e582cf5663e8751e96877331582c237a24eb1f962\"],[\"ff2b0dce97eece97c1c9b6041798b85dfdfb6d8882da20308f5404824526087e\",\"493d13fef524ba188af4c4dc54d07936c7b7ed6fb90e2ceb2c951e01f0c29907\"],[\"827fbbe4b1e880ea9ed2b2e6301b212b57f1ee148cd6dd28780e5e2cf856e241\",\"c60f9c923c727b0b71bef2c67d1d12687ff7a63186903166d605b68baec293ec\"],[\"eaa649f21f51bdbae7be4ae34ce6e5217a58fdce7f47f9aa7f3b58fa2120e2b3\",\"be3279ed5bbbb03ac69a80f89879aa5a01a6b965f13f7e59d47a5305ba5ad93d\"],[\"e4a42d43c5cf169d9391df6decf42ee541b6d8f0c9a137401e23632dda34d24f\",\"4d9f92e716d1c73526fc99ccfb8ad34ce886eedfa8d8e4f13a7f7131deba9414\"],[\"1ec80fef360cbdd954160fadab352b6b92b53576a88fea4947173b9d4300bf19\",\"aeefe93756b5340d2f3a4958a7abbf5e0146e77f6295a07b671cdc1cc107cefd\"],[\"146a778c04670c2f91b00af4680dfa8bce3490717d58ba889ddb5928366642be\",\"b318e0ec3354028add669827f9d4b2870aaa971d2f7e5ed1d0b297483d83efd0\"],[\"fa50c0f61d22e5f07e3acebb1aa07b128d0012209a28b9776d76a8793180eef9\",\"6b84c6922397eba9b72cd2872281a68a5e683293a57a213b38cd8d7d3f4f2811\"],[\"da1d61d0ca721a11b1a5bf6b7d88e8421a288ab5d5bba5220e53d32b5f067ec2\",\"8157f55a7c99306c79c0766161c91e2966a73899d279b48a655fba0f1ad836f1\"],[\"a8e282ff0c9706907215ff98e8fd416615311de0446f1e062a73b0610d064e13\",\"7f97355b8db81c09abfb7f3c5b2515888b679a3e50dd6bd6cef7c73111f4cc0c\"],[\"174a53b9c9a285872d39e56e6913cab15d59b1fa512508c022f382de8319497c\",\"ccc9dc37abfc9c1657b4155f2c47f9e6646b3a1d8cb9854383da13ac079afa73\"],[\"959396981943785c3d3e57edf5018cdbe039e730e4918b3d884fdff09475b7ba\",\"2e7e552888c331dd8ba0386a4b9cd6849c653f64c8709385e9b8abf87524f2fd\"],[\"d2a63a50ae401e56d645a1153b109a8fcca0a43d561fba2dbb51340c9d82b151\",\"e82d86fb6443fcb7565aee58b2948220a70f750af484ca52d4142174dcf89405\"],[\"64587e2335471eb890ee7896d7cfdc866bacbdbd3839317b3436f9b45617e073\",\"d99fcdd5bf6902e2ae96dd6447c299a185b90a39133aeab358299e5e9faf6589\"],[\"8481bde0e4e4d885b3a546d3e549de042f0aa6cea250e7fd358d6c86dd45e458\",\"38ee7b8cba5404dd84a25bf39cecb2ca900a79c42b262e556d64b1b59779057e\"],[\"13464a57a78102aa62b6979ae817f4637ffcfed3c4b1ce30bcd6303f6caf666b\",\"69be159004614580ef7e433453ccb0ca48f300a81d0942e13f495a907f6ecc27\"],[\"bc4a9df5b713fe2e9aef430bcc1dc97a0cd9ccede2f28588cada3a0d2d83f366\",\"d3a81ca6e785c06383937adf4b798caa6e8a9fbfa547b16d758d666581f33c1\"],[\"8c28a97bf8298bc0d23d8c749452a32e694b65e30a9472a3954ab30fe5324caa\",\"40a30463a3305193378fedf31f7cc0eb7ae784f0451cb9459e71dc73cbef9482\"],[\"8ea9666139527a8c1dd94ce4f071fd23c8b350c5a4bb33748c4ba111faccae0\",\"620efabbc8ee2782e24e7c0cfb95c5d735b783be9cf0f8e955af34a30e62b945\"],[\"dd3625faef5ba06074669716bbd3788d89bdde815959968092f76cc4eb9a9787\",\"7a188fa3520e30d461da2501045731ca941461982883395937f68d00c644a573\"],[\"f710d79d9eb962297e4f6232b40e8f7feb2bc63814614d692c12de752408221e\",\"ea98e67232d3b3295d3b535532115ccac8612c721851617526ae47a9c77bfc82\"]]},naf:{wnd:7,points:[[\"f9308a019258c31049344f85f89d5229b531c845836f99b08601f113bce036f9\",\"388f7b0f632de8140fe337e62a37f3566500a99934c2231b6cb9fd7584b8e672\"],[\"2f8bde4d1a07209355b4a7250a5c5128e88b84bddc619ab7cba8d569b240efe4\",\"d8ac222636e5e3d6d4dba9dda6c9c426f788271bab0d6840dca87d3aa6ac62d6\"],[\"5cbdf0646e5db4eaa398f365f2ea7a0e3d419b7e0330e39ce92bddedcac4f9bc\",\"6aebca40ba255960a3178d6d861a54dba813d0b813fde7b5a5082628087264da\"],[\"acd484e2f0c7f65309ad178a9f559abde09796974c57e714c35f110dfc27ccbe\",\"cc338921b0a7d9fd64380971763b61e9add888a4375f8e0f05cc262ac64f9c37\"],[\"774ae7f858a9411e5ef4246b70c65aac5649980be5c17891bbec17895da008cb\",\"d984a032eb6b5e190243dd56d7b7b365372db1e2dff9d6a8301d74c9c953c61b\"],[\"f28773c2d975288bc7d1d205c3748651b075fbc6610e58cddeeddf8f19405aa8\",\"ab0902e8d880a89758212eb65cdaf473a1a06da521fa91f29b5cb52db03ed81\"],[\"d7924d4f7d43ea965a465ae3095ff41131e5946f3c85f79e44adbcf8e27e080e\",\"581e2872a86c72a683842ec228cc6defea40af2bd896d3a5c504dc9ff6a26b58\"],[\"defdea4cdb677750a420fee807eacf21eb9898ae79b9768766e4faa04a2d4a34\",\"4211ab0694635168e997b0ead2a93daeced1f4a04a95c0f6cfb199f69e56eb77\"],[\"2b4ea0a797a443d293ef5cff444f4979f06acfebd7e86d277475656138385b6c\",\"85e89bc037945d93b343083b5a1c86131a01f60c50269763b570c854e5c09b7a\"],[\"352bbf4a4cdd12564f93fa332ce333301d9ad40271f8107181340aef25be59d5\",\"321eb4075348f534d59c18259dda3e1f4a1b3b2e71b1039c67bd3d8bcf81998c\"],[\"2fa2104d6b38d11b0230010559879124e42ab8dfeff5ff29dc9cdadd4ecacc3f\",\"2de1068295dd865b64569335bd5dd80181d70ecfc882648423ba76b532b7d67\"],[\"9248279b09b4d68dab21a9b066edda83263c3d84e09572e269ca0cd7f5453714\",\"73016f7bf234aade5d1aa71bdea2b1ff3fc0de2a887912ffe54a32ce97cb3402\"],[\"daed4f2be3a8bf278e70132fb0beb7522f570e144bf615c07e996d443dee8729\",\"a69dce4a7d6c98e8d4a1aca87ef8d7003f83c230f3afa726ab40e52290be1c55\"],[\"c44d12c7065d812e8acf28d7cbb19f9011ecd9e9fdf281b0e6a3b5e87d22e7db\",\"2119a460ce326cdc76c45926c982fdac0e106e861edf61c5a039063f0e0e6482\"],[\"6a245bf6dc698504c89a20cfded60853152b695336c28063b61c65cbd269e6b4\",\"e022cf42c2bd4a708b3f5126f16a24ad8b33ba48d0423b6efd5e6348100d8a82\"],[\"1697ffa6fd9de627c077e3d2fe541084ce13300b0bec1146f95ae57f0d0bd6a5\",\"b9c398f186806f5d27561506e4557433a2cf15009e498ae7adee9d63d01b2396\"],[\"605bdb019981718b986d0f07e834cb0d9deb8360ffb7f61df982345ef27a7479\",\"2972d2de4f8d20681a78d93ec96fe23c26bfae84fb14db43b01e1e9056b8c49\"],[\"62d14dab4150bf497402fdc45a215e10dcb01c354959b10cfe31c7e9d87ff33d\",\"80fc06bd8cc5b01098088a1950eed0db01aa132967ab472235f5642483b25eaf\"],[\"80c60ad0040f27dade5b4b06c408e56b2c50e9f56b9b8b425e555c2f86308b6f\",\"1c38303f1cc5c30f26e66bad7fe72f70a65eed4cbe7024eb1aa01f56430bd57a\"],[\"7a9375ad6167ad54aa74c6348cc54d344cc5dc9487d847049d5eabb0fa03c8fb\",\"d0e3fa9eca8726909559e0d79269046bdc59ea10c70ce2b02d499ec224dc7f7\"],[\"d528ecd9b696b54c907a9ed045447a79bb408ec39b68df504bb51f459bc3ffc9\",\"eecf41253136e5f99966f21881fd656ebc4345405c520dbc063465b521409933\"],[\"49370a4b5f43412ea25f514e8ecdad05266115e4a7ecb1387231808f8b45963\",\"758f3f41afd6ed428b3081b0512fd62a54c3f3afbb5b6764b653052a12949c9a\"],[\"77f230936ee88cbbd73df930d64702ef881d811e0e1498e2f1c13eb1fc345d74\",\"958ef42a7886b6400a08266e9ba1b37896c95330d97077cbbe8eb3c7671c60d6\"],[\"f2dac991cc4ce4b9ea44887e5c7c0bce58c80074ab9d4dbaeb28531b7739f530\",\"e0dedc9b3b2f8dad4da1f32dec2531df9eb5fbeb0598e4fd1a117dba703a3c37\"],[\"463b3d9f662621fb1b4be8fbbe2520125a216cdfc9dae3debcba4850c690d45b\",\"5ed430d78c296c3543114306dd8622d7c622e27c970a1de31cb377b01af7307e\"],[\"f16f804244e46e2a09232d4aff3b59976b98fac14328a2d1a32496b49998f247\",\"cedabd9b82203f7e13d206fcdf4e33d92a6c53c26e5cce26d6579962c4e31df6\"],[\"caf754272dc84563b0352b7a14311af55d245315ace27c65369e15f7151d41d1\",\"cb474660ef35f5f2a41b643fa5e460575f4fa9b7962232a5c32f908318a04476\"],[\"2600ca4b282cb986f85d0f1709979d8b44a09c07cb86d7c124497bc86f082120\",\"4119b88753c15bd6a693b03fcddbb45d5ac6be74ab5f0ef44b0be9475a7e4b40\"],[\"7635ca72d7e8432c338ec53cd12220bc01c48685e24f7dc8c602a7746998e435\",\"91b649609489d613d1d5e590f78e6d74ecfc061d57048bad9e76f302c5b9c61\"],[\"754e3239f325570cdbbf4a87deee8a66b7f2b33479d468fbc1a50743bf56cc18\",\"673fb86e5bda30fb3cd0ed304ea49a023ee33d0197a695d0c5d98093c536683\"],[\"e3e6bd1071a1e96aff57859c82d570f0330800661d1c952f9fe2694691d9b9e8\",\"59c9e0bba394e76f40c0aa58379a3cb6a5a2283993e90c4167002af4920e37f5\"],[\"186b483d056a033826ae73d88f732985c4ccb1f32ba35f4b4cc47fdcf04aa6eb\",\"3b952d32c67cf77e2e17446e204180ab21fb8090895138b4a4a797f86e80888b\"],[\"df9d70a6b9876ce544c98561f4be4f725442e6d2b737d9c91a8321724ce0963f\",\"55eb2dafd84d6ccd5f862b785dc39d4ab157222720ef9da217b8c45cf2ba2417\"],[\"5edd5cc23c51e87a497ca815d5dce0f8ab52554f849ed8995de64c5f34ce7143\",\"efae9c8dbc14130661e8cec030c89ad0c13c66c0d17a2905cdc706ab7399a868\"],[\"290798c2b6476830da12fe02287e9e777aa3fba1c355b17a722d362f84614fba\",\"e38da76dcd440621988d00bcf79af25d5b29c094db2a23146d003afd41943e7a\"],[\"af3c423a95d9f5b3054754efa150ac39cd29552fe360257362dfdecef4053b45\",\"f98a3fd831eb2b749a93b0e6f35cfb40c8cd5aa667a15581bc2feded498fd9c6\"],[\"766dbb24d134e745cccaa28c99bf274906bb66b26dcf98df8d2fed50d884249a\",\"744b1152eacbe5e38dcc887980da38b897584a65fa06cedd2c924f97cbac5996\"],[\"59dbf46f8c94759ba21277c33784f41645f7b44f6c596a58ce92e666191abe3e\",\"c534ad44175fbc300f4ea6ce648309a042ce739a7919798cd85e216c4a307f6e\"],[\"f13ada95103c4537305e691e74e9a4a8dd647e711a95e73cb62dc6018cfd87b8\",\"e13817b44ee14de663bf4bc808341f326949e21a6a75c2570778419bdaf5733d\"],[\"7754b4fa0e8aced06d4167a2c59cca4cda1869c06ebadfb6488550015a88522c\",\"30e93e864e669d82224b967c3020b8fa8d1e4e350b6cbcc537a48b57841163a2\"],[\"948dcadf5990e048aa3874d46abef9d701858f95de8041d2a6828c99e2262519\",\"e491a42537f6e597d5d28a3224b1bc25df9154efbd2ef1d2cbba2cae5347d57e\"],[\"7962414450c76c1689c7b48f8202ec37fb224cf5ac0bfa1570328a8a3d7c77ab\",\"100b610ec4ffb4760d5c1fc133ef6f6b12507a051f04ac5760afa5b29db83437\"],[\"3514087834964b54b15b160644d915485a16977225b8847bb0dd085137ec47ca\",\"ef0afbb2056205448e1652c48e8127fc6039e77c15c2378b7e7d15a0de293311\"],[\"d3cc30ad6b483e4bc79ce2c9dd8bc54993e947eb8df787b442943d3f7b527eaf\",\"8b378a22d827278d89c5e9be8f9508ae3c2ad46290358630afb34db04eede0a4\"],[\"1624d84780732860ce1c78fcbfefe08b2b29823db913f6493975ba0ff4847610\",\"68651cf9b6da903e0914448c6cd9d4ca896878f5282be4c8cc06e2a404078575\"],[\"733ce80da955a8a26902c95633e62a985192474b5af207da6df7b4fd5fc61cd4\",\"f5435a2bd2badf7d485a4d8b8db9fcce3e1ef8e0201e4578c54673bc1dc5ea1d\"],[\"15d9441254945064cf1a1c33bbd3b49f8966c5092171e699ef258dfab81c045c\",\"d56eb30b69463e7234f5137b73b84177434800bacebfc685fc37bbe9efe4070d\"],[\"a1d0fcf2ec9de675b612136e5ce70d271c21417c9d2b8aaaac138599d0717940\",\"edd77f50bcb5a3cab2e90737309667f2641462a54070f3d519212d39c197a629\"],[\"e22fbe15c0af8ccc5780c0735f84dbe9a790badee8245c06c7ca37331cb36980\",\"a855babad5cd60c88b430a69f53a1a7a38289154964799be43d06d77d31da06\"],[\"311091dd9860e8e20ee13473c1155f5f69635e394704eaa74009452246cfa9b3\",\"66db656f87d1f04fffd1f04788c06830871ec5a64feee685bd80f0b1286d8374\"],[\"34c1fd04d301be89b31c0442d3e6ac24883928b45a9340781867d4232ec2dbdf\",\"9414685e97b1b5954bd46f730174136d57f1ceeb487443dc5321857ba73abee\"],[\"f219ea5d6b54701c1c14de5b557eb42a8d13f3abbcd08affcc2a5e6b049b8d63\",\"4cb95957e83d40b0f73af4544cccf6b1f4b08d3c07b27fb8d8c2962a400766d1\"],[\"d7b8740f74a8fbaab1f683db8f45de26543a5490bca627087236912469a0b448\",\"fa77968128d9c92ee1010f337ad4717eff15db5ed3c049b3411e0315eaa4593b\"],[\"32d31c222f8f6f0ef86f7c98d3a3335ead5bcd32abdd94289fe4d3091aa824bf\",\"5f3032f5892156e39ccd3d7915b9e1da2e6dac9e6f26e961118d14b8462e1661\"],[\"7461f371914ab32671045a155d9831ea8793d77cd59592c4340f86cbc18347b5\",\"8ec0ba238b96bec0cbdddcae0aa442542eee1ff50c986ea6b39847b3cc092ff6\"],[\"ee079adb1df1860074356a25aa38206a6d716b2c3e67453d287698bad7b2b2d6\",\"8dc2412aafe3be5c4c5f37e0ecc5f9f6a446989af04c4e25ebaac479ec1c8c1e\"],[\"16ec93e447ec83f0467b18302ee620f7e65de331874c9dc72bfd8616ba9da6b5\",\"5e4631150e62fb40d0e8c2a7ca5804a39d58186a50e497139626778e25b0674d\"],[\"eaa5f980c245f6f038978290afa70b6bd8855897f98b6aa485b96065d537bd99\",\"f65f5d3e292c2e0819a528391c994624d784869d7e6ea67fb18041024edc07dc\"],[\"78c9407544ac132692ee1910a02439958ae04877151342ea96c4b6b35a49f51\",\"f3e0319169eb9b85d5404795539a5e68fa1fbd583c064d2462b675f194a3ddb4\"],[\"494f4be219a1a77016dcd838431aea0001cdc8ae7a6fc688726578d9702857a5\",\"42242a969283a5f339ba7f075e36ba2af925ce30d767ed6e55f4b031880d562c\"],[\"a598a8030da6d86c6bc7f2f5144ea549d28211ea58faa70ebf4c1e665c1fe9b5\",\"204b5d6f84822c307e4b4a7140737aec23fc63b65b35f86a10026dbd2d864e6b\"],[\"c41916365abb2b5d09192f5f2dbeafec208f020f12570a184dbadc3e58595997\",\"4f14351d0087efa49d245b328984989d5caf9450f34bfc0ed16e96b58fa9913\"],[\"841d6063a586fa475a724604da03bc5b92a2e0d2e0a36acfe4c73a5514742881\",\"73867f59c0659e81904f9a1c7543698e62562d6744c169ce7a36de01a8d6154\"],[\"5e95bb399a6971d376026947f89bde2f282b33810928be4ded112ac4d70e20d5\",\"39f23f366809085beebfc71181313775a99c9aed7d8ba38b161384c746012865\"],[\"36e4641a53948fd476c39f8a99fd974e5ec07564b5315d8bf99471bca0ef2f66\",\"d2424b1b1abe4eb8164227b085c9aa9456ea13493fd563e06fd51cf5694c78fc\"],[\"336581ea7bfbbb290c191a2f507a41cf5643842170e914faeab27c2c579f726\",\"ead12168595fe1be99252129b6e56b3391f7ab1410cd1e0ef3dcdcabd2fda224\"],[\"8ab89816dadfd6b6a1f2634fcf00ec8403781025ed6890c4849742706bd43ede\",\"6fdcef09f2f6d0a044e654aef624136f503d459c3e89845858a47a9129cdd24e\"],[\"1e33f1a746c9c5778133344d9299fcaa20b0938e8acff2544bb40284b8c5fb94\",\"60660257dd11b3aa9c8ed618d24edff2306d320f1d03010e33a7d2057f3b3b6\"],[\"85b7c1dcb3cec1b7ee7f30ded79dd20a0ed1f4cc18cbcfcfa410361fd8f08f31\",\"3d98a9cdd026dd43f39048f25a8847f4fcafad1895d7a633c6fed3c35e999511\"],[\"29df9fbd8d9e46509275f4b125d6d45d7fbe9a3b878a7af872a2800661ac5f51\",\"b4c4fe99c775a606e2d8862179139ffda61dc861c019e55cd2876eb2a27d84b\"],[\"a0b1cae06b0a847a3fea6e671aaf8adfdfe58ca2f768105c8082b2e449fce252\",\"ae434102edde0958ec4b19d917a6a28e6b72da1834aff0e650f049503a296cf2\"],[\"4e8ceafb9b3e9a136dc7ff67e840295b499dfb3b2133e4ba113f2e4c0e121e5\",\"cf2174118c8b6d7a4b48f6d534ce5c79422c086a63460502b827ce62a326683c\"],[\"d24a44e047e19b6f5afb81c7ca2f69080a5076689a010919f42725c2b789a33b\",\"6fb8d5591b466f8fc63db50f1c0f1c69013f996887b8244d2cdec417afea8fa3\"],[\"ea01606a7a6c9cdd249fdfcfacb99584001edd28abbab77b5104e98e8e3b35d4\",\"322af4908c7312b0cfbfe369f7a7b3cdb7d4494bc2823700cfd652188a3ea98d\"],[\"af8addbf2b661c8a6c6328655eb96651252007d8c5ea31be4ad196de8ce2131f\",\"6749e67c029b85f52a034eafd096836b2520818680e26ac8f3dfbcdb71749700\"],[\"e3ae1974566ca06cc516d47e0fb165a674a3dabcfca15e722f0e3450f45889\",\"2aeabe7e4531510116217f07bf4d07300de97e4874f81f533420a72eeb0bd6a4\"],[\"591ee355313d99721cf6993ffed1e3e301993ff3ed258802075ea8ced397e246\",\"b0ea558a113c30bea60fc4775460c7901ff0b053d25ca2bdeee98f1a4be5d196\"],[\"11396d55fda54c49f19aa97318d8da61fa8584e47b084945077cf03255b52984\",\"998c74a8cd45ac01289d5833a7beb4744ff536b01b257be4c5767bea93ea57a4\"],[\"3c5d2a1ba39c5a1790000738c9e0c40b8dcdfd5468754b6405540157e017aa7a\",\"b2284279995a34e2f9d4de7396fc18b80f9b8b9fdd270f6661f79ca4c81bd257\"],[\"cc8704b8a60a0defa3a99a7299f2e9c3fbc395afb04ac078425ef8a1793cc030\",\"bdd46039feed17881d1e0862db347f8cf395b74fc4bcdc4e940b74e3ac1f1b13\"],[\"c533e4f7ea8555aacd9777ac5cad29b97dd4defccc53ee7ea204119b2889b197\",\"6f0a256bc5efdf429a2fb6242f1a43a2d9b925bb4a4b3a26bb8e0f45eb596096\"],[\"c14f8f2ccb27d6f109f6d08d03cc96a69ba8c34eec07bbcf566d48e33da6593\",\"c359d6923bb398f7fd4473e16fe1c28475b740dd098075e6c0e8649113dc3a38\"],[\"a6cbc3046bc6a450bac24789fa17115a4c9739ed75f8f21ce441f72e0b90e6ef\",\"21ae7f4680e889bb130619e2c0f95a360ceb573c70603139862afd617fa9b9f\"],[\"347d6d9a02c48927ebfb86c1359b1caf130a3c0267d11ce6344b39f99d43cc38\",\"60ea7f61a353524d1c987f6ecec92f086d565ab687870cb12689ff1e31c74448\"],[\"da6545d2181db8d983f7dcb375ef5866d47c67b1bf31c8cf855ef7437b72656a\",\"49b96715ab6878a79e78f07ce5680c5d6673051b4935bd897fea824b77dc208a\"],[\"c40747cc9d012cb1a13b8148309c6de7ec25d6945d657146b9d5994b8feb1111\",\"5ca560753be2a12fc6de6caf2cb489565db936156b9514e1bb5e83037e0fa2d4\"],[\"4e42c8ec82c99798ccf3a610be870e78338c7f713348bd34c8203ef4037f3502\",\"7571d74ee5e0fb92a7a8b33a07783341a5492144cc54bcc40a94473693606437\"],[\"3775ab7089bc6af823aba2e1af70b236d251cadb0c86743287522a1b3b0dedea\",\"be52d107bcfa09d8bcb9736a828cfa7fac8db17bf7a76a2c42ad961409018cf7\"],[\"cee31cbf7e34ec379d94fb814d3d775ad954595d1314ba8846959e3e82f74e26\",\"8fd64a14c06b589c26b947ae2bcf6bfa0149ef0be14ed4d80f448a01c43b1c6d\"],[\"b4f9eaea09b6917619f6ea6a4eb5464efddb58fd45b1ebefcdc1a01d08b47986\",\"39e5c9925b5a54b07433a4f18c61726f8bb131c012ca542eb24a8ac07200682a\"],[\"d4263dfc3d2df923a0179a48966d30ce84e2515afc3dccc1b77907792ebcc60e\",\"62dfaf07a0f78feb30e30d6295853ce189e127760ad6cf7fae164e122a208d54\"],[\"48457524820fa65a4f8d35eb6930857c0032acc0a4a2de422233eeda897612c4\",\"25a748ab367979d98733c38a1fa1c2e7dc6cc07db2d60a9ae7a76aaa49bd0f77\"],[\"dfeeef1881101f2cb11644f3a2afdfc2045e19919152923f367a1767c11cceda\",\"ecfb7056cf1de042f9420bab396793c0c390bde74b4bbdff16a83ae09a9a7517\"],[\"6d7ef6b17543f8373c573f44e1f389835d89bcbc6062ced36c82df83b8fae859\",\"cd450ec335438986dfefa10c57fea9bcc521a0959b2d80bbf74b190dca712d10\"],[\"e75605d59102a5a2684500d3b991f2e3f3c88b93225547035af25af66e04541f\",\"f5c54754a8f71ee540b9b48728473e314f729ac5308b06938360990e2bfad125\"],[\"eb98660f4c4dfaa06a2be453d5020bc99a0c2e60abe388457dd43fefb1ed620c\",\"6cb9a8876d9cb8520609af3add26cd20a0a7cd8a9411131ce85f44100099223e\"],[\"13e87b027d8514d35939f2e6892b19922154596941888336dc3563e3b8dba942\",\"fef5a3c68059a6dec5d624114bf1e91aac2b9da568d6abeb2570d55646b8adf1\"],[\"ee163026e9fd6fe017c38f06a5be6fc125424b371ce2708e7bf4491691e5764a\",\"1acb250f255dd61c43d94ccc670d0f58f49ae3fa15b96623e5430da0ad6c62b2\"],[\"b268f5ef9ad51e4d78de3a750c2dc89b1e626d43505867999932e5db33af3d80\",\"5f310d4b3c99b9ebb19f77d41c1dee018cf0d34fd4191614003e945a1216e423\"],[\"ff07f3118a9df035e9fad85eb6c7bfe42b02f01ca99ceea3bf7ffdba93c4750d\",\"438136d603e858a3a5c440c38eccbaddc1d2942114e2eddd4740d098ced1f0d8\"],[\"8d8b9855c7c052a34146fd20ffb658bea4b9f69e0d825ebec16e8c3ce2b526a1\",\"cdb559eedc2d79f926baf44fb84ea4d44bcf50fee51d7ceb30e2e7f463036758\"],[\"52db0b5384dfbf05bfa9d472d7ae26dfe4b851ceca91b1eba54263180da32b63\",\"c3b997d050ee5d423ebaf66a6db9f57b3180c902875679de924b69d84a7b375\"],[\"e62f9490d3d51da6395efd24e80919cc7d0f29c3f3fa48c6fff543becbd43352\",\"6d89ad7ba4876b0b22c2ca280c682862f342c8591f1daf5170e07bfd9ccafa7d\"],[\"7f30ea2476b399b4957509c88f77d0191afa2ff5cb7b14fd6d8e7d65aaab1193\",\"ca5ef7d4b231c94c3b15389a5f6311e9daff7bb67b103e9880ef4bff637acaec\"],[\"5098ff1e1d9f14fb46a210fada6c903fef0fb7b4a1dd1d9ac60a0361800b7a00\",\"9731141d81fc8f8084d37c6e7542006b3ee1b40d60dfe5362a5b132fd17ddc0\"],[\"32b78c7de9ee512a72895be6b9cbefa6e2f3c4ccce445c96b9f2c81e2778ad58\",\"ee1849f513df71e32efc3896ee28260c73bb80547ae2275ba497237794c8753c\"],[\"e2cb74fddc8e9fbcd076eef2a7c72b0ce37d50f08269dfc074b581550547a4f7\",\"d3aa2ed71c9dd2247a62df062736eb0baddea9e36122d2be8641abcb005cc4a4\"],[\"8438447566d4d7bedadc299496ab357426009a35f235cb141be0d99cd10ae3a8\",\"c4e1020916980a4da5d01ac5e6ad330734ef0d7906631c4f2390426b2edd791f\"],[\"4162d488b89402039b584c6fc6c308870587d9c46f660b878ab65c82c711d67e\",\"67163e903236289f776f22c25fb8a3afc1732f2b84b4e95dbda47ae5a0852649\"],[\"3fad3fa84caf0f34f0f89bfd2dcf54fc175d767aec3e50684f3ba4a4bf5f683d\",\"cd1bc7cb6cc407bb2f0ca647c718a730cf71872e7d0d2a53fa20efcdfe61826\"],[\"674f2600a3007a00568c1a7ce05d0816c1fb84bf1370798f1c69532faeb1a86b\",\"299d21f9413f33b3edf43b257004580b70db57da0b182259e09eecc69e0d38a5\"],[\"d32f4da54ade74abb81b815ad1fb3b263d82d6c692714bcff87d29bd5ee9f08f\",\"f9429e738b8e53b968e99016c059707782e14f4535359d582fc416910b3eea87\"],[\"30e4e670435385556e593657135845d36fbb6931f72b08cb1ed954f1e3ce3ff6\",\"462f9bce619898638499350113bbc9b10a878d35da70740dc695a559eb88db7b\"],[\"be2062003c51cc3004682904330e4dee7f3dcd10b01e580bf1971b04d4cad297\",\"62188bc49d61e5428573d48a74e1c655b1c61090905682a0d5558ed72dccb9bc\"],[\"93144423ace3451ed29e0fb9ac2af211cb6e84a601df5993c419859fff5df04a\",\"7c10dfb164c3425f5c71a3f9d7992038f1065224f72bb9d1d902a6d13037b47c\"],[\"b015f8044f5fcbdcf21ca26d6c34fb8197829205c7b7d2a7cb66418c157b112c\",\"ab8c1e086d04e813744a655b2df8d5f83b3cdc6faa3088c1d3aea1454e3a1d5f\"],[\"d5e9e1da649d97d89e4868117a465a3a4f8a18de57a140d36b3f2af341a21b52\",\"4cb04437f391ed73111a13cc1d4dd0db1693465c2240480d8955e8592f27447a\"],[\"d3ae41047dd7ca065dbf8ed77b992439983005cd72e16d6f996a5316d36966bb\",\"bd1aeb21ad22ebb22a10f0303417c6d964f8cdd7df0aca614b10dc14d125ac46\"],[\"463e2763d885f958fc66cdd22800f0a487197d0a82e377b49f80af87c897b065\",\"bfefacdb0e5d0fd7df3a311a94de062b26b80c61fbc97508b79992671ef7ca7f\"],[\"7985fdfd127c0567c6f53ec1bb63ec3158e597c40bfe747c83cddfc910641917\",\"603c12daf3d9862ef2b25fe1de289aed24ed291e0ec6708703a5bd567f32ed03\"],[\"74a1ad6b5f76e39db2dd249410eac7f99e74c59cb83d2d0ed5ff1543da7703e9\",\"cc6157ef18c9c63cd6193d83631bbea0093e0968942e8c33d5737fd790e0db08\"],[\"30682a50703375f602d416664ba19b7fc9bab42c72747463a71d0896b22f6da3\",\"553e04f6b018b4fa6c8f39e7f311d3176290d0e0f19ca73f17714d9977a22ff8\"],[\"9e2158f0d7c0d5f26c3791efefa79597654e7a2b2464f52b1ee6c1347769ef57\",\"712fcdd1b9053f09003a3481fa7762e9ffd7c8ef35a38509e2fbf2629008373\"],[\"176e26989a43c9cfeba4029c202538c28172e566e3c4fce7322857f3be327d66\",\"ed8cc9d04b29eb877d270b4878dc43c19aefd31f4eee09ee7b47834c1fa4b1c3\"],[\"75d46efea3771e6e68abb89a13ad747ecf1892393dfc4f1b7004788c50374da8\",\"9852390a99507679fd0b86fd2b39a868d7efc22151346e1a3ca4726586a6bed8\"],[\"809a20c67d64900ffb698c4c825f6d5f2310fb0451c869345b7319f645605721\",\"9e994980d9917e22b76b061927fa04143d096ccc54963e6a5ebfa5f3f8e286c1\"],[\"1b38903a43f7f114ed4500b4eac7083fdefece1cf29c63528d563446f972c180\",\"4036edc931a60ae889353f77fd53de4a2708b26b6f5da72ad3394119daf408f9\"]]}}]};this.p=new t(e.p,16),this.red=new i(e.prime),this.zero=new t(0).toRed(this.red),this.one=new t(1).toRed(this.red),this.two=new t(2).toRed(this.red),this.n=new t(e.n,16),this.g=at.fromJSON(e.g,e.gRed),this._wnafT1=new Array(4),this._wnafT2=new Array(4),this._wnafT3=new Array(4),this._wnafT4=new Array(4),this._bitLength=this.n.bitLength(),this.redN=this.n.toRed(this.red),this.a=new t(e.a,16).toRed(this.red),this.b=new t(e.b,16).toRed(this.red),this.tinv=this.two.redInvm(),this.zeroA=0===this.a.fromRed().cmpn(0),this.threeA=0===this.a.fromRed().sub(this.p).cmpn(-3),this.endo=this._getEndomorphism(e),this._endoWnafT1=new Array(4),this._endoWnafT2=new Array(4)}_getEndomorphism(e){if(!this.zeroA||1!==this.p.modrn(3))return;let r,i,s;if(void 0!==e.beta)r=new t(e.beta,16).toRed(this.red);else{const t=this._getEndoRoots(this.p);if(null===t)throw new Error(\"Failed to get endomorphism roots for beta.\");r=t[0].cmp(t[1])<0?t[0]:t[1],r=r.toRed(this.red)}if(void 0!==e.lambda)i=new t(e.lambda,16);else{const t=this._getEndoRoots(this.n);if(null===t)throw new Error(\"Failed to get endomorphism roots for lambda.\");if(null==this.g)throw new Error(\"Curve generator point (g) is not defined.\");const e=this.g.mul(t[0])?.x,s=null!=this.g.x?this.g.x.redMul(r):void 0;if(null!=e&&null!=s&&0===e.cmp(s))i=t[0];else{if(i=t[1],null==this.g)throw new Error(\"Curve generator point (g) is not defined.\");const e=this.g.mul(i)?.x,s=null!=this.g.x?this.g.x.redMul(r):void 0;if(null==e||null==s)throw new Error(\"Lambda computation failed: g.mul(lambda).x or g.x.redMul(beta) is undefined.\");ct.assert(0===e.cmp(s),\"Lambda selection does not match computed beta.\")}}return s=\"object\"==typeof e.basis&&null!==e.basis?e.basis.map((function(e){return{a:new t(e.a,16),b:new t(e.b,16)}})):this._getEndoBasis(i),{beta:r,lambda:i,basis:s}}_getEndoRoots(e){const r=e===this.p?this.red:new s(e),i=new t(2).toRed(r).redInvm(),n=i.redNeg(),a=new t(3).toRed(r).redNeg().redSqrt().redMul(i);return[n.redAdd(a).fromRed(),n.redSub(a).fromRed()]}_getEndoBasis(e){const r=this.n.ushrn(Math.floor(this.n.bitLength()/2));let i,s,n,a,o,c,h=e,d=this.n.clone(),u=new t(1),f=new t(0),l=new t(0),b=new t(1),p=new t(0),g=0,m=new t(0),w=new t(0);for(;0!==h.cmpn(0);){const t=d.div(h);m=d.sub(t.mul(h)),w=l.sub(t.mul(u));const e=b.sub(t.mul(f));if(void 0===n&&m.cmp(r)<0)i=p.neg(),s=u,n=m.neg(),a=w;else if(void 0!==n&&2==++g)break;p=m,d=h,h=m,l=u,u=w,b=f,f=e}if(void 0===i||void 0===s||void 0===n||void 0===a)throw new Error(\"Failed to compute Endo Basis values\");o=m.neg(),c=w;const y=n.sqr().add(a.sqr());return o.sqr().add(c.sqr()).cmp(y)>=0&&(o=i,c=s),0!==n.negative&&(n=n.neg(),a=a.neg()),0!==o.negative&&(o=o.neg(),c=c.neg()),[{a:n,b:a},{a:o,b:c}]}_endoSplit(t){if(null==this.endo)throw new Error(\"Endomorphism is not defined.\");const e=this.endo.basis,r=e[0],i=e[1],s=i.b.mul(t).divRound(this.n),n=r.b.neg().mul(t).divRound(this.n),a=s.mul(r.a),o=n.mul(i.a),c=s.mul(r.b),h=n.mul(i.b);return{k1:t.sub(a).sub(o),k2:c.add(h).neg()}}validate(t){if(t.inf)return!0;const e=t.x,r=t.y;if(null===e||null===r)throw new Error(\"Point coordinates cannot be null\");const i=this.a.redMul(e),s=e.redSqr().redMul(e).redIAdd(i).redIAdd(this.b);return 0===r.redSqr().redISub(s).cmpn(0)}}class ht{r;s;static fromDER(e,r){const i=(t,e)=>{const r=t[e.place++];if(128&r)throw new Error(\"Invalid DER entity length\");return r};e=j(e,r);const s=new class{place;constructor(){this.place=0}};if(48!==e[s.place++])throw new Error(\"Signature DER must start with 0x30\");if(i(e,s)+s.place!==e.length)throw new Error(\"Signature DER invalid\");if(2!==e[s.place++])throw new Error(\"Signature DER invalid\");const n=i(e,s);let a=e.slice(s.place,n+s.place);if(s.place+=n,2!==e[s.place++])throw new Error(\"Signature DER invalid\");const o=i(e,s);if(e.length!==o+s.place)throw new Error(\"Invalid R-length in signature DER\");let c=e.slice(s.place,o+s.place);if(0===a[0]){if(!(128&a[1]))throw new Error(\"Invalid R-value in signature DER\");a=a.slice(1)}if(0===c[0]){if(!(128&c[1]))throw new Error(\"Invalid S-value in signature DER\");c=c.slice(1)}return new ht(new t(a),new t(c))}static fromCompact(e,r){if(65!==(e=j(e,r)).length)throw new Error(\"Invalid Compact Signature\");const i=e[0];if(i<27||i>=35)throw new Error(\"Invalid Compact Byte\");return new ht(new t(e.slice(1,33)),new t(e.slice(33,65)))}constructor(t,e){this.r=t,this.s=e}verify(e,r,i){const s=new t(C(e,i),16);return lt(s,this,r)}toString(t){return this.toDER(t)}toDER(t){const e=(t,e)=>{if(!(e<128))throw new Error(\"len must be < 0x80\");t.push(e)},r=t=>{let e=0;const r=t.length-1;for(;0===t[e]&&!(128&t[e+1])&&e<r;)e++;return 0===e?t:t.slice(e)};let i=this.r.toArray(),s=this.s.toArray();for(128&i[0]&&(i=[0].concat(i)),128&s[0]&&(s=[0].concat(s)),i=r(i),s=r(s);0===s[0]&&!(128&s[1]);)s=s.slice(1);let n=[2];e(n,i.length),n=n.concat(i),n.push(2),e(n,s.length);const a=n.concat(s);let o=[48];return e(o,a.length),o=o.concat(a),\"hex\"===t?K(o):\"base64\"===t?G(o):o}toCompact(t,e,r){if(t<0||t>3)throw new Error(\"Invalid recovery param\");if(\"boolean\"!=typeof e)throw new Error(\"Invalid compressed param\");let i=27+t;e&&(i+=4);let s=[i];return s=s.concat(this.r.toArray(\"be\",32)),s=s.concat(this.s.toArray(\"be\",32)),\"hex\"===r?K(s):\"base64\"===r?G(s):s}RecoverPublicKey(t,e){const r=this.r,i=this.s,s=!!(1&t),n=t>>1,a=new ct,o=a.n,c=a.g,h=0!==n?r.add(o):r,d=at.fromX(h,s);if(!d.mul(o).isInfinity())throw new Error(\"nR is not at infinity\");const u=e.neg().umod(o),f=r.invm(o),l=f.mul(i).umod(o),b=f.mul(u).umod(o),p=c.mul(b).add(d.mul(l)),g=new bt(p);return g.validate(),g}CalculateRecoveryFactor(t,e){for(let r=0;r<4;r++){let i;try{i=this.RecoverPublicKey(r,e)}catch{continue}if(t.eq(i))return r}throw new Error(\"Unable to find valid recovery factor\")}}class dt{K;V;constructor(t,e){if(t=j(t,\"hex\"),e=j(e,\"hex\"),t.length<32)throw new Error(\"Not enough entropy. Minimum is 256 bits\");const r=t.concat(e);this.K=new Array(32),this.V=new Array(32);for(let t=0;t<32;t++)this.K[t]=0,this.V[t]=1;this.update(r)}hmac(){return new D(this.K)}update(t){let e=this.hmac().update(this.V).update([0]);void 0!==t&&(e=e.update(t)),this.K=e.digest(),this.V=this.hmac().update(this.V).digest(),void 0!==t&&(this.K=this.hmac().update(this.V).update([1]).update(t).digest(),this.V=this.hmac().update(this.V).digest())}generate(t){let e=[];for(;e.length<t;)this.V=this.hmac().update(this.V).digest(),e=e.concat(this.V);const r=e.slice(0,t);return this.update(),K(r)}}function ut(t,e,r=new ct){const i=8*t.byteLength()-r.n.bitLength();return i>0&&t.iushrn(i),null===e&&t.cmp(r.n)>=0?t.sub(r.n):t}const ft=(e,r,i=!1,s)=>{if(\"function\"==typeof BigInt){const n=BigInt(0),a=BigInt(1),o=BigInt(2),c=BigInt(\"0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141\"),h=BigInt(\"0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEFFFFFC2F\"),d={x:BigInt(\"0x79BE667EF9DCBBAC55A06295CE870B07029BFCDB2DCE28D959F2815B16F81798\"),y:BigInt(\"0x483ADA7726A3C4655DA4FBFC0E1108A8FD17B448A68554199C47D08FFB10D4B8\")},u=BigInt(\"0x\"+e.toString(16)),f=BigInt(\"0x\"+r.toString(16));if(f<=n||f>=c)throw new Error(\"Invalid private key\");function l(t,e){const r=t.toString(16).padStart(2*e,\"0\"),i=new Uint8Array(e);for(let t=0;t<e;t++)i[t]=parseInt(r.substr(2*t,2),16);return i}const b=32,p=l(f,b),g=l(u,b),m=new dt(Array.from(p),Array.from(g)),w=c-a;let y=0;function v(t,e,r=!0){const i=t.toString(2).length-e.toString(2).length;return i>0&&(t>>=BigInt(i)),!r&&t>=e?t-e:t}function P(e){if(\"function\"==typeof e){const t=e(y).toString(16);return BigInt(\"0x\"+t)}if(null!=e&&t.isBN(e)){const t=e.toString(16);return BigInt(\"0x\"+t)}{const t=m.generate(b);return BigInt(\"0x\"+t)}}function O(t,e){return(t%e+e)%e}function E(t,e){let r=a,i=n,s=O(t,e),o=e;for(;s>a;){const t=o/s,e=i-r*t,n=o-s*t;i=r,r=e,o=s,s=n}return O(r,e)}function k(t,e){if(null===t)return e;if(null===e)return t;if(t.x===e.x&&t.y===O(-e.y,h))return null;let r;if(t.x===e.x&&t.y===e.y){if(t.y===n)return null;const e=O(BigInt(3)*t.x*t.x,h);r=O(e*E(o*t.y,h),h)}else{const i=O(e.y-t.y,h);r=O(i*E(e.x-t.x,h),h)}const i=O(r*r-t.x-e.x,h);return{x:i,y:O(r*(t.x-i)-t.y,h)}}function _(t,e){let r=e,i=null;for(;t>BigInt(0);)t%BigInt(2)===BigInt(1)&&(i=null===i?r:k(i,r)??i),r=k(r,r)??r,t>>=BigInt(1);if(null===i)throw new Error(\"Scalar multiplication resulted in an invalid point.\");return i}let x=!1;for(;!x;){y+=1,x=!0,y+=1;let I=P(s);if(I=v(I,c,!0),I<=a||I>=w){if(s instanceof t)throw new Error(\"Invalid fixed custom K value (must be more than 1 and less than N-1)\");continue}const S=_(I,d);if(null===S){if(s instanceof t)throw new Error(\"Invalid fixed custom K value (must not create a point at infinity when multiplied by the generator point)\");continue}const A=O(S.x,c);if(A===n){if(s instanceof t)throw new Error(\"Invalid fixed custom K value (when multiplied by G, the resulting x coordinate mod N must not be zero)\");continue}const M=E(I,c),T=O(A*f,c);let N=O(M*(u+T),c);if(N===n){if(s instanceof t)throw new Error(\"Invalid fixed custom K value (when used with the key, it cannot create a zero value for S)\");continue}i&&N>c/o&&(N=c-N);const F=new t(A.toString(16),16),B=new t(N.toString(16),16);return new ht(F,B)}}else{const R=new ct;e=ut(e);const U=R.n.byteLength(),L=r.toArray(\"be\",U),D=e.toArray(\"be\",U),C=new dt(L,D),H=R.n.subn(1);for(let q=0;;q++){let V=\"function\"==typeof s?s(q):t.isBN(s)?s:new t(C.generate(U),16);if(null==V)throw new Error(\"k is undefined\");if(V=ut(V,!0),V.cmpn(1)<=0||V.cmp(H)>=0){if(t.isBN(s))throw new Error(\"Invalid fixed custom K value (must be more than 1 and less than N-1)\");continue}const $=R.g.mul(V);if($.isInfinity()){if(t.isBN(s))throw new Error(\"Invalid fixed custom K value (must not create a point at infinity when multiplied by the generator point)\");continue}const K=$.getX().umod(R.n);if(0===K.cmpn(0)){if(t.isBN(s))throw new Error(\"Invalid fixed custom K value (when multiplied by G, the resulting x coordinate mod N must not be zero)\");continue}let j=V.invm(R.n).mul(K.mul(r).iadd(e));if(j=j.umod(R.n),0!==j.cmpn(0))return i&&j.cmp(R.n.ushrn(1))>0&&(j=R.n.sub(j)),new ht(K,j);if(t.isBN(s))throw new Error(\"Invalid fixed custom K value (when used with the key, it cannot create a zero value for S)\")}}throw new Error(\"Failed to generate a valid signature\")},lt=(t,e,r)=>{if(\"function\"==typeof BigInt){const i=BigInt(0),s=BigInt(1),n=BigInt(2),a=BigInt(3),o=BigInt(\"0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEFFFFFC2F\"),c=BigInt(\"0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141\"),h={x:BigInt(\"0x79BE667EF9DCBBAC55A06295CE870B07029BFCDB2DCE28D959F2815B16F81798\"),y:BigInt(\"0x483ADA7726A3C4655DA4FBFC0E1108A8FD17B448A68554199C47D08FFB10D4B8\")},d=(t,e)=>(t%e+e)%e,u=(t,e)=>{let[r,n]=[t,e],[a,o]=[BigInt(1),BigInt(0)];for(;n!==i;){const t=r/n;[r,n]=[n,r-t*n],[a,o]=[o,a-t*o]}return r>s?i:d(a,e)},f=(t,e,r)=>d(t*e,r),l=(t,e,r)=>d(t-e,r),b=BigInt(4),p=BigInt(8),g=t=>{const{X:e,Y:r,Z:c}=t;if(r===i)return{X:i,Y:s,Z:i};const h=f(r,r,o),d=f(b,f(e,h,o),o),u=f(a,f(e,e,o),o),g=l(f(u,u,o),f(n,d,o),o);return{X:g,Y:l(f(u,l(d,g,o),o),f(p,f(h,h,o),o),o),Z:f(n,f(r,c,o),o)}},m=(t,e)=>{if(t.Z===i)return e;if(e.Z===i)return t;const r=f(t.Z,t.Z,o),a=f(e.Z,e.Z,o),c=f(t.X,a,o),h=f(e.X,r,o),d=f(t.Y,f(a,e.Z,o),o),u=f(e.Y,f(r,t.Z,o),o),b=l(h,c,o),p=l(u,d,o);if(b===i)return p===i?g(t):{X:i,Y:s,Z:i};const m=f(b,b,o),w=f(b,m,o),y=f(c,m,o),v=l(l(f(p,p,o),w,o),f(n,y,o),o);return{X:v,Y:l(f(p,l(y,v,o),o),f(d,w,o),o),Z:f(b,f(t.Z,e.Z,o),o)}},w=(t,e)=>{const r={X:e.x,Y:e.y,Z:s};let n={X:i,Y:s,Z:i};const a=t.toString(2);for(let t=0;t<a.length;t++)n=g(n),\"1\"===a[t]&&(n=m(n,r));return n},y=(t,e,r)=>{const{r:s,s:n}=r,a=t;if(s<=i||s>=c||n<=i||n>=c)return!1;const l=u(n,c);if(l===i)return!1;const b=f(a,l,c),p=f(s,l,c),g=w(b,h),y=w(p,e),v=m(g,y);if(v.Z===i)return!1;const P=u(v.Z,o);if(P===i)return!1;const O=f(P,P,o),E=f(v.X,O,o);return d(E,c)===s},v=BigInt(\"0x\"+t.toString(16));if(null==r.x||null==r.y)throw new Error(\"Invalid public key: missing coordinates.\");return y(v,{x:BigInt(\"0x\"+r.x.toString(16)),y:BigInt(\"0x\"+r.y.toString(16))},{r:BigInt(\"0x\"+e.r.toString(16)),s:BigInt(\"0x\"+e.s.toString(16))})}{const i=new ct;t=ut(t);const s=e.r,n=e.s;if(s.cmpn(1)<0||s.cmp(i.n)>=0)return!1;if(n.cmpn(1)<0||n.cmp(i.n)>=0)return!1;const a=n.invm(i.n),o=a.mul(t).umod(i.n),c=a.mul(s).umod(i.n),h=i.g.jmulAdd(o,r,c);return!h.isInfinity()&&h.eqXToP(s)}};class bt extends at{static fromPrivateKey(t){const e=(new ct).g.mul(t);return new bt(e.x,e.y)}static fromString(t){const e=at.fromString(t);return new bt(e.x,e.y)}static fromDER(t){const e=at.fromDER(t);return new bt(e.x,e.y)}constructor(t,e=null,r=!0){if(t instanceof at)super(t.getX(),t.getY());else{if(null===e&&r&&\"string\"==typeof t&&(66===t.length||130===t.length))throw new Error('You are using the \"new PublicKey()\" constructor with a DER hex string. You need to use \"PublicKey.fromString()\" instead.');super(t,e,r)}}deriveSharedSecret(t){if(!this.validate())throw new Error(\"Public key not valid for ECDH secret derivation\");return this.mul(t)}verify(e,r,i){const s=new t(C(e,i),16);return lt(s,r,this)}toDER(t){return\"hex\"===t?this.encode(!0,t):this.encode(!0)}toHash(t){const e=q(this.encode(!0));return\"hex\"===t?K(e):e}toAddress(t=[0]){if(\"string\"==typeof t)if(\"testnet\"===t||\"test\"===t)t=[111];else{if(\"mainnet\"!==t&&\"main\"!==t)throw new Error(`Invalid prefix ${t}`);t=[0]}return tt(this.toHash(),t)}deriveChild(e,r){const i=this.deriveSharedSecret(e),s=j(r,\"utf8\"),n=V(i.encode(!0),s),a=(new ct).g.mul(new t(n)),o=this.add(a);return new bt(o.x,o.y)}static fromMsgHashAndCompactSignature(e,r,i){const s=j(r,i);if(65!==s.length)throw new Error(\"Invalid Compact Signature\");const n=s[0];if(n<27||n>=35)throw new Error(\"Invalid Compact Byte\");let a=s[0]-27;a>3&&(a-=4);return new ht(new t(s.slice(1,33)),new t(s.slice(33,65))).RecoverPublicKey(a,e)}}class pt{_rand;constructor(){const t=()=>{throw new Error(\"No secure random number generator is available in this environment.\")};if(this._rand=t,\"object\"==typeof self)self.crypto?.getRandomValues?this._rand=t=>{const e=new Uint8Array(t);return self.crypto.getRandomValues(e),[...e]}:this._rand=t;else try{const t=require(\"crypto\");\"function\"==typeof t.randomBytes&&(this._rand=e=>[...t.randomBytes(e)])}catch{this._rand=t}}generate(t){return this._rand(t)}}let gt=null;var mt=t=>(null==gt&&(gt=new pt),gt.generate(t));class wt{x;y;constructor(t,e){const r=(new ct).p;this.x=t.umod(r),this.y=e.umod(r)}toString(){return Q(this.x.toArray())+\".\"+Q(this.y.toArray())}static fromString(e){const[r,i]=e.split(\".\");return new wt(new t(J(r)),new t(J(i)))}}class yt{points;threshold;constructor(t,e){this.points=t,this.threshold=e??t.length}static fromPrivateKey(e,r){const i=(new ct).p,s=[new wt(new t(0),new t(e.toArray()))];for(let e=1;e<r;e++){const e=new t(mt(32)).umod(i),r=new t(mt(32)).umod(i);s.push(new wt(e,r))}return new yt(s)}valueAt(e){const r=(new ct).p;let i=new t(0);for(let t=0;t<this.threshold;t++){let s=this.points[t].y;for(let i=0;i<this.threshold;i++)if(t!==i){const n=this.points[i].x,a=this.points[t].x,o=e.sub(n).umod(r),c=a.sub(n).umod(r).invm(r),h=o.mul(c).umod(r);s=s.mul(h).umod(r)}i=i.add(s).umod(r)}return i}}class vt{points;threshold;integrity;constructor(t,e,r){this.points=t,this.threshold=e,this.integrity=r}static fromBackupFormat(t){let e=0,r=\"\";const i=t.map(((t,i)=>{const s=t.split(\".\");if(4!==s.length)throw new Error(\"Invalid share format in share \"+i.toString()+'. Expected format: \"x.y.t.i\" - received '+t);const[n,a,o,c]=s;if(void 0===o)throw new Error(\"Threshold not found in share \"+i.toString());if(void 0===c)throw new Error(\"Integrity not found in share \"+i.toString());const h=parseInt(o);if(0!==i&&e!==h)throw new Error(\"Threshold mismatch in share \"+i.toString());if(0!==i&&r!==c)throw new Error(\"Integrity mismatch in share \"+i.toString());return e=h,r=c,wt.fromString([n,a].join(\".\"))}));return new vt(i,e,r)}toBackupFormat(){return this.points.map((t=>t.toString()+\".\"+this.threshold.toString()+\".\"+this.integrity))}}class Pt extends t{static fromRandom(){return new Pt(mt(32))}static fromString(t,e=\"hex\"){return new Pt(super.fromString(t,e).toArray())}static fromHex(t){return new Pt(super.fromHex(t,\"big\"))}static fromWif(t,e=1){const r=et(t,void 0,e);if(33!==r.data.length)throw new Error(\"Invalid WIF length\");if(1!==r.data[32])throw new Error(\"Invalid WIF padding\");return new Pt(r.data.slice(0,32))}constructor(e=0,r=10,i=\"be\",s=\"apply\"){if(e instanceof t?(super(),e.copy(this)):super(e,r,i),\"nocheck\"!==s){const e=this.checkInField();if(!e.inField){if(\"error\"===s)throw new Error(\"Input is out of field\");t.move(this,e.modN)}}}checkInField(){const t=new ct,e=this.mod(t.n);return{inField:0===this.cmp(e),modN:e}}isValid(){return this.checkInField().inField}sign(e,r,i=!0,s){const n=new t(C(e,r),16);return ft(n,this,i,s)}verify(e,r,i){const s=new t(C(e,i),16);return lt(s,r,this.toPublicKey())}toPublicKey(){const t=(new ct).g.mul(this);return new bt(t.x,t.y)}toWif(t=[128]){if(!this.isValid())throw new Error(\"Value is out of field\");return tt([...this.toArray(\"be\",32),1],t)}toAddress(t=[0]){return this.toPublicKey().toAddress(t)}toHex(){return super.toHex(32)}toString(t=\"hex\",e=64){return super.toString(t,e)}deriveSharedSecret(t){if(!t.validate())throw new Error(\"Public key not valid for ECDH secret derivation\");return t.mul(this)}deriveChild(e,r){const i=this.deriveSharedSecret(e),s=j(r,\"utf8\"),n=V(i.encode(!0),s),a=new ct;return new Pt(this.add(new t(n)).mod(a.n).toArray())}toKeyShares(e,r){if(\"number\"!=typeof e||\"number\"!=typeof r)throw new Error(\"threshold and totalShares must be numbers\");if(e<2)throw new Error(\"threshold must be at least 2\");if(r<2)throw new Error(\"totalShares must be at least 2\");if(e>r)throw new Error(\"threshold should be less than or equal to totalShares\");const i=yt.fromPrivateKey(this,e),s=[];for(let e=0;e<r;e++){const e=new t(Pt.fromRandom().toArray()),r=i.valueAt(e);s.push(new wt(e,r))}const n=this.toPublicKey().toHash(\"hex\").slice(0,8);return new vt(s,e,n)}toBackupShares(t,e){return this.toKeyShares(t,e).toBackupFormat()}static fromBackupShares(t){return Pt.fromKeyShares(vt.fromBackupFormat(t))}static fromKeyShares(e){const{points:r,threshold:i,integrity:s}=e;if(i<2)throw new Error(\"threshold must be at least 2\");if(r.length<i)throw new Error(`At least ${i} shares are required to reconstruct the private key`);for(let t=0;t<i;t++)for(let e=t+1;e<i;e++)if(r[t].x.eq(r[e].x))throw new Error(\"Duplicate share detected, each must be unique.\");const n=new yt(r,i),a=new Pt(n.valueAt(new t(0)).toArray());if(a.toPublicKey().toHash(\"hex\").slice(0,8)!==s)throw new Error(\"Integrity hash mismatch\");return a}}class Ot extends ht{static SIGHASH_ALL=1;static SIGHASH_NONE=2;static SIGHASH_SINGLE=3;static SIGHASH_FORKID=64;static SIGHASH_ANYONECANPAY=128;scope;static format(t){const e={sourceTXID:t.sourceTXID,sourceOutputIndex:t.sourceOutputIndex,sequence:t.inputSequence},r=[...t.otherInputs];r.splice(t.inputIndex,0,e);function i(e){const r=new rt;if(void 0===e)for(const e of t.outputs){const t=e.satoshis??0;r.writeUInt64LE(t);const i=e.lockingScript?.toBinary()??[];r.writeVarIntNum(i.length),r.write(i)}else{const i=t.outputs[e];if(void 0===i)throw new Error(`Output at index ${e} does not exist`);const s=i.satoshis??0;r.writeUInt64LE(s);const n=i.lockingScript?.toBinary()??[];r.writeVarIntNum(n.length),r.write(n)}const i=r.toArray();return H(i)}let s=new Array(32).fill(0),n=new Array(32).fill(0),a=new Array(32).fill(0);t.scope&Ot.SIGHASH_ANYONECANPAY||(s=(()=>{const t=new rt;for(const e of r){if(void 0===e.sourceTXID){if(null==e.sourceTransaction)throw new Error(\"Missing sourceTransaction for input\");t.write(e.sourceTransaction.hash())}else t.writeReverse(j(e.sourceTXID,\"hex\"));t.writeUInt32LE(e.sourceOutputIndex)}const e=t.toArray();return H(e)})()),t.scope&Ot.SIGHASH_ANYONECANPAY||(31&t.scope)===Ot.SIGHASH_SINGLE||(31&t.scope)===Ot.SIGHASH_NONE||(n=(()=>{const t=new rt;for(const e of r){const r=e.sequence??4294967295;t.writeUInt32LE(r)}const e=t.toArray();return H(e)})()),(31&t.scope)!==Ot.SIGHASH_SINGLE&&(31&t.scope)!==Ot.SIGHASH_NONE?a=i():(31&t.scope)===Ot.SIGHASH_SINGLE&&t.inputIndex<t.outputs.length&&(a=i(t.inputIndex));const o=new rt;o.writeInt32LE(t.transactionVersion),o.write(s),o.write(n),o.writeReverse(j(t.sourceTXID,\"hex\")),o.writeUInt32LE(t.sourceOutputIndex);const c=t.subscript.toBinary();o.writeVarIntNum(c.length),o.write(c),o.writeUInt64LE(t.sourceSatoshis);const h=e.sequence;o.writeUInt32LE(h),o.write(a),o.writeUInt32LE(t.lockTime),o.writeUInt32LE(t.scope>>>0);return o.toArray()}static fromChecksigFormat(e){if(0===e.length){const e=new t(1),r=new t(1);return new Ot(e,r,1)}const r=e[e.length-1],i=e.slice(0,e.length-1),s=ht.fromDER(i);return new Ot(s.r,s.s,r)}constructor(t,e,r){super(t,e),this.scope=r}hasLowS(){return!this.s.ltn(1)&&!this.s.gt(new t(\"7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0\",\"hex\"))}toChecksigFormat(){return[...this.toDER(),this.scope]}}const Et={OP_FALSE:0,OP_0:0,OP_PUSHDATA1:76,OP_PUSHDATA2:77,OP_PUSHDATA4:78,OP_1NEGATE:79,OP_RESERVED:80,OP_TRUE:81,OP_1:81,OP_2:82,OP_3:83,OP_4:84,OP_5:85,OP_6:86,OP_7:87,OP_8:88,OP_9:89,OP_10:90,OP_11:91,OP_12:92,OP_13:93,OP_14:94,OP_15:95,OP_16:96,OP_NOP:97,OP_VER:98,OP_IF:99,OP_NOTIF:100,OP_VERIF:101,OP_VERNOTIF:102,OP_ELSE:103,OP_ENDIF:104,OP_VERIFY:105,OP_RETURN:106,OP_TOALTSTACK:107,OP_FROMALTSTACK:108,OP_2DROP:109,OP_2DUP:110,OP_3DUP:111,OP_2OVER:112,OP_2ROT:113,OP_2SWAP:114,OP_IFDUP:115,OP_DEPTH:116,OP_DROP:117,OP_DUP:118,OP_NIP:119,OP_OVER:120,OP_PICK:121,OP_ROLL:122,OP_ROT:123,OP_SWAP:124,OP_TUCK:125,OP_CAT:126,OP_SUBSTR:127,OP_SPLIT:127,OP_LEFT:128,OP_NUM2BIN:128,OP_RIGHT:129,OP_BIN2NUM:129,OP_SIZE:130,OP_INVERT:131,OP_AND:132,OP_OR:133,OP_XOR:134,OP_EQUAL:135,OP_EQUALVERIFY:136,OP_RESERVED1:137,OP_RESERVED2:138,OP_1ADD:139,OP_1SUB:140,OP_2MUL:141,OP_2DIV:142,OP_NEGATE:143,OP_ABS:144,OP_NOT:145,OP_0NOTEQUAL:146,OP_ADD:147,OP_SUB:148,OP_MUL:149,OP_DIV:150,OP_MOD:151,OP_LSHIFT:152,OP_RSHIFT:153,OP_BOOLAND:154,OP_BOOLOR:155,OP_NUMEQUAL:156,OP_NUMEQUALVERIFY:157,OP_NUMNOTEQUAL:158,OP_LESSTHAN:159,OP_GREATERTHAN:160,OP_LESSTHANOREQUAL:161,OP_GREATERTHANOREQUAL:162,OP_MIN:163,OP_MAX:164,OP_WITHIN:165,OP_RIPEMD160:166,OP_SHA1:167,OP_SHA256:168,OP_HASH160:169,OP_HASH256:170,OP_CODESEPARATOR:171,OP_CHECKSIG:172,OP_CHECKSIGVERIFY:173,OP_CHECKMULTISIG:174,OP_CHECKMULTISIGVERIFY:175,OP_NOP1:176,OP_NOP2:177,OP_NOP3:178,OP_NOP4:179,OP_NOP5:180,OP_NOP6:181,OP_NOP7:182,OP_NOP8:183,OP_NOP9:184,OP_NOP10:185,OP_NOP11:186,OP_NOP12:187,OP_NOP13:188,OP_NOP14:189,OP_NOP15:190,OP_NOP16:191,OP_NOP17:192,OP_NOP18:193,OP_NOP19:194,OP_NOP20:195,OP_NOP21:196,OP_NOP22:197,OP_NOP23:198,OP_NOP24:199,OP_NOP25:200,OP_NOP26:201,OP_NOP27:202,OP_NOP28:203,OP_NOP29:204,OP_NOP30:205,OP_NOP31:206,OP_NOP32:207,OP_NOP33:208,OP_NOP34:209,OP_NOP35:210,OP_NOP36:211,OP_NOP37:212,OP_NOP38:213,OP_NOP39:214,OP_NOP40:215,OP_NOP41:216,OP_NOP42:217,OP_NOP43:218,OP_NOP44:219,OP_NOP45:220,OP_NOP46:221,OP_NOP47:222,OP_NOP48:223,OP_NOP49:224,OP_NOP50:225,OP_NOP51:226,OP_NOP52:227,OP_NOP53:228,OP_NOP54:229,OP_NOP55:230,OP_NOP56:231,OP_NOP57:232,OP_NOP58:233,OP_NOP59:234,OP_NOP60:235,OP_NOP61:236,OP_NOP62:237,OP_NOP63:238,OP_NOP64:239,OP_NOP65:240,OP_NOP66:241,OP_NOP67:242,OP_NOP68:243,OP_NOP69:244,OP_NOP70:245,OP_NOP71:246,OP_NOP72:247,OP_NOP73:248,OP_NOP77:252,OP_SMALLDATA:249,OP_SMALLINTEGER:250,OP_PUBKEYS:251,OP_PUBKEYHASH:253,OP_PUBKEY:254,OP_INVALIDOPCODE:255};for(const t in Et)Et[Et[t]]=t;class kt{chunks;static fromASM(t){const e=[],r=t.split(\" \");let i=0;for(;i<r.length;){const t=r[i];let s,n=0;if(t.startsWith(\"OP_\")&&void 0!==Et[t]&&(s=t,n=Et[t]),\"0\"===t)n=0,e.push({op:n}),i+=1;else if(\"-1\"===t)n=Et.OP_1NEGATE,e.push({op:n}),i+=1;else if(void 0===s){let t=r[i];t.length%2!=0&&(t=\"0\"+t);const s=j(t,\"hex\");if(W(s,\"hex\")!==t)throw new Error(\"invalid hex string in script\");const a=s.length;a>=0&&a<Et.OP_PUSHDATA1?n=a:a<Math.pow(2,8)?n=Et.OP_PUSHDATA1:a<Math.pow(2,16)?n=Et.OP_PUSHDATA2:a<Math.pow(2,32)&&(n=Et.OP_PUSHDATA4),e.push({data:s,op:n}),i+=1}else n===Et.OP_PUSHDATA1||n===Et.OP_PUSHDATA2||n===Et.OP_PUSHDATA4?(e.push({data:j(r[i+2],\"hex\"),op:n}),i+=3):(e.push({op:n}),i+=1)}return new kt(e)}static fromHex(t){if(0===t.length)return kt.fromBinary([]);if(t.length%2!=0)throw new Error(\"There is an uneven number of characters in the string which suggests it is not hex encoded.\");if(!/^[0-9a-fA-F]+$/.test(t))throw new Error(\"Some elements in this string are not hex encoded.\");return kt.fromBinary(j(t,\"hex\"))}static fromBinary(t){t=[...t];const e=[],r=new it(t);for(;!r.eof();){const t=r.readUInt8();let i=0,s=[];if(t>0&&t<Et.OP_PUSHDATA1)i=t,e.push({data:r.read(i),op:t});else if(t===Et.OP_PUSHDATA1){try{i=r.readUInt8(),s=r.read(i)}catch{r.read()}e.push({data:s,op:t})}else if(t===Et.OP_PUSHDATA2){try{i=r.readUInt16LE(),s=r.read(i)}catch{r.read()}e.push({data:s,op:t})}else if(t===Et.OP_PUSHDATA4){try{i=r.readUInt32LE(),s=r.read(i)}catch{r.read()}e.push({data:s,op:t})}else e.push({op:t})}return new kt(e)}constructor(t=[]){this.chunks=t}toASM(){let t=\"\";for(let e=0;e<this.chunks.length;e++){const r=this.chunks[e];t+=this._chunkToString(r)}return t.slice(1)}toHex(){return W(this.toBinary(),\"hex\")}toBinary(){const t=new rt;for(let e=0;e<this.chunks.length;e++){const r=this.chunks[e],i=r.op;t.writeUInt8(i),null!=r.data&&(i<Et.OP_PUSHDATA1?t.write(r.data):i===Et.OP_PUSHDATA1?(t.writeUInt8(r.data.length),t.write(r.data)):i===Et.OP_PUSHDATA2?(t.writeUInt16LE(r.data.length),t.write(r.data)):i===Et.OP_PUSHDATA4&&(t.writeUInt32LE(r.data.length),t.write(r.data)))}return t.toArray()}writeScript(t){return this.chunks=this.chunks.concat(t.chunks),this}writeOpCode(t){return this.chunks.push({op:t}),this}setChunkOpCode(t,e){return this.chunks[t]={op:e},this}writeBn(t){if(t.cmpn(0)===Et.OP_0)this.chunks.push({op:Et.OP_0});else if(0===t.cmpn(-1))this.chunks.push({op:Et.OP_1NEGATE});else if(t.cmpn(1)>=0&&t.cmpn(16)<=0)this.chunks.push({op:t.toNumber()+Et.OP_1-1});else{const e=t.toSm(\"little\");this.writeBin(e)}return this}writeBin(t){let e;if(t.length>0&&t.length<Et.OP_PUSHDATA1)e=t.length;else if(0===t.length)e=Et.OP_0;else if(t.length<Math.pow(2,8))e=Et.OP_PUSHDATA1;else if(t.length<Math.pow(2,16))e=Et.OP_PUSHDATA2;else{if(!(t.length<Math.pow(2,32)))throw new Error(\"You can't push that much data\");e=Et.OP_PUSHDATA4}return this.chunks.push({data:t,op:e}),this}writeNumber(e){return this.writeBn(new t(e)),this}removeCodeseparators(){const t=[];for(let e=0;e<this.chunks.length;e++)this.chunks[e].op!==Et.OP_CODESEPARATOR&&t.push(this.chunks[e]);return this.chunks=t,this}findAndDelete(t){const e=t.toHex();for(let t=0;t<this.chunks.length;t++){e===new kt([this.chunks[t]]).toHex()&&this.chunks.splice(t,1)}return this}isPushOnly(){for(let t=0;t<this.chunks.length;t++){if(this.chunks[t].op>Et.OP_16)return!1}return!0}isLockingScript(){throw new Error(\"Not implemented\")}isUnlockingScript(){throw new Error(\"Not implemented\")}_chunkToString(t){const e=t.op;let r=\"\";if(void 0===t.data){r=`${r} ${Et[e]}`}else r=`${r} ${K(t.data)}`;return r}}class _t extends kt{isLockingScript(){return!0}isUnlockingScript(){return!1}}class xt extends kt{isLockingScript(){return!1}isUnlockingScript(){return!0}}const It=1073741824,St=Math.pow(2,31)-1,At=!0;class Mt{sourceTXID;sourceOutputIndex;sourceSatoshis;lockingScript;transactionVersion;otherInputs;outputs;inputIndex;unlockingScript;inputSequence;lockTime;context;programCounter;lastCodeSeparator;stack;altStack;ifStack;constructor(t){this.sourceTXID=t.sourceTXID,this.sourceOutputIndex=t.sourceOutputIndex,this.sourceSatoshis=t.sourceSatoshis,this.lockingScript=t.lockingScript,this.transactionVersion=t.transactionVersion,this.otherInputs=t.otherInputs,this.outputs=t.outputs,this.inputIndex=t.inputIndex,this.unlockingScript=t.unlockingScript,this.inputSequence=t.inputSequence,this.lockTime=t.lockTime,this.reset()}reset(){this.context=\"UnlockingScript\",this.programCounter=0,this.lastCodeSeparator=null,this.stack=[],this.altStack=[],this.ifStack=[]}step(){let e;\"UnlockingScript\"===this.context&&this.programCounter>=this.unlockingScript.chunks.length&&(this.context=\"LockingScript\",this.programCounter=0),e=\"UnlockingScript\"===this.context?this.unlockingScript.chunks[this.programCounter]:this.lockingScript.chunks[this.programCounter];const r=t=>{if(0===t.length)return!0;(t=>{if(t.length<9)return!1;if(t.length>73)return!1;if(48!==t[0])return!1;if(t[1]!==t.length-3)return!1;const e=t[3];if(5+e>=t.length)return!1;const r=t[5+e];if(e+r+7!==t.length)return!1;const i=t.slice(4);if(2!==t[2])return!1;if(0===e)return!1;if(128&i[0])return!1;if(e>1&&0===i[0]&&!(128&i[1]))return!1;const s=t.slice(6+e);return!(2!==t[6+e-2]||0===r||128&s[0]||r>1&&0===s[0]&&!(128&s[1]))})(t)||this.scriptEvaluationError(\"The signature format is invalid.\");const e=Ot.fromChecksigFormat(t);return e.hasLowS()||this.scriptEvaluationError(\"The signature must have a low S value.\"),!!(e.scope&Ot.SIGHASH_FORKID)||(this.scriptEvaluationError(\"The signature must use SIGHASH_FORKID.\"),!1)},i=t=>(t.length<33&&this.scriptEvaluationError(\"The public key is too short, it must be at least 33 bytes.\"),4===t[0]?65!==t.length&&this.scriptEvaluationError(\"The non-compressed public key must be 65 bytes.\"):2===t[0]||3===t[0]?33!==t.length&&this.scriptEvaluationError(\"The compressed public key must be 33 bytes.\"):this.scriptEvaluationError(\"The public key is in an unknown format.\"),!0),s=(e,r,i)=>{const s=Ot.format({sourceTXID:this.sourceTXID,sourceOutputIndex:this.sourceOutputIndex,sourceSatoshis:this.sourceSatoshis,transactionVersion:this.transactionVersion,otherInputs:this.otherInputs,outputs:this.outputs,inputIndex:this.inputIndex,subscript:i,inputSequence:this.inputSequence,lockTime:this.lockTime,scope:e.scope}),n=new t(H(s));return lt(n,e,r)},n=!this.ifStack.includes(!1);let a,o,c,h,d,u,f,l,b,p,g,m,w,y,v,P,O,E,k,_,x,I,S,A,M,T,N,F,B,U,D,V;const $=e.op;var j,X,Y;if(void 0===$&&this.scriptEvaluationError(`An opcode is missing in this chunk of the ${this.context}!`),Array.isArray(e.data)&&e.data.length>It&&this.scriptEvaluationError(\"It's not currently possible to push data larger than 1073741824 bytes.\"),n&&((j=$)===Et.OP_2MUL||j===Et.OP_2DIV||j===Et.OP_VERIF||j===Et.OP_VERNOTIF||j===Et.OP_VER)&&this.scriptEvaluationError(\"This opcode is currently disabled.\"),n&&$>=0&&$<=Et.OP_PUSHDATA4)(t=>{const e=t.data,r=t.op;return!(Array.isArray(e)&&(0===e.length?r!==Et.OP_0:1===e.length&&e[0]>=1&&e[0]<=16?r!==Et.OP_1+(e[0]-1):1===e.length&&129===e[0]?r!==Et.OP_1NEGATE:e.length<=75?r!==e.length:e.length<=255?r!==Et.OP_PUSHDATA1:e.length<=65535&&r!==Et.OP_PUSHDATA2))})(e)||this.scriptEvaluationError(\"This data is not minimally-encoded.\"),Array.isArray(e.data)?this.stack.push(e.data):this.stack.push([]);else if(n||Et.OP_IF<=$&&$<=Et.OP_ENDIF)switch($){case Et.OP_1NEGATE:case Et.OP_1:case Et.OP_2:case Et.OP_3:case Et.OP_4:case Et.OP_5:case Et.OP_6:case Et.OP_7:case Et.OP_8:case Et.OP_9:case Et.OP_10:case Et.OP_11:case Et.OP_12:case Et.OP_13:case Et.OP_14:case Et.OP_15:case Et.OP_16:u=$-(Et.OP_1-1),a=new t(u).toScriptNum(),this.stack.push(a);break;case Et.OP_NOP:case Et.OP_NOP2:case Et.OP_NOP3:case Et.OP_NOP1:case Et.OP_NOP4:case Et.OP_NOP5:case Et.OP_NOP6:case Et.OP_NOP7:case Et.OP_NOP8:case Et.OP_NOP9:case Et.OP_NOP10:case Et.OP_NOP11:case Et.OP_NOP12:case Et.OP_NOP13:case Et.OP_NOP14:case Et.OP_NOP15:case Et.OP_NOP16:case Et.OP_NOP17:case Et.OP_NOP18:case Et.OP_NOP19:case Et.OP_NOP20:case Et.OP_NOP21:case Et.OP_NOP22:case Et.OP_NOP23:case Et.OP_NOP24:case Et.OP_NOP25:case Et.OP_NOP26:case Et.OP_NOP27:case Et.OP_NOP28:case Et.OP_NOP29:case Et.OP_NOP30:case Et.OP_NOP31:case Et.OP_NOP32:case Et.OP_NOP33:case Et.OP_NOP34:case Et.OP_NOP35:case Et.OP_NOP36:case Et.OP_NOP37:case Et.OP_NOP38:case Et.OP_NOP39:case Et.OP_NOP40:case Et.OP_NOP41:case Et.OP_NOP42:case Et.OP_NOP43:case Et.OP_NOP44:case Et.OP_NOP45:case Et.OP_NOP46:case Et.OP_NOP47:case Et.OP_NOP48:case Et.OP_NOP49:case Et.OP_NOP50:case Et.OP_NOP51:case Et.OP_NOP52:case Et.OP_NOP53:case Et.OP_NOP54:case Et.OP_NOP55:case Et.OP_NOP56:case Et.OP_NOP57:case Et.OP_NOP58:case Et.OP_NOP59:case Et.OP_NOP60:case Et.OP_NOP61:case Et.OP_NOP62:case Et.OP_NOP63:case Et.OP_NOP64:case Et.OP_NOP65:case Et.OP_NOP66:case Et.OP_NOP67:case Et.OP_NOP68:case Et.OP_NOP69:case Et.OP_NOP70:case Et.OP_NOP71:case Et.OP_NOP72:case Et.OP_NOP73:case Et.OP_NOP77:break;case Et.OP_IF:case Et.OP_NOTIF:U=!1,n&&(this.stack.length<1&&this.scriptEvaluationError(\"OP_IF and OP_NOTIF require at least one item on the stack when they are used!\"),a=this.stacktop(-1),U=this.castToBool(a),$===Et.OP_NOTIF&&(U=!U),this.stack.pop()),this.ifStack.push(U);break;case Et.OP_ELSE:0===this.ifStack.length&&this.scriptEvaluationError(\"OP_ELSE requires a preceeding OP_IF.\"),this.ifStack[this.ifStack.length-1]=!this.ifStack[this.ifStack.length-1];break;case Et.OP_ENDIF:0===this.ifStack.length&&this.scriptEvaluationError(\"OP_ENDIF requires a preceeding OP_IF.\"),this.ifStack.pop();break;case Et.OP_VERIFY:this.stack.length<1&&this.scriptEvaluationError(\"OP_VERIFY requires at least one item to be on the stack.\"),a=this.stacktop(-1),U=this.castToBool(a),U?this.stack.pop():this.scriptEvaluationError(\"OP_VERIFY requires the top stack value to be truthy.\");break;case Et.OP_RETURN:\"UnlockingScript\"===this.context?this.programCounter=this.unlockingScript.chunks.length:this.programCounter=this.lockingScript.chunks.length,this.ifStack=[];break;case Et.OP_TOALTSTACK:this.stack.length<1&&this.scriptEvaluationError(\"OP_TOALTSTACK requires at oeast one item to be on the stack.\"),this.altStack.push(this.stack.pop()??[]);break;case Et.OP_FROMALTSTACK:this.altStack.length<1&&this.scriptEvaluationError(\"OP_FROMALTSTACK requires at least one item to be on the stack.\"),this.stack.push(this.altStack.pop()??[]);break;case Et.OP_2DROP:this.stack.length<2&&this.scriptEvaluationError(\"OP_2DROP requires at least two items to be on the stack.\"),this.stack.pop(),this.stack.pop();break;case Et.OP_2DUP:this.stack.length<2&&this.scriptEvaluationError(\"OP_2DUP requires at least two items to be on the stack.\"),o=this.stacktop(-2),c=this.stacktop(-1),this.stack.push([...o]),this.stack.push([...c]);break;case Et.OP_3DUP:this.stack.length<3&&this.scriptEvaluationError(\"OP_3DUP requires at least three items to be on the stack.\"),o=this.stacktop(-3),c=this.stacktop(-2),h=this.stacktop(-1),this.stack.push([...o]),this.stack.push([...c]),this.stack.push([...h]);break;case Et.OP_2OVER:this.stack.length<4&&this.scriptEvaluationError(\"OP_2OVER requires at least four items to be on the stack.\"),o=this.stacktop(-4),c=this.stacktop(-3),this.stack.push([...o]),this.stack.push([...c]);break;case Et.OP_2ROT:this.stack.length<6&&this.scriptEvaluationError(\"OP_2ROT requires at least six items to be on the stack.\"),d=this.stack.splice(this.stack.length-6,2),this.stack.push(d[0]),this.stack.push(d[1]);break;case Et.OP_2SWAP:this.stack.length<4&&this.scriptEvaluationError(\"OP_2SWAP requires at least four items to be on the stack.\"),d=this.stack.splice(this.stack.length-4,2),this.stack.push(d[0]),this.stack.push(d[1]);break;case Et.OP_IFDUP:this.stack.length<1&&this.scriptEvaluationError(\"OP_IFDUP requires at least one item to be on the stack.\"),a=this.stacktop(-1),U=this.castToBool(a),U&&this.stack.push([...a]);break;case Et.OP_DEPTH:a=new t(this.stack.length).toScriptNum(),this.stack.push(a);break;case Et.OP_DROP:this.stack.length<1&&this.scriptEvaluationError(\"OP_DROP requires at least one item to be on the stack.\"),this.stack.pop();break;case Et.OP_DUP:this.stack.length<1&&this.scriptEvaluationError(\"OP_DUP requires at least one item to be on the stack.\"),this.stack.push([...this.stacktop(-1)]);break;case Et.OP_NIP:this.stack.length<2&&this.scriptEvaluationError(\"OP_NIP requires at least two items to be on the stack.\"),this.stack.splice(this.stack.length-2,1);break;case Et.OP_OVER:this.stack.length<2&&this.scriptEvaluationError(\"OP_OVER requires at least two items to be on the stack.\"),this.stack.push([...this.stacktop(-2)]);break;case Et.OP_PICK:case Et.OP_ROLL:this.stack.length<2&&this.scriptEvaluationError(`${Et[$]} requires at least two items to be on the stack.`),a=this.stacktop(-1),y=t.fromScriptNum(a,At),u=y.toNumber(),this.stack.pop(),(u<0||u>=this.stack.length)&&this.scriptEvaluationError(`${Et[$]} requires the top stack element to be 0 or a positive number less than the current size of the stack.`),a=this.stacktop(-u-1),$===Et.OP_ROLL&&this.stack.splice(this.stack.length-u-1,1),this.stack.push([...a]);break;case Et.OP_ROT:this.stack.length<3&&this.scriptEvaluationError(\"OP_ROT requires at least three items to be on the stack.\"),g=this.stacktop(-3),m=this.stacktop(-2),w=this.stacktop(-1),this.stack[this.stack.length-3]=m,this.stack[this.stack.length-2]=w,this.stack[this.stack.length-1]=g;break;case Et.OP_SWAP:this.stack.length<2&&this.scriptEvaluationError(\"OP_SWAP requires at least two items to be on the stack.\"),g=this.stacktop(-2),m=this.stacktop(-1),this.stack[this.stack.length-2]=m,this.stack[this.stack.length-1]=g;break;case Et.OP_TUCK:this.stack.length<2&&this.scriptEvaluationError(\"OP_TUCK requires at least two items to be on the stack.\"),this.stack.splice(this.stack.length-2,0,[...this.stacktop(-1)]);break;case Et.OP_SIZE:this.stack.length<1&&this.scriptEvaluationError(\"OP_SIZE requires at least one item to be on the stack.\"),y=new t(this.stacktop(-1).length),this.stack.push(y.toScriptNum());break;case Et.OP_AND:case Et.OP_OR:case Et.OP_XOR:switch(this.stack.length<2&&this.scriptEvaluationError(`${Et[$]} requires at least one item to be on the stack.`),o=this.stacktop(-2),c=this.stacktop(-1),o.length!==c.length&&this.scriptEvaluationError(`${Et[$]} requires the top two stack items to be the same size.`),$){case Et.OP_AND:for(let t=0;t<o.length;t++)o[t]&=c[t];break;case Et.OP_OR:for(let t=0;t<o.length;t++)o[t]|=c[t];break;case Et.OP_XOR:for(let t=0;t<o.length;t++)o[t]^=c[t]}this.stack.pop();break;case Et.OP_INVERT:this.stack.length<1&&this.scriptEvaluationError(\"OP_INVERT requires at least one item to be on the stack.\"),a=this.stacktop(-1);for(let t=0;t<a.length;t++)a[t]=~a[t];break;case Et.OP_LSHIFT:case Et.OP_RSHIFT:if(this.stack.length<2&&this.scriptEvaluationError(`${Et[$]} requires at least two items to be on the stack.`),o=this.stacktop(-2),0===o.length)this.stack.pop();else{let e;v=new t(o),P=t.fromScriptNum(this.stacktop(-1),At),u=P.toNumber(),u<0&&this.scriptEvaluationError(`${Et[$]} requires the top item on the stack not to be negative.`),this.stack.pop(),this.stack.pop(),$===Et.OP_LSHIFT&&(e=v.ushln(u)),$===Et.OP_RSHIFT&&(e=v.ushrn(u));const r=((t,e)=>{const r=t;for(;r.length<e;)r.unshift(0);return r})(e.toArray().slice(-1*o.length),o.length);this.stack.push(r)}break;case Et.OP_EQUAL:case Et.OP_EQUALVERIFY:this.stack.length<2&&this.scriptEvaluationError(`${Et[$]} requires at least two items to be on the stack.`),o=this.stacktop(-2),c=this.stacktop(-1),D=K(o)===K(c),this.stack.pop(),this.stack.pop(),this.stack.push(D?[1]:[]),$===Et.OP_EQUALVERIFY&&(D?this.stack.pop():this.scriptEvaluationError(\"OP_EQUALVERIFY requires the top two stack items to be equal.\"));break;case Et.OP_1ADD:case Et.OP_1SUB:case Et.OP_NEGATE:case Et.OP_ABS:case Et.OP_NOT:case Et.OP_0NOTEQUAL:switch(this.stack.length<1&&this.scriptEvaluationError(`${Et[$]} requires at least one items to be on the stack.`),a=this.stacktop(-1),y=t.fromScriptNum(a,At),$){case Et.OP_1ADD:y=y.addn(1);break;case Et.OP_1SUB:y=y.subn(1);break;case Et.OP_NEGATE:y=y.neg();break;case Et.OP_ABS:y.cmpn(0)<0&&(y=y.neg());break;case Et.OP_NOT:y=new t(0===y.cmpn(0)?1:0);break;case Et.OP_0NOTEQUAL:y=new t(0!==y.cmpn(0)?1:0)}this.stack.pop(),this.stack.push(y.toScriptNum());break;case Et.OP_ADD:case Et.OP_SUB:case Et.OP_MUL:case Et.OP_MOD:case Et.OP_DIV:case Et.OP_BOOLAND:case Et.OP_BOOLOR:case Et.OP_NUMEQUAL:case Et.OP_NUMEQUALVERIFY:case Et.OP_NUMNOTEQUAL:case Et.OP_LESSTHAN:case Et.OP_GREATERTHAN:case Et.OP_LESSTHANOREQUAL:case Et.OP_GREATERTHANOREQUAL:case Et.OP_MIN:case Et.OP_MAX:switch(this.stack.length<2&&this.scriptEvaluationError(`${Et[$]} requires at least two items to be on the stack.`),v=t.fromScriptNum(this.stacktop(-2),At),P=t.fromScriptNum(this.stacktop(-1),At),y=new t(0),$){case Et.OP_ADD:y=v.add(P);break;case Et.OP_SUB:y=v.sub(P);break;case Et.OP_MUL:y=v.mul(P);break;case Et.OP_DIV:0===P.cmpn(0)&&this.scriptEvaluationError(\"OP_DIV cannot divide by zero!\"),y=v.div(P);break;case Et.OP_MOD:0===P.cmpn(0)&&this.scriptEvaluationError(\"OP_MOD cannot divide by zero!\"),y=v.mod(P);break;case Et.OP_BOOLAND:y=new t(0!==v.cmpn(0)&&0!==P.cmpn(0)?1:0);break;case Et.OP_BOOLOR:y=new t(0!==v.cmpn(0)||0!==P.cmpn(0)?1:0);break;case Et.OP_NUMEQUAL:case Et.OP_NUMEQUALVERIFY:y=new t(0===v.cmp(P)?1:0);break;case Et.OP_NUMNOTEQUAL:y=new t(0!==v.cmp(P)?1:0);break;case Et.OP_LESSTHAN:y=new t(v.cmp(P)<0?1:0);break;case Et.OP_GREATERTHAN:y=new t(v.cmp(P)>0?1:0);break;case Et.OP_LESSTHANOREQUAL:y=new t(v.cmp(P)<=0?1:0);break;case Et.OP_GREATERTHANOREQUAL:y=new t(v.cmp(P)>=0?1:0);break;case Et.OP_MIN:y=v.cmp(P)<0?v:P;break;case Et.OP_MAX:y=v.cmp(P)>0?v:P}this.stack.pop(),this.stack.pop(),this.stack.push(y.toScriptNum()),$===Et.OP_NUMEQUALVERIFY&&(this.castToBool(this.stacktop(-1))?this.stack.pop():this.scriptEvaluationError(\"OP_NUMEQUALVERIFY requires the top stack item to be truthy.\"));break;case Et.OP_WITHIN:this.stack.length<3&&this.scriptEvaluationError(\"OP_WITHIN requires at least three items to be on the stack.\"),v=t.fromScriptNum(this.stacktop(-3),At),P=t.fromScriptNum(this.stacktop(-2),At),O=t.fromScriptNum(this.stacktop(-1),At),U=P.cmp(v)<=0&&v.cmp(O)<0,this.stack.pop(),this.stack.pop(),this.stack.pop(),this.stack.push(U?[1]:[]);break;case Et.OP_RIPEMD160:case Et.OP_SHA1:case Et.OP_SHA256:case Et.OP_HASH160:case Et.OP_HASH256:{this.stack.length<1&&this.scriptEvaluationError(`${Et[$]} requires at least one item to be on the stack.`);let t=[];a=this.stacktop(-1),$===Et.OP_RIPEMD160?(X=a,t=(new R).update(X,Y).digest()):$===Et.OP_SHA1?t=((t,e)=>(new L).update(t,e).digest())(a):$===Et.OP_SHA256?t=C(a):$===Et.OP_HASH160?t=q(a):$===Et.OP_HASH256&&(t=H(a)),this.stack.pop(),this.stack.push(t);break}case Et.OP_CODESEPARATOR:this.lastCodeSeparator=this.programCounter;break;case Et.OP_CHECKSIG:case Et.OP_CHECKSIGVERIFY:this.stack.length<2&&this.scriptEvaluationError(`${Et[$]} requires at least two items to be on the stack.`),E=this.stacktop(-2),k=this.stacktop(-1),r(E)&&i(k)||this.scriptEvaluationError(`${Et[$]} requires correct encoding for the public key and signature.`),_=\"UnlockingScript\"===this.context?new kt(this.unlockingScript.chunks.slice(this.lastCodeSeparator??0)):new kt(this.lockingScript.chunks.slice(this.lastCodeSeparator??0)),_.findAndDelete((new kt).writeBin(E));try{x=Ot.fromChecksigFormat(E),I=bt.fromDER(k),V=s(x,I,_)}catch(t){V=!1}!V&&E.length>0&&this.scriptEvaluationError(`${Et[$]} failed to verify the signature, and requires an empty signature when verification fails.`),this.stack.pop(),this.stack.pop(),this.stack.push(V?[1]:[]),$===Et.OP_CHECKSIGVERIFY&&(V?this.stack.pop():this.scriptEvaluationError(\"OP_CHECKSIGVERIFY requires that a valid signature is provided.\"));break;case Et.OP_CHECKMULTISIG:case Et.OP_CHECKMULTISIGVERIFY:S=1,this.stack.length<S&&this.scriptEvaluationError(`${Et[$]} requires at least 1 item to be on the stack.`),M=t.fromScriptNum(this.stacktop(-S),At).toNumber(),(M<0||M>St)&&this.scriptEvaluationError(`${Et[$]} requires a key count between 0 and ${St}.`),T=++S,S+=M,N=M+2,this.stack.length<S&&this.scriptEvaluationError(`${Et[$]} requires the number of stack items not to be less than the number of keys used.`),F=t.fromScriptNum(this.stacktop(-S),At).toNumber(),(F<0||F>M)&&this.scriptEvaluationError(`${Et[$]} requires the number of signatures to be no greater than the number of keys.`),B=++S,S+=F,this.stack.length<S&&this.scriptEvaluationError(`${Et[$]} requires the number of stack items not to be less than the number of signatures provided.`),_=\"UnlockingScript\"===this.context?new kt(this.unlockingScript.chunks.slice(this.lastCodeSeparator??0)):new kt(this.lockingScript.chunks.slice(this.lastCodeSeparator??0));for(let t=0;t<F;t++)E=this.stacktop(-B-t),_.findAndDelete((new kt).writeBin(E));for(V=!0;V&&F>0;){E=this.stacktop(-B),k=this.stacktop(-T),r(E)&&i(k)||this.scriptEvaluationError(`${Et[$]} requires correct encoding for the public key and signature.`);try{x=Ot.fromChecksigFormat(E),I=bt.fromString(K(k)),A=s(x,I,_)}catch(t){A=!1}A&&(B++,F--),T++,M--,F>M&&(V=!1)}for(;S-- >1;)!V&&0===N&&this.stacktop(-1).length>0&&this.scriptEvaluationError(`${Et[$]} failed to verify a signature, and requires an empty signature when verification fails.`),N>0&&N--,this.stack.pop();this.stack.length<1&&this.scriptEvaluationError(`${Et[$]} requires an extra item to be on the stack.`),this.stacktop(-1).length>0&&this.scriptEvaluationError(`${Et[$]} requires the extra stack item to be empty.`),this.stack.pop(),this.stack.push(V?[1]:[]),$===Et.OP_CHECKMULTISIGVERIFY&&(V?this.stack.pop():this.scriptEvaluationError(\"OP_CHECKMULTISIGVERIFY requires that a sufficient number of valid signatures are provided.\"));break;case Et.OP_CAT:this.stack.length<2&&this.scriptEvaluationError(\"OP_CAT requires at least two items to be on the stack.\"),o=this.stacktop(-2),c=this.stacktop(-1),o.length+c.length>It&&this.scriptEvaluationError(\"It's not currently possible to push data larger than 1073741824 bytes.\"),this.stack[this.stack.length-2]=[...o,...c],this.stack.pop();break;case Et.OP_SPLIT:this.stack.length<2&&this.scriptEvaluationError(\"OP_SPLIT requires at least two items to be on the stack.\"),o=this.stacktop(-2),u=t.fromScriptNum(this.stacktop(-1),At).toNumber(),(u<0||u>o.length)&&this.scriptEvaluationError(\"OP_SPLIT requires the first stack item to be a non-negative number less than or equal to the size of the second-from-top stack item.\"),c=[...o],this.stack[this.stack.length-2]=c.slice(0,u),this.stack[this.stack.length-1]=c.slice(u);break;case Et.OP_NUM2BIN:if(this.stack.length<2&&this.scriptEvaluationError(\"OP_NUM2BIN requires at least two items to be on the stack.\"),f=t.fromScriptNum(this.stacktop(-1),At).toNumber(),f>It&&this.scriptEvaluationError(\"It's not currently possible to push data larger than 1073741824 bytes.\"),this.stack.pop(),l=this.stacktop(-1),l=st(l),l.length>f&&this.scriptEvaluationError(\"OP_NUM2BIN requires that the size expressed in the top stack item is large enough to hold the value expressed in the second-from-top stack item.\"),l.length===f){this.stack[this.stack.length-1]=l;break}for(p=0,l.length>0&&(p=128&l[l.length-1],l[l.length-1]&=127),b=new Array(f),b.fill(0),u=0;u<f;u++)b[u]=l[u];for(u=l.length-1;u++<f-2;)b[u]=0;b[u]=p,this.stack[this.stack.length-1]=b;break;case Et.OP_BIN2NUM:this.stack.length<1&&this.scriptEvaluationError(\"OP_BIN2NUM requires at least one item to be on the stack.\"),o=this.stacktop(-1),c=st(o),this.stack[this.stack.length-1]=c,((t,e=Number.MAX_SAFE_INTEGER)=>!(t.length>e||t.length>0&&!(127&t[t.length-1]||!(t.length<=1)&&128&t[t.length-2])))(c)||this.scriptEvaluationError(\"OP_BIN2NUM requires that the resulting number is valid.\");break;default:this.scriptEvaluationError(\"Invalid opcode!\")}this.programCounter++}validate(){for(this.unlockingScript.isPushOnly()||this.scriptEvaluationError(\"Unlocking scripts can only contain push operations, and no other opcodes.\");this.step(),!(\"LockingScript\"===this.context&&this.programCounter>=this.lockingScript.chunks.length););return this.ifStack.length>0&&this.scriptEvaluationError(\"Every OP_IF must be terminated prior to the end of the script.\"),1!==this.stack.length&&this.scriptEvaluationError(\"The clean stack rule requires exactly one item to be on the stack after script execution.\"),this.castToBool(this.stacktop(-1))||this.scriptEvaluationError(\"The top stack element must be truthy after script evaluation.\"),!0}stacktop(t){return this.stack[this.stack.length+t]}castToBool(t){for(let e=0;e<t.length;e++)if(0!==t[e])return e!==t.length-1||128!==t[e];return!1}scriptEvaluationError(t){throw new Error(`Script evaluation error: ${t}\\n\\nSource TXID: ${this.sourceTXID}\\nSource output index: ${this.sourceOutputIndex}\\nContext: ${this.context}\\nProgram counter: ${this.programCounter}\\nStack size: ${this.stack.length}\\nAlt stack size: ${this.altStack.length}`)}}function Tt(t){if(null==t)throw new Error(\"must have value\");return t}class Nt{lock(t){let e;if(\"string\"==typeof t){const r=et(t);if(0!==r.prefix[0]&&111!==r.prefix[0])throw new Error(\"only P2PKH is supported\");e=r.data}else e=t;if(20!==e.length)throw new Error(\"P2PKH hash length must be 20 bytes\");return new _t([{op:Et.OP_DUP},{op:Et.OP_HASH160},{op:e.length,data:e},{op:Et.OP_EQUALVERIFY},{op:Et.OP_CHECKSIG}])}unlock(t,e=\"all\",r=!1,i,s){return{sign:async(n,a)=>{let o=Ot.SIGHASH_FORKID;\"all\"===e&&(o|=Ot.SIGHASH_ALL),\"none\"===e&&(o|=Ot.SIGHASH_NONE),\"single\"===e&&(o|=Ot.SIGHASH_SINGLE),r&&(o|=Ot.SIGHASH_ANYONECANPAY);const c=n.inputs[a],h=n.inputs.filter(((t,e)=>e!==a)),d=c.sourceTXID??c.sourceTransaction?.id(\"hex\");if(null==d||void 0===d)throw new Error(\"The input sourceTXID or sourceTransaction is required for transaction signing.\");if(\"\"===d)throw new Error(\"The input sourceTXID or sourceTransaction is required for transaction signing.\");if(i||=c.sourceTransaction?.outputs[c.sourceOutputIndex].satoshis,null==i||void 0===i)throw new Error(\"The sourceSatoshis or input sourceTransaction is required for transaction signing.\");if(s||=c.sourceTransaction?.outputs[c.sourceOutputIndex].lockingScript,null==s)throw new Error(\"The lockingScript or input sourceTransaction is required for transaction signing.\");const u=Ot.format({sourceTXID:d,sourceOutputIndex:Tt(c.sourceOutputIndex),sourceSatoshis:i,transactionVersion:n.version,otherInputs:h,inputIndex:a,outputs:n.outputs,inputSequence:Tt(c.sequence),subscript:s,lockTime:n.lockTime,scope:o}),f=t.sign(C(u)),l=new Ot(f.r,f.s,o).toChecksigFormat(),b=t.toPublicKey().encode(!0);return new xt([{op:l.length,data:l},{op:b.length,data:b}])},estimateLength:async()=>108}}}class Ft{value;constructor(t){this.value=t}async computeFee(t){const e=t=>t>2**32?9:t>65536?5:t>253?3:1;let r=4;r+=e(t.inputs.length);for(let i=0;i<t.inputs.length;i++){const s=t.inputs[i];let n;if(r+=40,\"object\"==typeof s.unlockingScript)n=s.unlockingScript.toBinary().length;else{if(\"object\"!=typeof s.unlockingScriptTemplate)throw new Error(\"All inputs must have an unlocking script or an unlocking script template for sat/kb fee computation.\");n=await s.unlockingScriptTemplate.estimateLength(t,i)}r+=e(n),r+=n}r+=e(t.outputs.length);for(const i of t.outputs){r+=8;const t=i.lockingScript.toBinary().length;r+=e(t),r+=t}r+=4;return Math.ceil(r/1e3*this.value)}}class Bt{https;constructor(t){this.https=t}async request(t,e){return await new Promise(((r,i)=>{const s=this.https.request(t,e,(t=>{let e=\"\";t.on(\"data\",(t=>{e+=t})),t.on(\"end\",(()=>{const i=t.statusCode>=200&&t.statusCode<=299,s=t.headers[\"content-type\"],n=\"\"!==e&&\"string\"==typeof s&&s.startsWith(\"application/json\")?JSON.parse(e):e;r({status:t.statusCode,statusText:t.statusMessage,ok:i,data:n})}))}));s.on(\"error\",(t=>{i(t)})),null!==e.data&&void 0!==e.data&&s.write(JSON.stringify(e.data)),s.end()}))}}class Rt{fetch;constructor(t){this.fetch=t}async request(t,e){const r={method:e.method,headers:e.headers,body:JSON.stringify(e.data)},i=await this.fetch(t,r),s=i.headers.get(\"Content-Type\"),n=s?.startsWith(\"application/json\")?await i.json():await i.text();return{ok:i.ok,status:i.status,statusText:i.statusText,data:n}}}function Ut(){const t={async request(...t){throw new Error(\"No method available to perform HTTP request\")}};if(\"undefined\"!=typeof window&&\"function\"==typeof window.fetch)return new Rt(window.fetch.bind(window));if(\"undefined\"==typeof require)return t;try{const t=require(\"https\");return new Bt(t)}catch(e){return t}}function Lt(){return`ts-sdk-${K(mt(16))}`}class Dt{URL;apiKey;deploymentId;callbackUrl;callbackToken;headers;httpClient;constructor(t,e){if(this.URL=t,\"string\"==typeof e)this.apiKey=e,this.httpClient=Ut(),this.deploymentId=Lt(),this.callbackToken=void 0,this.callbackUrl=void 0;else{const t=e??{},{apiKey:r,deploymentId:i,httpClient:s,callbackToken:n,callbackUrl:a,headers:o}=t;this.apiKey=r,this.httpClient=s??Ut(),this.deploymentId=i??Lt(),this.callbackToken=n,this.callbackUrl=a,this.headers=o}}requestHeaders(){const t={\"Content-Type\":\"application/json\",\"XDeployment-ID\":this.deploymentId};if(null!=this.apiKey&&\"\"!==this.apiKey&&(t.Authorization=`Bearer ${this.apiKey}`),null!=this.callbackUrl&&\"\"!==this.callbackUrl&&(t[\"X-CallbackUrl\"]=this.callbackUrl),null!=this.callbackToken&&\"\"!==this.callbackToken&&(t[\"X-CallbackToken\"]=this.callbackToken),null!=this.headers)for(const e in this.headers)t[e]=this.headers[e];return t}async broadcast(t){let e;try{e=t.toHexEF()}catch(r){if(\"All inputs must have source transactions when serializing to EF format\"!==r.message)throw r;e=t.toHex()}const r={method:\"POST\",headers:this.requestHeaders(),data:{rawTx:e}};try{const t=await this.httpClient.request(`${this.URL}/v1/tx`,r);if(t.ok){const{txid:e,extraInfo:r,txStatus:i,competingTxs:s}=t.data,n={status:\"success\",txid:e,message:`${i} ${r}`};return null!=s&&(n.competingTxs=s),n}{const e=typeof t.status,r={status:\"error\",code:\"number\"===e||\"string\"===e?t.status.toString():\"ERR_UNKNOWN\",description:\"Unknown error\"};let i=t.data;if(\"string\"==typeof i)try{i=JSON.parse(t.data)}catch{}return\"object\"==typeof i&&(null!==i&&(r.more=i),null!=i&&\"string\"==typeof i.txid&&(r.txid=i.txid),null!=i&&\"detail\"in i&&\"string\"==typeof i.detail&&(r.description=i.detail)),r}}catch(t){return{status:\"error\",code:\"500\",description:\"string\"==typeof t.message?t.message:\"Internal Server Error\"}}}async broadcastMany(t){const e=t.map((t=>{try{return{rawTx:t.toHexEF()}}catch(e){if(\"All inputs must have source transactions when serializing to EF format\"===e.message)return{rawTx:t.toHex()};throw e}})),r={method:\"POST\",headers:this.requestHeaders(),data:e};try{return(await this.httpClient.request(`${this.URL}/v1/txs`,r)).data}catch(e){const r={status:\"error\",code:\"500\",description:\"string\"==typeof e.message?e.message:\"Internal Server Error\"};return t.map((()=>r))}}}class Ct{network;apiKey;URL;httpClient;constructor(t=\"main\",e={}){const{apiKey:r,httpClient:i}=e;this.network=t,this.URL=`https://api.whatsonchain.com/v1/bsv/${t}`,this.httpClient=i??Ut(),this.apiKey=r??\"\"}async isValidRootForHeight(t,e){const r={method:\"GET\",headers:this.getHttpHeaders()},i=await this.httpClient.request(`${this.URL}/block/${e}/header`,r);if(i.ok){const{merkleroot:e}=i.data;return e===t}if(404===i.status)return!1;throw new Error(`Failed to verify merkleroot for height ${e} because of an error: ${JSON.stringify(i.data)} `)}async currentHeight(){try{const t={method:\"GET\",headers:this.getHttpHeaders()},e=await this.httpClient.request(`${this.URL}/block/headers`,t);if(e.ok)return e.data[0].height;throw new Error(`Failed to get current height because of an error: ${JSON.stringify(e.data)} `)}catch(t){throw new Error(`Failed to get current height because of an error: ${t instanceof Error?t.message:String(t)}`)}}getHttpHeaders(){const t={Accept:\"application/json\"};return\"string\"==typeof this.apiKey&&\"\"!==this.apiKey.trim()&&(t.Authorization=this.apiKey),t}}class Ht{blockHeight;path;static fromHex(t){return Ht.fromBinary(j(t,\"hex\"))}static fromReader(t,e=!0){const r=t.readVarIntNum(),i=t.readUInt8(),s=Array(i).fill(null).map((()=>[]));let n,a,o;for(let e=0;e<i;e++){for(o=t.readVarIntNum();o>0;){a=t.readVarIntNum(),n=t.readUInt8();const r={offset:a};1&n?r.duplicate=!0:(2&n&&(r.txid=!0),r.hash=K(t.read(32).reverse())),Array.isArray(s[e])&&0!==s[e].length||(s[e]=[]),s[e].push(r),o--}s[e].sort(((t,e)=>t.offset-e.offset))}return new Ht(r,s,e)}static fromBinary(t){const e=new it(t);return Ht.fromReader(e)}static fromCoinbaseTxidAndHeight(t,e){return new Ht(e,[[{offset:0,hash:t,txid:!0}]])}constructor(t,e,r=!0){this.blockHeight=t,this.path=e;const i=Array(this.path.length).fill(0).map((()=>new Set));let s;this.path.forEach(((t,e)=>{if(0===t.length&&0===e)throw new Error(`Empty level at height: ${e}`);const s=new Set;t.forEach((t=>{if(s.has(t.offset))throw new Error(`Duplicate offset: ${t.offset}, at height: ${e}`);if(s.add(t.offset),0===e){if(!0!==t.duplicate)for(let e=1;e<this.path.length;e++)i[e].add(t.offset>>e^1)}else if(r&&!i[e].has(t.offset))throw new Error(`Invalid offset: ${t.offset}, at height: ${e}, with legal offsets: ${Array.from(i[e]).join(\", \")}`)}))})),this.path[0].forEach(((t,e)=>{if(0===e&&(s=this.computeRoot(t.hash)),s!==this.computeRoot(t.hash))throw new Error(\"Mismatched roots\")}))}toBinary(){const t=new rt;t.writeVarIntNum(this.blockHeight);const e=this.path.length;t.writeUInt8(e);for(let r=0;r<e;r++){const e=Object.keys(this.path[r]).length;t.writeVarIntNum(e);for(const e of this.path[r]){t.writeVarIntNum(e.offset);let r=0;!0===e?.duplicate&&(r|=1),void 0!==e?.txid&&null!==e.txid&&(r|=2),t.writeUInt8(r),1&r||t.write(j(e.hash,\"hex\").reverse())}}return t.toArray()}toHex(){return K(this.toBinary())}indexOf(t){const e=this.path[0].find((e=>e.hash===t));if(null==e)throw new Error(`Transaction ID ${t} not found in the Merkle Path`);return e.offset}computeRoot(t){if(\"string\"!=typeof t){const e=this.path[0].find((t=>Boolean(t?.hash)));if(null==e)throw new Error(\"No valid leaf found in the Merkle Path\");t=e.hash}if(\"string\"!=typeof t)throw new Error(\"Transaction ID is undefined\");const e=this.indexOf(t);if(\"number\"!=typeof e)throw new Error(`This proof does not contain the txid: ${t??\"undefined\"}`);const r=t=>K(H(j(t,\"hex\").reverse()).reverse());let i=t;if(1===this.path.length&&1===this.path[0].length)return i;for(let t=0;t<this.path.length;t++){this.path[t];const s=e>>t^1,n=this.findOrComputeLeaf(t,s);if(\"object\"!=typeof n)throw new Error(`Missing hash for index ${e} at height ${t}`);i=!0===n.duplicate?r((i??\"\")+(i??\"\")):r(s%2!=0?(n.hash??\"\")+(i??\"\"):(i??\"\")+(n.hash??\"\"))}return i}findOrComputeLeaf(t,e){const r=t=>K(H(j(t,\"hex\").reverse()).reverse());let i=this.path[t].find((t=>t.offset===e));if(null!=i)return i;if(0===t)return;const s=t-1,n=e<<1,a=this.findOrComputeLeaf(s,n);if(null==a||null==a.hash||\"\"===a.hash)return;const o=this.findOrComputeLeaf(s,n+1);if(null==o)return;let c;return c=!0===o.duplicate?r(a.hash+a.hash):r((o.hash??\"\")+(a.hash??\"\")),i={offset:e,hash:c},i}async verify(t,e){const r=this.computeRoot(t);if(0===this.indexOf(t)){const t=await e.currentHeight();if(this.blockHeight+100<t)return!1}return await e.isValidRootForHeight(r,this.blockHeight)}combine(t){if(this.blockHeight!==t.blockHeight)throw new Error(\"You cannot combine paths which do not have the same block height.\");if(this.computeRoot()!==t.computeRoot())throw new Error(\"You cannot combine paths which do not have the same root.\");const e=[];for(let r=0;r<this.path.length;r++){e.push([]);for(let t=0;t<this.path[r].length;t++)e[r].push(this.path[r][t]);for(let i=0;i<t.path[r].length;i++)if(void 0===e[r].find((e=>e.offset===t.path[r][i].offset)))e[r].push(t.path[r][i]);else if(void 0!==t.path[r][i]?.txid&&null!==t.path[r][i]?.txid){const s=e[r].find((e=>e.offset===t.path[r][i].offset));null!=s&&(s.txid=!0)}}this.path=e,this.trim()}trim(){const t=(t,e)=>{0!==e.length&&e.slice(-1)[0]===t||e.push(t)},e=(t,e)=>{for(let r=t.length;r>=0;r--){const i=this.path[e].findIndex((e=>e.offset===t[r]));i>=0&&this.path[e].splice(i,1)}},r=e=>{const r=[];for(const i of e)t(i>>1,r);return r};let i=[],s=[];for(let t=0;t<this.path.length;t++)this.path[t].sort(((t,e)=>t.offset-e.offset));for(let e=0;e<this.path[0].length;e++){const r=this.path[0][e];if(!0===r.txid)t(r.offset>>1,i);else{const i=r.offset%2==1,n=this.path[0][e+(i?-1:1)];void 0!==n.txid&&null!==n.txid&&n.txid||t(n.offset,s)}}e(s,0);for(let t=1;t<this.path.length;t++)s=i,i=r(i),e(s,t)}}class qt{_bumpIndex;_tx;_rawTx;_txid;inputTxids=[];isValid=void 0;get bumpIndex(){return this._bumpIndex}set bumpIndex(t){this._bumpIndex=t,this.updateInputTxids()}get hasProof(){return void 0!==this._bumpIndex}get isTxidOnly(){return void 0!==this._txid&&null!==this._txid&&null==this._rawTx&&null==this._tx}get txid(){if(void 0!==this._txid&&null!==this._txid&&\"\"!==this._txid)return this._txid;if(null!=this._tx)return this._txid=this._tx.id(\"hex\"),this._txid;if(null!=this._rawTx)return this._txid=K(H(this._rawTx)),this._txid;throw new Error(\"Internal\")}get tx(){return null!=this._tx?this._tx:null!=this._rawTx?(this._tx=zt.fromBinary(this._rawTx),this._tx):void 0}get rawTx(){return null!=this._rawTx?this._rawTx:null!=this._tx?(this._rawTx=this._tx.toBinary(),this._rawTx):void 0}constructor(t,e){\"string\"==typeof t?this._txid=t:Array.isArray(t)?this._rawTx=t:this._tx=t,this.bumpIndex=e,this.updateInputTxids()}static fromTx(t,e){return new qt(t,e)}static fromRawTx(t,e){return new qt(t,e)}static fromTxid(t,e){return new qt(t,e)}updateInputTxids(){if(this.hasProof||null==this.tx)this.inputTxids=[];else{const t={};for(const e of this.tx.inputs)void 0!==e.sourceTXID&&null!==e.sourceTXID&&\"\"!==e.sourceTXID&&(t[e.sourceTXID]=!0);this.inputTxids=Object.keys(t)}}toWriter(t,e){const r=e=>{t.writeUInt8(e)},i=()=>{if(null==this._txid)throw new Error(\"Transaction ID (_txid) is undefined\");t.writeReverse(j(this._txid,\"hex\"))},s=()=>{if(null!=this._rawTx)t.write(this._rawTx);else{if(null==this._tx)throw new Error(\"a valid serialized Transaction is expected\");t.write(this._tx.toBinary())}},n=()=>{void 0===this.bumpIndex?r(Xt.RAWTX):(r(Xt.RAWTX_AND_BUMP_INDEX),t.writeVarIntNum(this.bumpIndex))};e===Kt?this.isTxidOnly?(r(Xt.TXID_ONLY),i()):void 0!==this.bumpIndex?(r(Xt.RAWTX_AND_BUMP_INDEX),t.writeVarIntNum(this.bumpIndex),s()):(r(Xt.RAWTX),s()):(s(),n())}static fromReader(t,e){let r,i,s;if(e===Kt){const e=t.readUInt8();e===Xt.TXID_ONLY?s=qt.fromTxid(K(t.readReverse(32))):(e===Xt.RAWTX_AND_BUMP_INDEX&&(i=t.readVarIntNum()),r=zt.fromReader(t),s=qt.fromTx(r,i))}else r=zt.fromReader(t),i=0!==t.readUInt8()?t.readVarIntNum():void 0,s=qt.fromTx(r,i);return s}}function Vt(t){if(null==t)throw new Error(\"Expected a valid value, but got undefined.\");return t}const $t=4022206465,Kt=4022206466,jt=16843009;var Xt;!function(t){t[t.RAWTX=0]=\"RAWTX\",t[t.RAWTX_AND_BUMP_INDEX=1]=\"RAWTX_AND_BUMP_INDEX\",t[t.TXID_ONLY=2]=\"TXID_ONLY\"}(Xt||(Xt={}));class Yt{bumps=[];txs=[];version=Kt;atomicTxid=void 0;constructor(t=Kt){this.version=t}findTxid(t){return this.txs.find((e=>e.txid===t))}makeTxidOnly(t){const e=this.txs.findIndex((e=>e.txid===t));if(-1===e)return;let r=this.txs[e];return r.isTxidOnly||(this.txs.splice(e,1),r=this.mergeTxidOnly(t)),r}findBump(t){return this.bumps.find((e=>e.path[0].some((e=>e.hash===t))))}findTransactionForSigning(t){const e=this.findTxid(t);if(null!=e&&null!=e.tx){for(const t of e.tx.inputs)if(null==t.sourceTransaction){const e=this.findTxid(Vt(t.sourceTXID));null!=e&&(t.sourceTransaction=e.tx)}return e.tx}}findAtomicTransaction(t){const e=this.findTxid(t);if(null==e||null==e.tx)return;const r=(t,e)=>{const i=t.findBump(e.id(\"hex\"));if(null!=i)e.merklePath=i;else for(const i of e.inputs){if(null==i.sourceTransaction){const e=t.findTxid(Vt(i.sourceTXID));null!=e&&(i.sourceTransaction=e.tx)}if(null!=i.sourceTransaction){const e=t.findBump(i.sourceTransaction.id(\"hex\"));null!=e?i.sourceTransaction.merklePath=e:r(t,i.sourceTransaction)}}};return r(this,e.tx),e.tx}mergeBump(t){let e;for(let r=0;r<this.bumps.length;r++){const i=this.bumps[r];if(i===t)return r;if(i.blockHeight===t.blockHeight){if(i.computeRoot()===t.computeRoot()){i.combine(t),e=r;break}}}void 0===e&&(e=this.bumps.length,this.bumps.push(t));const r=this.bumps[e];for(const t of this.txs){const i=t.txid;if(null==t.bumpIndex)for(const s of r.path[0])if(s.hash===i){t.bumpIndex=e,s.txid=!0;break}}return e}mergeRawTx(t,e){const r=new qt(t,e);return this.removeExistingTxid(r.txid),this.txs.push(r),this.tryToValidateBumpIndex(r),r}mergeTransaction(t){const e=t.id(\"hex\");let r;this.removeExistingTxid(e),null!=t.merklePath&&(r=this.mergeBump(t.merklePath));const i=new qt(t,r);if(this.txs.push(i),this.tryToValidateBumpIndex(i),r=i.bumpIndex,void 0===r)for(const e of t.inputs)null!=e.sourceTransaction&&this.mergeTransaction(e.sourceTransaction);return i}removeExistingTxid(t){const e=this.txs.findIndex((e=>e.txid===t));e>=0&&this.txs.splice(e,1)}mergeTxidOnly(t){let e=this.txs.find((e=>e.txid===t));return null==e&&(e=new qt(t),this.txs.push(e),this.tryToValidateBumpIndex(e)),e}mergeBeefTx(t){let e=this.findTxid(t.txid);if(t.isTxidOnly&&null==e?e=this.mergeTxidOnly(t.txid):null==t._tx||null!=e&&!e.isTxidOnly?null==t._rawTx||null!=e&&!e.isTxidOnly||(e=this.mergeRawTx(t._rawTx)):e=this.mergeTransaction(t._tx),null==e)throw new Error(`Failed to merge BeefTx for txid: ${t.txid}`);return e}mergeBeef(t){const e=Array.isArray(t)?Yt.fromBinary(t):t;for(const t of e.bumps)this.mergeBump(t);for(const t of e.txs)this.mergeBeefTx(t)}isValid(t){return this.verifyValid(t).valid}async verify(t,e){const r=this.verifyValid(e);if(!r.valid)return!1;for(const e of Object.keys(r.roots)){if(!await t.isValidRootForHeight(r.roots[e],Number(e)))return!1}return!0}verifyValid(t){const e={valid:!1,roots:{}},r=this.sortTxs();if(r.missingInputs.length>0||r.notValid.length>0||r.txidOnly.length>0&&!0!==t||r.withMissingInputs.length>0)return e;const i={};for(const r of this.txs)if(r.isTxidOnly){if(!0!==t)return e;i[r.txid]=!0}const s=(t,r)=>{const i=t.computeRoot(r);return void 0!==e.roots[t.blockHeight]&&\"\"!==e.roots[t.blockHeight]||(e.roots[t.blockHeight]=i),e.roots[t.blockHeight]===i};for(const t of this.bumps)for(const r of t.path[0])if(!0===r.txid&&\"string\"==typeof r.hash&&r.hash.length>0&&(i[r.hash]=!0,!s(t,r.hash)))return e;for(const t of this.txs)if(void 0!==t.bumpIndex){const r=this.bumps[t.bumpIndex].path[0].find((e=>e.hash===t.txid));if(null==r)return e}for(const t of this.txs){for(const r of t.inputTxids)if(!i[r])return e;i[t.txid]=!0}return e.valid=!0,e}toWriter(t){t.writeUInt32LE(this.version),t.writeVarIntNum(this.bumps.length);for(const e of this.bumps)t.write(e.toBinary());t.writeVarIntNum(this.txs.length);for(const e of this.txs)e.toWriter(t,this.version)}toBinary(){this.sortTxs();const t=new rt;return this.toWriter(t),t.toArray()}toBinaryAtomic(t){this.sortTxs();const e=this.findTxid(t);if(null==e)throw new Error(`${t} does not exist in this Beef`);const r=this.txs[this.txs.length-1]===e?this:this.clone();if(r!==this){const e=this.txs.findIndex((e=>e.txid===t));r.txs.splice(e+1)}const i=new rt;return i.writeUInt32LE(jt),i.writeReverse(j(t,\"hex\")),r.toWriter(i),i.toArray()}toHex(){return K(this.toBinary())}static fromReader(t){let e,r=t.readUInt32LE();if(r===jt&&(e=K(t.readReverse(32)),r=t.readUInt32LE()),r!==$t&&r!==Kt)throw new Error(`Serialized BEEF must start with 4022206465 or ${Kt} but starts with ${r}`);const i=new Yt(r),s=t.readVarIntNum();for(let e=0;e<s;e++){const e=Ht.fromReader(t,!1);i.bumps.push(e)}const n=t.readVarIntNum();for(let e=0;e<n;e++){const e=qt.fromReader(t,r);i.txs.push(e)}return i.atomicTxid=e,i}static fromBinary(t){const e=new it(t);return Yt.fromReader(e)}static fromString(t,e=\"hex\"){const r=j(t,e),i=new it(r);return Yt.fromReader(i)}tryToValidateBumpIndex(t){if(void 0!==t.bumpIndex)return!0;const e=t.txid;for(let r=0;r<this.bumps.length;r++){const i=this.bumps[r].path[0].findIndex((t=>t.hash===e));if(i>=0)return t.bumpIndex=r,this.bumps[r].path[0][i].txid=!0,!0}return!1}sortTxs(){const t={},e={};let r=[];const i=[],s=[];for(const n of this.txs)e[n.txid]=n,n.isValid=n.hasProof,n.isValid?(t[n.txid]=!0,i.push(n)):n.isTxidOnly&&0===n.inputTxids.length?(t[n.txid]=!0,s.push(n)):r.push(n);const n={},a=[],o=r;r=[];for(const t of o){let i=!1;for(const r of t.inputTxids)void 0===e[r]&&(n[r]=!0,i=!0);i?a.push(t):r.push(t)}for(;r.length>0;){const e=r;r=[];for(const s of e)s.inputTxids.every((e=>t[e]))?(t[s.txid]=!0,i.push(s)):r.push(s);if(e.length===r.length)break}const c=r;return this.txs=a.concat(c).concat(s).concat(i),{missingInputs:Object.keys(n),notValid:c.map((t=>t.txid)),valid:Object.keys(t),withMissingInputs:a.map((t=>t.txid)),txidOnly:s.map((t=>t.txid))}}clone(){const t=new Yt;return t.version=this.version,t.bumps=Array.from(this.bumps),t.txs=Array.from(this.txs),t}trimKnownTxids(t){for(let e=0;e<this.txs.length;){const r=this.txs[e];r.isTxidOnly&&t.includes(r.txid)?this.txs.splice(e,1):e++}}getValidTxids(){return this.sortTxs().valid}toLogString(){let t=\"\";t+=`BEEF with ${this.bumps.length} BUMPS and ${this.txs.length} Transactions, isValid ${this.isValid().toString()}\\n`;let e=-1;for(const r of this.bumps)e++,t+=`  BUMP ${e}\\n    block: ${r.blockHeight}\\n    txids: [\\n${r.path[0].filter((t=>!0===t.txid)).map((t=>`      '${t.hash??\"\"}'`)).join(\",\\n\")}\\n    ]\\n`;e=-1;for(const r of this.txs)e++,t+=`  TX ${e}\\n    txid: ${r.txid}\\n`,void 0!==r.bumpIndex&&(t+=`    bumpIndex: ${r.bumpIndex}\\n`),r.isTxidOnly?t+=\"    txidOnly\\n\":t+=`    rawTx length=${r.rawTx?.length??0}\\n`,r.inputTxids.length>0&&(t+=`    inputs: [\\n${r.inputTxids.map((t=>`      '${t}'`)).join(\",\\n\")}\\n    ]\\n`);return t}addComputedLeaves(){const t=t=>K(H(j(t,\"hex\").reverse()).reverse());for(const e of this.bumps)for(let r=1;r<e.path.length;r++)for(const i of e.path[r-1])if(\"string\"==typeof i.hash&&!(1&i.offset)){const s=e.path[r-1].find((t=>t.offset===i.offset+1)),n=i.offset>>1;void 0!==s&&\"string\"==typeof s.hash&&e.path[r].every((t=>t.offset!==n))&&e.path[r].push({offset:n,hash:t(s.hash+i.hash)})}}}class zt{version;inputs;outputs;lockTime;metadata;merklePath;cachedHash;static addPathOrInputs(t,e,r){if(\"number\"==typeof t.pathIndex){const e=r[t.pathIndex];if(\"object\"!=typeof e)throw new Error(\"Invalid merkle path index found in BEEF!\");t.tx.merklePath=e}else for(const i of t.tx.inputs){if(void 0===i.sourceTXID)throw new Error(\"Input sourceTXID is undefined\");const t=e[i.sourceTXID];if(\"object\"!=typeof t)throw new Error(`Reference to unknown TXID in BEEF: ${i.sourceTXID??\"undefined\"}`);i.sourceTransaction=t.tx,this.addPathOrInputs(t,e,r)}}static fromBEEF(t,e){const{tx:r}=zt.fromAnyBeef(t,e);return r}static fromAtomicBEEF(t){const{tx:e,txid:r,beef:i}=zt.fromAnyBeef(t);if(r!==i.atomicTxid)throw i.atomicTxid?new Error(`Transaction with TXID ${i.atomicTxid} not found in BEEF data.`):new Error(\"beef must conform to BRC-95 and must contain the subject txid.\");return e}static fromAnyBeef(t,e){const r=Yt.fromBinary(t);if(r.txs.length<1)throw new Error(\"beef must include at least one transaction.\");const i=e||r.atomicTxid||r.txs.slice(-1)[0].txid,s=r.findAtomicTransaction(i);if(null==s)throw e?new Error(`Transaction with TXID ${i} not found in BEEF data.`):new Error(\"beef does not contain transaction for atomic txid.\");return{tx:s,beef:r,txid:i}}static fromEF(t){const e=new it(t),r=e.readUInt32LE();if(\"0000000000ef\"!==K(e.read(6)))throw new Error(\"Invalid EF marker\");const i=e.readVarIntNum(),s=[];for(let t=0;t<i;t++){const t=K(e.readReverse(32)),r=e.readUInt32LE(),i=e.readVarIntNum(),n=e.read(i),a=xt.fromBinary(n),o=e.readUInt32LE(),c=e.readUInt64LEBn().toNumber(),h=e.readVarIntNum(),d=e.read(h),u=_t.fromBinary(d),f=new zt(void 0,[],[],void 0);f.outputs=Array(r+1).fill(null),f.outputs[r]={satoshis:c,lockingScript:u},s.push({sourceTransaction:f,sourceTXID:t,sourceOutputIndex:r,unlockingScript:a,sequence:o})}const n=e.readVarIntNum(),a=[];for(let t=0;t<n;t++){const t=e.readUInt64LEBn().toNumber(),r=e.readVarIntNum(),i=e.read(r),s=_t.fromBinary(i);a.push({satoshis:t,lockingScript:s})}const o=e.readUInt32LE();return new zt(r,s,a,o)}static parseScriptOffsets(t){const e=new it(t),r=[],i=[];e.pos+=4;const s=e.readVarIntNum();for(let t=0;t<s;t++){e.pos+=36;const i=e.readVarIntNum();r.push({vin:t,offset:e.pos,length:i}),e.pos+=i+4}const n=e.readVarIntNum();for(let t=0;t<n;t++){e.pos+=8;const r=e.readVarIntNum();i.push({vout:t,offset:e.pos,length:r}),e.pos+=r}return{inputs:r,outputs:i}}static fromReader(t){const e=t.readUInt32LE(),r=t.readVarIntNum(),i=[];for(let e=0;e<r;e++){const e=K(t.readReverse(32)),r=t.readUInt32LE(),s=t.readVarIntNum(),n=t.read(s),a=xt.fromBinary(n),o=t.readUInt32LE();i.push({sourceTXID:e,sourceOutputIndex:r,unlockingScript:a,sequence:o})}const s=t.readVarIntNum(),n=[];for(let e=0;e<s;e++){const e=t.readUInt64LEBn().toNumber(),r=t.readVarIntNum(),i=t.read(r),s=_t.fromBinary(i);n.push({satoshis:e,lockingScript:s})}const a=t.readUInt32LE();return new zt(e,i,n,a)}static fromBinary(t){const e=new it(t);return zt.fromReader(e)}static fromHex(t){return zt.fromBinary(j(t,\"hex\"))}static fromHexEF(t){return zt.fromEF(j(t,\"hex\"))}static fromHexBEEF(t,e){return zt.fromBEEF(j(t,\"hex\"),e)}constructor(t=1,e=[],r=[],i=0,s={},n){this.version=t,this.inputs=e,this.outputs=r,this.lockTime=i,this.metadata=s,this.merklePath=n}addInput(t){if(void 0===t.sourceTXID&&void 0===t.sourceTransaction)throw new Error(\"A reference to an an input transaction is required. If the input transaction itself cannot be referenced, its TXID must still be provided.\");void 0===t.sequence&&(t.sequence=4294967295),this.cachedHash=void 0,this.inputs.push(t)}addOutput(t){if(this.cachedHash=void 0,!0!==t.change){if(void 0===t.satoshis)throw new Error(\"either satoshis must be defined or change must be set to true\");if(t.satoshis<0)throw new Error(\"satoshis must be a positive integer or zero\")}if(null==t.lockingScript)throw new Error(\"lockingScript must be defined\");this.outputs.push(t)}addP2PKHOutput(t,e){const r=(new Nt).lock(t);if(void 0===e)return this.addOutput({lockingScript:r,change:!0});this.addOutput({lockingScript:r,satoshis:e})}updateMetadata(t){this.metadata={...this.metadata,...t}}async fee(t=new Ft(1),e=\"equal\"){if(this.cachedHash=void 0,\"number\"==typeof t){const e=t;t={computeFee:async()=>e}}const r=await t.computeFee(this),i=this.calculateChange(r);i<=0?this.outputs=this.outputs.filter((t=>!0!==t.change)):this.distributeChange(i,e)}calculateChange(t){let e=0;for(const t of this.inputs){if(\"object\"!=typeof t.sourceTransaction)throw new Error(\"Source transactions are required for all inputs during fee computation\");e+=t.sourceTransaction.outputs[t.sourceOutputIndex].satoshis??0}e-=t;for(const t of this.outputs)!0!==t.change&&void 0!==t.satoshis&&(e-=t.satoshis);return e}distributeChange(t,e){let r=0;const i=this.outputs.filter((t=>t.change));if(\"random\"===e?r=this.distributeRandomChange(t,i):\"equal\"===e&&(r=this.distributeEqualChange(t,i)),r<t){const e=this.outputs[this.outputs.length-1];void 0!==e.satoshis?e.satoshis+=t-r:e.satoshis=t-r}}distributeRandomChange(t,e){let r=0,i=t;const s=Array(e.length).fill(1);i-=e.length,r+=e.length;for(let t=0;t<e.length-1;t++){const e=this.benfordNumber(0,i);s[t]=s[t]+e,r+=e,i-=e}for(const t of this.outputs)!0===t.change&&(t.satoshis=s.shift());return r}distributeEqualChange(t,e){let r=0;const i=Math.floor(t/e.length);for(const t of e)r+=i,t.satoshis=i;return r}benfordNumber(t,e){const r=Math.floor(9*Math.random())+1;return Math.floor(t+(e-t)*Math.log10(1+1/r)/Math.log10(10))}getFee(){let t=0;for(const e of this.inputs){if(\"object\"!=typeof e.sourceTransaction)throw new Error(\"Source transactions or sourceSatoshis are required for all inputs to calculate fee\");t+=e.sourceTransaction.outputs[e.sourceOutputIndex].satoshis??0}let e=0;for(const t of this.outputs)e+=t.satoshis??0;return t-e}async sign(){this.cachedHash=void 0;for(const t of this.outputs)if(void 0===t.satoshis)throw!0===t.change?new Error(\"There are still change outputs with uncomputed amounts. Use the fee() method to compute the change amounts and transaction fees prior to signing.\"):new Error(\"One or more transaction outputs is missing an amount. Ensure all output amounts are provided before signing.\");const t=await Promise.all(this.inputs.map((async(t,e)=>\"object\"==typeof this.inputs[e].unlockingScriptTemplate?await(this.inputs[e]?.unlockingScriptTemplate?.sign(this,e)):await Promise.resolve(void 0))));for(let e=0,r=this.inputs.length;e<r;e++)\"object\"==typeof this.inputs[e].unlockingScriptTemplate&&(this.inputs[e].unlockingScript=t[e])}async broadcast(t=function(t=!1,e={}){return new Dt(t?\"https://arc-test.taal.com\":\"https://arc.taal.com\",e)}()){return await t.broadcast(this)}toBinary(){const t=new rt;t.writeUInt32LE(this.version),t.writeVarIntNum(this.inputs.length);for(const e of this.inputs){if(void 0===e.sourceTXID){if(null==e.sourceTransaction)throw new Error(\"sourceTransaction is undefined\");t.write(e.sourceTransaction.hash())}else t.writeReverse(j(e.sourceTXID,\"hex\"));if(t.writeUInt32LE(e.sourceOutputIndex),null==e.unlockingScript)throw new Error(\"unlockingScript is undefined\");const r=e.unlockingScript.toBinary();t.writeVarIntNum(r.length),t.write(r),t.writeUInt32LE(e.sequence??0)}t.writeVarIntNum(this.outputs.length);for(const e of this.outputs){t.writeUInt64LE(e.satoshis??0);const r=e.lockingScript.toBinary();t.writeVarIntNum(r.length),t.write(r)}return t.writeUInt32LE(this.lockTime),t.toArray()}toEF(){const t=new rt;t.writeUInt32LE(this.version),t.write([0,0,0,0,0,239]),t.writeVarIntNum(this.inputs.length);for(const e of this.inputs){if(void 0===e.sourceTransaction)throw new Error(\"All inputs must have source transactions when serializing to EF format\");if(void 0===e.sourceTXID?t.write(e.sourceTransaction.hash()):t.write(j(e.sourceTXID,\"hex\").reverse()),t.writeUInt32LE(e.sourceOutputIndex),null==e.unlockingScript)throw new Error(\"unlockingScript is undefined\");const r=e.unlockingScript.toBinary();t.writeVarIntNum(r.length),t.write(r),t.writeUInt32LE(e.sequence??0),t.writeUInt64LE(e.sourceTransaction.outputs[e.sourceOutputIndex].satoshis??0);const i=e.sourceTransaction.outputs[e.sourceOutputIndex].lockingScript.toBinary();t.writeVarIntNum(i.length),t.write(i)}t.writeVarIntNum(this.outputs.length);for(const e of this.outputs){t.writeUInt64LE(e.satoshis??0);const r=e.lockingScript.toBinary();t.writeVarIntNum(r.length),t.write(r)}return t.writeUInt32LE(this.lockTime),t.toArray()}toHexEF(){return K(this.toEF())}toHex(){return K(this.toBinary())}toHexBEEF(){return K(this.toBEEF())}toHexAtomicBEEF(){return K(this.toAtomicBEEF())}hash(t){let e;return null!=this.cachedHash?e=this.cachedHash:(e=H(this.toBinary()),this.cachedHash=e),\"hex\"===t?K(e):e}id(t){const e=[...this.hash()];return e.reverse(),\"hex\"===t?K(e):e}async verify(t=function(){return new Ct}(),e){const r=new Set,i=[this];for(;i.length>0;){const s=i.shift(),n=s?.id(\"hex\")??\"\";if(null!=n&&\"\"!==n&&r.has(n))continue;if(\"object\"==typeof s?.merklePath){if(\"scripts only\"===t){null!=n&&r.add(n);continue}if(await s.merklePath.verify(n,t)){r.add(n);continue}}if(void 0!==e){if(void 0===s)throw new Error(\"Transaction is undefined\");const t=zt.fromEF(s.toEF());if(delete t.outputs[0].satoshis,t.outputs[0].change=!0,await t.fee(e),s.getFee()<t.getFee())throw new Error(`Verification failed because the transaction ${n} has an insufficient fee and has not been mined.`)}let a=0;if(void 0===s)throw new Error(\"Transaction is undefined\");for(let t=0;t<s.inputs.length;t++){const e=s.inputs[t];if(\"object\"!=typeof e.sourceTransaction)throw new Error(`Verification failed because the input at index ${t} of transaction ${n} is missing an associated source transaction. This source transaction is required for transaction verification because there is no merkle proof for the transaction spending a UTXO it contains.`);if(\"object\"!=typeof e.unlockingScript)throw new Error(`Verification failed because the input at index ${t} of transaction ${n} is missing an associated unlocking script. This script is required for transaction verification because there is no merkle proof for the transaction spending the UTXO.`);const o=e.sourceTransaction.outputs[e.sourceOutputIndex];a+=o.satoshis??0;const c=e.sourceTransaction.id(\"hex\");r.has(c)||i.push(e.sourceTransaction);const h=s.inputs.filter(((e,r)=>r!==t));void 0===e.sourceTXID&&(e.sourceTXID=c);if(!new Mt({sourceTXID:e.sourceTXID,sourceOutputIndex:e.sourceOutputIndex,lockingScript:o.lockingScript,sourceSatoshis:o.satoshis??0,transactionVersion:s.version,otherInputs:h,unlockingScript:e.unlockingScript,inputSequence:e.sequence??0,inputIndex:t,outputs:s.outputs,lockTime:s.lockTime}).validate())return!1}let o=0;for(const t of s.outputs){if(\"number\"!=typeof t.satoshis)throw new Error(\"Every output must have a defined amount during transaction verification.\");o+=t.satoshis}if(o>a)return!1;r.add(n)}return!0}toBEEF(t){const e=new rt;e.writeUInt32LE($t);const r=[],i=[],s=e=>{const n={tx:e},a=\"object\"==typeof e.merklePath;if(a){let t=!1;for(let i=0;i<r.length;i++){if(r[i]===e.merklePath){n.pathIndex=i,t=!0;break}if(null!==e.merklePath&&void 0!==e.merklePath&&r[i].blockHeight===e.merklePath.blockHeight){if(r[i].computeRoot()===e.merklePath.computeRoot()){r[i].combine(e.merklePath),n.pathIndex=i,t=!0;break}}}t||(n.pathIndex=r.length,null!==e.merklePath&&void 0!==e.merklePath&&r.push(e.merklePath))}const o=i.some((t=>t.tx.id(\"hex\")===e.id(\"hex\")));if(o||i.unshift(n),!a)for(let r=0;r<e.inputs.length;r++){const i=e.inputs[r];if(\"object\"==typeof i.sourceTransaction)s(i.sourceTransaction);else if(!1===t)throw new Error(\"A required source transaction is missing!\")}};s(this),e.writeVarIntNum(r.length);for(const t of r)e.write(t.toBinary());e.writeVarIntNum(i.length);for(const t of i)e.write(t.tx.toBinary()),\"number\"==typeof t.pathIndex?(e.writeUInt8(1),e.writeVarIntNum(t.pathIndex)):e.writeUInt8(0);return e.toArray()}toAtomicBEEF(t){const e=new rt;e.writeUInt32LE(16843009),e.write(this.hash());const r=this.toBEEF(t);return e.write(r),e.toArray()}}const Wt=\"Bitcoin Signed Message:\\n\",Gt=t=>{const e=new rt;e.writeVarIntNum(24),e.write(j(Wt,\"utf8\")),e.writeVarIntNum(t.length),e.write(t);const r=e.toArray();return H(r)},Zt=(e,r,i)=>{const s=Gt(e);return lt(new t(s),r,i)};var Jt,Qt,te;!function(t){t[t.Silent=0]=\"Silent\",t[t.App=1]=\"App\",t[t.Counterparty=2]=\"Counterparty\"}(Jt||(Jt={})),function(t){t[t.unknownError=1]=\"unknownError\",t[t.unsupportedAction=2]=\"unsupportedAction\",t[t.invalidHmac=3]=\"invalidHmac\",t[t.invalidSignature=4]=\"invalidSignature\",t[t.reviewActions=5]=\"reviewActions\"}(Qt||(Qt={})),function(t){t[t.createAction=1]=\"createAction\",t[t.signAction=2]=\"signAction\",t[t.abortAction=3]=\"abortAction\",t[t.listActions=4]=\"listActions\",t[t.internalizeAction=5]=\"internalizeAction\",t[t.listOutputs=6]=\"listOutputs\",t[t.relinquishOutput=7]=\"relinquishOutput\",t[t.getPublicKey=8]=\"getPublicKey\",t[t.revealCounterpartyKeyLinkage=9]=\"revealCounterpartyKeyLinkage\",t[t.revealSpecificKeyLinkage=10]=\"revealSpecificKeyLinkage\",t[t.encrypt=11]=\"encrypt\",t[t.decrypt=12]=\"decrypt\",t[t.createHmac=13]=\"createHmac\",t[t.verifyHmac=14]=\"verifyHmac\",t[t.createSignature=15]=\"createSignature\",t[t.verifySignature=16]=\"verifySignature\",t[t.acquireCertificate=17]=\"acquireCertificate\",t[t.listCertificates=18]=\"listCertificates\",t[t.proveCertificate=19]=\"proveCertificate\",t[t.relinquishCertificate=20]=\"relinquishCertificate\",t[t.discoverByIdentityKey=21]=\"discoverByIdentityKey\",t[t.discoverByAttributes=22]=\"discoverByAttributes\",t[t.isAuthenticated=23]=\"isAuthenticated\",t[t.waitForAuthentication=24]=\"waitForAuthentication\",t[t.getHeight=25]=\"getHeight\",t[t.getHeaderForHeight=26]=\"getHeaderForHeight\",t[t.getNetwork=27]=\"getNetwork\",t[t.getVersion=28]=\"getVersion\"}(te||(te={})),\"undefined\"!=typeof window?fetch.bind(window):fetch;var ee=\"undefined\"!=typeof global?global:\"undefined\"!=typeof self?self:\"undefined\"!=typeof window?window:{},re=[],ie=[],se=\"undefined\"!=typeof Uint8Array?Uint8Array:Array,ne=!1;function ae(){ne=!0;for(var t=\"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\",e=0;e<64;++e)re[e]=t[e],ie[t.charCodeAt(e)]=e;ie[\"-\".charCodeAt(0)]=62,ie[\"_\".charCodeAt(0)]=63}function oe(t,e,r){for(var i,s,n=[],a=e;a<r;a+=3)i=(t[a]<<16)+(t[a+1]<<8)+t[a+2],n.push(re[(s=i)>>18&63]+re[s>>12&63]+re[s>>6&63]+re[63&s]);return n.join(\"\")}function ce(t){var e;ne||ae();for(var r=t.length,i=r%3,s=\"\",n=[],a=16383,o=0,c=r-i;o<c;o+=a)n.push(oe(t,o,o+a>c?c:o+a));return 1===i?(e=t[r-1],s+=re[e>>2],s+=re[e<<4&63],s+=\"==\"):2===i&&(e=(t[r-2]<<8)+t[r-1],s+=re[e>>10],s+=re[e>>4&63],s+=re[e<<2&63],s+=\"=\"),n.push(s),n.join(\"\")}function he(t,e,r,i,s){var n,a,o=8*s-i-1,c=(1<<o)-1,h=c>>1,d=-7,u=r?s-1:0,f=r?-1:1,l=t[e+u];for(u+=f,n=l&(1<<-d)-1,l>>=-d,d+=o;d>0;n=256*n+t[e+u],u+=f,d-=8);for(a=n&(1<<-d)-1,n>>=-d,d+=i;d>0;a=256*a+t[e+u],u+=f,d-=8);if(0===n)n=1-h;else{if(n===c)return a?NaN:1/0*(l?-1:1);a+=Math.pow(2,i),n-=h}return(l?-1:1)*a*Math.pow(2,n-i)}function de(t,e,r,i,s,n){var a,o,c,h=8*n-s-1,d=(1<<h)-1,u=d>>1,f=23===s?Math.pow(2,-24)-Math.pow(2,-77):0,l=i?0:n-1,b=i?1:-1,p=e<0||0===e&&1/e<0?1:0;for(e=Math.abs(e),isNaN(e)||e===1/0?(o=isNaN(e)?1:0,a=d):(a=Math.floor(Math.log(e)/Math.LN2),e*(c=Math.pow(2,-a))<1&&(a--,c*=2),(e+=a+u>=1?f/c:f*Math.pow(2,1-u))*c>=2&&(a++,c/=2),a+u>=d?(o=0,a=d):a+u>=1?(o=(e*c-1)*Math.pow(2,s),a+=u):(o=e*Math.pow(2,u-1)*Math.pow(2,s),a=0));s>=8;t[r+l]=255&o,l+=b,o/=256,s-=8);for(a=a<<s|o,h+=s;h>0;t[r+l]=255&a,l+=b,a/=256,h-=8);t[r+l-b]|=128*p}var ue={}.toString,fe=Array.isArray||function(t){return\"[object Array]\"==ue.call(t)};function le(){return pe.TYPED_ARRAY_SUPPORT?2147483647:1073741823}function be(t,e){if(le()<e)throw new RangeError(\"Invalid typed array length\");return pe.TYPED_ARRAY_SUPPORT?(t=new Uint8Array(e)).__proto__=pe.prototype:(null===t&&(t=new pe(e)),t.length=e),t}function pe(t,e,r){if(!(pe.TYPED_ARRAY_SUPPORT||this instanceof pe))return new pe(t,e,r);if(\"number\"==typeof t){if(\"string\"==typeof e)throw new Error(\"If encoding is specified then the first argument must be a string\");return we(this,t)}return ge(this,t,e,r)}function ge(t,e,r,i){if(\"number\"==typeof e)throw new TypeError('\"value\" argument must not be a number');return\"undefined\"!=typeof ArrayBuffer&&e instanceof ArrayBuffer?function(t,e,r,i){if(e.byteLength,r<0||e.byteLength<r)throw new RangeError(\"'offset' is out of bounds\");if(e.byteLength<r+(i||0))throw new RangeError(\"'length' is out of bounds\");e=void 0===r&&void 0===i?new Uint8Array(e):void 0===i?new Uint8Array(e,r):new Uint8Array(e,r,i);pe.TYPED_ARRAY_SUPPORT?(t=e).__proto__=pe.prototype:t=ye(t,e);return t}(t,e,r,i):\"string\"==typeof e?function(t,e,r){\"string\"==typeof r&&\"\"!==r||(r=\"utf8\");if(!pe.isEncoding(r))throw new TypeError('\"encoding\" must be a valid string encoding');var i=0|Oe(e,r);t=be(t,i);var s=t.write(e,r);s!==i&&(t=t.slice(0,s));return t}(t,e,r):function(t,e){if(Pe(e)){var r=0|ve(e.length);return 0===(t=be(t,r)).length||e.copy(t,0,0,r),t}if(e){if(\"undefined\"!=typeof ArrayBuffer&&e.buffer instanceof ArrayBuffer||\"length\"in e)return\"number\"!=typeof e.length||(i=e.length)!=i?be(t,0):ye(t,e);if(\"Buffer\"===e.type&&fe(e.data))return ye(t,e.data)}var i;throw new TypeError(\"First argument must be a string, Buffer, ArrayBuffer, Array, or array-like object.\")}(t,e)}function me(t){if(\"number\"!=typeof t)throw new TypeError('\"size\" argument must be a number');if(t<0)throw new RangeError('\"size\" argument must not be negative')}function we(t,e){if(me(e),t=be(t,e<0?0:0|ve(e)),!pe.TYPED_ARRAY_SUPPORT)for(var r=0;r<e;++r)t[r]=0;return t}function ye(t,e){var r=e.length<0?0:0|ve(e.length);t=be(t,r);for(var i=0;i<r;i+=1)t[i]=255&e[i];return t}function ve(t){if(t>=le())throw new RangeError(\"Attempt to allocate Buffer larger than maximum size: 0x\"+le().toString(16)+\" bytes\");return 0|t}function Pe(t){return!(null==t||!t._isBuffer)}function Oe(t,e){if(Pe(t))return t.length;if(\"undefined\"!=typeof ArrayBuffer&&\"function\"==typeof ArrayBuffer.isView&&(ArrayBuffer.isView(t)||t instanceof ArrayBuffer))return t.byteLength;\"string\"!=typeof t&&(t=\"\"+t);var r=t.length;if(0===r)return 0;for(var i=!1;;)switch(e){case\"ascii\":case\"latin1\":case\"binary\":return r;case\"utf8\":case\"utf-8\":case void 0:return We(t).length;case\"ucs2\":case\"ucs-2\":case\"utf16le\":case\"utf-16le\":return 2*r;case\"hex\":return r>>>1;case\"base64\":return Ge(t).length;default:if(i)return We(t).length;e=(\"\"+e).toLowerCase(),i=!0}}function Ee(t,e,r){var i=!1;if((void 0===e||e<0)&&(e=0),e>this.length)return\"\";if((void 0===r||r>this.length)&&(r=this.length),r<=0)return\"\";if((r>>>=0)<=(e>>>=0))return\"\";for(t||(t=\"utf8\");;)switch(t){case\"hex\":return De(this,e,r);case\"utf8\":case\"utf-8\":return Be(this,e,r);case\"ascii\":return Ue(this,e,r);case\"latin1\":case\"binary\":return Le(this,e,r);case\"base64\":return Fe(this,e,r);case\"ucs2\":case\"ucs-2\":case\"utf16le\":case\"utf-16le\":return Ce(this,e,r);default:if(i)throw new TypeError(\"Unknown encoding: \"+t);t=(t+\"\").toLowerCase(),i=!0}}function ke(t,e,r){var i=t[e];t[e]=t[r],t[r]=i}function _e(t,e,r,i,s){if(0===t.length)return-1;if(\"string\"==typeof r?(i=r,r=0):r>2147483647?r=2147483647:r<-2147483648&&(r=-2147483648),r=+r,isNaN(r)&&(r=s?0:t.length-1),r<0&&(r=t.length+r),r>=t.length){if(s)return-1;r=t.length-1}else if(r<0){if(!s)return-1;r=0}if(\"string\"==typeof e&&(e=pe.from(e,i)),Pe(e))return 0===e.length?-1:xe(t,e,r,i,s);if(\"number\"==typeof e)return e&=255,pe.TYPED_ARRAY_SUPPORT&&\"function\"==typeof Uint8Array.prototype.indexOf?s?Uint8Array.prototype.indexOf.call(t,e,r):Uint8Array.prototype.lastIndexOf.call(t,e,r):xe(t,[e],r,i,s);throw new TypeError(\"val must be string, number or Buffer\")}function xe(t,e,r,i,s){var n,a=1,o=t.length,c=e.length;if(void 0!==i&&(\"ucs2\"===(i=String(i).toLowerCase())||\"ucs-2\"===i||\"utf16le\"===i||\"utf-16le\"===i)){if(t.length<2||e.length<2)return-1;a=2,o/=2,c/=2,r/=2}function h(t,e){return 1===a?t[e]:t.readUInt16BE(e*a)}if(s){var d=-1;for(n=r;n<o;n++)if(h(t,n)===h(e,-1===d?0:n-d)){if(-1===d&&(d=n),n-d+1===c)return d*a}else-1!==d&&(n-=n-d),d=-1}else for(r+c>o&&(r=o-c),n=r;n>=0;n--){for(var u=!0,f=0;f<c;f++)if(h(t,n+f)!==h(e,f)){u=!1;break}if(u)return n}return-1}function Ie(t,e,r,i){r=Number(r)||0;var s=t.length-r;i?(i=Number(i))>s&&(i=s):i=s;var n=e.length;if(n%2!=0)throw new TypeError(\"Invalid hex string\");i>n/2&&(i=n/2);for(var a=0;a<i;++a){var o=parseInt(e.substr(2*a,2),16);if(isNaN(o))return a;t[r+a]=o}return a}function Se(t,e,r,i){return Ze(We(e,t.length-r),t,r,i)}function Ae(t,e,r,i){return Ze(function(t){for(var e=[],r=0;r<t.length;++r)e.push(255&t.charCodeAt(r));return e}(e),t,r,i)}function Me(t,e,r,i){return Ae(t,e,r,i)}function Te(t,e,r,i){return Ze(Ge(e),t,r,i)}function Ne(t,e,r,i){return Ze(function(t,e){for(var r,i,s,n=[],a=0;a<t.length&&!((e-=2)<0);++a)i=(r=t.charCodeAt(a))>>8,s=r%256,n.push(s),n.push(i);return n}(e,t.length-r),t,r,i)}function Fe(t,e,r){return 0===e&&r===t.length?ce(t):ce(t.slice(e,r))}function Be(t,e,r){r=Math.min(t.length,r);for(var i=[],s=e;s<r;){var n,a,o,c,h=t[s],d=null,u=h>239?4:h>223?3:h>191?2:1;if(s+u<=r)switch(u){case 1:h<128&&(d=h);break;case 2:128==(192&(n=t[s+1]))&&(c=(31&h)<<6|63&n)>127&&(d=c);break;case 3:n=t[s+1],a=t[s+2],128==(192&n)&&128==(192&a)&&(c=(15&h)<<12|(63&n)<<6|63&a)>2047&&(c<55296||c>57343)&&(d=c);break;case 4:n=t[s+1],a=t[s+2],o=t[s+3],128==(192&n)&&128==(192&a)&&128==(192&o)&&(c=(15&h)<<18|(63&n)<<12|(63&a)<<6|63&o)>65535&&c<1114112&&(d=c)}null===d?(d=65533,u=1):d>65535&&(d-=65536,i.push(d>>>10&1023|55296),d=56320|1023&d),i.push(d),s+=u}return function(t){var e=t.length;if(e<=Re)return String.fromCharCode.apply(String,t);var r=\"\",i=0;for(;i<e;)r+=String.fromCharCode.apply(String,t.slice(i,i+=Re));return r}(i)}pe.TYPED_ARRAY_SUPPORT=void 0===ee.TYPED_ARRAY_SUPPORT||ee.TYPED_ARRAY_SUPPORT,le(),pe.poolSize=8192,pe._augment=function(t){return t.__proto__=pe.prototype,t},pe.from=function(t,e,r){return ge(null,t,e,r)},pe.TYPED_ARRAY_SUPPORT&&(pe.prototype.__proto__=Uint8Array.prototype,pe.__proto__=Uint8Array,\"undefined\"!=typeof Symbol&&Symbol.species&&pe[Symbol.species]),pe.alloc=function(t,e,r){return function(t,e,r,i){return me(e),e<=0?be(t,e):void 0!==r?\"string\"==typeof i?be(t,e).fill(r,i):be(t,e).fill(r):be(t,e)}(null,t,e,r)},pe.allocUnsafe=function(t){return we(null,t)},pe.allocUnsafeSlow=function(t){return we(null,t)},pe.isBuffer=function(t){return null!=t&&(!!t._isBuffer||Je(t)||function(t){return\"function\"==typeof t.readFloatLE&&\"function\"==typeof t.slice&&Je(t.slice(0,0))}(t))},pe.compare=function(t,e){if(!Pe(t)||!Pe(e))throw new TypeError(\"Arguments must be Buffers\");if(t===e)return 0;for(var r=t.length,i=e.length,s=0,n=Math.min(r,i);s<n;++s)if(t[s]!==e[s]){r=t[s],i=e[s];break}return r<i?-1:i<r?1:0},pe.isEncoding=function(t){switch(String(t).toLowerCase()){case\"hex\":case\"utf8\":case\"utf-8\":case\"ascii\":case\"latin1\":case\"binary\":case\"base64\":case\"ucs2\":case\"ucs-2\":case\"utf16le\":case\"utf-16le\":return!0;default:return!1}},pe.concat=function(t,e){if(!fe(t))throw new TypeError('\"list\" argument must be an Array of Buffers');if(0===t.length)return pe.alloc(0);var r;if(void 0===e)for(e=0,r=0;r<t.length;++r)e+=t[r].length;var i=pe.allocUnsafe(e),s=0;for(r=0;r<t.length;++r){var n=t[r];if(!Pe(n))throw new TypeError('\"list\" argument must be an Array of Buffers');n.copy(i,s),s+=n.length}return i},pe.byteLength=Oe,pe.prototype._isBuffer=!0,pe.prototype.swap16=function(){var t=this.length;if(t%2!=0)throw new RangeError(\"Buffer size must be a multiple of 16-bits\");for(var e=0;e<t;e+=2)ke(this,e,e+1);return this},pe.prototype.swap32=function(){var t=this.length;if(t%4!=0)throw new RangeError(\"Buffer size must be a multiple of 32-bits\");for(var e=0;e<t;e+=4)ke(this,e,e+3),ke(this,e+1,e+2);return this},pe.prototype.swap64=function(){var t=this.length;if(t%8!=0)throw new RangeError(\"Buffer size must be a multiple of 64-bits\");for(var e=0;e<t;e+=8)ke(this,e,e+7),ke(this,e+1,e+6),ke(this,e+2,e+5),ke(this,e+3,e+4);return this},pe.prototype.toString=function(){var t=0|this.length;return 0===t?\"\":0===arguments.length?Be(this,0,t):Ee.apply(this,arguments)},pe.prototype.equals=function(t){if(!Pe(t))throw new TypeError(\"Argument must be a Buffer\");return this===t||0===pe.compare(this,t)},pe.prototype.inspect=function(){var t=\"\";return this.length>0&&(t=this.toString(\"hex\",0,50).match(/.{2}/g).join(\" \"),this.length>50&&(t+=\" ... \")),\"<Buffer \"+t+\">\"},pe.prototype.compare=function(t,e,r,i,s){if(!Pe(t))throw new TypeError(\"Argument must be a Buffer\");if(void 0===e&&(e=0),void 0===r&&(r=t?t.length:0),void 0===i&&(i=0),void 0===s&&(s=this.length),e<0||r>t.length||i<0||s>this.length)throw new RangeError(\"out of range index\");if(i>=s&&e>=r)return 0;if(i>=s)return-1;if(e>=r)return 1;if(this===t)return 0;for(var n=(s>>>=0)-(i>>>=0),a=(r>>>=0)-(e>>>=0),o=Math.min(n,a),c=this.slice(i,s),h=t.slice(e,r),d=0;d<o;++d)if(c[d]!==h[d]){n=c[d],a=h[d];break}return n<a?-1:a<n?1:0},pe.prototype.includes=function(t,e,r){return-1!==this.indexOf(t,e,r)},pe.prototype.indexOf=function(t,e,r){return _e(this,t,e,r,!0)},pe.prototype.lastIndexOf=function(t,e,r){return _e(this,t,e,r,!1)},pe.prototype.write=function(t,e,r,i){if(void 0===e)i=\"utf8\",r=this.length,e=0;else if(void 0===r&&\"string\"==typeof e)i=e,r=this.length,e=0;else{if(!isFinite(e))throw new Error(\"Buffer.write(string, encoding, offset[, length]) is no longer supported\");e|=0,isFinite(r)?(r|=0,void 0===i&&(i=\"utf8\")):(i=r,r=void 0)}var s=this.length-e;if((void 0===r||r>s)&&(r=s),t.length>0&&(r<0||e<0)||e>this.length)throw new RangeError(\"Attempt to write outside buffer bounds\");i||(i=\"utf8\");for(var n=!1;;)switch(i){case\"hex\":return Ie(this,t,e,r);case\"utf8\":case\"utf-8\":return Se(this,t,e,r);case\"ascii\":return Ae(this,t,e,r);case\"latin1\":case\"binary\":return Me(this,t,e,r);case\"base64\":return Te(this,t,e,r);case\"ucs2\":case\"ucs-2\":case\"utf16le\":case\"utf-16le\":return Ne(this,t,e,r);default:if(n)throw new TypeError(\"Unknown encoding: \"+i);i=(\"\"+i).toLowerCase(),n=!0}},pe.prototype.toJSON=function(){return{type:\"Buffer\",data:Array.prototype.slice.call(this._arr||this,0)}};var Re=4096;function Ue(t,e,r){var i=\"\";r=Math.min(t.length,r);for(var s=e;s<r;++s)i+=String.fromCharCode(127&t[s]);return i}function Le(t,e,r){var i=\"\";r=Math.min(t.length,r);for(var s=e;s<r;++s)i+=String.fromCharCode(t[s]);return i}function De(t,e,r){var i=t.length;(!e||e<0)&&(e=0),(!r||r<0||r>i)&&(r=i);for(var s=\"\",n=e;n<r;++n)s+=ze(t[n]);return s}function Ce(t,e,r){for(var i=t.slice(e,r),s=\"\",n=0;n<i.length;n+=2)s+=String.fromCharCode(i[n]+256*i[n+1]);return s}function He(t,e,r){if(t%1!=0||t<0)throw new RangeError(\"offset is not uint\");if(t+e>r)throw new RangeError(\"Trying to access beyond buffer length\")}function qe(t,e,r,i,s,n){if(!Pe(t))throw new TypeError('\"buffer\" argument must be a Buffer instance');if(e>s||e<n)throw new RangeError('\"value\" argument is out of bounds');if(r+i>t.length)throw new RangeError(\"Index out of range\")}function Ve(t,e,r,i){e<0&&(e=65535+e+1);for(var s=0,n=Math.min(t.length-r,2);s<n;++s)t[r+s]=(e&255<<8*(i?s:1-s))>>>8*(i?s:1-s)}function $e(t,e,r,i){e<0&&(e=4294967295+e+1);for(var s=0,n=Math.min(t.length-r,4);s<n;++s)t[r+s]=e>>>8*(i?s:3-s)&255}function Ke(t,e,r,i,s,n){if(r+i>t.length)throw new RangeError(\"Index out of range\");if(r<0)throw new RangeError(\"Index out of range\")}function je(t,e,r,i,s){return s||Ke(t,0,r,4),de(t,e,r,i,23,4),r+4}function Xe(t,e,r,i,s){return s||Ke(t,0,r,8),de(t,e,r,i,52,8),r+8}pe.prototype.slice=function(t,e){var r,i=this.length;if((t=~~t)<0?(t+=i)<0&&(t=0):t>i&&(t=i),(e=void 0===e?i:~~e)<0?(e+=i)<0&&(e=0):e>i&&(e=i),e<t&&(e=t),pe.TYPED_ARRAY_SUPPORT)(r=this.subarray(t,e)).__proto__=pe.prototype;else{var s=e-t;r=new pe(s,void 0);for(var n=0;n<s;++n)r[n]=this[n+t]}return r},pe.prototype.readUIntLE=function(t,e,r){t|=0,e|=0,r||He(t,e,this.length);for(var i=this[t],s=1,n=0;++n<e&&(s*=256);)i+=this[t+n]*s;return i},pe.prototype.readUIntBE=function(t,e,r){t|=0,e|=0,r||He(t,e,this.length);for(var i=this[t+--e],s=1;e>0&&(s*=256);)i+=this[t+--e]*s;return i},pe.prototype.readUInt8=function(t,e){return e||He(t,1,this.length),this[t]},pe.prototype.readUInt16LE=function(t,e){return e||He(t,2,this.length),this[t]|this[t+1]<<8},pe.prototype.readUInt16BE=function(t,e){return e||He(t,2,this.length),this[t]<<8|this[t+1]},pe.prototype.readUInt32LE=function(t,e){return e||He(t,4,this.length),(this[t]|this[t+1]<<8|this[t+2]<<16)+16777216*this[t+3]},pe.prototype.readUInt32BE=function(t,e){return e||He(t,4,this.length),16777216*this[t]+(this[t+1]<<16|this[t+2]<<8|this[t+3])},pe.prototype.readIntLE=function(t,e,r){t|=0,e|=0,r||He(t,e,this.length);for(var i=this[t],s=1,n=0;++n<e&&(s*=256);)i+=this[t+n]*s;return i>=(s*=128)&&(i-=Math.pow(2,8*e)),i},pe.prototype.readIntBE=function(t,e,r){t|=0,e|=0,r||He(t,e,this.length);for(var i=e,s=1,n=this[t+--i];i>0&&(s*=256);)n+=this[t+--i]*s;return n>=(s*=128)&&(n-=Math.pow(2,8*e)),n},pe.prototype.readInt8=function(t,e){return e||He(t,1,this.length),128&this[t]?-1*(255-this[t]+1):this[t]},pe.prototype.readInt16LE=function(t,e){e||He(t,2,this.length);var r=this[t]|this[t+1]<<8;return 32768&r?4294901760|r:r},pe.prototype.readInt16BE=function(t,e){e||He(t,2,this.length);var r=this[t+1]|this[t]<<8;return 32768&r?4294901760|r:r},pe.prototype.readInt32LE=function(t,e){return e||He(t,4,this.length),this[t]|this[t+1]<<8|this[t+2]<<16|this[t+3]<<24},pe.prototype.readInt32BE=function(t,e){return e||He(t,4,this.length),this[t]<<24|this[t+1]<<16|this[t+2]<<8|this[t+3]},pe.prototype.readFloatLE=function(t,e){return e||He(t,4,this.length),he(this,t,!0,23,4)},pe.prototype.readFloatBE=function(t,e){return e||He(t,4,this.length),he(this,t,!1,23,4)},pe.prototype.readDoubleLE=function(t,e){return e||He(t,8,this.length),he(this,t,!0,52,8)},pe.prototype.readDoubleBE=function(t,e){return e||He(t,8,this.length),he(this,t,!1,52,8)},pe.prototype.writeUIntLE=function(t,e,r,i){(t=+t,e|=0,r|=0,i)||qe(this,t,e,r,Math.pow(2,8*r)-1,0);var s=1,n=0;for(this[e]=255&t;++n<r&&(s*=256);)this[e+n]=t/s&255;return e+r},pe.prototype.writeUIntBE=function(t,e,r,i){(t=+t,e|=0,r|=0,i)||qe(this,t,e,r,Math.pow(2,8*r)-1,0);var s=r-1,n=1;for(this[e+s]=255&t;--s>=0&&(n*=256);)this[e+s]=t/n&255;return e+r},pe.prototype.writeUInt8=function(t,e,r){return t=+t,e|=0,r||qe(this,t,e,1,255,0),pe.TYPED_ARRAY_SUPPORT||(t=Math.floor(t)),this[e]=255&t,e+1},pe.prototype.writeUInt16LE=function(t,e,r){return t=+t,e|=0,r||qe(this,t,e,2,65535,0),pe.TYPED_ARRAY_SUPPORT?(this[e]=255&t,this[e+1]=t>>>8):Ve(this,t,e,!0),e+2},pe.prototype.writeUInt16BE=function(t,e,r){return t=+t,e|=0,r||qe(this,t,e,2,65535,0),pe.TYPED_ARRAY_SUPPORT?(this[e]=t>>>8,this[e+1]=255&t):Ve(this,t,e,!1),e+2},pe.prototype.writeUInt32LE=function(t,e,r){return t=+t,e|=0,r||qe(this,t,e,4,4294967295,0),pe.TYPED_ARRAY_SUPPORT?(this[e+3]=t>>>24,this[e+2]=t>>>16,this[e+1]=t>>>8,this[e]=255&t):$e(this,t,e,!0),e+4},pe.prototype.writeUInt32BE=function(t,e,r){return t=+t,e|=0,r||qe(this,t,e,4,4294967295,0),pe.TYPED_ARRAY_SUPPORT?(this[e]=t>>>24,this[e+1]=t>>>16,this[e+2]=t>>>8,this[e+3]=255&t):$e(this,t,e,!1),e+4},pe.prototype.writeIntLE=function(t,e,r,i){if(t=+t,e|=0,!i){var s=Math.pow(2,8*r-1);qe(this,t,e,r,s-1,-s)}var n=0,a=1,o=0;for(this[e]=255&t;++n<r&&(a*=256);)t<0&&0===o&&0!==this[e+n-1]&&(o=1),this[e+n]=(t/a|0)-o&255;return e+r},pe.prototype.writeIntBE=function(t,e,r,i){if(t=+t,e|=0,!i){var s=Math.pow(2,8*r-1);qe(this,t,e,r,s-1,-s)}var n=r-1,a=1,o=0;for(this[e+n]=255&t;--n>=0&&(a*=256);)t<0&&0===o&&0!==this[e+n+1]&&(o=1),this[e+n]=(t/a|0)-o&255;return e+r},pe.prototype.writeInt8=function(t,e,r){return t=+t,e|=0,r||qe(this,t,e,1,127,-128),pe.TYPED_ARRAY_SUPPORT||(t=Math.floor(t)),t<0&&(t=255+t+1),this[e]=255&t,e+1},pe.prototype.writeInt16LE=function(t,e,r){return t=+t,e|=0,r||qe(this,t,e,2,32767,-32768),pe.TYPED_ARRAY_SUPPORT?(this[e]=255&t,this[e+1]=t>>>8):Ve(this,t,e,!0),e+2},pe.prototype.writeInt16BE=function(t,e,r){return t=+t,e|=0,r||qe(this,t,e,2,32767,-32768),pe.TYPED_ARRAY_SUPPORT?(this[e]=t>>>8,this[e+1]=255&t):Ve(this,t,e,!1),e+2},pe.prototype.writeInt32LE=function(t,e,r){return t=+t,e|=0,r||qe(this,t,e,4,2147483647,-2147483648),pe.TYPED_ARRAY_SUPPORT?(this[e]=255&t,this[e+1]=t>>>8,this[e+2]=t>>>16,this[e+3]=t>>>24):$e(this,t,e,!0),e+4},pe.prototype.writeInt32BE=function(t,e,r){return t=+t,e|=0,r||qe(this,t,e,4,2147483647,-2147483648),t<0&&(t=4294967295+t+1),pe.TYPED_ARRAY_SUPPORT?(this[e]=t>>>24,this[e+1]=t>>>16,this[e+2]=t>>>8,this[e+3]=255&t):$e(this,t,e,!1),e+4},pe.prototype.writeFloatLE=function(t,e,r){return je(this,t,e,!0,r)},pe.prototype.writeFloatBE=function(t,e,r){return je(this,t,e,!1,r)},pe.prototype.writeDoubleLE=function(t,e,r){return Xe(this,t,e,!0,r)},pe.prototype.writeDoubleBE=function(t,e,r){return Xe(this,t,e,!1,r)},pe.prototype.copy=function(t,e,r,i){if(r||(r=0),i||0===i||(i=this.length),e>=t.length&&(e=t.length),e||(e=0),i>0&&i<r&&(i=r),i===r)return 0;if(0===t.length||0===this.length)return 0;if(e<0)throw new RangeError(\"targetStart out of bounds\");if(r<0||r>=this.length)throw new RangeError(\"sourceStart out of bounds\");if(i<0)throw new RangeError(\"sourceEnd out of bounds\");i>this.length&&(i=this.length),t.length-e<i-r&&(i=t.length-e+r);var s,n=i-r;if(this===t&&r<e&&e<i)for(s=n-1;s>=0;--s)t[s+e]=this[s+r];else if(n<1e3||!pe.TYPED_ARRAY_SUPPORT)for(s=0;s<n;++s)t[s+e]=this[s+r];else Uint8Array.prototype.set.call(t,this.subarray(r,r+n),e);return n},pe.prototype.fill=function(t,e,r,i){if(\"string\"==typeof t){if(\"string\"==typeof e?(i=e,e=0,r=this.length):\"string\"==typeof r&&(i=r,r=this.length),1===t.length){var s=t.charCodeAt(0);s<256&&(t=s)}if(void 0!==i&&\"string\"!=typeof i)throw new TypeError(\"encoding must be a string\");if(\"string\"==typeof i&&!pe.isEncoding(i))throw new TypeError(\"Unknown encoding: \"+i)}else\"number\"==typeof t&&(t&=255);if(e<0||this.length<e||this.length<r)throw new RangeError(\"Out of range index\");if(r<=e)return this;var n;if(e>>>=0,r=void 0===r?this.length:r>>>0,t||(t=0),\"number\"==typeof t)for(n=e;n<r;++n)this[n]=t;else{var a=Pe(t)?t:We(new pe(t,i).toString()),o=a.length;for(n=0;n<r-e;++n)this[n+e]=a[n%o]}return this};var Ye=/[^+\\/0-9A-Za-z-_]/g;function ze(t){return t<16?\"0\"+t.toString(16):t.toString(16)}function We(t,e){var r;e=e||1/0;for(var i=t.length,s=null,n=[],a=0;a<i;++a){if((r=t.charCodeAt(a))>55295&&r<57344){if(!s){if(r>56319){(e-=3)>-1&&n.push(239,191,189);continue}if(a+1===i){(e-=3)>-1&&n.push(239,191,189);continue}s=r;continue}if(r<56320){(e-=3)>-1&&n.push(239,191,189),s=r;continue}r=65536+(s-55296<<10|r-56320)}else s&&(e-=3)>-1&&n.push(239,191,189);if(s=null,r<128){if((e-=1)<0)break;n.push(r)}else if(r<2048){if((e-=2)<0)break;n.push(r>>6|192,63&r|128)}else if(r<65536){if((e-=3)<0)break;n.push(r>>12|224,r>>6&63|128,63&r|128)}else{if(!(r<1114112))throw new Error(\"Invalid code point\");if((e-=4)<0)break;n.push(r>>18|240,r>>12&63|128,r>>6&63|128,63&r|128)}}return n}function Ge(t){return function(t){var e,r,i,s,n,a;ne||ae();var o=t.length;if(o%4>0)throw new Error(\"Invalid string. Length must be a multiple of 4\");n=\"=\"===t[o-2]?2:\"=\"===t[o-1]?1:0,a=new se(3*o/4-n),i=n>0?o-4:o;var c=0;for(e=0,r=0;e<i;e+=4,r+=3)s=ie[t.charCodeAt(e)]<<18|ie[t.charCodeAt(e+1)]<<12|ie[t.charCodeAt(e+2)]<<6|ie[t.charCodeAt(e+3)],a[c++]=s>>16&255,a[c++]=s>>8&255,a[c++]=255&s;return 2===n?(s=ie[t.charCodeAt(e)]<<2|ie[t.charCodeAt(e+1)]>>4,a[c++]=255&s):1===n&&(s=ie[t.charCodeAt(e)]<<10|ie[t.charCodeAt(e+1)]<<4|ie[t.charCodeAt(e+2)]>>2,a[c++]=s>>8&255,a[c++]=255&s),a}(function(t){if((t=function(t){return t.trim?t.trim():t.replace(/^\\s+|\\s+$/g,\"\")}(t).replace(Ye,\"\")).length<2)return\"\";for(;t.length%4!=0;)t+=\"=\";return t}(t))}function Ze(t,e,r,i){for(var s=0;s<i&&!(s+r>=e.length||s>=t.length);++s)e[s+r]=t[s];return s}function Je(t){return!!t.constructor&&\"function\"==typeof t.constructor.isBuffer&&t.constructor.isBuffer(t)}const Qe=\"bigint\";function tr(t,e,r){if(!function(...t){return t.every((t=>\"string\"==typeof t))}(t)&&!function(...t){return t.every((t=>\"number\"==typeof t))}(t)&&!function(...t){return t.every((t=>\"bigint\"==typeof t))}(t))throw new TypeError(\"toTokenSat must be called on a number, string or bigint, got \"+typeof t);if(!Number.isInteger(e)||e<0)throw new TypeError(\"decimals must be a non-negative integer\");let i=\"\";const s=\"string\"==typeof t?t.startsWith(\"-\")&&\"-0\"!==t:t<0;switch(typeof t){case\"bigint\":i=(t*10n**BigInt(e)).toString();break;case\"string\":{const r=t.replace(\"-\",\"\"),[n,a]=r.split(\".\");i=n+(a||\"\").padEnd(e,\"0\"),!s||\"0\"===n&&\"0\"===a||(i=`-${i}`);break}default:i=(Math.round(Math.abs(t)*10**e)*(s?-1:1)).toString()}switch(r){case\"bigint\":return BigInt(i);case\"string\":return i;default:{let t;try{t=Number(i)}catch(t){throw new Error(`Invalid number: ${i}`)}if(!Number.isSafeInteger(Math.round(t)))throw new Error(\"Integer overflow. Try returning a string instead.\");return t}}}function er(){return er=Object.assign?Object.assign.bind():function(t){for(var e=1;e<arguments.length;e++){var r=arguments[e];for(var i in r)({}).hasOwnProperty.call(r,i)&&(t[i]=r[i])}return t},er.apply(null,arguments)}function rr(t){var e=function(t){if(\"object\"!=typeof t||!t)return t;var e=t[Symbol.toPrimitive];if(void 0!==e){var r=e.call(t,\"string\");if(\"object\"!=typeof r)return r;throw new TypeError(\"@@toPrimitive must return a primitive value.\")}return String(t)}(t);return\"symbol\"==typeof e?e:e+\"\"}var ir,sr=Gt,nr=K,ar=\"5349474d41\";!function(t){t.BSM=\"BSM\"}(ir||(ir={}));var or=function(){function e(t,e,r,i){var s=this;void 0===e&&(e=0),void 0===r&&(r=0),void 0===i&&(i=0),this._inputHash=null,this._dataHash=null,this._transaction=void 0,this._sigmaInstance=void 0,this._refVin=void 0,this._targetVout=void 0,this._sig=void 0,this.setHashes=function(){s._inputHash=s.getInputHash(),s._dataHash=s.getDataHash()},this.setTargetVout=function(t){s._targetVout=t},this.setSigmaInstance=function(t){s._sigmaInstance=t},this.verify=function(){if(!s.sig)throw new Error(\"No signature data provided\");var t=s.getMessageHash();if(!t)throw new Error(\"No tx data provided\");var e=ht.fromCompact(s.sig.signature,\"base64\");return-1!==cr(e,t,s.sig.address)},this.getInputHash=function(){return s._getInputHashByVin(-1===s._refVin?s._targetVout:s._refVin)},this._getInputHashByVin=function(t){var e=s._transaction.inputs[t];if(null!=e&&e.sourceTXID){var r=pe.alloc(36),i=pe.from(e.sourceTXID,\"hex\");return r.set(i,0),r.writeUInt32LE(e.sourceOutputIndex,32),C(Array.from(r))}return C(Array.from(new Uint8Array(32)))},this.getDataHash=function(){var t;if(!s._transaction)throw new Error(\"No transaction provided\");for(var e=null==(t=s._transaction)?void 0:t.outputs[s._targetVout].lockingScript,r=(null==e?void 0:e.toASM().split(\" \"))||[],i=0,n=0;n<r.length;n++)if(r[n].toUpperCase()===ar.toUpperCase()){if(i===s._sigmaInstance){var a=r.slice(0,n-1),o=kt.fromASM(a.join(\" \"));return C(o.toBinary())}i++}var c=kt.fromASM(r.join(\" \"));return C(c.toBinary())},this._transaction=t,this._targetVout=e,this._refVin=i,this._sigmaInstance=r,this._sig=this.sig,this.setHashes()}var r,i,s=e.prototype;return s.getMessageHash=function(){if(!this._inputHash||!this._dataHash)throw new Error(\"Input hash and data hash must be set\");var t=this._inputHash,e=this._dataHash,r=new Uint8Array(t.length+e.length);return r.set(t,0),r.set(e,t.length),C(Array.from(r))},s._sign=function(t,e,r){var i,s,n,a=-1===this._refVin?this._targetVout:this._refVin;if(void 0===r)throw new Error(\"Failed recovery missing\");var o=ar+\" \"+pe.from(ir.BSM,\"utf-8\").toString(\"hex\")+\" \"+pe.from(e,\"utf-8\").toString(\"hex\")+\" \"+t.toCompact(r,!0,\"hex\")+\" \"+pe.from(a.toString(),\"utf-8\").toString(\"hex\"),c=kt.fromASM(o);this._sig={algorithm:ir.BSM,address:e,signature:t.toCompact(r,!0,\"base64\"),vin:a,targetVout:this._targetVout};var h=null==(i=this.targetTxOut)?void 0:i.lockingScript.toASM(),d=(null==(s=h)?void 0:s.split(\" \").includes(\"OP_RETURN\"))?\"7c\":\"OP_RETURN\";if(this.sig&&this._sigmaInstance===this.getSigInstanceCount()){var u,f=(null==(u=h)?void 0:u.split(\" \"))||[],l=this.getSigInstancePosition(),b=o.split(\" \");-1!==l&&(h=f.splice.apply(f,[l,5].concat(b)).join(\"\"))}var p=kt.fromASM(h+\" \"+d+\" \"+o),g=new zt(this._transaction.version,this._transaction.inputs.map((function(t){return er({},t)})),this._transaction.outputs.map((function(t){return er({},t)}))),m={satoshis:null==(n=this.targetTxOut)?void 0:n.satoshis,lockingScript:p};return g.outputs[this._targetVout]=m,this._transaction=g,er({sigmaScript:c,signedTx:g},this._sig)},s.sign=function(e){var r=this.getMessageHash(),i=((e,r,i=\"base64\")=>{const s=Gt(e),n=ft(new t(s),r,!0);if(\"raw\"===i)return n;const a=new t(s),o=n.CalculateRecoveryFactor(r.toPublicKey(),a);return n.toCompact(o,!0,\"base64\")})(r,e,\"raw\"),s=e.toAddress(),n=new t(sr(r)),a=i.CalculateRecoveryFactor(e.toPublicKey(),n);return this._sign(i,s,a)},s.remoteSign=function(t,e){try{var r,i=this,s=e?((r={})[e.key]=e.value,r):{},n=t+\"/sign\"+(\"query\"===(null==e?void 0:e.type)?\"?\"+(null==e?void 0:e.key)+\"=\"+(null==e?void 0:e.value):\"\"),a={message:nr(i.getMessageHash()),encoding:\"hex\"};return Promise.resolve(function(t,e){try{var r=Promise.resolve(fetch(n,{method:\"POST\",headers:er({},s,{\"Content-Type\":\"application/json\",Accept:\"application/json\"}),body:JSON.stringify(a)})).then((function(t){function e(e){return Promise.resolve(t.json()).then((function(t){var e=t.address,r=t.recovery,s=ht.fromCompact(t.sig,\"base64\");return i._sign(s,e,r)}))}var r=function(){if(!t.ok)return Promise.resolve(t.text()).then((function(e){throw console.error(\"Response Error:\",e),new Error(\"HTTP Error: \"+t.status)}))}();return r&&r.then?r.then(e):e()}))}catch(t){return e(t)}return r&&r.then?r.then(void 0,e):r}(0,(function(t){throw console.error(\"Fetch Error:\",t),t})))}catch(t){return Promise.reject(t)}},s.getSigInstanceCount=function(){var t,e=null==(t=this.targetTxOut)?void 0:t.lockingScript.toASM();return((null==e?void 0:e.split(\" \"))||[]).filter((function(t){return t.toUpperCase()===ar.toUpperCase()})).length},s.getSigInstancePosition=function(){var t,e=null==(t=this.targetTxOut)?void 0:t.lockingScript.toASM();return((null==e?void 0:e.split(\" \"))||[]).findIndex((function(t){return t.toUpperCase()===ar.toUpperCase()}))},r=e,(i=[{key:\"transaction\",get:function(){return this._transaction}},{key:\"targetTxOut\",get:function(){return this._transaction.outputs[this._targetVout]||null}},{key:\"sig\",get:function(){for(var t=this._transaction.outputs[this._targetVout],e=null==t?void 0:t.lockingScript,r=(null==e?void 0:e.toASM().split(\" \"))||[],i=[],s=0;s<r.length;s++)if(r[s].toUpperCase()===ar.toUpperCase()){var n={algorithm:pe.from(r[s+1],\"hex\").toString(\"utf-8\"),address:pe.from(r[s+2],\"hex\").toString(\"utf-8\"),signature:pe.from(r[s+3],\"hex\").toString(\"base64\"),vin:Number.parseInt(pe.from(r[s+4],\"hex\").toString(\"utf-8\"))};i.push(n),s+=4}return 0===i.length?this._sig:i[this._sigmaInstance]}}])&&function(t,e){for(var r=0;r<e.length;r++){var i=e[r];i.enumerable=i.enumerable||!1,i.configurable=!0,\"value\"in i&&(i.writable=!0),Object.defineProperty(t,rr(i.key),i)}}(r.prototype,i),Object.defineProperty(r,\"prototype\",{writable:!1}),r}(),cr=function(e,r,i){for(var s=0;s<4;s++)try{var n=e.RecoverPublicKey(s,new t(sr(r)));if(Zt(r,e,n)&&n.toAddress()===i)return s}catch(e){}return-1};const hr=t=>pe.from(t).toString(\"hex\"),dr=10,ur=\"https://ordinals.gorillapool.io/api\";class fr extends Nt{lock(t,e,r){const i=(new Nt).lock(t);return lr(i,e,r)}}const lr=(t,e,r,i=!1)=>{let s=\"\";if(void 0!==(null==e?void 0:e.dataB64)&&void 0!==(null==e?void 0:e.contentType)){const t=hr(\"ord\"),r=pe.from(e.dataB64,\"base64\").toString(\"hex\").trim();if(!r)throw new Error(\"Invalid file data\");const i=hr(e.contentType);if(!i)throw new Error(\"Invalid media type\");s=`OP_0 OP_IF ${t} OP_1 ${i} OP_0 ${r} OP_ENDIF`}let n=`${s?`${s} ${i?\"OP_CODESEPARATOR \":\"\"}`:\"\"}${t.toASM()}`;if(r&&(!r.app||!r.type))throw new Error(\"MAP.app and MAP.type are required fields\");if(null!=r&&r.app&&null!=r&&r.type){n=`${n?`${n} `:\"\"}OP_RETURN ${hr(\"1PuQa7K62MiKCtssSLKy1kh56WWU7MtUR5\")} ${hr(\"SET\")}`;for(const[t,e]of Object.entries(r))\"cmd\"!==t&&(n=`${n} ${hr(t)} ${hr(e)}`)}return _t.fromASM(n)};function br(){return br=Object.assign?Object.assign.bind():function(t){for(var e=1;e<arguments.length;e++){var r=arguments[e];for(var i in r)({}).hasOwnProperty.call(r,i)&&(t[i]=r[i])}return t},br.apply(null,arguments)}var pr,gr,mr,wr;!function(t){t.SmallestFirst=\"smallest\",t.LargestFirst=\"largest\",t.RetainOrder=\"retain\",t.Random=\"random\"}(pr||(pr={})),function(t){t.BSV20=\"bsv20\",t.BSV21=\"bsv21\"}(gr||(gr={})),function(t){t.Paymail=\"paymail\",t.Address=\"address\",t.Script=\"script\"}(mr||(mr={})),function(t){t.All=\"all\",t.Needed=\"needed\"}(wr||(wr={}));const{fromBase58Check:yr}=nt,vr=(t,e)=>function(t,e){const r=new zt(0,[],[],0);return r.outputs=Array(t.vout+1).fill(null),r.outputs[t.vout]={satoshis:t.satoshis,lockingScript:_t.fromHex(t.script)},{sourceTransaction:r,sourceTXID:t.txid,sourceOutputIndex:t.vout,unlockingScriptTemplate:e,sequence:4294967295}}(br({},t,{script:pe.from(t.script,\"base64\").toString(\"hex\")}),e),Pr=async(t,e=\"base64\")=>{const r=`${ur}/txos/address/${t}/unspent?bsv20=false`;console.log({payUrl:r});const i=await fetch(r);if(!i.ok)throw new Error(\"Error fetching pay utxos\");let s=await i.json();s=s.filter((t=>1!==t.satoshis&&!Er(t)));const n=yr(t),a=(new Nt).lock(n.data);return s=s.map((t=>({txid:t.txid,vout:t.vout,satoshis:t.satoshis,script:\"hex\"===e||\"base64\"===e?pe.from(a.toBinary()).toString(e):a.toASM()}))),s},Or=async(t,e,r,i=10,s=0)=>{const n=`${ur}/bsv20/${r}/${t===gr.BSV20?\"tick\":\"id\"}/${e}?bsv20=true&listing=false&limit=${i}&offset=${s}`,a=await fetch(n);if(!a.ok)throw new Error(`Error fetching ${t} utxos`);let o=await a.json();return o=o.map((t=>({amt:t.amt,script:t.script,vout:t.vout,txid:t.txid,id:e,satoshis:1}))),o},Er=t=>!!t.lock,kr=async(t,e)=>{const r=null==e?void 0:e.idKey,i=null==e?void 0:e.keyHost;if(r){const e=new or(t),{signedTx:i}=e.sign(r);return i}if(i){const r=null==e?void 0:e.authToken,s=new or(t);try{const{signedTx:t}=await s.remoteSign(i,r);return t}catch(t){throw console.log(t),new Error(`Remote signing to ${i} failed`)}}throw new Error(\"Signer must be a LocalSigner or RemoteSigner\")},_r=t=>{if(!t)return;const e={app:t.app,type:t.type};for(const[r,i]of Object.entries(t))void 0!==i&&(e[r]=\"string\"==typeof i?i:Array.isArray(i)||\"object\"==typeof i?JSON.stringify(i):String(i));return e},xr=(t,e,r,i,s,n,a,o)=>{const c=[],h=void 0!==a.threshold?tr(a.threshold,o,Qe):void 0,d=a.outputs,u=e;let f;console.log({splitChangeAmt:u}),void 0!==h&&h>0n?(f=u/h,f=BigInt(Math.min(Number(f),d))):f=BigInt(d),f=BigInt(Math.max(Number(f),1));const l=u/f;let b=u%f;for(let e=0n;e<f;e++){let e=l;b>0n&&(e+=1n,b-=1n);const o={p:\"bsv-20\",op:\"transfer\",amt:e.toString()};let h;if(r===gr.BSV20)h=br({},o,{tick:i});else{if(r!==gr.BSV21)throw new Error(\"Invalid protocol\");h=br({},o,{id:i})}const d=(new fr).lock(s,{dataB64:pe.from(JSON.stringify(h)).toString(\"base64\"),contentType:\"application/bsv-20\"},a.omitMetaData?void 0:_r(n)),u=t.outputs.length;t.addOutput({lockingScript:d,satoshis:1}),c.push({id:i,satoshis:1,script:pe.from(d.toBinary()).toString(\"base64\"),txid:\"\",vout:u,amt:e.toString()})}return c};class Ir{lock(t,e,r,i){const s=et(t).data,n=et(e).data;let a=new kt;if(void 0!==(null==i?void 0:i.dataB64)&&void 0!==(null==i?void 0:i.contentType)){const t=hr(\"ord\"),e=pe.from(i.dataB64,\"base64\").toString(\"hex\").trim();if(!e)throw new Error(\"Invalid file data\");const r=hr(i.contentType);if(!r)throw new Error(\"Invalid media type\");a=kt.fromASM(`OP_0 OP_IF ${t} OP_1 ${r} OP_0 ${e} OP_ENDIF`)}return a.writeScript(kt.fromHex(\"2097dfd76851bf465e8f715593b217714858bbe9570ff3bd5e33840a34e20ff0262102ba79df5f8ae7604a9830f03c7933028186aede0675a16f025dc4f8be8eec0382201008ce7480da41702918d1ec8e6849ba32b4d65b1e40dc669c31a1e6306b266c0000\")).writeBin(s).writeBin(Ir.buildOutput(r,(new Nt).lock(n).toBinary())).writeScript(kt.fromHex(\"615179547a75537a537a537a0079537a75527a527a7575615579008763567901c161517957795779210ac407f0e4bd44bfc207355a778b046225a7068fc59ee7eda43ad905aadbffc800206c266b30e6a1319c66dc401e5bd6b432ba49688eecd118297041da8074ce081059795679615679aa0079610079517f517f517f517f517f517f517f517f517f517f517f517f517f517f517f517f517f517f517f517f517f517f517f517f517f517f517f517f517f517f517f7c7e7c7e7c7e7c7e7c7e7c7e7c7e7c7e7c7e7c7e7c7e7c7e7c7e7c7e7c7e7c7e7c7e7c7e7c7e7c7e7c7e7c7e7c7e7c7e7c7e7c7e7c7e7c7e7c7e7c7e7c7e01007e81517a75615779567956795679567961537956795479577995939521414136d08c5ed2bf3ba048afe6dcaebafeffffffffffffffffffffffffffffff00517951796151795179970079009f63007952799367007968517a75517a75517a7561527a75517a517951795296a0630079527994527a75517a6853798277527982775379012080517f517f517f517f517f517f517f517f517f517f517f517f517f517f517f517f517f517f517f517f517f517f517f517f517f517f517f517f517f517f517f7c7e7c7e7c7e7c7e7c7e7c7e7c7e7c7e7c7e7c7e7c7e7c7e7c7e7c7e7c7e7c7e7c7e7c7e7c7e7c7e7c7e7c7e7c7e7c7e7c7e7c7e7c7e7c7e7c7e7c7e7c7e01205279947f7754537993527993013051797e527e54797e58797e527e53797e52797e57797e0079517a75517a75517a75517a75517a75517a75517a75517a75517a75517a75517a75517a75517a756100795779ac517a75517a75517a75517a75517a75517a75517a75517a75517a7561517a75517a756169587951797e58797eaa577961007982775179517958947f7551790128947f77517a75517a75618777777777777777777767557951876351795779a9876957795779ac777777777777777767006868\"))}cancelListing(t,e=\"all\",r=!1,i,s){const n=(new Nt).unlock(t,e,r,i,s);return{sign:async function(t,e){return(await n.sign(t,e)).writeOpCode(Et.OP_1)},estimateLength:async function(){return 107}}}purchaseListing(t,e){const r={sign:async function(r,i){var s;if(r.outputs.length<2)throw new Error(\"Malformed transaction\");const n=(new xt).writeBin(Ir.buildOutput(r.outputs[0].satoshis||0,r.outputs[0].lockingScript.toBinary()));if(r.outputs.length>2){const t=new rt;for(const e of r.outputs.slice(2))t.write(Ir.buildOutput(e.satoshis||0,e.lockingScript.toBinary()));n.writeBin(t.toArray())}else n.writeOpCode(Et.OP_0);const a=r.inputs[i];let o=t;if(!o&&a.sourceTransaction)o=a.sourceTransaction.outputs[a.sourceOutputIndex].satoshis;else if(!t)throw new Error(\"sourceTransaction or sourceSatoshis is required\");const c=a.sourceTXID||(null==(s=a.sourceTransaction)?void 0:s.id(\"hex\"));let h=e;var d;h||(h=null==(d=a.sourceTransaction)?void 0:d.outputs[a.sourceOutputIndex].lockingScript);const u=Ot.format({sourceTXID:c,sourceOutputIndex:a.sourceOutputIndex,sourceSatoshis:o,transactionVersion:r.version,otherInputs:[],inputIndex:i,outputs:r.outputs,inputSequence:a.sequence,subscript:h,lockTime:r.lockTime,scope:Ot.SIGHASH_ALL|Ot.SIGHASH_ANYONECANPAY|Ot.SIGHASH_FORKID});return n.writeBin(u).writeOpCode(Et.OP_0)},estimateLength:async function(t,e){return(await r.sign(t,e)).toBinary().length}};return r}static buildOutput(e,r){const i=new rt;return i.writeUInt64LEBn(new t(e)),i.writeVarIntNum(r.length),i.write(r),i.toArray()}}const{toArray:Sr}=nt,Ar=async(t,e)=>{throw new Error(\"Not implemented\")};class Mr{constructor(t){this.fetch=void 0,this.fetch=t}async request(t,e){const r={method:e.method,headers:e.headers,body:JSON.stringify(e.data)},i=await this.fetch.call(window,t,r),s=i.headers.get(\"Content-Type\"),n=null!=s&&s.startsWith(\"application/json\")?await i.json():await i.text();return{ok:i.ok,status:i.status,statusText:i.statusText,data:n}}}const Tr=()=>new Nr;class Nr{constructor(t=function(){const t={async request(...t){throw new Error(\"No method available to perform HTTP request\")}};if(\"undefined\"!=typeof window&&\"function\"==typeof window.fetch){const t=window.fetch;return window.fetch=async(...e)=>await t(...e),new Mr(window.fetch)}if(\"undefined\"==typeof require)return t;try{const t=require(\"node:https\");return new Bt(t)}catch(e){return t}}()){this.URL=void 0,this.httpClient=void 0,this.URL=`${ur}/tx`,this.httpClient=t}async broadcast(t){const e={method:\"POST\",headers:{\"Content-Type\":\"application/json\",Accept:\"application/json\"},data:{rawtx:G(t.toBinary())}};try{var r,i;const t=await this.httpClient.request(this.URL,e);return t.ok?{status:\"success\",txid:t.data,message:\"broadcast successful\"}:{status:\"error\",code:null!=(r=t.status.toString())?r:\"ERR_UNKNOWN\",description:null!=(i=t.data.message)?i:\"Unknown error\"}}catch(t){return{status:\"error\",code:\"500\",description:t instanceof Error?t.message:\"Internal Server Error\"}}}}const Fr=t=>Pt.fromWif(t).toAddress(),Br=async(t,e)=>{let r;return r=\"BSV20\"===e?(await(await fetch(`https://ordinals.gorillapool.io/api/bsv20/tick/${t}`)).json()).dec:(await(await fetch(`https://ordinals.gorillapool.io/api/bsv20/id/${t}`)).json()).dec,r},Rr=async t=>{try{const t=await fetch(`https://ordinals.gorillapool.io/api/inscriptions/${origin}/latest`);if(200!==t.status)throw new Error(\"Failed to fetch data from GorilaPool API\");return(await t.json()).outpoint}catch{throw new Error(\"Failed to fetch data from GorilaPool API\")}},Ur=async t=>{try{const e=await fetch(`https://ordinals.gorillapool.io/api/txos/${t}?script=true`);if(200!==e.status)throw new Error(\"Failed to fetch data from GorilaPool API\");return(await e.json()).script}catch{throw new Error(\"Failed to fetch data from GorilaPool API\")}};window.ord={checkIfUserHasOrdinal:async(t,e)=>{try{try{const r=await fetch(`https://ordinals.gorillapool.io/api/inscriptions/${e}/latest`);if(200!==r.status)throw new Error(\"Failed to fetch data from GorilaPool API\");return(await r.json()).owner===t}catch{const r=await fetch(`https://api.whatsonchain.com/v1/bsv/main/token/1satordinals/${e}/latest`);if(200!==r.status)throw new Error(\"Failed to fetch data from WhatsOnChain API\");return(await r.json()).token.ownerAddress===t}}catch{return!1}},generatePrivateKey:()=>Pt.fromRandom().toWif(),privKeyToPubKey:t=>Pt.fromWif(t).toPublicKey().toString(),privKeyToAddress:Fr,pubKeyToAddress:t=>bt.fromString(t).toAddress(),getBalanceInSats:async t=>{const e=await Pr(t);let r=0;return e.forEach((t=>{r+=t.satoshis})),r},getTokenBalance:async(t,e,r)=>{const i=\"BSV20\"===r?gr.BSV20:gr.BSV21,s=await Or(i,e,t,100);let n=1;for(;s.length===100*n;){const r=await Or(i,e,t,100,100*n);s.push(...r),n++}let a=0;return s.forEach((t=>{a+=+t.amt})),a/Math.pow(10,await Br(e,r))},sendBsv:async(t,e,r)=>{const i=await Pr(Fr(e)),s=Pt.fromWif(e),n=(await(async t=>{const{utxos:e,paymentPk:r,payments:i,satsPerKb:s=dr,metaData:n}=t,a=new Ft(s),o=new zt;for(const t of i){const e={satoshis:t.amount,lockingScript:(new fr).lock(t.to,void 0,n)};o.addOutput(e)}let c=0n;const h=o.outputs.reduce(((t,e)=>t+(e.satoshis||0)),0);let d,u=0;for(const t of e){const e=t.pk||r;if(!e)throw new Error(\"Private key is required to sign the utxos\");const i=vr(t,(new Nt).unlock(e,\"all\",!0,t.satoshis,kt.fromBinary(j(t.script,\"base64\"))));if(o.addInput(i),c+=BigInt(t.satoshis),u=await a.computeFee(o),c>=h+u)break}if(c<h+u)throw new Error(`Not enough funds to send. Total sats in: ${c}, Total sats out: ${h}, Fee: ${u}`);if(c>h+u){const e=t.changeAddress||(null==r?void 0:r.toAddress());if(!e)throw new Error(\"Either changeAddress or paymentPk is required\");const i=(new Nt).lock(e),s={lockingScript:i,change:!0};d={txid:\"\",vout:o.outputs.length,satoshis:0,script:pe.from(i.toHex(),\"hex\").toString(\"base64\")},o.addOutput(s)}else c<h+u&&console.log(\"No change needed\");await o.fee(a),await o.sign();const f=o.outputs.findIndex((t=>t.change));if(-1!==f){const t=o.outputs[f];d={satoshis:t.satoshis,txid:o.id(\"hex\"),vout:f,script:pe.from(t.lockingScript.toBinary()).toString(\"base64\")}}return d&&(d.satoshis=o.outputs[o.outputs.length-1].satoshis,d.txid=o.id(\"hex\")),{tx:o,spentOutpoints:e.map((t=>`${t.txid}_${t.vout}`)),payChange:d}})({utxos:i,paymentPk:s,payments:[{to:r,amount:t}],satsPerKb:1})).tx;await n.broadcast(Tr())},sendToken:async(t,e,r,i,s,n)=>{const a=(await(async t=>{const{protocol:e,tokenID:r,utxos:i,inputTokens:s,distributions:n,paymentPk:a,ordPk:o,satsPerKb:c=dr,metaData:h,signer:d,decimals:u,additionalPayments:f=[],burn:l=!1,tokenInputMode:b=wr.Needed,splitConfig:p={outputs:1,omitMetaData:!1}}=t;if(!s.every((t=>t.id===r)))throw new Error(\"Input tokens do not match the provided tokenID\");let g=0n,m=0n,w=0n;const y=n.reduce(((t,e)=>t+tr(e.tokens,u,Qe)),0n),v=new Ft(c);let P,O=new zt;if(b===wr.All)P=s,m=s.reduce(((t,e)=>t+BigInt(e.amt)),0n);else{P=[];for(const t of s)if(P.push(t),m+=BigInt(t.amt),m>=y)break;if(m<y)throw new Error(\"Not enough tokens to satisfy the transfer amount\")}for(const t of P){const e=t.pk||o;if(!e)throw new Error(\"Private key required for token input\");const r=j(t.script,\"base64\"),i=kt.fromBinary(r);O.addInput(vr(t,(new fr).unlock(e,\"all\",!0,t.satoshis,i)))}if(h)for(const t of Object.keys(h))void 0===h[t]&&delete h[t];for(const t of n){const i=tr(t.tokens,u,Qe);console.log({distTokenSat:i});const s={p:\"bsv-20\",op:l?\"burn\":\"transfer\",amt:i.toString()};let n;if(e===gr.BSV20)n=br({},s,{tick:r});else{if(e!==gr.BSV21)throw new Error(\"Invalid protocol\");n=br({},s,{id:r})}const a={dataB64:pe.from(JSON.stringify(n)).toString(\"base64\"),contentType:\"application/bsv-20\"};let o=\"string\"==typeof t.address?(new fr).lock(t.address,a,t.omitMetaData?void 0:_r(h)):lr(t.address,a);O.addOutput({satoshis:1,lockingScript:o}),w+=i}if(g=m-w,g<0n)throw new Error(\"Not enough tokens to send\");let E,k=[];if(g>0n){const i=t.tokenChangeAddress||(null==o?void 0:o.toAddress());if(!i)throw new Error(\"ordPk or changeAddress required for token change\");k=xr(O,g,e,r,i,h,p,u)}for(const t of f)O.addOutput({satoshis:t.amount,lockingScript:(new Nt).lock(t.to)});const _=t.changeAddress||(null==a?void 0:a.toAddress());if(!_)throw new Error(\"paymentPk or changeAddress required for payment change\");const x=(new Nt).lock(_);O.addOutput({lockingScript:x,change:!0});let I=0n;const S=O.outputs.reduce(((t,e)=>t+BigInt(e.satoshis||0)),0n);let A=0;for(const t of i){const e=t.pk||a;if(!e)throw new Error(\"paymentPk required for payment utxo\");const r=vr(t,(new Nt).unlock(e,\"all\",!0,t.satoshis,kt.fromBinary(j(t.script,\"base64\"))));if(O.addInput(r),I+=BigInt(t.satoshis),A=await v.computeFee(O),I>=S+BigInt(A))break}if(I<S+BigInt(A))throw new Error(`Not enough funds to transfer tokens. Total sats in: ${I}, Total sats out: ${S}, Fee: ${A}`);d&&(O=await kr(O,d)),await O.fee(v),await O.sign();const M=O.id(\"hex\");for(const t of k)t.txid=M;const T=O.outputs.findIndex((t=>t.change));if(-1!==T){const t=O.outputs[T];E={satoshis:t.satoshis,txid:M,vout:T,script:pe.from(t.lockingScript.toBinary()).toString(\"base64\")}}return E&&(E.satoshis=O.outputs[O.outputs.length-1].satoshis,E.txid=O.id(\"hex\")),{tx:O,spentOutpoints:O.inputs.map((t=>`${t.sourceTXID}_${t.sourceOutputIndex}`)),payChange:E,tokenChange:k}})({protocol:\"BSV20\"===n?gr.BSV20:gr.BSV21,tokenID:e,decimals:await Br(e,n),utxos:await Pr(Fr(i)),inputTokens:await Or(\"BSV20\"===n?gr.BSV20:gr.BSV21,e,Fr(r)),distributions:[{address:s,tokens:t*Math.pow(10,await Br(e,n))}],satsPerKb:1,paymentPk:Pt.fromWif(i),ordPk:Pt.fromWif(r)})).tx;await a.broadcast(Tr())},sendOrdinal:async(t,e,r,i)=>{const s=(await(async t=>{t.satsPerKb||(t.satsPerKb=dr),t.additionalPayments||(t.additionalPayments=[]),void 0===t.enforceUniformSend&&(t.enforceUniformSend=!0);const{ordPk:e,paymentPk:r}=t,i=new Ft(t.satsPerKb);let s=new zt;const n=[];for(const r of t.ordinals){const t=r.pk||e;if(!t)throw new Error(\"Private key is required to sign the ordinal\");if(1!==r.satoshis)throw new Error(\"1Sat Ordinal utxos must have exactly 1 satoshi\");const i=vr(r,(new fr).unlock(t,\"all\",!0,r.satoshis,kt.fromBinary(j(r.script,\"base64\"))));n.push(`${r.txid}_${r.vout}`),s.addInput(i)}if(t.enforceUniformSend&&t.destinations.length!==t.ordinals.length)throw new Error(\"Number of destinations must match number of ordinals being sent\");for(const e of t.destinations){var a,o;let r;r=null!=(a=e.inscription)&&a.dataB64&&null!=(o=e.inscription)&&o.contentType?(new fr).lock(e.address,e.inscription,_r(t.metaData)):(new Nt).lock(e.address),s.addOutput({satoshis:1,lockingScript:r})}for(const e of t.additionalPayments)s.addOutput({satoshis:e.amount,lockingScript:(new Nt).lock(e.to)});let c;const h=t.changeAddress||(null==r?void 0:r.toAddress());if(!h)throw new Error(\"Either changeAddress or paymentPk is required\");const d=(new Nt).lock(h);s.addOutput({lockingScript:d,change:!0});let u=0n;const f=s.outputs.reduce(((t,e)=>t+BigInt(e.satoshis||0)),0n);let l=0;for(const e of t.paymentUtxos){const t=e.pk||r;if(!t)throw new Error(\"Private key is required to sign the payment\");const a=vr(e,(new Nt).unlock(t,\"all\",!0,e.satoshis,kt.fromBinary(j(e.script,\"base64\"))));if(n.push(`${e.txid}_${e.vout}`),s.addInput(a),u+=BigInt(e.satoshis),l=await i.computeFee(s),u>=f+BigInt(l))break}if(u<f)throw new Error(\"Not enough ordinals to send\");t.signer&&(s=await kr(s,t.signer)),await s.fee(i),await s.sign();const b=s.outputs.findIndex((t=>t.change));if(-1!==b){const t=s.outputs[b];c={satoshis:t.satoshis,txid:s.id(\"hex\"),vout:b,script:pe.from(t.lockingScript.toBinary()).toString(\"base64\")}}return c&&(c.satoshis=s.outputs[s.outputs.length-1].satoshis,c.txid=s.id(\"hex\")),{tx:s,spentOutpoints:n,payChange:c}})({paymentUtxos:await Pr(Fr(e)),paymentPk:Pt.fromWif(e),satsPerKb:1,ordPk:Pt.fromWif(t),ordinals:[{satoshis:1,txid:(await Rr()).slice(0,64),vout:+(await Rr()).slice(65),script:await Ur(await Rr())}],destinations:[{address:r}]})).tx;await s.broadcast(Tr())},getBSVPrice:async()=>(await(await fetch(\"https://api.whatsonchain.com/v1/bsv/main/exchangerate\")).json()).rate,getOwnedOrdinals:async(t,e,r,i)=>{const s=await(async(t,e,r=10,i=0,s=\"base64\")=>{let n=`${ur}/txos/address/${t}/unspent?limit=${r}&offset=${i}&`;e&&(n+=`q=${pe.from(JSON.stringify({map:{subTypeData:{collectionId:e}}})).toString(\"base64\")}`);const a=await fetch(n);if(!a.ok)throw new Error(`Error fetching NFT utxos for ${t}`);let o=await a.json();o=o.filter((t=>{var e;return 1===t.satoshis&&!(null!=(e=t.data)&&e.list)}));const c=o.map((t=>`${t.txid}_${t.vout}`)),h=await fetch(`${ur}/txos/outpoints?script=true`,{method:\"POST\",headers:{\"Content-Type\":\"application/json\"},body:JSON.stringify([...c])});if(!h.ok)throw new Error(`Error fetching NFT scripts for ${t}`);return o=(await h.json()||[]).map((t=>{let r=t.script;\"hex\"===s?r=pe.from(r,\"base64\").toString(\"hex\"):\"asm\"===s&&(r=kt.fromHex(pe.from(r,\"base64\").toString(\"hex\")).toASM());const i={origin:t.origin.outpoint,script:r,vout:t.vout,txid:t.txid,satoshis:1};return e&&(i.collectionId=e),i})),o})(t,i,e,r);let n=[];return s.forEach((t=>{n.push(t.origin)})),n},createSignature:(t,e)=>Pt.fromWif(e).sign(t).toString(\"base64\"),verifySignature:(t,e,r)=>{const i=bt.fromString(r);return ht.fromDER(e,\"base64\").verify(t,i)},getCollectionOrdinals:async(t,e,r,i)=>{const s=await(await fetch(`https://api.1sat.market/collection/${t}/${i}?limit=${e}&offset=${r}`)).json();let n=[];return s.forEach((t=>{n.push(t.outpoint)})),n},checkIfAddressHasOrdInCollection:async(t,e)=>{const r=await(async(t,e,r=\"base64\")=>{let i=`https://ordinals.gorillapool.io/api/txos/address/${t}/unspent?`;if(e){const t={map:{subTypeData:{collectionId:e}}};i+=`q=${pe.from(JSON.stringify(t)).toString(\"base64\")}`}const s=await fetch(i);if(!s.ok)throw new Error(`Error fetching NFT utxos for ${t}`);let n=await s.json();n=n.filter((t=>1===t.satoshis&&!t.data?.list));const a=n.map((t=>`${t.txid}_${t.vout}`)),o=await fetch(\"https://ordinals.gorillapool.io/api/txos/outpoints?script=true\",{method:\"POST\",headers:{\"Content-Type\":\"application/json\"},body:JSON.stringify([...a])});if(!o.ok)throw new Error(`Error fetching NFT scripts for ${t}`);return n=(await o.json()||[]).map((t=>{let i=t.script;\"hex\"===r?i=pe.from(i,\"base64\").toString(\"hex\"):\"asm\"===r&&(i=kt.fromHex(pe.from(i,\"base64\").toString(\"hex\")).toASM());const s={origin:t.origin.outpoint,script:i,vout:t.vout,txid:t.txid,satoshis:1};return e&&(s.collectionId=e),s})),n})(t,e);return r.length>0},getOrdPrice:async t=>{try{const e=await fetch(`https://ordinals.gorillapool.io/api/inscriptions/${t}/latest`);if(200!==e.status)throw new Error(\"Failed to fetch data from GorilaPool API\");const r=await e.json();return void 0===r.data?.list?0:r.data?.list.price}catch{const e=await(await fetch(`https://ordinals.gorillapool.io/api/inscriptions/${t}`)).json();return void 0===e.data?.list?0:e.data?.list.price}},isOrdSigValid:async t=>{const e=await(await fetch(`https://ordinals.gorillapool.io/api/inscriptions/${t}`)).json();return void 0!==e.origin.data.sigma&&e.origin.data.sigma[0].isValid},sellOnMarket:async(t,e,r,i)=>{const s=(await(async t=>{const{utxos:e,listings:r,paymentPk:i,ordPk:s,satsPerKb:n=dr,additionalPayments:a=[]}=t,o=new Ft(n),c=new zt;r.length>100&&console.warn(\"Creating many inscriptions at once can be slow. Consider using multiple transactions instead.\");for(const t of r){c.addOutput({satoshis:1,lockingScript:(new Ir).lock(t.ordAddress,t.payAddress,t.price)});const e=Sr(t.listingUtxo.script,\"base64\"),r=kt.fromBinary(e),i=t.listingUtxo.pk||s;if(!i)throw new Error(\"Private key is required to sign the ordinal\");c.addInput(vr(t.listingUtxo,(new fr).unlock(i,\"all\",!0,t.listingUtxo.satoshis,r)))}for(const t of a)c.addOutput({satoshis:t.amount,lockingScript:(new Nt).lock(t.to)});let h;const d=t.changeAddress||(null==i?void 0:i.toAddress());if(!d)throw new Error(\"changeAddress or private key is required\");const u=(new Nt).lock(d);c.addOutput({lockingScript:u,change:!0});let f=0n;const l=c.outputs.reduce(((t,e)=>t+BigInt(e.satoshis||0)),0n);let b=0;for(const t of e){const e=t.pk||i;if(!e)throw new Error(\"Private key is required to sign the transaction\");const r=vr(t,(new Nt).unlock(e,\"all\",!0,t.satoshis,kt.fromBinary(j(t.script,\"base64\"))));if(c.addInput(r),f+=BigInt(t.satoshis),b=await o.computeFee(c),f>=l+BigInt(b))break}if(f<l+BigInt(b))throw new Error(`Not enough funds to create ordinal listings. Total sats in: ${f}, Total sats out: ${l}, Fee: ${b}`);await c.fee(o),await c.sign();const p=c.outputs.findIndex((t=>t.change));if(-1!==p){const t=c.outputs[p];h={satoshis:t.satoshis,txid:c.id(\"hex\"),vout:p,script:pe.from(t.lockingScript.toBinary()).toString(\"base64\")}}return h&&(h.satoshis=c.outputs[c.outputs.length-1].satoshis,h.txid=c.id(\"hex\")),{tx:c,spentOutpoints:c.inputs.map((t=>`${t.sourceTXID}_${t.sourceOutputIndex}`)),payChange:h}})({listings:[{payAddress:Fr(i),price:e,ordAddress:Fr(r),listingUtxo:{txid:t.slice(0,64),vout:+t.slice(65),script:(await(await fetch(`https://ordinals.gorillapool.io/api/txos/${t}?script=true`)).json()).script,satoshis:1}}],utxos:await Pr(Fr(i)),paymentPk:Pt.fromWif(i),ordPk:Pt.fromWif(r),satsPerKb:1})).tx;await s.broadcast(Tr())},buyOnMarket:async(t,e,r,i,s)=>{const n=JSON.parse((await(await fetch(`https://ordinals.gorillapool.io/api/inscriptions/${t}`)).json()).origin.data.map.royalties);let a=[];a.push({type:mr.Address,destination:i,percentage:s.toString()}),n.forEach((t=>{\"address\"===t.type?a.push({type:mr.Address,destination:t.destination,percentage:t.percentage}):\"paymail\"===t.type?a.push({type:mr.Paymail,destination:t.destination,percentage:t.percentage}):\"script\"===t.type&&a.push({type:mr.Script,destination:t.destination,percentage:t.percentage})}));const o=(await(async t=>{const{utxos:e,paymentPk:r,listing:i,ordAddress:s,additionalPayments:n=[],satsPerKb:a=dr,royalties:o=[],metaData:c}=t,h=new Ft(a),d=new zt;d.addInput(vr(i.listingUtxo,(new Ir).purchaseListing(1,kt.fromBinary(j(i.listingUtxo.script,\"base64\"))))),d.addOutput({satoshis:1,lockingScript:(new fr).lock(s,void 0,c)});const u=new it(j(i.payout,\"base64\")),f=u.readUInt64LEBn().toNumber(),l=u.readVarIntNum(),b=u.read(l),p=_t.fromBinary(b);d.addOutput({satoshis:f,lockingScript:p});for(const t of n)d.addOutput({satoshis:t.amount,lockingScript:(new Nt).lock(t.to)});for(const t of o){let e;const r=Math.floor(Number(t.percentage)*f);switch(t.type){case mr.Paymail:e=await Ar();break;case mr.Script:e=kt.fromBinary(j(t.destination,\"base64\"));break;case mr.Address:e=(new Nt).lock(t.destination);break;default:throw new Error(\"Invalid royalty type\")}if(!e)throw new Error(\"Invalid royalty destination\");d.addOutput({satoshis:r,lockingScript:e})}let g;const m=t.changeAddress||(null==r?void 0:r.toAddress());if(!m)throw new Error(\"Either changeAddress or paymentPk is required\");const w=(new Nt).lock(m);d.addOutput({lockingScript:w,change:!0});let y=0n;const v=d.outputs.reduce(((t,e)=>t+BigInt(e.satoshis||0)),0n);let P=0;for(const t of e){const e=t.pk||r;if(!e)throw new Error(\"Private key is required to sign the payment\");const i=vr(t,(new Nt).unlock(e,\"all\",!0,t.satoshis,kt.fromBinary(j(t.script,\"base64\"))));if(d.addInput(i),y+=BigInt(t.satoshis),P=await h.computeFee(d),y>=v+BigInt(P))break}if(y<v+BigInt(P))throw new Error(`Not enough funds to purchase ordinal listing. Total sats in: ${y}, Total sats out: ${v}, Fee: ${P}`);await d.fee(h),await d.sign();const O=d.outputs.findIndex((t=>t.change));if(-1!==O){const t=d.outputs[O];g={satoshis:t.satoshis,txid:d.id(\"hex\"),vout:O,script:pe.from(t.lockingScript.toBinary()).toString(\"base64\")}}return g&&(g.satoshis=d.outputs[d.outputs.length-1].satoshis,g.txid=d.id(\"hex\")),{tx:d,spentOutpoints:d.inputs.map((t=>`${t.sourceTXID}_${t.sourceOutputIndex}`)),payChange:g}})({listing:{payout:e,listingUtxo:{txid:t.slice(0,64),vout:+t.slice(65),script:(await(await fetch(`https://ordinals.gorillapool.io/api/txos/${t}?script=true`)).json()).script,satoshis:1}},utxos:await Pr(Fr(r)),paymentPk:Pt.fromWif(r),ordAddress:e,satsPerKb:1,royalties:a})).tx;await o.broadcast(Tr())},cancelMarketListing:async(t,e,r)=>{const i=(await(async t=>{const{utxos:e,listingUtxos:r,ordPk:i,paymentPk:s,additionalPayments:n=[],satsPerKb:a=dr}=t;r.length>100&&console.warn(\"Creating many inscriptions at once can be slow. Consider using multiple transactions instead.\");const o=new Ft(a),c=new zt;for(const t of r){const e=t.pk||i;if(!e)throw new Error(\"Private key required for token input\");c.addInput(vr(t,(new Ir).cancelListing(e,\"all\",!0,t.satoshis,kt.fromBinary(j(t.script,\"base64\"))))),c.addOutput({satoshis:1,lockingScript:(new Nt).lock(e.toAddress().toString())})}for(const t of n)c.addOutput({satoshis:t.amount,lockingScript:(new Nt).lock(t.to)});let h;const d=t.changeAddress||(null==s?void 0:s.toAddress());if(!d)throw new Error(\"paymentPk or changeAddress required for payment change\");const u=d,f=(new Nt).lock(u);c.addOutput({lockingScript:f,change:!0});let l=0n;const b=c.outputs.reduce(((t,e)=>t+BigInt(e.satoshis||0)),0n);let p=0;for(const t of e){const e=t.pk||s;if(!e)throw new Error(\"paymentPk required for payment utxo\");const r=vr(t,(new Nt).unlock(e,\"all\",!0,t.satoshis,kt.fromBinary(j(t.script,\"base64\"))));if(c.addInput(r),l+=BigInt(t.satoshis),p=await o.computeFee(c),l>=b+BigInt(p))break}if(l<b+BigInt(p))throw new Error(`Not enough funds to cancel ordinal listings. Total sats in: ${l}, Total sats out: ${b}, Fee: ${p}`);await c.fee(o),await c.sign();const g=c.outputs.findIndex((t=>t.change));if(-1!==g){const t=c.outputs[g];h={satoshis:t.satoshis,txid:c.id(\"hex\"),vout:g,script:pe.from(t.lockingScript.toBinary()).toString(\"base64\")}}return h&&(h.satoshis=c.outputs[c.outputs.length-1].satoshis,h.txid=c.id(\"hex\")),{tx:c,spentOutpoints:c.inputs.map((t=>`${t.sourceTXID}_${t.sourceOutputIndex}`)),payChange:h}})({listingUtxos:[{txid:t.slice(0,64),vout:+t.slice(65),script:(await(await fetch(`https://ordinals.gorillapool.io/api/txos/${t}?script=true`)).json()).script,satoshis:1}],utxos:await Pr(Fr(r)),ordPk:Pt.fromWif(e),paymentPk:Pt.fromWif(r),satsPerKb:1})).tx;await i.broadcast(Tr())}}}();",
          "parameterObjects": "",
          "useStrict": true,
          "eventsSheetExpanded": false
        }
      ],
      "parameters": [],
      "objectGroups": []
    },
    {
      "async": true,
      "description": "Allows you to sell an ordinal, using an ordlock smart contract.",
      "fullName": "Sell an Ordinal with an OrdLock",
      "functionType": "Action",
      "name": "Sell_Ordinal_Action",
      "sentence": "Sell _PARAM1_ for _PARAM2_ which is held in _PARAM3_, with the transaction being funded by _PARAM4_",
      "events": [
        {
          "type": "BuiltinCommonInstructions::JsCode",
          "inlineCode": [
            "const outpoint = eventsFunctionContext.getArgument('Outpoint');",
            "const price = eventsFunctionContext.getArgument('Price');",
            "const privKey = eventsFunctionContext.getArgument('PrivKey');",
            "const fundPrivKey = eventsFunctionContext.getArgument('fundPrivKey');",
            "",
            "return new gdjs.PromiseTask(window.ord.sellOnMarket(outpoint, price, privKey, fundPrivKey).then(() => {",
            "    eventsFunctionContext.task.resolve();",
            "}));"
          ],
          "parameterObjects": "",
          "useStrict": true,
          "eventsSheetExpanded": false
        }
      ],
      "parameters": [
        {
          "description": "Ordinal Outpoint of the ordinal you wish to sell",
          "name": "Outpoint",
          "type": "string"
        },
        {
          "description": "Price you wish to sell it for, in sats",
          "name": "Price",
          "type": "expression"
        },
        {
          "description": "Private Key of address that has ordinal",
          "name": "PrivKey",
          "type": "string"
        },
        {
          "description": "Private Key of address funding the transaction",
          "name": "FundPrivKey",
          "type": "string"
        }
      ],
      "objectGroups": []
    },
    {
      "async": true,
      "description": "Allows you to buy an ordinal locked in an ordlock.",
      "fullName": "Buy an ordinal locked in an ordlock",
      "functionType": "Action",
      "name": "Buy_Ordinal_Action",
      "sentence": "Buy _PARAM1_ and send to _PARAM2_ with tx funded by _PARAM3_",
      "events": [
        {
          "type": "BuiltinCommonInstructions::JsCode",
          "inlineCode": [
            "const outpoint = eventsFunctionContext.getArgument('Outpoint');",
            "const receiveAddress = eventsFunctionContext.getArgument('ReceiveAddress');",
            "const fundPrivKey = eventsFunctionContext.getArgument('FundPrivKey');",
            "/** @type {gdjs.Variable} */",
            "const marketplaceFeeAddress = runtimeScene.getVariablesForExtension('OneSatOrdinalsBSV').get('MarketFeeAddress');",
            "/** @type {gdjs.Variable} */",
            "const marketplaceFeePercent = runtimeScene.getVariablesForExtension('OneSatOrdinalsBSV').get('MarketFeePercent');",
            "",
            "return new gdjs.PromiseTask(window.ord.buyOnMarket(outpoint, receiveAddress, fundPrivKey, marketplaceFeeAddress.getAsNumber(), marketplaceFeePercent.getAsNumber()).then(() => {",
            "    eventsFunctionContext.task.resolve();",
            "}));"
          ],
          "parameterObjects": "",
          "useStrict": true,
          "eventsSheetExpanded": false
        }
      ],
      "parameters": [
        {
          "description": "Ordinal outpoint of the ordinal you wish to buy",
          "name": "Outpoint",
          "type": "string"
        },
        {
          "description": "Address that will receive the ordinal",
          "name": "ReceiveAddress",
          "type": "string"
        },
        {
          "description": "Private Key funding the transaction",
          "name": "FundPrivKey",
          "type": "string"
        }
      ],
      "objectGroups": []
    },
    {
      "async": true,
      "description": "Cancels the sale of an ordinal in an ordlock.",
      "fullName": "Cancel sale of ordinal",
      "functionType": "Action",
      "name": "Cancel_Ordinal_Sale_Action",
      "sentence": "Cancel sale of _PARAM1_ owned by _PARAM2_ funded by _PARAM3_",
      "events": [
        {
          "type": "BuiltinCommonInstructions::JsCode",
          "inlineCode": [
            "const outpoint = eventsFunctionContext.getArgument('Outpoint');",
            "const privKey = eventsFunctionContext.getArgument('PrivKey');",
            "const fundPrivKey = eventsFunctionContext.getArgument('fundPrivKey');",
            "",
            "return new gdjs.PromiseTask(window.ord.cancelMarketListing(outpoint, privKey, fundPrivKey).then(() => {",
            "    eventsFunctionContext.task.resolve();",
            "}));"
          ],
          "parameterObjects": "",
          "useStrict": true,
          "eventsSheetExpanded": false
        }
      ],
      "parameters": [
        {
          "description": "Outpoint of ordinal you wish to cancel the sale of",
          "name": "Outpoint",
          "type": "string"
        },
        {
          "description": "Private Key of address that owns the ordinal",
          "name": "PrivKey",
          "type": "string"
        },
        {
          "description": "Private Key of address that will fund the transaction",
          "name": "FundPrivKey",
          "type": "string"
        }
      ],
      "objectGroups": []
    },
    {
      "async": true,
      "description": "Get the price of an ordinal, by inputting one of its outpoint, in sats.",
      "fullName": "Get Price of Ordinal",
      "functionType": "Action",
      "name": "Get_Ordinal_Price_Action",
      "sentence": "Get price of ordinal _PARAM1_ and return to _PARAM2_",
      "events": [
        {
          "type": "BuiltinCommonInstructions::JsCode",
          "inlineCode": [
            "const outpoint = eventsFunctionContext.getArgument('Outpoint');",
            "/** @type {gdjs.Variable} */",
            "const returnTo = eventsFunctionContext.getArgument('ReturnTo');",
            "",
            "return new gdjs.PromiseTask(window.ord.getOrdPrice(outpoint).then((price) => {",
            "    returnTo.setNumber(price);",
            "    eventsFunctionContext.task.resolve();",
            "}));"
          ],
          "parameterObjects": "",
          "useStrict": true,
          "eventsSheetExpanded": false
        }
      ],
      "parameters": [
        {
          "description": "Ordinal outpoint. Doesn't have to be the latest outpoint",
          "name": "Outpoint",
          "type": "string"
        },
        {
          "description": "Number Variable to return to",
          "name": "ReturnTo",
          "type": "variable"
        }
      ],
      "objectGroups": []
    },
    {
      "async": true,
      "description": "Checks if the SIGMA signature of an ordinal is valid.",
      "fullName": "Check if a SIGMA signature is valid",
      "functionType": "Action",
      "name": "Is_Ordinal_Sigma_Signature_Valid_Action",
      "sentence": "Is _PARAM1_'s signature valid, return to _PARAM2_",
      "events": [
        {
          "type": "BuiltinCommonInstructions::JsCode",
          "inlineCode": [
            "const outpoint = eventsFunctionContext.getArgument('Outpoint');",
            "/** @type {gdjs.Variable} */",
            "const returnTo = eventsFunctionContext.getArgument('ReturnTo');",
            "",
            "return new gdjs.PromiseTask(window.ord.isOrdSigValid(outpoint).then((isValid) => {",
            "    returnTo.setBoolean(isValid);",
            "    eventsFunctionContext.task.resolve();",
            "}));"
          ],
          "parameterObjects": "",
          "useStrict": true,
          "eventsSheetExpanded": false
        }
      ],
      "parameters": [
        {
          "description": "Ordinal Outpoint, does not need to be latest",
          "name": "Outpoint",
          "type": "string"
        },
        {
          "description": "Return Boolean Variable",
          "name": "ReturnTo",
          "type": "variable"
        }
      ],
      "objectGroups": []
    },
    {
      "description": "Set the address that marketplace fees will go to.",
      "fullName": "Set Marketplace Fee Address",
      "functionType": "Action",
      "name": "Set_Market_Fee_Address_Action",
      "sentence": "Set Marketplace Fee Address to _PARAM1_",
      "events": [
        {
          "type": "BuiltinCommonInstructions::Standard",
          "conditions": [],
          "actions": [
            {
              "type": {
                "value": "SetStringVariable"
              },
              "parameters": [
                "MarketFeeAddress",
                "=",
                "Address"
              ]
            }
          ]
        }
      ],
      "parameters": [
        {
          "description": "Address where fees will be sent to",
          "name": "Address",
          "type": "string"
        }
      ],
      "objectGroups": []
    },
    {
      "description": "Sets the marketplace fee percentage, as a decimal. Fees are added ontop of the sale price.",
      "fullName": "Set Marketplace Fee Percentage",
      "functionType": "Action",
      "name": "Set_Market_Fee_Percent_Action",
      "sentence": "Set Marketplace Fee to _PARAM1_",
      "events": [
        {
          "type": "BuiltinCommonInstructions::Standard",
          "conditions": [],
          "actions": [
            {
              "type": {
                "value": "SetNumberVariable"
              },
              "parameters": [
                "MarketFeePercent",
                "=",
                "Fee"
              ]
            }
          ]
        }
      ],
      "parameters": [
        {
          "description": "Marketplace Fee Percentage (as a decimal)",
          "name": "Fee",
          "type": "expression"
        }
      ],
      "objectGroups": []
    },
    {
      "description": "Returns the Public Key related to the Private Key in WIF passed.",
      "fullName": "Convert Private Key in WIF to Public Key",
      "functionType": "StringExpression",
      "name": "PrivateKey_To_PubKey",
      "sentence": "",
      "events": [
        {
          "type": "BuiltinCommonInstructions::JsCode",
          "inlineCode": [
            "const privKey = eventsFunctionContext.getArgument('PrivateKey');",
            "",
            "eventsFunctionContext.returnValue = window.ord.privKeyToPubKey(privKey);"
          ],
          "parameterObjects": "",
          "useStrict": true,
          "eventsSheetExpanded": false
        }
      ],
      "expressionType": {
        "type": "string"
      },
      "parameters": [
        {
          "description": "Private Key in WIF",
          "name": "PrivateKey",
          "type": "string"
        }
      ],
      "objectGroups": []
    },
    {
      "description": "Returns the Address related to the Private Key in WIF passed.",
      "fullName": "Convert Private Key in WIF to Address",
      "functionType": "StringExpression",
      "name": "PrivateKey_To_Address",
      "sentence": "",
      "events": [
        {
          "type": "BuiltinCommonInstructions::JsCode",
          "inlineCode": [
            "const privKey = eventsFunctionContext.getArgument('PrivateKey');",
            "",
            "eventsFunctionContext.returnValue = window.ord.privKeyToAddress(privKey);"
          ],
          "parameterObjects": "",
          "useStrict": true,
          "eventsSheetExpanded": false
        }
      ],
      "expressionType": {
        "type": "string"
      },
      "parameters": [
        {
          "description": "Private Key in WIF",
          "name": "PrivateKey",
          "type": "string"
        }
      ],
      "objectGroups": []
    },
    {
      "description": "Converts a Public Key to an Address.",
      "fullName": "Convert Public Key to Address",
      "functionType": "StringExpression",
      "name": "PubKey_To_Address",
      "sentence": "",
      "events": [
        {
          "type": "BuiltinCommonInstructions::JsCode",
          "inlineCode": [
            "const pubkey = eventsFunctionContext.getArgument('PubKey');\r",
            "\r",
            "eventsFunctionContext.returnValue = window.ord.pubKeyToAddress(pubkey);"
          ],
          "parameterObjects": "",
          "useStrict": true,
          "eventsSheetExpanded": false
        }
      ],
      "expressionType": {
        "type": "string"
      },
      "parameters": [
        {
          "description": "Public Key",
          "name": "PubKey",
          "type": "string"
        }
      ],
      "objectGroups": []
    },
    {
      "async": true,
      "description": "Gets the balance of the specified BSV address in sats.",
      "fullName": "Get Balance of Specified Address in Sats",
      "functionType": "Action",
      "name": "Get_Balance_Action",
      "sentence": "Get Balance of _PARAM1_ and return to _PARAM2_",
      "events": [
        {
          "type": "BuiltinCommonInstructions::JsCode",
          "inlineCode": [
            "/** @type {gdjs.Variable} */",
            "const variable = eventsFunctionContext.getArgument('ReturnTo');",
            "const address = eventsFunctionContext.getArgument('Address');",
            "",
            "return new gdjs.PromiseTask(window.ord.getBalanceInSats(address).then((balance) => {",
            "    variable.setNumber(balance);",
            "    eventsFunctionContext.task.resolve();",
            "}));"
          ],
          "parameterObjects": "",
          "useStrict": true,
          "eventsSheetExpanded": false
        }
      ],
      "parameters": [
        {
          "description": "Address",
          "name": "Address",
          "type": "string"
        },
        {
          "description": "Return Var",
          "name": "ReturnTo",
          "type": "variable"
        }
      ],
      "objectGroups": []
    },
    {
      "async": true,
      "description": "Allows you to get the balance of any BSV20/21 token that a user holds.",
      "fullName": "Get balance of BSV20/21 token",
      "functionType": "Action",
      "name": "Get_Token_Balance_Action",
      "sentence": "Get balance of token _PARAM1_ held by _PARAM2_ which is a _PARAM3_ and return result to _PARAM4_",
      "events": [
        {
          "type": "BuiltinCommonInstructions::JsCode",
          "inlineCode": [
            "const tokenId = eventsFunctionContext.getArgument('TokenID');",
            "const address = eventsFunctionContext.getArgument('Address');",
            "const tokenType = eventsFunctionContext.getArgument('TokenType');",
            "/** @type {gdjs.Variable} */",
            "const returnVar = eventsFunctionContext.getArgument('ReturnTo');",
            "",
            "return new gdjs.PromiseTask(window.ord.getTokenBalance(address, tokenId, tokenType).then((balance) => {",
            "    returnVar.setNumber(balance);",
            "    eventsFunctionContext.task.resolve();",
            "}));"
          ],
          "parameterObjects": "",
          "useStrict": true,
          "eventsSheetExpanded": false
        }
      ],
      "parameters": [
        {
          "description": "Token Origin or Ticker (for BSV20)",
          "name": "TokenID",
          "type": "string"
        },
        {
          "description": "Address to check balance of",
          "name": "Address",
          "type": "string"
        },
        {
          "description": "The type of token it is",
          "name": "TokenType",
          "supplementaryInformation": "[\"BSV20\",\"BSV21\"]",
          "type": "stringWithSelector"
        },
        {
          "description": "Return Variable",
          "name": "ReturnTo",
          "type": "variable"
        }
      ],
      "objectGroups": []
    },
    {
      "async": true,
      "description": "Send BSV to the specified address.",
      "fullName": "Send BSV",
      "functionType": "Action",
      "name": "Send_Bsv_Action",
      "sentence": "Send _PARAM1_ sats to _PARAM2_ from Private Key _PARAM3_",
      "events": [
        {
          "type": "BuiltinCommonInstructions::JsCode",
          "inlineCode": [
            "const sats = eventsFunctionContext.getArgument('Sats');",
            "const address = eventsFunctionContext.getArgument('Address');",
            "const privKey = eventsFunctionContext.getArgument('PrivateKey');",
            "",
            "return new gdjs.PromiseTask(window.ord.sendBsv(sats, privKey, address).then(() => {",
            "    eventsFunctionContext.task.resolve();",
            "}));"
          ],
          "parameterObjects": "",
          "useStrict": true,
          "eventsSheetExpanded": false
        }
      ],
      "parameters": [
        {
          "description": "Number of sats to send. 1 sat = 10^-8 of a BSV",
          "name": "Sats",
          "type": "expression"
        },
        {
          "description": "Address to send to",
          "name": "Address",
          "type": "string"
        },
        {
          "description": "Private Key in WIF format to send from. Change will also be sent here",
          "name": "PrivateKey",
          "type": "string"
        }
      ],
      "objectGroups": []
    },
    {
      "async": true,
      "description": "Send a BSV20/21 token to the specified address.",
      "fullName": "Send BSV20/21 token",
      "functionType": "Action",
      "name": "Send_Token_Action",
      "sentence": "Send _PARAM1_ of token _PARAM2_ of type _PARAM3_  from Private Key _PARAM4_ funded by _PARAM5_ to _PARAM6_",
      "events": [
        {
          "type": "BuiltinCommonInstructions::JsCode",
          "inlineCode": [
            "const tokenAmount = eventsFunctionContext.getArgument('TokenAmount');",
            "const tokenId = eventsFunctionContext.getArgument('TokenId');",
            "const tokenType = eventsFunctionContext.getArgument('TokenType');",
            "const privKey = eventsFunctionContext.getArgument('PrivKey');",
            "const fundPrivKey = eventsFunctionContext.getArgument('FundPrivKey');",
            "const toAddress = eventsFunctionContext.getArgument('ToAddress');",
            "",
            "return new gdjs.PromiseTask(window.ord.sendToken(tokenAmount, tokenId, privKey, fundPrivKey, toAddress, tokenType).then(() => {",
            "    eventsFunctionContext.task.resolve();",
            "}));"
          ],
          "parameterObjects": "",
          "useStrict": true,
          "eventsSheetExpanded": false
        }
      ],
      "parameters": [
        {
          "description": "Token Amount, with decimals if you wish to send fractional amounts",
          "name": "TokenAmount",
          "type": "expression"
        },
        {
          "description": "Token ID or Ticker (for BSV20) of the token you wish to send",
          "name": "TokenId",
          "type": "string"
        },
        {
          "description": "The type of token it is",
          "name": "TokenType",
          "supplementaryInformation": "[\"BSV20\",\"BSV21\"]",
          "type": "stringWithSelector"
        },
        {
          "description": "Private Key of address that has the token you wish to send",
          "name": "PrivKey",
          "type": "string"
        },
        {
          "description": "Private Key of address that will be funding transaction fees",
          "name": "FundPrivKey",
          "type": "string"
        },
        {
          "description": "Address that tokens will be sent to",
          "name": "ToAddress",
          "type": "string"
        }
      ],
      "objectGroups": []
    },
    {
      "async": true,
      "description": "Sends an ordinal to the specified address.",
      "fullName": "Send Ordinal to Specified Address",
      "functionType": "Action",
      "name": "Send_Ord_Action",
      "sentence": "Send _PARAM1_ to _PARAM2_ from _PARAM3_ funded by _PARAM4_",
      "events": [
        {
          "type": "BuiltinCommonInstructions::JsCode",
          "inlineCode": [
            "const outpoint = eventsFunctionContext.getArgument('Outpoint');",
            "const toAddress = eventsFunctionContext.getArgument('ToAddress');",
            "const privKey = eventsFunctionContext.getArgument('PrivKey');",
            "const fundPriv = eventsFunctionContext.getArgument('FundPriv');",
            "",
            "return new gdjs.PromiseTask(window.ord.sendOrdinal(privKey, fundPriv, toAddress, outpoint).then(() => {",
            "    eventsFunctionContext.task.resolve();",
            "}));"
          ],
          "parameterObjects": "",
          "useStrict": true,
          "eventsSheetExpanded": false
        }
      ],
      "parameters": [
        {
          "description": "Ordinal Outpoint",
          "name": "Outpoint",
          "type": "string"
        },
        {
          "description": "Address to send ordinal to",
          "name": "ToAddress",
          "type": "string"
        },
        {
          "description": "Private Key in WIF of the wallet that has the ordinal",
          "name": "PrivKey",
          "type": "string"
        },
        {
          "description": "Private Key in WIF that will fund the transaction",
          "name": "FundPriv",
          "type": "string"
        }
      ],
      "objectGroups": []
    },
    {
      "async": true,
      "description": "Gets the current exchange rate of BSV, in USD.",
      "fullName": "Get BSV Price",
      "functionType": "Action",
      "name": "Get_BSV_Price_Action",
      "sentence": "Get BSV price and save result to _PARAM1_",
      "events": [
        {
          "type": "BuiltinCommonInstructions::JsCode",
          "inlineCode": [
            "/** @type {gdjs.Variable} */\r",
            "const saveTo = eventsFunctionContext.getArgument('SaveTo');\r",
            "\r",
            "return new gdjs.PromiseTask(window.ord.getBSVPrice().then((price) => {\r",
            "    saveTo.setNumber(price);\r",
            "    eventsFunctionContext.task.resolve();\r",
            "}));"
          ],
          "parameterObjects": "",
          "useStrict": true,
          "eventsSheetExpanded": false
        }
      ],
      "parameters": [
        {
          "description": "Variable to save result to",
          "name": "SaveTo",
          "type": "variable"
        }
      ],
      "objectGroups": []
    },
    {
      "async": true,
      "description": "Gets the origins of the ordinals that someone has in their wallet.",
      "fullName": "Get the Ordinals that an address has",
      "functionType": "Action",
      "name": "Get_Owned_Ordinals_Action",
      "sentence": "Get _PARAM1_ Ordinals that _PARAM2_ owns and return to _PARAM3_",
      "events": [
        {
          "type": "BuiltinCommonInstructions::JsCode",
          "inlineCode": [
            "const limit = eventsFunctionContext.getArgument('Limit');",
            "const address = eventsFunctionContext.getArgument('Address');",
            "/** @type {gdjs.Variable} */",
            "const returnTo = eventsFunctionContext.getArgument('ReturnTo');",
            "const offset = eventsFunctionContext.getArgument('Offset');",
            "",
            "return new gdjs.PromiseTask(window.ord.getOwnedOrdinals(address, limit, offset).then((origins) => {",
            "    returnTo.fromJSObject(origins);",
            "    eventsFunctionContext.task.resolve();",
            "}));"
          ],
          "parameterObjects": "",
          "useStrict": true,
          "eventsSheetExpanded": false
        }
      ],
      "parameters": [
        {
          "description": "Max number of ordinal origins that can be returned",
          "name": "Limit",
          "type": "expression"
        },
        {
          "description": "Address that you wish to get owned ordinals of",
          "name": "Address",
          "type": "string"
        },
        {
          "description": "Variable to return result to",
          "name": "ReturnTo",
          "type": "variable"
        },
        {
          "description": "Offset of owned ordinals. Useful for Pageination",
          "name": "Offset",
          "type": "expression"
        }
      ],
      "objectGroups": []
    },
    {
      "async": true,
      "description": "Similar to \"Get the Ordinals that an address has\", exept you can specify a specific collection to only get ordinals from a specific collection.",
      "fullName": "Get the Ordinals that the specified address has in a specific collection",
      "functionType": "Action",
      "name": "Get_Owned_Ordinals_In_Collection_Action",
      "sentence": "Get _PARAM1_ ordinals from _PARAM2_ belonging to _PARAM3_ and return to _PARAM4_",
      "events": [
        {
          "type": "BuiltinCommonInstructions::JsCode",
          "inlineCode": [
            "const limit = eventsFunctionContext.getArgument('Limit');",
            "const collection = eventsFunctionContext.getArgument('Collection');",
            "const address = eventsFunctionContext.getArgument('Address');",
            "/** @type {gdjs.Variable} */",
            "const returnTo = eventsFunctionContext.getArgument('ReturnTo');",
            "const offset = eventsFunctionContext.getArgument('Offset');",
            "",
            "return new gdjs.PromiseTask(window.ord.getOwnedOrdinals(address, limit, offset, collection).then((origins) => {",
            "    returnTo.fromJSObject(origins);",
            "    eventsFunctionContext.task.resolve();",
            "}));"
          ],
          "parameterObjects": "",
          "useStrict": true,
          "eventsSheetExpanded": false
        }
      ],
      "parameters": [
        {
          "description": "Maximum amount of ordinal outpoints that will be returned",
          "name": "Limit",
          "type": "expression"
        },
        {
          "description": "The collection ID of the ordinals that will be returned",
          "name": "Collection",
          "type": "string"
        },
        {
          "description": "Address that you wish to get the owned ordinals of",
          "name": "Address",
          "type": "string"
        },
        {
          "description": "Array Variable that the outpoints will be returned to",
          "name": "ReturnTo",
          "type": "variable"
        },
        {
          "description": "Offset of owned ordinals. Useful for Pageination",
          "name": "Offset",
          "type": "expression"
        }
      ],
      "objectGroups": []
    }
  ],
  "eventsBasedBehaviors": [],
  "eventsBasedObjects": []
}