{
  "author": "Arthur Pacaud (arthuro555)",
  "category": "Advanced",
  "extensionNamespace": "",
  "fullName": "Sprite Snapshot",
  "gdevelopVersion": ">=5.5.222",
  "helpPath": "",
  "iconUrl": "data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0iVVRGLTgiPz48IURPQ1RZUEUgc3ZnIFBVQkxJQyAiLS8vVzNDLy9EVEQgU1ZHIDEuMS8vRU4iICJodHRwOi8vd3d3LnczLm9yZy9HcmFwaGljcy9TVkcvMS4xL0RURC9zdmcxMS5kdGQiPjxzdmcgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIiB4bWxuczp4bGluaz0iaHR0cDovL3d3dy53My5vcmcvMTk5OS94bGluayIgdmVyc2lvbj0iMS4xIiBpZD0ibWRpLWNhbWVyYS1lbmhhbmNlIiB3aWR0aD0iMjQiIGhlaWdodD0iMjQiIHZpZXdCb3g9IjAgMCAyNCAyNCI+PHBhdGggZD0iTTksM0w3LjE3LDVINEEyLDIgMCAwLDAgMiw3VjE5QTIsMiAwIDAsMCA0LDIxSDIwQTIsMiAwIDAsMCAyMiwxOVY3QTIsMiAwIDAsMCAyMCw1SDE2LjgzTDE1LDNNMTIsMThBNSw1IDAgMCwxIDcsMTNBNSw1IDAgMCwxIDEyLDhBNSw1IDAgMCwxIDE3LDEzQTUsNSAwIDAsMSAxMiwxOE0xMiwxN0wxMy4yNSwxNC4yNUwxNiwxM0wxMy4yNSwxMS43NUwxMiw5TDEwLjc1LDExLjc1TDgsMTNMMTAuNzUsMTQuMjUiIC8+PC9zdmc+",
  "name": "RenderToSprite",
  "previewIconUrl": "https://resources.gdevelop-app.com/assets/Icons/camera-enhance.svg",
  "shortDescription": "Renders an object, layer, scene or an area of a scene and puts the resulting image into a sprite.",
  "version": "0.0.6",
  "description": [
    "Allows rendering (creating an image) of objects, layers and the scene to display in a sprite. ",
    "This allows to make optimizations by transforming the resulting image of a shape painter into a faster sprite, or to make viewports/cameras."
  ],
  "origin": {
    "identifier": "RenderToSprite",
    "name": "gdevelop-extension-store"
  },
  "tags": [
    "experimental",
    "non-public apis",
    "visual",
    "sprite",
    "viewport",
    "camera",
    "render",
    "texture",
    "pixijs",
    "snapshot"
  ],
  "authorIds": [
    "ZgrsWuRTAkXgeuPV9bo0zuEcA2w1",
    "PEzPAaWHgYgk5UwIPppsL6f2ugp2",
    "nrasHJ5nmnWucadlqzx0EctTKZ73"
  ],
  "dependencies": [],
  "globalVariables": [],
  "sceneVariables": [],
  "eventsFunctions": [
    {
      "fullName": "",
      "functionType": "Action",
      "name": "onFirstSceneLoaded",
      "sentence": "",
      "events": [
        {
          "type": "BuiltinCommonInstructions::JsCode",
          "inlineCode": [
            "gdjs._renderToSprite = {};",
            "gdjs._renderToSprite.alertTriggered = false;",
            "gdjs._renderToSprite.rt = PIXI.RenderTexture.create({ width: 100, height: 100 });",
            "gdjs._renderToSprite.sprite = PIXI.Sprite.from(gdjs._renderToSprite.rt);",
            "gdjs._renderToSprite.snapshotCanvas = document.createElement('canvas');",
            "gdjs._renderToSprite.snapshotThreeRenderer = new THREE.WebGLRenderer({",
            "    canvas: gdjs._renderToSprite.snapshotCanvas,",
            "    antialias:",
            "        runtimeScene.getGame().getAntialiasingMode() !== 'none' &&",
            "        (runtimeScene.getGame().isAntialisingEnabledOnMobile() || !gdjs.evtTools.common.isMobile())",
            "});",
            "gdjs._renderToSprite.snapshotThreeRenderer.autoClear = false;",
            "gdjs._renderToSprite.snapshotThreeRenderer.setSize(100, 100);",
            "gdjs._renderToSprite.snapshotPixiRenderer = new PIXI.Renderer({",
            "    width: 100,",
            "    height: 100,",
            "    view: gdjs._renderToSprite.snapshotCanvas,",
            "    // @ts-ignore - reuse the context from Three.js.",
            "    context: gdjs._renderToSprite.snapshotThreeRenderer.getContext(),",
            "    clearBeforeRender: false,",
            "    preserveDrawingBuffer: true,",
            "    antialias: false,",
            "    backgroundAlpha: 0",
            "});",
            ""
          ],
          "parameterObjects": "",
          "useStrict": true,
          "eventsSheetExpanded": false
        }
      ],
      "parameters": [],
      "objectGroups": []
    },
    {
      "description": "Renders an object and puts the rendered image into a sprite object.",
      "fullName": "Render an object into a sprite",
      "functionType": "Action",
      "name": "RenderObject",
      "sentence": "Render _PARAM1_ into sprite _PARAM2_",
      "events": [
        {
          "type": "BuiltinCommonInstructions::JsCode",
          "inlineCode": [
            "/** @type {gdjs.RuntimeObject} */",
            "const sourceParam = eventsFunctionContext.getObjects(\"source\")[0];",
            "",
            "/** @type {gdjs.SpriteRuntimeObject} */",
            "const renderTargetParam = eventsFunctionContext.getObjects(\"renderTarget\")[0];",
            "",
            "let render3DClipWidth = eventsFunctionContext.getArgument(\"render3DClipWidth\");",
            "let render3DClipHeight = eventsFunctionContext.getArgument(\"render3DClipHeight\");",
            "",
            "if (sourceParam && renderTargetParam) {",
            "",
            "    if (sourceParam === renderTargetParam) {",
            "        if (!gdjs._renderToSprite.alertTriggered) {",
            "            const errString = 'Target Sprite and Object to render cannot be the same.';",
            "            gdjs._renderToSprite.alertTriggered = true;",
            "            console.log('ERROR: RenderToSprite.RenderObject(...) -> ' + errString);",
            "            alert('Error in RenderToSprite.RenderObject:\\n\\n    ' + errString);",
            "        }",
            "        return;",
            "    }",
            "    ",
            "    const source = (sourceParam instanceof gdjs.RuntimeObject3D ? ",
            "        sourceParam.get3DRendererObject() : sourceParam.getRendererObject());",
            "    const renderTarget = renderTargetParam.getRendererObject();",
            "",
            "    render3DClipWidth = (render3DClipWidth === null || render3DClipWidth === 0) ? 200 : render3DClipWidth;",
            "    render3DClipHeight = (render3DClipHeight === null || render3DClipHeight === 0) ? 200 : render3DClipHeight;",
            "",
            "    if (renderTargetParam instanceof gdjs.SpriteRuntimeObject && renderTargetParam._animator) {",
            "    ",
            "        const noAnimationFrames = ",
            "            (renderTargetParam._animator._animations === undefined || ",
            "             renderTargetParam._animator._animations.length === 0) ||",
            "            (renderTargetParam._animator._animations[0].directions === undefined || ",
            "             renderTargetParam._animator._animations[0].directions.length === 0) ||",
            "            (renderTargetParam._animator._animations[0].directions[0].frames === undefined || ",
            "             renderTargetParam._animator._animations[0].directions[0].frames.length === 0) ||",
            "            renderTargetParam._animator._animations[0].directions[0].frames[0].image === undefined;",
            "",
            "        if (noAnimationFrames) {",
            "            if (!gdjs._renderToSprite.alertTriggered) {",
            "                const errString = 'Target Sprite must contain a single textured animation frame.';",
            "                gdjs._renderToSprite.alertTriggered = true;",
            "                console.log('ERROR: RenderToSprite.RenderObject(...) -> ' + errString);",
            "                alert('Error in RenderToSprite.RenderObject:\\n\\n    ' + errString);",
            "            }",
            "            return;",
            "        }",
            "    }",
            "",
            "    const pixiRenderer = runtimeScene.getGame().getRenderer().getPIXIRenderer(); //PIXI.Renderer",
            "",
            "    if (sourceParam instanceof gdjs.RuntimeObject3D) {",
            "",
            "        // 3D Object Rendering",
            "",
            "        const layer = runtimeScene.getLayer(sourceParam.getLayer());",
            "        const layerRenderer = layer.getRenderer();",
            "        const threeCamera = layerRenderer.getThreeCamera();",
            "        const threeComposer = layerRenderer.getThreeEffectComposer();",
            "        const threeScene = layerRenderer.getThreeScene();",
            "",
            "        layerRenderer.show2DRenderingPlane(false);",
            "        ",
            "        // Cycle through all of the objects in the same layer as the target",
            "        // 3D Object. Store their original visibility values, and then make",
            "        // all but the target object invisible.",
            "",
            "        const objectsInLayer = layerRenderer._threeGroup.children;",
            "        const visibilityProps = {};",
            "        objectsInLayer.forEach(currObj => {",
            "            visibilityProps[currObj.uuid] = currObj.visible;",
            "            if (currObj.uuid !== source.uuid) {",
            "                currObj.visible = false;",
            "            } else {",
            "                currObj.visible = true;",
            "            }",
            "        });",
            "",
            "        // Get the full dimensions of the camera; this is the size we'll",
            "        // initially render to.",
            "",
            "        let cameraWidth = runtimeScene.getLayer(\"\").getCameraWidth();",
            "        let cameraHeight = runtimeScene.getLayer(\"\").getCameraHeight();",
            "  ",
            "        // Changing the 'z' value of the camera impacts the zoom factor",
            "        if (runtimeScene.getLayer(\"\").getCameraZ() !== 0) {",
            "            cameraWidth = cameraWidth * layerCameraZoom;",
            "            cameraHeight = cameraHeight * layerCameraZoom;",
            "        }",
            "",
            "        cameraWidth = Math.floor(cameraWidth);",
            "        cameraHeight = Math.floor(cameraHeight);",
            "",
            "        //Set the 3d object's position in the center",
            "        //of the scene.",
            "        ",
            "        const sceneCenterX = cameraWidth / 2;",
            "        const sceneCenterY = cameraHeight / 2;",
            "        const sourceCenterX = sourceParam.getCenterX();",
            "        const sourceCenterY = sourceParam.getCenterY();",
            "        const sourceX = sourceParam.getX();",
            "        const sourceY = sourceParam.getY();",
            "",
            "        sourceParam.setX(sceneCenterX - sourceCenterX);",
            "        sourceParam.setY(sceneCenterY - sourceCenterY);",
            "",
            "        // Prepare for render at full camera size.",
            "",
            "        runtimeScene._updateLayersPreRender();",
            "        runtimeScene._updateObjectsPreRender();",
            "",
            "        //Set the size of our initial render to full camera width/height",
            "",
            "        gdjs._renderToSprite.snapshotThreeRenderer.setSize(cameraWidth, cameraHeight);",
            "        gdjs._renderToSprite.snapshotPixiRenderer.resize(cameraWidth, cameraHeight);",
            "        gdjs._renderToSprite.snapshotPixiRenderer.reset();",
            "        gdjs._renderToSprite.snapshotThreeRenderer.resetState();",
            "",
            "        // Render the background color. Be sure to make the background color transparent.",
            "        ",
            "        gdjs._renderToSprite.snapshotThreeRenderer.setClearColor(runtimeScene.getBackgroundColor());",
            "        gdjs._renderToSprite.snapshotThreeRenderer.setClearAlpha(0.0);",
            "        gdjs._renderToSprite.snapshotThreeRenderer.resetState();",
            "        if (runtimeScene.getClearCanvas()) gdjs._renderToSprite.snapshotThreeRenderer.clear();",
            "        threeScene.background = null;",
            "",
            "        // Clear the depth as each layer is independent and display on top of the previous one, even 3D objects.",
            "        // SEE: RuntimeScenePixiRenderer",
            "",
            "        gdjs._renderToSprite.snapshotThreeRenderer.clearDepth();",
            "",
            "        if (layerRenderer.hasPostProcessingPass() && 'renderer' in threeComposer) {",
            "            ",
            "            //If there are any post processing effects, fake out the Effect Composer",
            "            //by temporarily setting its renderer to the snapshotThreeRenderer, so that",
            "            //the snapshot includes those effects.",
            "            ",
            "            const originalRenderer = threeComposer.renderer;",
            "            threeComposer.renderer = gdjs._renderToSprite.snapshotThreeRenderer;",
            "            threeComposer.render();",
            "            threeComposer.renderer = originalRenderer;",
            "            ",
            "        } else {",
            "            gdjs._renderToSprite.snapshotThreeRenderer.render(threeScene, threeCamera);",
            "        }",
            "",
            "        const snapshotSprite = PIXI.Sprite.from(gdjs._renderToSprite.snapshotCanvas);",
            "",
            "        // Calculate the new dimensions of the texture based on the pixels which ",
            "        // ARE NOT transparent.",
            "",
            "        /* const pixels = pixiRenderer.extract.pixels(snapshotSprite);",
            "",
            "        let minX = Infinity, minY = Infinity, maxX = 0, maxY = 0;",
            "        for (let y = 0; y < cameraHeight; y++) {",
            "            for (let x = 0; x < cameraWidth; x++) {",
            "                const idx = (y * cameraWidth + x) * 4;",
            "                const alpha = pixels[idx + 3];",
            "                if (alpha > 0) {",
            "                    minX = Math.min(minX, x);",
            "                    minY = Math.min(minY, y);",
            "                    maxX = Math.max(maxX, x);",
            "                    maxY = Math.max(maxY, y);",
            "                }",
            "            }",
            "        } */",
            "",
            "        /* if (minX < maxX && minY < maxY) { */",
            "",
            "            // Resize the target textures to the size of the clipped sprite.",
            "            ",
            "            /* const frame = new PIXI.Rectangle(minX, minY, maxX - minX + 1, maxY - minY + 1); */",
            "            ",
            "            const newX = Math.floor(sceneCenterX - (render3DClipWidth/2));",
            "            const newY = Math.floor(sceneCenterY - (render3DClipHeight/2));",
            "            snapshotSprite.x = -newX;",
            "            snapshotSprite.y = -newY;",
            "            ",
            "            gdjs._renderToSprite.rt.resize(render3DClipWidth, render3DClipHeight);",
            "            if (renderTarget.texture instanceof PIXI.RenderTexture) {",
            "                renderTarget.texture.resize(render3DClipWidth, render3DClipHeight);",
            "            } else {",
            "                renderTarget.texture = PIXI.RenderTexture.create({",
            "                    width: render3DClipWidth,",
            "                    height: render3DClipHeight,",
            "                    scaleMode: runtimeScene.getGame().getScaleMode() === \"linear\"",
            "                        ? PIXI.SCALE_MODES.LINEAR",
            "                        : PIXI.SCALE_MODES.NEAREST",
            "                });",
            "            }",
            "",
            "            pixiRenderer.render(snapshotSprite, {clear: true, renderTexture: gdjs._renderToSprite.rt });",
            "        ",
            "            // Actually render",
            "            pixiRenderer.render(gdjs._renderToSprite.sprite, {clear: true, renderTexture: renderTarget.texture });",
            "",
            "        /* } */",
            "",
            "        //Reset the 3d object's position",
            "        ",
            "        sourceParam.setX(sourceX);",
            "        sourceParam.setY(sourceY);",
            "",
            "        //Destroy the temporary snapshot sprite, reset object visibiity, and return the",
            "        //scene's background color to its original value.",
            "",
            "        snapshotSprite.destroy({ children: true, texture: true, baseTexture: true });",
            "        objectsInLayer.forEach(currObj => {currObj.visible = visibilityProps[currObj.uuid];});",
            "        threeScene.background = new THREE.Color(runtimeScene.getBackgroundColor());",
            "        gdjs._renderToSprite.snapshotThreeRenderer.setClearColor(runtimeScene.getBackgroundColor());",
            "",
            "    } else {",
            "        ",
            "        // 2D Object Rendering",
            "",
            "        const position = source.position;",
            "        const bounds = source.getLocalBounds();",
            "        const originalX = position.x; const originalY = position.y;",
            "        const x = bounds.x; const y = bounds.y; const width = bounds.width; const height = bounds.height;",
            "        source.position = { x: -x, y: -y };",
            "",
            "        if (renderTarget.texture instanceof PIXI.RenderTexture) {",
            "            renderTarget.texture.resize(width, height);",
            "        } else {",
            "            renderTarget.texture = PIXI.RenderTexture.create({",
            "            width: width,",
            "            height: height,",
            "            scaleMode: runtimeScene.getGame().getScaleMode() === \"linear\"",
            "              ? PIXI.SCALE_MODES.LINEAR",
            "              : PIXI.SCALE_MODES.NEAREST",
            "            });",
            "        }",
            "",
            "        pixiRenderer.background.color = runtimeScene.getBackgroundColor();",
            "        pixiRenderer.background.alpha = 1;",
            "        if (runtimeScene.getClearCanvas()) pixiRenderer.clear();",
            "",
            "        pixiRenderer.render(source, { clear: true, renderTexture: renderTarget.texture });",
            "",
            "        // Restore original position",
            "        source.position = { x: originalX, y: originalY };",
            "",
            "    }",
            "",
            "    // Ensure the original width/height is restored",
            "    renderTarget.width = renderTargetParam.getWidth();",
            "    renderTarget.height = renderTargetParam.getHeight();",
            "    gdjs._renderToSprite.alertTriggered = false;",
            "",
            "} else {",
            "    if (!gdjs._renderToSprite.alertTriggered) {",
            "        gdjs._renderToSprite.alertTriggered = true;",
            "        const paramName = (sourceParam ? 'RenderTarget' : 'Source')",
            "        const errString = 'Passed-in object reference (' + paramName +') is empty.'",
            "        console.log('ERROR: RenderToSprite.RenderObject(...) -> ' + errString);",
            "        alert('Error in RenderToSprite.RenderObject:\\n\\n    ' + errString);",
            "    }",
            "}",
            ""
          ],
          "parameterObjects": "",
          "useStrict": true,
          "eventsSheetExpanded": true
        }
      ],
      "parameters": [
        {
          "description": "The object to render",
          "name": "source",
          "type": "objectList"
        },
        {
          "description": "The sprite to render to",
          "name": "renderTarget",
          "supplementaryInformation": "Sprite",
          "type": "objectList"
        },
        {
          "description": "Clip width for 3D render (Default: 200px)",
          "name": "render3DClipWidth",
          "type": "expression"
        },
        {
          "description": "Clip height for 3D render (Default: 200px)",
          "name": "render3DClipHeight",
          "type": "expression"
        }
      ],
      "objectGroups": []
    },
    {
      "description": "Renders a layer and puts the rendered image into a sprite object.\n\nNOTE: The layer being rendered CANNOT contain the target sprite.",
      "fullName": "Render a layer into a sprite",
      "functionType": "Action",
      "name": "RenderLayer",
      "sentence": "Render layer _PARAM1_ into sprite _PARAM2_",
      "events": [
        {
          "type": "BuiltinCommonInstructions::JsCode",
          "inlineCode": [
            "/** @type {gdjs.Layer} */",
            "const layer = runtimeScene.getLayer(eventsFunctionContext.getArgument(\"layer\"));",
            "",
            "/** @type {gdjs.SpriteRuntimeObject} */",
            "const obj = objects[0];",
            "",
            "if (layer && obj) {",
            "",
            "    /** @type {PIXI.Sprite} */",
            "    const renderTarget = obj.getRendererObject();",
            "",
            "    if (obj._animator) {",
            "    ",
            "        const noAnimationFrames = ",
            "            (obj._animator._animations === undefined || obj._animator._animations.length === 0) ||",
            "            (obj._animator._animations[0].directions === undefined || ",
            "             obj._animator._animations[0].directions.length === 0) ||",
            "            (obj._animator._animations[0].directions[0].frames === undefined || ",
            "             obj._animator._animations[0].directions[0].frames.length === 0) ||",
            "            obj._animator._animations[0].directions[0].frames[0].image === undefined;",
            "",
            "        if (noAnimationFrames) {",
            "            if (!gdjs._renderToSprite.alertTriggered) {",
            "                const errString = 'Target Sprite must contain a single textured animation frame.';",
            "                gdjs._renderToSprite.alertTriggered = true;",
            "                console.log('ERROR: RenderToSprite.RenderLayer(...) -> ' + errString);",
            "                alert('Error in RenderToSprite.RenderLayer:\\n\\n    ' + errString);",
            "            }",
            "            return;",
            "        }",
            "    }",
            "",
            "    const layerRenderer = layer.getRenderer(); //gdjs.LayerPixiRenderer",
            "    const pixiRenderer = runtimeScene.getGame().getRenderer().getPIXIRenderer(); //PIXI.Renderer",
            "",
            "    const layerCameraZoom = layer.getCameraZoom();",
            "    const layerHas2DObjects = layerRenderer.has2DObjects();",
            "    const layerHas3DObjects = layerRenderer.has3DObjects();",
            "",
            "    let cameraWidth = runtimeScene.getLayer(\"\").getCameraWidth();",
            "    let cameraHeight = runtimeScene.getLayer(\"\").getCameraHeight();",
            "  ",
            "    // Changing the 'z' value of the camera impacts the zoom factor",
            "    if (runtimeScene.getLayer(\"\").getCameraZ() !== 0) {",
            "        cameraWidth = cameraWidth * layerCameraZoom;",
            "        cameraHeight = cameraHeight * layerCameraZoom;",
            "    }",
            "",
            "    cameraWidth = Math.floor(cameraWidth);",
            "    cameraHeight = Math.floor(cameraHeight);",
            "",
            "    // Prepare for render",
            "    runtimeScene._updateLayersPreRender();",
            "    runtimeScene._updateObjectsPreRender();",
            "",
            "    // Ensure the target is a RenderTexture of the correct size",
            "    gdjs._renderToSprite.rt.resize(cameraWidth, cameraHeight);",
            "    if (renderTarget.texture instanceof PIXI.RenderTexture) {",
            "        renderTarget.texture.resize(cameraWidth, cameraHeight);",
            "    } else {",
            "        renderTarget.texture = PIXI.RenderTexture.create({",
            "            width: cameraWidth,",
            "            height: cameraHeight,",
            "            scaleMode: runtimeScene.getGame().getScaleMode() === \"linear\"",
            "                ? PIXI.SCALE_MODES.LINEAR",
            "                : PIXI.SCALE_MODES.NEAREST",
            "        });",
            "    }",
            "    ",
            "    const renderTargetIndex = layerRenderer.getRendererObject().children.findIndex(",
            "        currChild => currChild === renderTarget",
            "    );",
            "    if (renderTargetIndex >= 0) {",
            "        renderTarget.width = obj.getWidth();",
            "        renderTarget.height = obj.getHeight();",
            "        if (!gdjs._renderToSprite.alertTriggered) {",
            "            gdjs._renderToSprite.alertTriggered = true;",
            "            console.log('ERROR: RenderToSprite.RenderLayer(...) -> Layer to render contains target Sprite.');",
            "            alert('Error in RenderToSprite.RenderLayer:\\n\\n    Layer to render contains target Sprite.');",
            "        }",
            "        return;",
            "    }",
            "",
            "    let lastRenderWas3D = true;",
            "    const layerRenderingType = layer.getRenderingType();",
            "    ",
            "    if (layerRenderingType === gdjs.RuntimeLayerRenderingType.TWO_D || !layerHas3DObjects) {",
            "        ",
            "        // Render a layer with 2D rendering (PixiJS) only if layer is configured as is",
            "        // or if there is no 3D object to render.",
            "",
            "        // Ensure the state is clean for PixiJS to render.",
            "        pixiRenderer.reset();",
            "",
            "        pixiRenderer.background.color = runtimeScene.getBackgroundColor();",
            "        pixiRenderer.background.alpha = 1;",
            "",
            "        if (runtimeScene.getClearCanvas()) pixiRenderer.clear();",
            "",
            "        if (layer.isLightingLayer()) {",
            "            // Render the lights on the render texture used then by the lighting Sprite.",
            "            layerRenderer.renderOnPixiRenderTexture(pixiRenderer);",
            "        }",
            "",
            "        // TODO (2d lights): refactor to remove the need for `getLightingSprite`.",
            "        const pixiContainer = ",
            "            (layer.isLightingLayer() && ",
            "             layerRenderer.getLightingSprite()) || layerRenderer.getRendererObject();",
            "",
            "        pixiRenderer.render(pixiContainer, {clear: true, renderTexture: gdjs._renderToSprite.rt });",
            "        pixiRenderer.render(gdjs._renderToSprite.sprite, ",
            "            { clear: true, renderTexture: renderTarget.texture });",
            "    ",
            "    } else {",
            "    ",
            "        const threeScene = layerRenderer.getThreeScene(); //THREE.Scene",
            "        const threeCamera = layerRenderer.getThreeCamera(); //THREE.PerspectiveCamera | THREE.OrthographicCamera",
            "        const threeComposer = layerRenderer.getThreeEffectComposer(); //THREE.EffectComposer",
            "        ",
            "        gdjs._renderToSprite.snapshotThreeRenderer.setSize(cameraWidth, cameraHeight);",
            "        gdjs._renderToSprite.snapshotPixiRenderer.resize(cameraWidth, cameraHeight);",
            "        ",
            "        // Render the 3D objects of this layer.",
            "        if (threeScene && threeCamera && threeComposer) {",
            "        ",
            "            // TODO (3D) - optimization: do this at the beginning for all layers that are 2d+3d?",
            "            // So the second pass is clearer (just rendering 2d or 3d layers without doing PixiJS ",
            "            // renders in between).",
            "            ",
            "            if (layerRenderingType === gdjs.RuntimeLayerRenderingType.TWO_D_PLUS_THREE_D) {",
            "        ",
            "                if (layerHas2DObjects) {",
            "                ",
            "                    gdjs._renderToSprite.snapshotThreeRenderer.resetState();",
            "                    gdjs._renderToSprite.snapshotPixiRenderer.reset();",
            "",
            "                    // Do the rendering of the PixiJS objects of the layer on the render texture.",
            "                    // Then, update the texture of the plane showing the PixiJS rendering,",
            "                    // so that the 2D rendering made by PixiJS can be shown in the 3D world.",
            "",
            "                    layerRenderer.renderOnPixiRenderTexture(gdjs._renderToSprite.snapshotPixiRenderer);",
            "                    layerRenderer.updateThreePlaneTextureFromPixiRenderTexture(",
            "                        gdjs._renderToSprite.snapshotThreeRenderer,",
            "                        gdjs._renderToSprite.snapshotPixiRenderer);",
            "                        ",
            "                    lastRenderWas3D = false;",
            "                }",
            "                ",
            "                layerRenderer.show2DRenderingPlane(layerHas2DObjects);",
            "            }",
            "",
            "            if (!lastRenderWas3D) {",
            "                //It's important to reset the internal WebGL state of PixiJS, then Three.js",
            "                // to ensure the 3D rendering is made properly by Three.js",
            "                gdjs._renderToSprite.snapshotPixiRenderer.reset();",
            "                gdjs._renderToSprite.snapshotThreeRenderer.resetState();",
            "            }",
            "",
            "            // Render the background color.",
            "            gdjs._renderToSprite.snapshotThreeRenderer.setClearColor(runtimeScene.getBackgroundColor());",
            "            gdjs._renderToSprite.snapshotThreeRenderer.resetState();",
            "            if (runtimeScene.getClearCanvas()) gdjs._renderToSprite.snapshotThreeRenderer.clear();",
            "            threeScene.background = new THREE.Color(runtimeScene.getBackgroundColor());",
            "",
            "            // Clear the depth as each layer is independent and display on top of the previous one, even 3D objects.",
            "            // SEE: RuntimeScenePixiRenderer",
            "            ",
            "            gdjs._renderToSprite.snapshotThreeRenderer.clearDepth();",
            "",
            "            if (layerRenderer.hasPostProcessingPass() && 'renderer' in threeComposer) {",
            "                ",
            "                //If there are any post processing effects, fake out the Effect Composer",
            "                //by temporarily setting its renderer to the snapshotThreeRenderer, so that",
            "                //the snapshot includes those effects.",
            "                ",
            "                const originalRenderer = threeComposer.renderer;",
            "                threeComposer.renderer = gdjs._renderToSprite.snapshotThreeRenderer;",
            "                threeComposer.render();",
            "                threeComposer.renderer = originalRenderer;",
            "                ",
            "            } else {",
            "                gdjs._renderToSprite.snapshotThreeRenderer.render(threeScene, threeCamera);",
            "            }",
            "    ",
            "            // Prerender to a temporary texture to prevent WebGL erroring out.",
            "            // See https://www.html5gamedevs.com/topic/45423-why-is-this-not-allowed/    ",
            "            const snapshotSprite = PIXI.Sprite.from(gdjs._renderToSprite.snapshotCanvas);",
            "            pixiRenderer.render(snapshotSprite, { clear: true, renderTexture: gdjs._renderToSprite.rt });",
            "",
            "            // Actually render",
            "            pixiRenderer.render(gdjs._renderToSprite.sprite, { clear: true, renderTexture: renderTarget.texture });",
            "",
            "            snapshotSprite.destroy({ children: true, texture: true, baseTexture: true });",
            "            ",
            "        }",
            "    }",
            "",
            "    // Ensure the original width/height is restored",
            "    renderTarget.width = obj.getWidth();",
            "    renderTarget.height = obj.getHeight();",
            "    gdjs._renderToSprite.alertTriggered = false;",
            "",
            "} else {",
            "    if (!gdjs._renderToSprite.alertTriggered) {",
            "        gdjs._renderToSprite.alertTriggered = true;",
            "        const paramName = (layer ? 'Sprite' : 'Layer')",
            "        const errString = 'Passed-in object reference (' + paramName +') is empty.'",
            "        console.log('ERROR: RenderToSprite.RenderLayer(...) -> ' + errString);",
            "        alert('Error in RenderToSprite.RenderLayer:\\n\\n    ' + errString);",
            "    }",
            "}"
          ],
          "parameterObjects": "renderTarget",
          "useStrict": true,
          "eventsSheetExpanded": true
        },
        {
          "type": "BuiltinCommonInstructions::Standard",
          "conditions": [],
          "actions": []
        }
      ],
      "parameters": [
        {
          "description": "The layer to render",
          "name": "layer",
          "supplementaryInformation": "Sprite",
          "type": "layer"
        },
        {
          "description": "The sprite to render to (should be placed in its own layer, or in a layer with other snapshot sprites)",
          "name": "renderTarget",
          "supplementaryInformation": "Sprite",
          "type": "objectList"
        }
      ],
      "objectGroups": []
    },
    {
      "description": "Renders a scene and puts the rendered image into a sprite object.\n\nNOTE: The layer containing the target sprite WILL NOT be rendered into the snapshot.",
      "fullName": "Render a scene into a sprite",
      "functionType": "Action",
      "name": "RenderScene",
      "sentence": "Render the current scene into sprite _PARAM1_",
      "events": [
        {
          "type": "BuiltinCommonInstructions::JsCode",
          "inlineCode": [
            "/** @type {gdjs.SpriteRuntimeObject} */",
            "const obj = objects[0];",
            "",
            "if (obj) {",
            "",
            "    /** @type {PIXI.Sprite} */",
            "    const renderTarget = obj.getRendererObject();",
            "",
            "    if (obj._animator) {",
            "",
            "        // Check to see if the target sprite has a single animation frame/texture.",
            "      ",
            "        const noAnimationFrames = ",
            "          (obj._animator._animations === undefined || obj._animator._animations.length === 0) ||",
            "          (obj._animator._animations[0].directions === undefined || ",
            "            obj._animator._animations[0].directions.length === 0) ||",
            "          (obj._animator._animations[0].directions[0].frames === undefined || ",
            "            obj._animator._animations[0].directions[0].frames.length === 0) ||",
            "          obj._animator._animations[0].directions[0].frames[0].image === undefined;",
            "",
            "        if (noAnimationFrames) {",
            "            if (!gdjs._renderToSprite.alertTriggered) {",
            "                const errString = 'Target Sprite must contain a single textured animation frame.';",
            "                gdjs._renderToSprite.alertTriggered = true;",
            "                console.log('ERROR: RenderToSprite.RenderScene(...) -> ' + errString);",
            "                alert('Error in RenderToSprite.RenderScene:\\n\\n    ' + errString);",
            "            }",
            "            return;",
            "        }",
            "    }",
            "",
            "    const sceneRenderer = runtimeScene.getRenderer(); //gdjs.RuntimeScenePixiRenderer",
            "    const gameRenderer = runtimeScene.getGame().getRenderer(); //gdjs.RuntimeGamePixiRenderer",
            "    const pixiRenderer = gameRenderer.getPIXIRenderer(); //PIXI.Renderer",
            "    const layerCameraZoom = runtimeScene.getLayer(\"\").getCameraZoom();",
            "",
            "    let cameraWidth = runtimeScene.getLayer(\"\").getCameraWidth();",
            "    let cameraHeight = runtimeScene.getLayer(\"\").getCameraHeight();",
            "",
            "",
            "    // Changing the 'z' value of the camera impacts the zoom factor",
            "",
            "    if (runtimeScene.getLayer(\"\").getCameraZ() !== 0) { ",
            "        cameraWidth = cameraWidth * layerCameraZoom;",
            "        cameraHeight = cameraHeight * layerCameraZoom;",
            "    }",
            "",
            "    cameraWidth = Math.floor(cameraWidth);",
            "    cameraHeight = Math.floor(cameraHeight);",
            "    ",
            "    // Prepare for render",
            "    runtimeScene._updateLayersPreRender();",
            "    runtimeScene._updateObjectsPreRender();",
            "",
            "    // Ensure the target is a RenderTexture of the correct size",
            "    gdjs._renderToSprite.rt.resize(cameraWidth, cameraHeight);",
            "",
            "    if (renderTarget.texture instanceof PIXI.RenderTexture) {",
            "        renderTarget.texture.resize(cameraWidth, cameraHeight);",
            "    } else {",
            "        renderTarget.texture = PIXI.RenderTexture.create({",
            "            width: cameraWidth,",
            "            height: cameraHeight,",
            "            scaleMode: runtimeScene.getGame().getScaleMode() === \"linear\"",
            "              ? PIXI.SCALE_MODES.LINEAR",
            "              : PIXI.SCALE_MODES.NEAREST",
            "        });",
            "    }",
            "       ",
            "    // Layered 2D, 3D or 2D+3D rendering.",
            "    gdjs._renderToSprite.snapshotThreeRenderer.info.autoReset = false;",
            "    gdjs._renderToSprite.snapshotThreeRenderer.info.reset();",
            "",
            "    /** Useful to render the background color. */",
            "    let isFirstRender = true;",
            "",
            "    /**",
            "    * true if the last layer rendered 3D objects using Three.js, false otherwise.",
            "    * Useful to avoid needlessly resetting the WebGL states between layers (which can be expensive).",
            "    */",
            "    let lastRenderWas3D = true;",
            "",
            "    // Even if no rendering at all has been made already, setting up the Three.js/PixiJS renderers",
            "    // might have changed some WebGL states already. Reset the state for the very first frame.",
            "    // And, out of caution, keep doing it for every frame.",
            "    // TODO (3D): optimization - check if this can be done only on the very first frame.",
            "    gdjs._renderToSprite.snapshotThreeRenderer.resetState();",
            "    gdjs._renderToSprite.snapshotPixiRenderer.reset();",
            "    pixiRenderer.reset();",
            "",
            "    // Render each layer one by one.",
            "",
            "    for (let i = 0; i < runtimeScene._orderedLayers.length; ++i) {",
            "        ",
            "        const runtimeLayer = runtimeScene._orderedLayers[i];",
            "        ",
            "        if (!runtimeLayer.isVisible()) continue;",
            "        ",
            "        const runtimeLayerRenderer = runtimeLayer.getRenderer();",
            "        const runtimeLayerRenderingType = runtimeLayer.getRenderingType();",
            "        const layerHas3DObjectsToRender = runtimeLayerRenderer.has3DObjects();",
            "        ",
            "        const renderTargetIndex = runtimeLayerRenderer.getRendererObject().children.findIndex(",
            "            currChild => currChild === renderTarget",
            "        );",
            "        if (renderTargetIndex >= 0) continue;",
            "",
            "        if (runtimeLayerRenderingType === gdjs.RuntimeLayerRenderingType.TWO_D || !layerHas3DObjectsToRender) {",
            "        ",
            "            // Render a layer with 2D rendering (PixiJS) only if layer is configured as is",
            "            // or if there is no 3D object to render.",
            "",
            "            if (lastRenderWas3D) {",
            "                // Ensure the state is clean for PixiJS to render.",
            "                pixiRenderer.reset();",
            "            }",
            "",
            "            if (isFirstRender) {",
            "                pixiRenderer.background.color = runtimeScene.getBackgroundColor();",
            "                pixiRenderer.background.alpha = 1;",
            "                if (runtimeScene.getClearCanvas()) pixiRenderer.clear();",
            "            }",
            "",
            "            if (runtimeLayer.isLightingLayer()) {",
            "                // Render the lights on the render texture used then by the lighting Sprite.",
            "                runtimeLayerRenderer.renderOnPixiRenderTexture(pixiRenderer);",
            "            }",
            "",
            "            // TODO (2d lights): refactor to remove the need for `getLightingSprite`.",
            "            const pixiContainer = ",
            "                (runtimeLayer.isLightingLayer() && ",
            "                runtimeLayerRenderer.getLightingSprite()) || runtimeLayerRenderer.getRendererObject();",
            "",
            "            pixiRenderer.render(pixiContainer, {clear: true, renderTexture: gdjs._renderToSprite.rt });",
            "            pixiRenderer.render(gdjs._renderToSprite.sprite, ",
            "                { clear: isFirstRender, renderTexture: renderTarget.texture });",
            "",
            "            lastRenderWas3D = false;",
            "            isFirstRender = false;",
            "        ",
            "        } else {",
            "        ",
            "            // Render a layer with 3D rendering, and possibly some 2D rendering too.",
            "            ",
            "            const threeScene = runtimeLayerRenderer.getThreeScene();",
            "            const threeCamera = runtimeLayerRenderer.getThreeCamera();",
            "            const threeEffectComposer = runtimeLayerRenderer.getThreeEffectComposer();",
            "",
            "            gdjs._renderToSprite.snapshotThreeRenderer.setSize(cameraWidth, cameraHeight);",
            "            gdjs._renderToSprite.snapshotPixiRenderer.resize(cameraWidth, cameraHeight);",
            "",
            "            // Render the 3D objects of this layer.",
            "            if (threeScene && threeCamera && threeEffectComposer) {",
            "        ",
            "                // TODO (3D) - optimization: do this at the beginning for all layers that are 2d+3d?",
            "                // So the second pass is clearer (just rendering 2d or 3d layers without doing PixiJS ",
            "                //renders in between).",
            "            ",
            "                if (runtimeLayerRenderingType === gdjs.RuntimeLayerRenderingType.TWO_D_PLUS_THREE_D) {",
            "            ",
            "                    const layerHas2DObjectsToRender = runtimeLayerRenderer.has2DObjects();",
            "",
            "                    if (layerHas2DObjectsToRender) {",
            "                    ",
            "                        if (lastRenderWas3D) {",
            "                            // Ensure the state is clean for PixiJS to render.",
            "                            gdjs._renderToSprite.snapshotThreeRenderer.resetState();",
            "                            gdjs._renderToSprite.snapshotPixiRenderer.reset();",
            "                        }",
            "",
            "                        // Do the rendering of the PixiJS objects of the layer on the render texture.",
            "                        // Then, update the texture of the plane showing the PixiJS rendering,",
            "                        // so that the 2D rendering made by PixiJS can be shown in the 3D world.",
            "                        ",
            "                        runtimeLayerRenderer.renderOnPixiRenderTexture(gdjs._renderToSprite.snapshotPixiRenderer);",
            "                        runtimeLayerRenderer.",
            "                            updateThreePlaneTextureFromPixiRenderTexture(",
            "                            gdjs._renderToSprite.snapshotThreeRenderer, ",
            "                            gdjs._renderToSprite.snapshotPixiRenderer);",
            "",
            "                        lastRenderWas3D = false;",
            "                    }",
            "            ",
            "                    runtimeLayerRenderer.show2DRenderingPlane(layerHas2DObjectsToRender);",
            "                }",
            "",
            "                if (!lastRenderWas3D) {",
            "                    // It's important to reset the internal WebGL state of PixiJS, then Three.js",
            "                    // to ensure the 3D rendering is made properly by Three.js",
            "                    gdjs._renderToSprite.snapshotThreeRenderer.resetState();",
            "                    gdjs._renderToSprite.snapshotPixiRenderer.reset();",
            "                }",
            "",
            "                if (isFirstRender) {",
            "                ",
            "                    // Render the background color.",
            "                    gdjs._renderToSprite.snapshotThreeRenderer.setClearColor(runtimeScene.getBackgroundColor());",
            "                    gdjs._renderToSprite.snapshotThreeRenderer.resetState();",
            "                    ",
            "                    if (runtimeScene.getClearCanvas()) gdjs._renderToSprite.snapshotThreeRenderer.clear();",
            "                    threeScene.background = new THREE.Color(runtimeScene.getBackgroundColor());",
            "                    ",
            "                } else {",
            "                    // It's important to set the background to null, as maybe the first rendered",
            "                    // layer has changed and so the Three.js scene background must be reset.",
            "                    if (runtimeScene.getClearCanvas()) gdjs._renderToSprite.snapshotThreeRenderer.clear();",
            "                    threeScene.background = null;",
            "                }",
            "",
            "                // Clear the depth as each layer is independent and display on top of the previous one,",
            "                // even 3D objects.",
            "                gdjs._renderToSprite.snapshotThreeRenderer.clearDepth();",
            "            ",
            "                if (runtimeLayerRenderer.hasPostProcessingPass() && 'renderer' in threeEffectComposer) {",
            "                    //If there are any post processing effects, fake out the Effect Composer",
            "                    //by temporarily setting its renderer to the snapshotThreeRenderer, so that",
            "                    //the snapshot includes those effects.",
            "                    const originalRenderer = threeEffectComposer.renderer;",
            "                    threeEffectComposer.renderer = gdjs._renderToSprite.snapshotThreeRenderer;",
            "                    threeEffectComposer.render();",
            "                    threeEffectComposer.renderer = originalRenderer;",
            "                } else {",
            "                    gdjs._renderToSprite.snapshotThreeRenderer.render(threeScene, threeCamera);",
            "                }",
            "            ",
            "                // Prerender to a temporary texture to prevent WebGL erroring out.",
            "                // See https://www.html5gamedevs.com/topic/45423-why-is-this-not-allowed/",
            "                const snapshotSprite = PIXI.Sprite.from(gdjs._renderToSprite.snapshotCanvas);",
            "                pixiRenderer.render(snapshotSprite, {clear: true, renderTexture: gdjs._renderToSprite.rt });",
            "        ",
            "                // Actually render",
            "                pixiRenderer.render(gdjs._renderToSprite.sprite, ",
            "                    {clear: isFirstRender, renderTexture: renderTarget.texture });",
            "",
            "                snapshotSprite.destroy({ children: true, texture: true, baseTexture: true });",
            "",
            "                lastRenderWas3D = true;",
            "                isFirstRender = false;",
            "            }",
            "",
            "        }",
            "",
            "    } // END OF LAYER LOOP",
            "    ",
            "    // Ensure the original width/height is restored",
            "    renderTarget.width = obj.getWidth();",
            "    renderTarget.height = obj.getHeight();",
            "    gdjs._renderToSprite.alertTriggered = false;",
            "  ",
            "} else {",
            "    if (!gdjs._renderToSprite.alertTriggered) {",
            "        gdjs._renderToSprite.alertTriggered = true;",
            "        console.log('ERROR: RenderToSprite.RenderScene(...) -> Passed-in object reference (Sprite) is empty.');",
            "        alert('Error in RenderToSprite.RenderScene:\\n\\n    Passed-in object reference (Sprite) is empty.');",
            "    }",
            "}"
          ],
          "parameterObjects": "renderTarget",
          "useStrict": true,
          "eventsSheetExpanded": true
        },
        {
          "type": "BuiltinCommonInstructions::Standard",
          "conditions": [],
          "actions": []
        }
      ],
      "parameters": [
        {
          "description": "The sprite to render to (should be placed in its own layer, or in a layer with other snapshot sprites)",
          "name": "renderTarget",
          "supplementaryInformation": "Sprite",
          "type": "objectList"
        }
      ],
      "objectGroups": []
    },
    {
      "description": "Renders a defined area of a scene and puts the rendered image into a sprite object.\n\nNOTE: The layer containing the target sprite WILL NOT be rendered into the snapshot.",
      "fullName": "Render an area of a scene into a sprite",
      "functionType": "Action",
      "name": "RenderSceneArea",
      "sentence": "Render the area of a current scene into Sprite: _PARAM1_, from OriginX: _PARAM2_, OriginY: _PARAM3_, with Width: _PARAM4_, Height: _PARAM5_",
      "events": [
        {
          "type": "BuiltinCommonInstructions::JsCode",
          "inlineCode": [
            "/** @type {gdjs.SpriteRuntimeObject} */",
            "const obj = objects[0];",
            "",
            "if (obj) {",
            "",
            "    /** @type {PIXI.Sprite} */",
            "    const renderTarget = obj.getRendererObject();",
            "",
            "    if (obj._animator) {",
            "",
            "        // Check to see if the target sprite has a single animation frame/texture.",
            "      ",
            "        const noAnimationFrames = ",
            "          (obj._animator._animations === undefined || obj._animator._animations.length === 0) ||",
            "          (obj._animator._animations[0].directions === undefined || ",
            "            obj._animator._animations[0].directions.length === 0) ||",
            "          (obj._animator._animations[0].directions[0].frames === undefined || ",
            "            obj._animator._animations[0].directions[0].frames.length === 0) ||",
            "          obj._animator._animations[0].directions[0].frames[0].image === undefined;",
            "",
            "        if (noAnimationFrames) {",
            "            if (!gdjs._renderToSprite.alertTriggered) {",
            "                const errString = 'Target Sprite must contain a single textured animation frame.';",
            "                gdjs._renderToSprite.alertTriggered = true;",
            "                console.log('ERROR: RenderToSprite.RenderSceneArea(...) -> ' + errString);",
            "                alert('Error in RenderToSprite.RenderSceneArea:\\n\\n    ' + errString);",
            "            }",
            "            return;",
            "        }",
            "    }",
            "",
            "    const sceneRenderer = runtimeScene.getRenderer(); //gdjs.RuntimeScenePixiRenderer",
            "    const gameRenderer = runtimeScene.getGame().getRenderer(); //gdjs.RuntimeGamePixiRenderer",
            "    const pixiRenderer = gameRenderer.getPIXIRenderer(); //PIXI.Renderer",
            "    const layerCameraZoom = runtimeScene.getLayer(\"\").getCameraZoom();",
            "    const xParam = Math.abs(eventsFunctionContext.getArgument(\"originPositionX\")) * -1;",
            "    const yParam = Math.abs(eventsFunctionContext.getArgument(\"originPositionY\")) * -1;",
            "    let widthParam = eventsFunctionContext.getArgument(\"areaWidth\");",
            "    let heightParam = eventsFunctionContext.getArgument(\"areaHeight\");",
            "",
            "    widthParam = (widthParam <= 0 ? 1 : widthParam);",
            "    heightParam = (heightParam <= 0 ? 1 : heightParam);",
            "    ",
            "    // Prepare for render",
            "    runtimeScene._updateLayersPreRender();",
            "    runtimeScene._updateObjectsPreRender();",
            "",
            "    // Ensure the target is a RenderTexture of the correct size",
            "    gdjs._renderToSprite.rt.resize(widthParam, heightParam);",
            "",
            "    if (renderTarget.texture instanceof PIXI.RenderTexture) {",
            "        renderTarget.texture.resize(widthParam, heightParam);",
            "    } else {",
            "        renderTarget.texture = PIXI.RenderTexture.create({",
            "            width: widthParam,",
            "            height: heightParam,",
            "            scaleMode: runtimeScene.getGame().getScaleMode() === \"linear\"",
            "              ? PIXI.SCALE_MODES.LINEAR",
            "              : PIXI.SCALE_MODES.NEAREST",
            "        });",
            "    }",
            "    ",
            "    // The initial render should be full-sized",
            "    let cameraWidth = runtimeScene.getLayer(\"\").getCameraWidth();",
            "    let cameraHeight = runtimeScene.getLayer(\"\").getCameraHeight();",
            "",
            "    // Changing the 'z' value of the camera impacts the zoom factor",
            "    if (runtimeScene.getLayer(\"\").getCameraZ() !== 0) { ",
            "        cameraWidth = cameraWidth * layerCameraZoom;",
            "        cameraHeight = cameraHeight * layerCameraZoom;",
            "    }",
            "",
            "    cameraWidth = Math.floor(cameraWidth);",
            "    cameraHeight = Math.floor(cameraHeight);",
            "       ",
            "    // Layered 2D, 3D or 2D+3D rendering.",
            "    gdjs._renderToSprite.snapshotThreeRenderer.info.autoReset = false;",
            "    gdjs._renderToSprite.snapshotThreeRenderer.info.reset();",
            "",
            "    /** Useful to render the background color. */",
            "    let isFirstRender = true;",
            "",
            "    /**",
            "    * true if the last layer rendered 3D objects using Three.js, false otherwise.",
            "    * Useful to avoid needlessly resetting the WebGL states between layers (which can be expensive).",
            "    */",
            "    let lastRenderWas3D = true;",
            "",
            "    // Even if no rendering at all has been made already, setting up the Three.js/PixiJS renderers",
            "    // might have changed some WebGL states already. Reset the state for the very first frame.",
            "    // And, out of caution, keep doing it for every frame.",
            "    // TODO (3D): optimization - check if this can be done only on the very first frame.",
            "    gdjs._renderToSprite.snapshotThreeRenderer.resetState();",
            "    gdjs._renderToSprite.snapshotPixiRenderer.reset();",
            "    pixiRenderer.reset();",
            "",
            "    // Render each layer one by one.",
            "",
            "    for (let i = 0; i < runtimeScene._orderedLayers.length; ++i) {",
            "        ",
            "        const runtimeLayer = runtimeScene._orderedLayers[i];",
            "        ",
            "        if (!runtimeLayer.isVisible()) continue;",
            "        ",
            "        const runtimeLayerRenderer = runtimeLayer.getRenderer();",
            "        const runtimeLayerRenderingType = runtimeLayer.getRenderingType();",
            "        const layerHas3DObjectsToRender = runtimeLayerRenderer.has3DObjects();",
            "        ",
            "        const renderTargetIndex = runtimeLayerRenderer.getRendererObject().children.findIndex(",
            "            currChild => currChild === renderTarget",
            "        );",
            "        if (renderTargetIndex >= 0) continue;",
            "",
            "        if (runtimeLayerRenderingType === gdjs.RuntimeLayerRenderingType.TWO_D || !layerHas3DObjectsToRender) {",
            "        ",
            "            // Render a layer with 2D rendering (PixiJS) only if layer is configured as is",
            "            // or if there is no 3D object to render.",
            "",
            "            if (lastRenderWas3D) {",
            "                // Ensure the state is clean for PixiJS to render.",
            "                pixiRenderer.reset();",
            "            }",
            "",
            "            if (isFirstRender) {",
            "                pixiRenderer.background.color = runtimeScene.getBackgroundColor();",
            "                pixiRenderer.background.alpha = 1;",
            "                if (runtimeScene.getClearCanvas()) pixiRenderer.clear();",
            "            }",
            "",
            "            if (runtimeLayer.isLightingLayer()) {",
            "                // Render the lights on the render texture used then by the lighting Sprite.",
            "                runtimeLayerRenderer.renderOnPixiRenderTexture(pixiRenderer);",
            "            }",
            "",
            "            // TODO (2d lights): refactor to remove the need for `getLightingSprite`.",
            "            const pixiContainer = ",
            "                (runtimeLayer.isLightingLayer() && ",
            "                runtimeLayerRenderer.getLightingSprite()) || runtimeLayerRenderer.getRendererObject();",
            "                ",
            "            const origX = pixiContainer.x;",
            "            const origY = pixiContainer.y;",
            "                ",
            "            pixiContainer.x = xParam;",
            "            pixiContainer.y = yParam;",
            "",
            "",
            "            pixiRenderer.render(pixiContainer, {clear: true, renderTexture: gdjs._renderToSprite.rt });",
            "            pixiRenderer.render(gdjs._renderToSprite.sprite, ",
            "                { clear: isFirstRender, renderTexture: renderTarget.texture });",
            "                ",
            "            pixiContainer.x = origX;",
            "            pixiContainer.y = origY;",
            "",
            "            lastRenderWas3D = false;",
            "            isFirstRender = false;",
            "        ",
            "        } else {",
            "        ",
            "            // Render a layer with 3D rendering, and possibly some 2D rendering too.",
            "            ",
            "            const threeScene = runtimeLayerRenderer.getThreeScene();",
            "            const threeCamera = runtimeLayerRenderer.getThreeCamera();",
            "            const threeEffectComposer = runtimeLayerRenderer.getThreeEffectComposer();",
            "",
            "            gdjs._renderToSprite.snapshotThreeRenderer.setSize(cameraWidth, cameraHeight);",
            "            gdjs._renderToSprite.snapshotPixiRenderer.resize(cameraWidth, cameraHeight);",
            "",
            "            // Render the 3D objects of this layer.",
            "            if (threeScene && threeCamera && threeEffectComposer) {",
            "        ",
            "                // TODO (3D) - optimization: do this at the beginning for all layers that are 2d+3d?",
            "                // So the second pass is clearer (just rendering 2d or 3d layers without doing PixiJS ",
            "                //renders in between).",
            "            ",
            "                if (runtimeLayerRenderingType === gdjs.RuntimeLayerRenderingType.TWO_D_PLUS_THREE_D) {",
            "            ",
            "                    const layerHas2DObjectsToRender = runtimeLayerRenderer.has2DObjects();",
            "",
            "                    if (layerHas2DObjectsToRender) {",
            "                    ",
            "                        if (lastRenderWas3D) {",
            "                            // Ensure the state is clean for PixiJS to render.",
            "                            gdjs._renderToSprite.snapshotThreeRenderer.resetState();",
            "                            gdjs._renderToSprite.snapshotPixiRenderer.reset();",
            "                        }",
            "",
            "                        // Do the rendering of the PixiJS objects of the layer on the render texture.",
            "                        // Then, update the texture of the plane showing the PixiJS rendering,",
            "                        // so that the 2D rendering made by PixiJS can be shown in the 3D world.",
            "                        ",
            "                        runtimeLayerRenderer.renderOnPixiRenderTexture(gdjs._renderToSprite.snapshotPixiRenderer);",
            "                        runtimeLayerRenderer.",
            "                            updateThreePlaneTextureFromPixiRenderTexture(",
            "                            gdjs._renderToSprite.snapshotThreeRenderer, ",
            "                            gdjs._renderToSprite.snapshotPixiRenderer);",
            "",
            "                        lastRenderWas3D = false;",
            "                    }",
            "            ",
            "                    runtimeLayerRenderer.show2DRenderingPlane(layerHas2DObjectsToRender);",
            "                }",
            "",
            "                if (!lastRenderWas3D) {",
            "                    // It's important to reset the internal WebGL state of PixiJS, then Three.js",
            "                    // to ensure the 3D rendering is made properly by Three.js",
            "                    gdjs._renderToSprite.snapshotThreeRenderer.resetState();",
            "                    gdjs._renderToSprite.snapshotPixiRenderer.reset();",
            "                }",
            "",
            "                if (isFirstRender) {",
            "                ",
            "                    // Render the background color.",
            "                    gdjs._renderToSprite.snapshotThreeRenderer.setClearColor(runtimeScene.getBackgroundColor());",
            "                    gdjs._renderToSprite.snapshotThreeRenderer.resetState();",
            "                    ",
            "                    if (runtimeScene.getClearCanvas()) gdjs._renderToSprite.snapshotThreeRenderer.clear();",
            "                    threeScene.background = new THREE.Color(runtimeScene.getBackgroundColor());",
            "                    ",
            "                } else {",
            "                    // It's important to set the background to null, as maybe the first rendered",
            "                    // layer has changed and so the Three.js scene background must be reset.",
            "                    if (runtimeScene.getClearCanvas()) gdjs._renderToSprite.snapshotThreeRenderer.clear();",
            "                    threeScene.background = null;",
            "                }",
            "",
            "                // Clear the depth as each layer is independent and display on top of the previous one,",
            "                // even 3D objects.",
            "                gdjs._renderToSprite.snapshotThreeRenderer.clearDepth();",
            "            ",
            "                if (runtimeLayerRenderer.hasPostProcessingPass() && 'renderer' in threeEffectComposer) {",
            "                    //If there are any post processing effects, fake out the Effect Composer",
            "                    //by temporarily setting its renderer to the snapshotThreeRenderer, so that",
            "                    //the snapshot includes those effects.",
            "                    const originalRenderer = threeEffectComposer.renderer;",
            "                    threeEffectComposer.renderer = gdjs._renderToSprite.snapshotThreeRenderer;",
            "                    threeEffectComposer.render();",
            "                    threeEffectComposer.renderer = originalRenderer;",
            "                } else {",
            "                    gdjs._renderToSprite.snapshotThreeRenderer.render(threeScene, threeCamera);",
            "                }",
            "            ",
            "                // Prerender to a temporary texture to prevent WebGL erroring out.",
            "                // See https://www.html5gamedevs.com/topic/45423-why-is-this-not-allowed/",
            "                ",
            "                const snapshotSprite = PIXI.Sprite.from(gdjs._renderToSprite.snapshotCanvas);",
            "                snapshotSprite.x = xParam;",
            "                snapshotSprite.y = yParam;",
            "                ",
            "                pixiRenderer.render(snapshotSprite, {clear: true, renderTexture: gdjs._renderToSprite.rt });",
            "        ",
            "                // Actually render",
            "                pixiRenderer.render(gdjs._renderToSprite.sprite, ",
            "                    {clear: isFirstRender, renderTexture: renderTarget.texture });",
            "",
            "                snapshotSprite.destroy({ children: true, texture: true, baseTexture: true });",
            "",
            "                lastRenderWas3D = true;",
            "                isFirstRender = false;",
            "            }",
            "",
            "        }",
            "",
            "    } // END OF LAYER LOOP",
            "    ",
            "    // Ensure the original width/height is restored",
            "    renderTarget.width = obj.getWidth();",
            "    renderTarget.height = obj.getHeight();",
            "    gdjs._renderToSprite.alertTriggered = false;",
            "  ",
            "} else {",
            "    if (!gdjs._renderToSprite.alertTriggered) {",
            "        gdjs._renderToSprite.alertTriggered = true;",
            "        console.log('ERROR: RenderToSprite.RenderSceneArea(...) -> Passed-in object reference (Sprite) is empty.');",
            "        alert('Error in RenderToSprite.RenderSceneArea:\\n\\n    Passed-in object reference (Sprite) is empty.');",
            "    }",
            "}"
          ],
          "parameterObjects": "renderTarget",
          "useStrict": true,
          "eventsSheetExpanded": true
        }
      ],
      "parameters": [
        {
          "description": "The sprite to render to (should be placed in its own layer, or in a layer with other snapshot sprites)",
          "name": "renderTarget",
          "supplementaryInformation": "Sprite",
          "type": "objectList"
        },
        {
          "description": "Origin X position of the render area",
          "name": "originPositionX",
          "type": "expression"
        },
        {
          "description": "Origin Y Position of the render area",
          "name": "originPositionY",
          "type": "expression"
        },
        {
          "description": "Width of the area to render",
          "name": "areaWidth",
          "type": "expression"
        },
        {
          "description": "Height of the area to render",
          "name": "areaHeight",
          "type": "expression"
        }
      ],
      "objectGroups": []
    }
  ],
  "eventsBasedBehaviors": [],
  "eventsBasedObjects": []
}