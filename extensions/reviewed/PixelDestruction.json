{
  "author": "",
  "category": "Visual effect",
  "extensionNamespace": "",
  "fullName": "Slice an object into fragments",
  "helpPath": "",
  "iconUrl": "data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0iVVRGLTgiPz48IURPQ1RZUEUgc3ZnIFBVQkxJQyAiLS8vVzNDLy9EVEQgU1ZHIDEuMS8vRU4iICJodHRwOi8vd3d3LnczLm9yZy9HcmFwaGljcy9TVkcvMS4xL0RURC9zdmcxMS5kdGQiPjxzdmcgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIiB4bWxuczp4bGluaz0iaHR0cDovL3d3dy53My5vcmcvMTk5OS94bGluayIgdmVyc2lvbj0iMS4xIiBpZD0ibWRpLXNrdWxsLXNjYW4iIHdpZHRoPSIyNCIgaGVpZ2h0PSIyNCIgdmlld0JveD0iMCAwIDI0IDI0Ij48cGF0aCBkPSJNMiAwQy45IDAgMCAuOSAwIDJWNkgyVjJINlYwSDJNMTggMFYySDIyVjZIMjRWMkMyNCAuOSAyMy4xIDAgMjIgMEgxOE0xMiAzQzcuNiAzIDQgNi42IDQgMTFDNCAxMy41IDUuMiAxNS44IDcgMTcuMlYyMUg5VjE4SDExVjIxSDEzVjE4SDE1VjIxSDE3VjE3LjJDMTguOCAxNS43IDIwIDEzLjUgMjAgMTFDMjAgNi42IDE2LjQgMyAxMiAzTTggMTRDNi45IDE0IDYgMTMuMSA2IDEyUzYuOSAxMCA4IDEwIDEwIDEwLjkgMTAgMTIgOS4xIDE0IDggMTRNMTAuNSAxNkwxMiAxM0wxMy41IDE2SDEwLjVNMTYgMTRDMTQuOSAxNCAxNCAxMy4xIDE0IDEyUzE0LjkgMTAgMTYgMTAgMTggMTAuOSAxOCAxMiAxNy4xIDE0IDE2IDE0TTAgMThWMjJDMCAyMy4xIC45IDI0IDIgMjRINlYyMkgyVjE4SDBNMjIgMThWMjJIMThWMjRIMjJDMjMuMSAyNCAyNCAyMy4xIDI0IDIyVjE4SDIyWiIgLz48L3N2Zz4=",
  "name": "PixelDestruction",
  "previewIconUrl": "https://resources.gdevelop-app.com/assets/Icons/skull-scan.svg",
  "shortDescription": "Slice an object into small fragments that match the color of original object",
  "version": "1.0.0",
  "description": [
    "Useful for creating death animations by breaking an object into small pieces.  ",
    "New objects must be a solid white color, or the final color will be wrong.",
    "",
    "Tips:",
    "- Fragments are linked to the original object which allows you to perform further actions on them (i.e. explode away from the original object) "
  ],
  "tags": [
    "slice",
    "brick",
    "destruction",
    "pixelizer"
  ],
  "authorIds": [
    "gqDaZjCfevOOxBYkK6zlhtZnXCg1"
  ],
  "dependencies": [],
  "eventsFunctions": [
    {
      "description": "Slice an object into smaller objects that match color of original object.",
      "fullName": "Slice object into smaller objects",
      "functionType": "Action",
      "name": "PixelDestruction",
      "sentence": "Cut _PARAM1_ into _PARAM3_ vertical strips and _PARAM4_ horizontal strips using _PARAM2_ for the new objects. Delete original object: _PARAM5_",
      "events": [
        {
          "colorB": 228,
          "colorG": 176,
          "colorR": 74,
          "creationTime": 0,
          "name": "Pixel destruction",
          "source": "",
          "type": "BuiltinCommonInstructions::Group",
          "events": [
            {
              "type": "BuiltinCommonInstructions::Comment",
              "color": {
                "b": 109,
                "g": 230,
                "r": 255,
                "textB": 0,
                "textG": 0,
                "textR": 0
              },
              "comment": "Calculate dimensions of small objects",
              "comment2": ""
            },
            {
              "type": "BuiltinCommonInstructions::Standard",
              "conditions": [],
              "actions": [
                {
                  "type": {
                    "value": "ModVarScene"
                  },
                  "parameters": [
                    "FragmentHeight",
                    "=",
                    "max(1, round(Object.Height() / GetArgumentAsNumber(\"HorizontalSlices\")))"
                  ]
                },
                {
                  "type": {
                    "value": "ModVarScene"
                  },
                  "parameters": [
                    "FragmentWidth",
                    "=",
                    "max(1, round(Object.Width() / GetArgumentAsNumber(\"VerticalSlices\")))"
                  ]
                }
              ]
            },
            {
              "type": "BuiltinCommonInstructions::Comment",
              "color": {
                "b": 109,
                "g": 230,
                "r": 255,
                "textB": 0,
                "textG": 0,
                "textR": 0
              },
              "comment": "Record the top left corner of sprite",
              "comment2": ""
            },
            {
              "type": "BuiltinCommonInstructions::Standard",
              "conditions": [],
              "actions": [
                {
                  "type": {
                    "value": "ModVarScene"
                  },
                  "parameters": [
                    "CurrentX",
                    "=",
                    "Object.BoundingBoxLeft()"
                  ]
                },
                {
                  "type": {
                    "value": "ModVarScene"
                  },
                  "parameters": [
                    "CurrentY",
                    "=",
                    "Object.BoundingBoxTop()"
                  ]
                }
              ]
            },
            {
              "type": "BuiltinCommonInstructions::Comment",
              "color": {
                "b": 109,
                "g": 230,
                "r": 255,
                "textB": 0,
                "textG": 0,
                "textR": 0
              },
              "comment": "Scan sprite from top to bottom",
              "comment2": ""
            },
            {
              "type": "BuiltinCommonInstructions::Standard",
              "conditions": [],
              "actions": [
                {
                  "type": {
                    "value": "ModVarScene"
                  },
                  "parameters": [
                    "CreationID",
                    "=",
                    "1"
                  ]
                }
              ]
            },
            {
              "infiniteLoopWarning": true,
              "type": "BuiltinCommonInstructions::While",
              "whileConditions": [
                {
                  "type": {
                    "value": "VarScene"
                  },
                  "parameters": [
                    "CurrentY",
                    "<=",
                    "Object.BoundingBoxBottom()"
                  ]
                }
              ],
              "conditions": [],
              "actions": [],
              "events": [
                {
                  "type": "BuiltinCommonInstructions::Comment",
                  "color": {
                    "b": 109,
                    "g": 230,
                    "r": 255,
                    "textB": 0,
                    "textG": 0,
                    "textR": 0
                  },
                  "comment": "Search left to right",
                  "comment2": ""
                },
                {
                  "infiniteLoopWarning": true,
                  "type": "BuiltinCommonInstructions::While",
                  "whileConditions": [
                    {
                      "type": {
                        "value": "VarScene"
                      },
                      "parameters": [
                        "CurrentX",
                        "<=",
                        "Object.BoundingBoxRight()"
                      ]
                    }
                  ],
                  "conditions": [],
                  "actions": [],
                  "events": [
                    {
                      "type": "BuiltinCommonInstructions::Comment",
                      "color": {
                        "b": 109,
                        "g": 230,
                        "r": 255,
                        "textB": 0,
                        "textG": 0,
                        "textR": 0
                      },
                      "comment": "Record the center of Fragment",
                      "comment2": ""
                    },
                    {
                      "type": "BuiltinCommonInstructions::Standard",
                      "conditions": [],
                      "actions": [
                        {
                          "type": {
                            "value": "ModVarScene"
                          },
                          "parameters": [
                            "FragmentCenterX",
                            "=",
                            "Variable(CurrentX) + 0.5 * Variable(FragmentWidth)"
                          ]
                        },
                        {
                          "type": {
                            "value": "ModVarScene"
                          },
                          "parameters": [
                            "FragmentCenterY",
                            "=",
                            "Variable(CurrentY) + 0.5 * Variable(FragmentHeight)"
                          ]
                        }
                      ]
                    },
                    {
                      "type": "BuiltinCommonInstructions::Comment",
                      "color": {
                        "b": 109,
                        "g": 230,
                        "r": 255,
                        "textB": 0,
                        "textG": 0,
                        "textR": 0
                      },
                      "comment": "Create objects when position divided by Fragment size has no remainder",
                      "comment2": ""
                    },
                    {
                      "type": "BuiltinCommonInstructions::Standard",
                      "conditions": [
                        {
                          "type": {
                            "value": "Egal"
                          },
                          "parameters": [
                            "mod(Variable(CurrentX),Variable(FragmentWidth))",
                            "=",
                            "0"
                          ]
                        },
                        {
                          "type": {
                            "value": "Egal"
                          },
                          "parameters": [
                            "mod(Variable(CurrentY),Variable(FragmentHeight))",
                            "=",
                            "0"
                          ]
                        }
                      ],
                      "actions": [],
                      "events": [
                        {
                          "type": "BuiltinCommonInstructions::Comment",
                          "color": {
                            "b": 109,
                            "g": 230,
                            "r": 255,
                            "textB": 0,
                            "textG": 0,
                            "textR": 0
                          },
                          "comment": "Check if position is inside collision mask",
                          "comment2": ""
                        },
                        {
                          "type": "BuiltinCommonInstructions::Standard",
                          "conditions": [
                            {
                              "type": {
                                "value": "CollisionPoint"
                              },
                              "parameters": [
                                "Object",
                                "Variable(FragmentCenterX)",
                                "Variable(FragmentCenterY)"
                              ]
                            }
                          ],
                          "actions": [
                            {
                              "type": {
                                "value": "Create"
                              },
                              "parameters": [
                                "",
                                "WhitePixel",
                                "Variable(CurrentX)",
                                "Variable(CurrentY)",
                                "\"\""
                              ]
                            },
                            {
                              "type": {
                                "value": "LinkedObjects::LinkObjects"
                              },
                              "parameters": [
                                "",
                                "Object",
                                "WhitePixel"
                              ]
                            }
                          ],
                          "events": [
                            {
                              "type": "BuiltinCommonInstructions::Comment",
                              "color": {
                                "b": 109,
                                "g": 230,
                                "r": 255,
                                "textB": 0,
                                "textG": 0,
                                "textR": 0
                              },
                              "comment": "Calculate length of new object sides",
                              "comment2": ""
                            },
                            {
                              "type": "BuiltinCommonInstructions::Standard",
                              "conditions": [],
                              "actions": [
                                {
                                  "type": {
                                    "value": "ChangeWidth"
                                  },
                                  "parameters": [
                                    "WhitePixel",
                                    "=",
                                    "Variable(FragmentWidth)"
                                  ]
                                },
                                {
                                  "type": {
                                    "value": "ChangeHeight"
                                  },
                                  "parameters": [
                                    "WhitePixel",
                                    "=",
                                    "Variable(FragmentHeight)"
                                  ]
                                },
                                {
                                  "type": {
                                    "value": "Physics2::ShapeScale"
                                  },
                                  "parameters": [
                                    "WhitePixel",
                                    "Physics2",
                                    "=",
                                    "min(Variable(FragmentWidth), Variable(FragmentHeight))/2"
                                  ]
                                }
                              ]
                            },
                            {
                              "type": "BuiltinCommonInstructions::Comment",
                              "color": {
                                "b": 109,
                                "g": 230,
                                "r": 255,
                                "textB": 0,
                                "textG": 0,
                                "textR": 0
                              },
                              "comment": "Match the color of the pixel that is in the center of the new Fragment",
                              "comment2": ""
                            },
                            {
                              "type": "BuiltinCommonInstructions::Standard",
                              "conditions": [],
                              "actions": [
                                {
                                  "type": {
                                    "value": "ChangeColor"
                                  },
                                  "parameters": [
                                    "WhitePixel",
                                    "ToString(PixelDestruction::ReadPixelRed(Variable(FragmentCenterX), Variable(FragmentCenterY))) + \";\" + ToString(PixelDestruction::ReadPixelGreen(Variable(FragmentCenterX), Variable(FragmentCenterY))) + \";\" + ToString(PixelDestruction::ReadPixelBlue(Variable(FragmentCenterX), Variable(FragmentCenterY)))"
                                  ]
                                }
                              ]
                            },
                            {
                              "type": "BuiltinCommonInstructions::Standard",
                              "conditions": [],
                              "actions": [
                                {
                                  "type": {
                                    "value": "ModVarObjet"
                                  },
                                  "parameters": [
                                    "WhitePixel",
                                    "CreationID",
                                    "=",
                                    "Variable(CreationID)"
                                  ]
                                },
                                {
                                  "type": {
                                    "value": "ModVarObjet"
                                  },
                                  "parameters": [
                                    "WhitePixel",
                                    "RowID",
                                    "=",
                                    "Variable(RowID)"
                                  ]
                                },
                                {
                                  "type": {
                                    "value": "ModVarObjet"
                                  },
                                  "parameters": [
                                    "WhitePixel",
                                    "ColumnID",
                                    "=",
                                    "Variable(ColumnID)"
                                  ]
                                }
                              ]
                            },
                            {
                              "type": "BuiltinCommonInstructions::Standard",
                              "conditions": [],
                              "actions": [
                                {
                                  "type": {
                                    "value": "ModVarScene"
                                  },
                                  "parameters": [
                                    "CreationID",
                                    "+",
                                    "1"
                                  ]
                                }
                              ]
                            }
                          ]
                        }
                      ]
                    },
                    {
                      "type": "BuiltinCommonInstructions::Comment",
                      "color": {
                        "b": 109,
                        "g": 230,
                        "r": 255,
                        "textB": 0,
                        "textG": 0,
                        "textR": 0
                      },
                      "comment": "Move one pixel to the right",
                      "comment2": ""
                    },
                    {
                      "type": "BuiltinCommonInstructions::Standard",
                      "conditions": [],
                      "actions": [
                        {
                          "type": {
                            "value": "ModVarScene"
                          },
                          "parameters": [
                            "CurrentX",
                            "+",
                            "1"
                          ]
                        }
                      ]
                    }
                  ]
                },
                {
                  "type": "BuiltinCommonInstructions::Comment",
                  "color": {
                    "b": 109,
                    "g": 230,
                    "r": 255,
                    "textB": 0,
                    "textG": 0,
                    "textR": 0
                  },
                  "comment": "Move one pixel down and start over at the left",
                  "comment2": ""
                },
                {
                  "type": "BuiltinCommonInstructions::Standard",
                  "conditions": [],
                  "actions": [
                    {
                      "type": {
                        "value": "ModVarScene"
                      },
                      "parameters": [
                        "CurrentY",
                        "+",
                        "1"
                      ]
                    },
                    {
                      "type": {
                        "value": "ModVarScene"
                      },
                      "parameters": [
                        "CurrentX",
                        "=",
                        "Object.BoundingBoxLeft()"
                      ]
                    }
                  ]
                }
              ]
            },
            {
              "type": "BuiltinCommonInstructions::Comment",
              "color": {
                "b": 109,
                "g": 230,
                "r": 255,
                "textB": 0,
                "textG": 0,
                "textR": 0
              },
              "comment": "Delete object if desired",
              "comment2": ""
            },
            {
              "type": "BuiltinCommonInstructions::Standard",
              "conditions": [
                {
                  "type": {
                    "value": "GetArgumentAsBoolean"
                  },
                  "parameters": [
                    "GetArgumentAsString(\"DeleteObject\")"
                  ]
                }
              ],
              "actions": [
                {
                  "type": {
                    "value": "Delete"
                  },
                  "parameters": [
                    "Object",
                    ""
                  ]
                }
              ]
            }
          ],
          "parameters": []
        }
      ],
      "parameters": [
        {
          "description": "Object",
          "name": "Object",
          "type": "objectList"
        },
        {
          "description": "Replacement object (a single white pixel)",
          "longDescription": "1x1 pixel sprite that is the color white",
          "name": "WhitePixel",
          "supplementaryInformation": "Sprite",
          "type": "objectList"
        },
        {
          "description": "Vertical slices",
          "name": "VerticalSlices",
          "type": "expression"
        },
        {
          "description": "Horizontal slices",
          "name": "HorizontalSlices",
          "type": "expression"
        },
        {
          "description": "Delete original object",
          "name": "DeleteObject",
          "type": "yesorno"
        }
      ],
      "objectGroups": []
    },
    {
      "fullName": "",
      "functionType": "Action",
      "name": "onFirstSceneLoaded",
      "sentence": "",
      "events": [
        {
          "type": "BuiltinCommonInstructions::JsCode",
          "inlineCode": [
            "// Define an new private object javascript for this extension",
            "gdjs._readPixels = {};",
            "",
            "/** ",
            " * @param {HTMLCanvasElement} canvas",
            " */",
            "gdjs._readPixels.getCanvasType = function (canvas) {",
            "    const is2d = canvas.getContext(\"2d\");",
            "    const isBitmap = canvas.getContext(\"bitmaprenderer\");",
            "    const isWebGL1 = canvas.getContext(\"webgl\");",
            "    const isWebGL2 = canvas.getContext(\"webgl2\");",
            "    const isExperimentalWebGL = canvas.getContext(\"experimental-webgl\");",
            "",
            "    return is2d ?",
            "        \"2d\" : isBitmap ?",
            "            \"bitmaprenderer\" : isWebGL1 ?",
            "                \"webgl\" : isWebGL2 ?",
            "                    \"webgl2\" : isExperimentalWebGL ?",
            "                        \"experimental-webgl\" : null;",
            "}",
            "",
            "/**",
            " * @param {HTMLCanvasElement} canvas",
            " * @param {number} colorIndex Should be 0, 1, 2 or 3, for red, green, blue or alpha channel.",
            " * @param {number} positionX The X position of the pixel on the canvas to read",
            " * @param {number} positionY The Y position of the pixel on the canvas to read",
            " */",
            "gdjs._readPixels.getPixelColor = function (canvas, colorIndex, positionX, positionY) {",
            "",
            "    const gl = canvas.getContext(\"webgl2\") ||  canvas.getContext(\"webgl\") || canvas.getContext(\"experimental-webgl\") ;",
            "",
            "    const data = new Uint8Array(1 * 4); // [255,255,255,255] RGBA",
            "",
            "    const invertedPositionY = gl.drawingBufferHeight - positionY;",
            "    // mandatory because textures in webGL are invert before rendering in the canvas,",
            "    // otherwise the bottom left corner will be used",
            "",
            "    gl.readPixels(positionX, invertedPositionY, 1, 1, gl.RGBA, gl.UNSIGNED_BYTE, data);",
            "    // Read 1 pixel and store it in data.",
            "",
            "    return data[colorIndex];",
            "}",
            "",
            ""
          ],
          "parameterObjects": "",
          "useStrict": true,
          "eventsSheetExpanded": true
        }
      ],
      "parameters": [],
      "objectGroups": []
    },
    {
      "description": "Return the blue component of the pixel at the specified position.",
      "fullName": "Read pixel blue",
      "functionType": "Expression",
      "name": "ReadPixelBlue",
      "sentence": "",
      "events": [
        {
          "type": "BuiltinCommonInstructions::Standard",
          "conditions": [],
          "actions": []
        },
        {
          "type": "BuiltinCommonInstructions::JsCode",
          "inlineCode": [
            "const canvas = runtimeScene.getGame().getRenderer().getCanvas();",
            "if (!canvas) return;",
            "",
            "const canvasType = gdjs._readPixels.getCanvasType(canvas);",
            "let x = eventsFunctionContext.getArgument(\"PositionX\");",
            "let y = eventsFunctionContext.getArgument(\"PositionY\");",
            "let layer = runtimeScene.getLayer(\"\");",
            "let position = layer.convertInverseCoords(x, y);",
            "",
            "if (canvasType === \"webgl\" || canvasType === \"webgl2\" || canvasType === \"experimental-webgl\") {",
            "    eventsFunctionContext.returnValue = gdjs._readPixels.getPixelColor(canvas, 2, position[0], position[1]);",
            "    // 2 is for blue in pixel buffer",
            "} else if (canvasType === \"2d\") {",
            "    let ctx = canvas.getContext(\"2d\");",
            "    let data = ctx.getImageData(position[0], position[1], 1, 1).data;",
            "    eventsFunctionContext.returnValue = data[2];",
            "} else {",
            "    eventsFunctionContext.returnValue = 0;",
            "}"
          ],
          "parameterObjects": "",
          "useStrict": true,
          "eventsSheetExpanded": true
        }
      ],
      "expressionType": {
        "type": "expression"
      },
      "parameters": [
        {
          "description": "Position X",
          "name": "PositionX",
          "type": "expression"
        },
        {
          "description": "Position Y",
          "name": "PositionY",
          "type": "expression"
        }
      ],
      "objectGroups": []
    },
    {
      "description": "Return the green component of the pixel at the specified position.",
      "fullName": "Read pixel green",
      "functionType": "Expression",
      "name": "ReadPixelGreen",
      "sentence": "",
      "events": [
        {
          "type": "BuiltinCommonInstructions::Standard",
          "conditions": [],
          "actions": []
        },
        {
          "type": "BuiltinCommonInstructions::JsCode",
          "inlineCode": [
            "const canvas = runtimeScene.getGame().getRenderer().getCanvas();",
            "if (!canvas) return;",
            "",
            "const canvasType = gdjs._readPixels.getCanvasType(canvas);",
            "let x = eventsFunctionContext.getArgument(\"PositionX\");",
            "let y = eventsFunctionContext.getArgument(\"PositionY\");",
            "let layer = runtimeScene.getLayer(\"\");",
            "let position = layer.convertInverseCoords(x, y);",
            "",
            "if (canvasType === \"webgl\" || canvasType === \"webgl2\" || canvasType === \"experimental-webgl\") {",
            "    eventsFunctionContext.returnValue = gdjs._readPixels.getPixelColor(canvas, 1, position[0], position[1]);",
            "    // 1 is for green in pixel buffer",
            "} else if (canvasType === \"2d\") {",
            "    let ctx = canvas.getContext(\"2d\");",
            "    let data = ctx.getImageData(position[0], position[1], 1, 1).data;",
            "    eventsFunctionContext.returnValue = data[1];",
            "} else {",
            "    eventsFunctionContext.returnValue = 0;",
            "}"
          ],
          "parameterObjects": "",
          "useStrict": true,
          "eventsSheetExpanded": true
        }
      ],
      "expressionType": {
        "type": "expression"
      },
      "parameters": [
        {
          "description": "Position X",
          "name": "PositionX",
          "type": "expression"
        },
        {
          "description": "Position Y",
          "name": "PositionY",
          "type": "expression"
        }
      ],
      "objectGroups": []
    },
    {
      "description": "Return the red component of the pixel at the specified position.",
      "fullName": "Read pixel red",
      "functionType": "Expression",
      "name": "ReadPixelRed",
      "sentence": "",
      "events": [
        {
          "type": "BuiltinCommonInstructions::Standard",
          "conditions": [],
          "actions": []
        },
        {
          "type": "BuiltinCommonInstructions::JsCode",
          "inlineCode": [
            "const canvas = runtimeScene.getGame().getRenderer().getCanvas();",
            "if (!canvas) return;",
            "",
            "const canvasType = gdjs._readPixels.getCanvasType(canvas);",
            "let x = eventsFunctionContext.getArgument(\"PositionX\");",
            "let y = eventsFunctionContext.getArgument(\"PositionY\");",
            "let layer = runtimeScene.getLayer(\"\");",
            "let position = layer.convertInverseCoords(x, y);",
            "",
            "if (canvasType === \"webgl\" || canvasType === \"webgl2\" || canvasType === \"experimental-webgl\") {",
            "    eventsFunctionContext.returnValue = gdjs._readPixels.getPixelColor(canvas, 0, position[0], position[1]);",
            "    // 0 is for red, in pixel buffer",
            "} else if (canvasType === \"2d\") {",
            "    let ctx = canvas.getContext(\"2d\");",
            "    let data = ctx.getImageData(position[0], position[1], 1, 1).data;",
            "    eventsFunctionContext.returnValue = data[0];",
            "} else {",
            "    eventsFunctionContext.returnValue = 0;",
            "}"
          ],
          "parameterObjects": "",
          "useStrict": true,
          "eventsSheetExpanded": true
        }
      ],
      "expressionType": {
        "type": "expression"
      },
      "parameters": [
        {
          "description": "Position X",
          "name": "PositionX",
          "type": "expression"
        },
        {
          "description": "Position Y",
          "name": "PositionY",
          "type": "expression"
        }
      ],
      "objectGroups": []
    }
  ],
  "eventsBasedBehaviors": [],
  "eventsBasedObjects": []
}