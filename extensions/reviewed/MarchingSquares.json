{
  "author": "D8H",
  "category": "Visual effect",
  "description": "It can be helpful for:\n  * Liquid effects like water, blobs or lava ([open the project online](https://editor.gdevelop.io/?project=example://marching-squares-liquids))\n  * Fog of wars ([open the project online](https://editor.gdevelop.io/?project=example://marching-squares-fog-of-war))\n  * Platformer with destructible platforms ([open the project online](https://editor.gdevelop.io/?project=example://marching-squares-platforms-painter))\n  * Dynamically paint territories ([open the project online](https://editor.gdevelop.io/?project=example://marching-squares-qix))\n  * Top-down relief with physics ([open the project online](https://editor.gdevelop.io/?project=example://marching-squares-terraforming))\n  * Island generator ([open the project online](https://editor.gdevelop.io/?project=example://marching-squares-island-generator))",
  "extensionNamespace": "",
  "fullName": "Marching Squares (experimental)",
  "helpPath": "/extensions/marching-squares",
  "iconUrl": "data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0iVVRGLTgiPz48IURPQ1RZUEUgc3ZnIFBVQkxJQyAiLS8vVzNDLy9EVEQgU1ZHIDEuMS8vRU4iICJodHRwOi8vd3d3LnczLm9yZy9HcmFwaGljcy9TVkcvMS4xL0RURC9zdmcxMS5kdGQiPjxzdmcgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIiB4bWxuczp4bGluaz0iaHR0cDovL3d3dy53My5vcmcvMTk5OS94bGluayIgdmVyc2lvbj0iMS4xIiBpZD0ibWRpLXBlYW51dC1vdXRsaW5lIiB3aWR0aD0iMjQiIGhlaWdodD0iMjQiIHZpZXdCb3g9IjAgMCAyNCAyNCI+PHBhdGggZD0iTTEyIDIzQzExLjUzIDIzIDExLjA3IDIyLjk1IDEwLjYxIDIyLjg1QzcuMSAyMi4xIDQuODcgMTguNjQgNS42MiAxNS4xM0M1Ljg3IDEzLjk1IDYuNDUgMTIuODcgNy4yOCAxMkM3LjYyIDExLjY0IDcuNjIgMTEuMDggNy4yOCAxMC43MkM1LjIgOC4xNCA1LjYgNC4zNiA4LjE4IDIuMjhTMTQuNTQuNjA3IDE2LjYyIDMuMTlDMTguMzkgNS4zOCAxOC4zOSA4LjUgMTYuNjIgMTAuNzJDMTYuMzMgMTEuMTMgMTYuMzcgMTEuNyAxNi43MiAxMi4wNkMxOS4xNyAxNC42OCAxOS4wNCAxOC44IDE2LjQxIDIxLjI1QzE1LjIyIDIyLjM3IDEzLjY0IDIzIDEyIDIzTTEyIDNDMTEuMDkgMyAxMC4yIDMuMzEgOS41IDMuODlDOC41NSA0LjY1IDggNS43OSA4IDdDOCA3LjkxIDguMzEgOC43OSA4Ljg4IDkuNUM5Ljg0IDEwLjY0IDkuNzcgMTIuMzMgOC43MyAxMy40MUM3LjAzIDE1LjIyIDcuMTMgMTguMDcgOC45NCAxOS43N1MxMy42IDIxLjM4IDE1LjMgMTkuNTZDMTYuOTIgMTcuODMgMTYuOTIgMTUuMTQgMTUuMyAxMy40MUMxNC4yMyAxMi4zMiAxNC4xNSAxMC42IDE1LjEyIDkuNDFDMTYuNSA3LjY5IDE2LjIyIDUuMTcgMTQuNSAzLjc5QzE0IDMuNDEgMTMuNDcgMy4xNCAxMi44OCAzQzEyLjU5IDMgMTIuMjkgMyAxMiAzTTEyIDZDMTIgNi41NSAxMi40NSA3IDEzIDdTMTQgNi41NSAxNCA2IDEzLjU1IDUgMTMgNSAxMiA1LjQ1IDEyIDZNMTQgMTlDMTQuNTUgMTkgMTUgMTguNTUgMTUgMThTMTQuNTUgMTcgMTQgMTcgMTMgMTcuNDUgMTMgMTggMTMuNDUgMTkgMTQgMTlNMTMgMTZDMTMuNTUgMTYgMTQgMTUuNTUgMTQgMTVTMTMuNTUgMTQgMTMgMTQgMTIgMTQuNDUgMTIgMTUgMTIuNDUgMTYgMTMgMTZNMTEgMThDMTEuNTUgMTggMTIgMTcuNTUgMTIgMTdTMTEuNTUgMTYgMTEgMTYgMTAgMTYuNDUgMTAgMTcgMTAuNDUgMTggMTEgMThaIiAvPjwvc3ZnPg==",
  "name": "MarchingSquares",
  "previewIconUrl": "https://resources.gdevelop-app.com/assets/Icons/peanut-outline.svg",
  "shortDescription": "Allow to build a \"scalar field\" and draw contour lines of it: useful for fog of wars, liquid effects, paint the ground, etc...",
  "version": "0.5.1",
  "origin": {
    "identifier": "MarchingSquares",
    "name": "gdevelop-extension-store"
  },
  "tags": [
    "blobs",
    "liquid",
    "lava",
    "water",
    "fog",
    "paint",
    "heightmap"
  ],
  "authorIds": [
    "IWykYNRvhCZBN3vEgKEbBPOR3Oc2"
  ],
  "dependencies": [],
  "eventsFunctions": [
    {
      "description": "Define the scalar field painter library JavaScript code.",
      "fullName": "Define scalar field painter library",
      "functionType": "Action",
      "group": "",
      "name": "DefineScalarFieldPainterLibrary",
      "private": true,
      "sentence": "Define the scalar field painter library JavaScript code",
      "events": [
        {
          "type": "BuiltinCommonInstructions::JsCode",
          "inlineCode": "// This library comes from https://github.com/D8H/scalar-field-painter\n// It can be generated with \"npm run build\" to the dist/ScalarFieldPainter.js\n\n    /**\n     * A stock to reuse instances and avoid allocation.\n     */\n    var Stock = /** @class */ (function () {\n        /**\n         * Create a stock.\n         */\n        function Stock() {\n            this.elements = [];\n        }\n        /**\n         * Get an element to avoid allocation or create a new one if the stock is\n         * empty.\n         * @param create\n         * @returns an element\n         */\n        Stock.prototype.getOrCreate = function (create) {\n            return this.elements.pop() || create();\n        };\n        /**\n         * Stock an element to use it later.\n         * @param element\n         */\n        Stock.prototype.stock = function (element) {\n            this.elements.push(element);\n        };\n        /**\n         * Free all the elements from the stock.\n         */\n        Stock.prototype.flush = function () {\n            this.elements.length = 0;\n        };\n        return Stock;\n    }());\n\n    var deltas = [\n        { x: -1, y: 0 },\n        { x: 1, y: 0 },\n        { x: 0, y: -1 },\n        { x: 0, y: 1 },\n    ];\n    var createNode = function () { return ({ x: 0, y: 0 }); };\n    var createContourNode = function () { return ({\n        x: 0,\n        y: 0,\n        originX: 0,\n        originY: 0,\n        value: 0,\n    }); };\n    /**\n     *\n     */\n    var FloodFill = /** @class */ (function () {\n        function FloodFill(scalarField) {\n            this.floodStack = [];\n            this.nodeStock = new Stock();\n            this.contourStack = [];\n            this.nextContourStack = [];\n            this.contourNodeStock = new Stock();\n            this.scalarField = scalarField;\n        }\n        /**\n         * Fill an area from a given location until a maximum field value is reached.\n         *\n         * The result is the same as drawing circles at every point of the area.\n         * This mean that the area will be filled with a value a lot gibber than 1.\n         *\n         * @param originX {float} in grid basis\n         * @param originY {float} in grid basis\n         * @param valueMax {float} the value where to stop the flooding\n         * @param thickness {float} the thickness of the contour shading.\n         * The field will have the value 1 at this given distance from the area.\n         * @param cappingRadiusRatio {float} the radius where to stop the contour shading\n         * or a maximum otherwise.\n         */\n        FloodFill.prototype.fillFrom = function (originX, originY, valueMax, thickness, cappingRadiusRatio) {\n            var thicknessSq = thickness * thickness;\n            var fillingValue = Math.max(valueMax, thicknessSq * 1024 * 1024);\n            var cappingRadius = cappingRadiusRatio * thickness;\n            var cappingRadiusSq = cappingRadius * cappingRadius;\n            var getContourValue = function (fieldValue, distanceSq) {\n                var value = thicknessSq / distanceSq;\n                return fieldValue < value && distanceSq < cappingRadiusSq ? value : null;\n            };\n            this.floodFrom(originX, originY, function (fieldValue) { return fieldValue < valueMax; }, fillingValue, getContourValue);\n            this.shadeContour(getContourValue);\n        };\n        /**\n         * Unfill an area from a given location until a minimum field value is reached.\n         *\n         * It fills the area with the value 0.\n         *\n         * @param originX {float} in grid basis\n         * @param originY {float} in grid basis\n         * @param valueMax {float} the value where to stop the flooding\n         * @param thickness {float} the thickness of the contour shading.\n         * The field will have the value 1 at this given distance from the area.\n         * @param cappingRadiusRatio {float} the radius where to stop the contour shading\n         * or a maximum otherwise.\n         */\n        FloodFill.prototype.unfillFrom = function (originX, originY, valueMin, thickness, cappingRadiusRatio) {\n            var fillingValue = 0;\n            var thicknessSq = thickness * thickness;\n            var cappingRadius = cappingRadiusRatio * thickness;\n            var cappingRadiusSq = cappingRadius * cappingRadius;\n            var getContourValue = function (fieldValue, distanceSq) {\n                var value = distanceSq / thicknessSq;\n                return fieldValue > value && distanceSq < cappingRadiusSq ? value : null;\n            };\n            this.floodFrom(originX, originY, function (fieldValue) { return fieldValue > valueMin; }, fillingValue, getContourValue);\n            this.shadeContour(getContourValue);\n        };\n        /**\n         * Flood an area from a given location until a condition is reached.\n         * @param originX {float} in grid basis\n         * @param originY {float} in grid basis\n         * @param canFlood {(float) => boolean}\n         * @param fillingValue {float}\n         * @param getContourValue {(number, number) => number}\n         * or a maximum otherwise.\n         */\n        FloodFill.prototype.floodFrom = function (originX, originY, canFlood, fillingValue, getContourValue) {\n            var scalarField = this.scalarField;\n            // They should already be empty at this point.\n            this.floodStack.length = 0;\n            this.contourStack.length = 0;\n            this.nextContourStack.length = 0;\n            {\n                var x = Math.round(originX);\n                var y = Math.round(originY);\n                if (!scalarField.isInside(x, y)) {\n                    return;\n                }\n                var fieldValue = scalarField.get(x, y);\n                if (canFlood(fieldValue)) {\n                    var node = this.nodeStock.getOrCreate(createNode);\n                    node.x = x;\n                    node.y = y;\n                    this.floodStack.push(node);\n                }\n            }\n            while (this.floodStack.length > 0) {\n                var node = this.floodStack.pop();\n                var x = node.x;\n                var y = node.y;\n                scalarField.set(x, y, fillingValue);\n                for (var _i = 0, deltas_1 = deltas; _i < deltas_1.length; _i++) {\n                    var delta = deltas_1[_i];\n                    var neighborX = x + delta.x;\n                    var neighborY = y + delta.y;\n                    if (!scalarField.isInside(neighborX, neighborY)) {\n                        continue;\n                    }\n                    var fieldValue = scalarField.get(neighborX, neighborY);\n                    if (canFlood(fieldValue)) {\n                        var neighbor = this.nodeStock.getOrCreate(createNode);\n                        neighbor.x = neighborX;\n                        neighbor.y = neighborY;\n                        this.floodStack.push(neighbor);\n                    }\n                    else {\n                        this.checkAnAddContourNode(neighborX, neighborY, x, y, getContourValue);\n                    }\n                }\n                this.nodeStock.stock(node);\n            }\n        };\n        /**\n         * Shade the contour to keep the field somewhat continuous.\n         * @param getContourValue\n         */\n        FloodFill.prototype.shadeContour = function (getContourValue) {\n            var scalarField = this.scalarField;\n            var swap = this.nextContourStack;\n            this.nextContourStack = this.contourStack;\n            this.contourStack = swap;\n            while (this.contourStack.length > 0) {\n                while (this.contourStack.length > 0) {\n                    var node = this.contourStack.pop();\n                    if (scalarField.get(node.x, node.y) > node.value) {\n                        // This node wasn't the nearest one.\n                        continue;\n                    }\n                    for (var _i = 0, deltas_2 = deltas; _i < deltas_2.length; _i++) {\n                        var delta = deltas_2[_i];\n                        var neighborX = node.x + delta.x;\n                        var neighborY = node.y + delta.y;\n                        this.checkAnAddContourNode(neighborX, neighborY, node.originX, node.originY, getContourValue);\n                    }\n                    this.contourNodeStock.stock(node);\n                }\n                var swap_1 = this.nextContourStack;\n                this.nextContourStack = this.contourStack;\n                this.contourStack = swap_1;\n            }\n        };\n        FloodFill.prototype.checkAnAddContourNode = function (nodeX, nodeY, originX, originY, getContourValue) {\n            var scalarField = this.scalarField;\n            if (!scalarField.isInside(nodeX, nodeY)) {\n                return;\n            }\n            // Avoid too big values\n            var minDistanceSq = 1 / 1024 / 1024;\n            var deltaX = nodeX - originX;\n            var deltaY = nodeY - originY;\n            var distanceSq = Math.max(minDistanceSq, deltaX * deltaX + deltaY * deltaY);\n            var value = getContourValue(scalarField.get(nodeX, nodeY), distanceSq);\n            if (value !== null) {\n                scalarField.set(nodeX, nodeY, value);\n                var newNode = this.contourNodeStock.getOrCreate(createContourNode);\n                newNode.x = nodeX;\n                newNode.y = nodeY;\n                newNode.originX = originX;\n                newNode.originY = originY;\n                newNode.value = value;\n                this.nextContourStack.push(newNode);\n            }\n        };\n        return FloodFill;\n    }());\n\n    /**\n     * @param x1 {float} fist point x\n     * @param y1 {float} fist point y\n     * @param x2 {float} second point x\n     * @param y2 {float} second point y\n     * @return {float} the square distance between 2 points\n     */\n    var getDistanceSq = function (x1, y1, x2, y2) {\n        var deltaX = x2 - x1;\n        var deltaY = y2 - y1;\n        return deltaX * deltaX + deltaY * deltaY;\n    };\n    /**\n     * @param x {float} point x\n     * @param y {float} point y\n     * @param x1 {float} segment extremity x\n     * @param y1 {float} segment extremity y\n     * @param x2 {float} segment extremity x\n     * @param y2 {float} segment extremity y\n     * @return {float} the square distance between a point and a segment\n     */\n    var getDistanceSqToSegment = function (x, y, x1, y1, x2, y2) {\n        var length2 = getDistanceSq(x1, y1, x2, y2);\n        if (length2 === 0)\n            return getDistanceSq(x, y, x1, y1);\n        var t = Math.max(0, Math.min(1, ((x - x1) * (x2 - x1) + (y - y1) * (y2 - y1)) / length2));\n        return getDistanceSq(x, y, x1 + t * (x2 - x1), y1 + t * (y2 - y1));\n    };\n    /**\n     * A scalar field.\n     */\n    var ScalarField = /** @class */ (function () {\n        /**\n         * Create a scalar field.\n         * @param dimX {integer}\n         * @param dimY {integer}\n         */\n        function ScalarField(dimX, dimY) {\n            var fieldValues = new Array(dimY);\n            for (var y = 0; y < dimY; y++) {\n                fieldValues[y] = new Array(dimX).fill(0);\n            }\n            this.values = fieldValues;\n            this.floodFill = new FloodFill(this);\n        }\n        /**\n         * @return {integer} grid dimension on y\n         */\n        ScalarField.prototype.dimY = function () {\n            return this.values.length;\n        };\n        /**\n         * @return {integer} grid dimension on y\n         */\n        ScalarField.prototype.dimX = function () {\n            var firstColumn = this.values[0];\n            return firstColumn ? firstColumn.length : 0;\n        };\n        ScalarField.prototype.isInside = function (x, y) {\n            return x >= 0 && x <= this.dimX() - 1 && y >= 0 && y <= this.dimY() - 1;\n        };\n        ScalarField.prototype.get = function (x, y) {\n            return this.values[y][x];\n        };\n        /**\n         * @param squareX {integer} x grid index\n         * @param squareY {integer} y grid index\n         * @param value {float} the field value\n         */\n        ScalarField.prototype.set = function (x, y, value) {\n            this.values[y][x] = value;\n        };\n        /**\n         * @param pointX {float} in grid basis\n         * @param pointY {float} in grid basis\n         * @return {float} the field value\n         */\n        ScalarField.prototype.extrapolate = function (x, y) {\n            var squareX = Math.floor(x);\n            var squareY = Math.floor(y);\n            if (squareX < 0 ||\n                squareY < 0 ||\n                squareX >= this.dimX() ||\n                squareY >= this.dimY()) {\n                return 0;\n            }\n            // Extrapolate\n            var weighedValueSum = 0;\n            var weightSum = 0;\n            for (var vertexX = squareX; vertexX <= squareX + 1; vertexX++) {\n                for (var vertexY = squareY; vertexY <= squareY + 1; vertexY++) {\n                    var value = this.values[vertexY][vertexX];\n                    var dx = vertexX - x;\n                    var dy = vertexY - y;\n                    if (dx === 0 && dy === 0) {\n                        // No interpolation needed.\n                        return value;\n                    }\n                    else {\n                        var distance = Math.hypot(dx, dy);\n                        weighedValueSum += value / distance;\n                        weightSum += 1 / distance;\n                    }\n                }\n            }\n            var mean = weighedValueSum / weightSum;\n            return mean;\n        };\n        /**\n         * Clear the field by filling it with a give value.\n         * @param value {float}\n         */\n        ScalarField.prototype.clear = function (value) {\n            if (value === void 0) { value = 0; }\n            for (var _i = 0, _a = this.values; _i < _a.length; _i++) {\n                var rowValues = _a[_i];\n                for (var x = 0; x < rowValues.length; x++) {\n                    rowValues[x] = value;\n                }\n            }\n        };\n        /**\n         * Cap the field between 2 values.\n         * @param min {float}\n         * @param max {float}\n         */\n        ScalarField.prototype.clamp = function (min, max) {\n            for (var _i = 0, _a = this.values; _i < _a.length; _i++) {\n                var rowValues = _a[_i];\n                for (var x = 0; x < rowValues.length; x++) {\n                    rowValues[x] = Math.max(Math.min(min, rowValues[x]), max);\n                }\n            }\n        };\n        /**\n         * Apply an affine transformation on each field value.\n         * @param a {float} factor\n         * @param b {float} offset\n         */\n        ScalarField.prototype.transform = function (a, b) {\n            for (var _i = 0, _a = this.values; _i < _a.length; _i++) {\n                var rowValues = _a[_i];\n                for (var x = 0; x < rowValues.length; x++) {\n                    rowValues[x] = a * rowValues[x] + b;\n                }\n            }\n        };\n        /**\n         * Merge the values from another field.\n         * @param scalarField {ScalarField}\n         * @param operation {function(float, float):float}\n         */\n        ScalarField.prototype.mergeField = function (scalarField, operation) {\n            for (var y = 0; y < this.values.length; y++) {\n                var thisRowValues = this.values[y];\n                var otherRowValues = scalarField.values[y];\n                for (var x = 0; x < thisRowValues.length; x++) {\n                    thisRowValues[x] = operation(thisRowValues[x], otherRowValues[x]);\n                }\n            }\n        };\n        /**\n         * Merge a disk in the field.\n         * @param centerX {float} in grid basis\n         * @param centerY {float} in grid basis\n         * @param radius {float} in grid basis\n         * @param cappingRadiusRatio {float}\n         * @param operation {function(float, float):float}\n         */\n        ScalarField.prototype.mergeDisk = function (centerX, centerY, radius, cappingRadiusRatio, operation) {\n            var cappingRadius = cappingRadiusRatio * radius;\n            var minX = Math.max(0, Math.floor(centerX - cappingRadius));\n            var minY = Math.max(0, Math.floor(centerY - cappingRadius));\n            var maxX = Math.min(this.dimX() - 1, Math.ceil(centerX + cappingRadius));\n            var maxY = Math.min(this.dimY() - 1, Math.ceil(centerY + cappingRadius));\n            var radiusSq = radius * radius;\n            // Avoid too big values\n            var minDistanceSq = 1 / 1024 / 1024;\n            for (var y = minY; y <= maxY; y++) {\n                var rowValues = this.values[y];\n                for (var x = minX; x <= maxX; x++) {\n                    var distanceSq = Math.max(minDistanceSq, getDistanceSq(x, y, centerX, centerY));\n                    rowValues[x] = operation(rowValues[x], radiusSq / distanceSq);\n                }\n            }\n        };\n        /**\n         * Merge a segment in the field.\n         * @param startX {float} in grid basis\n         * @param startY {float} in grid basis\n         * @param endX {float} in grid basis\n         * @param endY {float} in grid basis\n         * @param thickness {float} in grid basis\n         * @param cappingRadiusRatio {float}\n         * @param operation {function(float, float):float}\n         */\n        ScalarField.prototype.mergeSegment = function (startX, startY, endX, endY, thickness, cappingRadiusRatio, operation) {\n            var cappingRadius = cappingRadiusRatio * thickness;\n            var minX = Math.max(0, Math.floor(Math.min(startX, endX) - cappingRadius));\n            var minY = Math.max(0, Math.floor(Math.min(startY, endY) - cappingRadius));\n            var maxX = Math.min(this.dimX() - 1, Math.ceil(Math.max(startX, endX) + cappingRadius));\n            var maxY = Math.min(this.dimY() - 1, Math.ceil(Math.max(startY, endY) + cappingRadius));\n            var thicknessSq = thickness * thickness;\n            // Avoid too big values\n            var minDistanceSq = 1 / 1024 / 1024;\n            for (var y = minY; y <= maxY; y++) {\n                var rowValues = this.values[y];\n                for (var x = minX; x <= maxX; x++) {\n                    var distanceSq = Math.max(minDistanceSq, getDistanceSqToSegment(x, y, startX, startY, endX, endY));\n                    rowValues[x] = operation(rowValues[x], thicknessSq / distanceSq);\n                }\n            }\n        };\n        /**\n         * Merge a hill in the field.\n         * @param centerX {float} in grid basis\n         * @param centerY {float} in grid basis\n         * @param height {float}\n         * @param radius {float} in grid basis\n         * @param opacity {float}\n         * @param cappingRadiusRatio {float}\n         * @param operation {function(float, float):float}\n         */\n        ScalarField.prototype.mergeHill = function (centerX, centerY, height, radius, opacity, cappingRadiusRatio, operation) {\n            var cappingRadius = cappingRadiusRatio * radius;\n            var minX = Math.max(0, Math.floor(centerX - cappingRadius));\n            var minY = Math.max(0, Math.floor(centerY - cappingRadius));\n            var maxX = Math.min(this.dimX() - 1, Math.ceil(centerX + cappingRadius));\n            var maxY = Math.min(this.dimY() - 1, Math.ceil(centerY + cappingRadius));\n            var logHeightDividedByRadiusSq = Math.log(height) / (radius * radius);\n            var opacityMultipliedByHeight = opacity * height;\n            // Avoid too big values\n            var minDistanceSq = 1 / 1024 / 1024;\n            for (var y = minY; y <= maxY; y++) {\n                var rowValues = this.values[y];\n                for (var x = minX; x <= maxX; x++) {\n                    var distanceSq = Math.max(minDistanceSq, getDistanceSq(x, y, centerX, centerY));\n                    // This is like a gaussian, but parametrized differently.\n                    rowValues[x] = operation(rowValues[x], opacityMultipliedByHeight *\n                        Math.exp(-distanceSq * logHeightDividedByRadiusSq));\n                }\n            }\n        };\n        /**\n         * Flood an area from a given location until a maximum field value is reached.\n         * @param originX {float} in grid basis\n         * @param originY {float} in grid basis\n         * @param valueMax {float}\n         * @param thickness {float}\n         * @param cappingRadiusRatio {float} the radius where to stop the contour shading\n         * @param isMinimum {boolean} when set to true, the threshold is a minimum\n         * or a maximum otherwise.\n         */\n        ScalarField.prototype.fillFrom = function (originX, originY, valueMax, thickness, cappingRadiusRatio) {\n            this.floodFill.fillFrom(originX, originY, valueMax, thickness, cappingRadiusRatio);\n        };\n        /**\n         * Flood an area from a given location until a maximum field value is reached.\n         * @param originX {float} in grid basis\n         * @param originY {float} in grid basis\n         * @param valueMax {float}\n         * @param thickness {float}\n         * @param cappingRadiusRatio {float} the radius where to stop the contour shading\n         * @param isMinimum {boolean} when set to true, the threshold is a minimum\n         * or a maximum otherwise.\n         */\n        ScalarField.prototype.unfillFrom = function (originX, originY, valueMin, thickness, cappingRadiusRatio) {\n            this.floodFill.unfillFrom(originX, originY, valueMin, thickness, cappingRadiusRatio);\n        };\n        return ScalarField;\n    }());\n\n    var South = 0;\n    var East = 1;\n    var North = 2;\n    var West = 3;\n    var SouthWest = 4;\n    var SouthEast = 5;\n    var NorthEast = 6;\n    var NorthWest = 7;\n    var SouthWestMask = 1;\n    var SouthEastMask = 2;\n    var NorthEastMask = 4;\n    var NorthWestMask = 8;\n    var marchingSquaresFillVertices = [\n        [],\n        [South, West, SouthWest],\n        [East, South, SouthEast],\n        [East, West, SouthWest, SouthEast],\n        [North, East, NorthEast],\n        [South, SouthWest, West, North, NorthEast, East],\n        [South, North, NorthEast, SouthEast],\n        [West, North, NorthEast, SouthEast, SouthWest],\n        [West, North, NorthWest],\n        [North, South, SouthWest, NorthWest],\n        [South, West, NorthWest, North, East, SouthEast],\n        [North, East, SouthEast, SouthWest, NorthWest],\n        [East, West, NorthWest, NorthEast],\n        [East, South, SouthWest, NorthWest, NorthEast],\n        [South, West, NorthWest, NorthEast, SouthEast],\n        [],\n    ];\n    var marchingSquaresOutlineVertices = [\n        [[]],\n        [[South, West]],\n        [[East, South]],\n        [[East, West]],\n        [[North, East]],\n        [\n            [East, South],\n            [West, North],\n        ],\n        [[South, North]],\n        [[West, North]],\n        [[West, North]],\n        [[North, South]],\n        [\n            [South, West],\n            [North, East],\n        ],\n        [[North, East]],\n        [[East, West]],\n        [[East, South]],\n        [[South, West]],\n        [[]],\n    ];\n    /**\n     * A marching square algorithm implementation.\n     */\n    var MarchingSquares = /** @class */ (function () {\n        /**\n         *\n         * @param scalarField\n         */\n        function MarchingSquares(scalarField) {\n            /** {FloatPoint} Avoid memory allocations when returning points */\n            this.workingPoint = [0, 0];\n            this.scalarField = scalarField;\n        }\n        /**\n         * @param x {integer} the square top in the grid\n         * @param y {integer} the square left in the grid\n         * @param threshold {float}\n         * @return {integer} one of the 16 marching squares cases\n         */\n        MarchingSquares.prototype.getSquareIndex = function (x, y, threshold) {\n            /** @type {float} */\n            var squareIndex = 0;\n            if (this.scalarField.get(x, y + 1) > threshold) {\n                squareIndex |= SouthWestMask;\n            }\n            if (this.scalarField.get(x + 1, y + 1) > threshold) {\n                squareIndex |= SouthEastMask;\n            }\n            if (this.scalarField.get(x + 1, y) > threshold) {\n                squareIndex |= NorthEastMask;\n            }\n            if (this.scalarField.get(x, y) > threshold) {\n                squareIndex |= NorthWestMask;\n            }\n            return squareIndex;\n        };\n        /**\n         * Returns the mean between 2 corners weighted by their field value.\n         * @param indexX1 {integer} first corner x\n         * @param indexY1 {integer} first corner y\n         * @param indexX2 {integer} second corner x\n         * @param indexY2 {integer} second corner y\n         * @param threshold {float}\n         * @return {float} x in the grid\n         */\n        MarchingSquares.prototype.betweenX = function (indexX1, indexY1, indexX2, indexY2, threshold) {\n            var value1 = this.scalarField.get(indexX1, indexY1);\n            var value2 = this.scalarField.get(indexX2, indexY2);\n            var weight1 = Math.abs(value1 - threshold);\n            var weight2 = Math.abs(value2 - threshold);\n            return (weight2 * indexX1 + weight1 * indexX2) / (weight1 + weight2);\n        };\n        /**\n         * Returns the mean between 2 corners weighted by their field value.\n         * @param indexX1 {integer} first corner x\n         * @param indexY1 {integer} first corner y\n         * @param indexX2 {integer} second corner x\n         * @param indexY2 {integer} second corner y\n         * @param threshold {float}\n         * @return {float} y in the grid\n         */\n        MarchingSquares.prototype.betweenY = function (indexX1, indexY1, indexX2, indexY2, threshold) {\n            var value1 = this.scalarField.get(indexX1, indexY1);\n            var value2 = this.scalarField.get(indexX2, indexY2);\n            var weight1 = Math.abs(value1 - threshold);\n            var weight2 = Math.abs(value2 - threshold);\n            return (weight2 * indexY1 + weight1 * indexY2) / (weight1 + weight2);\n        };\n        /**\n         * @param side {integer} point location\n         * @param indexX {integer} the square top in the grid\n         * @param indexY {integer} the square left in the grid\n         * @param threshold {float}\n         * @param point {FloatPoint} is the result\n         */\n        MarchingSquares.prototype.calcPoint = function (side, indexX, indexY, threshold, point) {\n            var gridX = 0;\n            var gridY = 0;\n            switch (side) {\n                case South:\n                    gridY = indexY + 1;\n                    gridX = this.betweenX(indexX, gridY, indexX + 1, gridY, threshold);\n                    break;\n                case East:\n                    gridX = indexX + 1;\n                    gridY = this.betweenY(gridX, indexY, gridX, indexY + 1, threshold);\n                    break;\n                case North:\n                    gridY = indexY;\n                    gridX = this.betweenX(indexX, gridY, indexX + 1, gridY, threshold);\n                    break;\n                case West:\n                    gridX = indexX;\n                    gridY = this.betweenY(gridX, indexY, gridX, indexY + 1, threshold);\n                    break;\n                case SouthWest:\n                    gridX = indexX;\n                    gridY = indexY + 1;\n                    break;\n                case SouthEast:\n                    gridX = indexX + 1;\n                    gridY = indexY + 1;\n                    break;\n                case NorthEast:\n                    gridX = indexX + 1;\n                    gridY = indexY;\n                    break;\n                case NorthWest:\n                    gridX = indexX;\n                    gridY = indexY;\n                    break;\n            }\n            point[0] = gridX;\n            point[1] = gridY;\n        };\n        /**\n         * Draw the field squares\n         * @param minX {integer} left\n         * @param minY {integer} top\n         * @param maxX {integer} right\n         * @param maxY {integer} bottom\n         * @param threshold {float}\n         * @param drawUnder {boolean}\n         * @param shapePainter {ShapePainter}\n         */\n        MarchingSquares.prototype.fillContour = function (minX, minY, maxX, maxY, threshold, drawUnder, shapePainter) {\n            var point = this.workingPoint;\n            // It draws bands and small polygons.\n            // The contour line is in a second loop, it's more efficient\n            // than switching the style constantly.\n            for (var squareY = minY; squareY < maxY - 1; squareY++) {\n                // for run-length encoding\n                var first15SquareX = -1;\n                for (var squareX = minX; squareX < maxX - 1; squareX++) {\n                    var squareIndex = this.getSquareIndex(squareX, squareY, threshold);\n                    if (drawUnder) {\n                        squareIndex = 15 - squareIndex;\n                    }\n                    if (squareIndex === 15) {\n                        shapePainter.onFilledSquareChange(squareX, squareY);\n                    }\n                    if (first15SquareX === -1 && squareIndex === 15) {\n                        first15SquareX = squareX;\n                    }\n                    if (first15SquareX !== -1) {\n                        if (squareIndex !== 15) {\n                            shapePainter.drawRectangle(first15SquareX, squareY, squareX, squareY + 1);\n                            first15SquareX = -1;\n                        }\n                        else if (squareX === maxX - 2) {\n                            shapePainter.drawRectangle(first15SquareX, squareY, squareX + 1, squareY + 1);\n                            first15SquareX = -1;\n                        }\n                    }\n                    if (squareIndex !== 0 && squareIndex !== 15) {\n                        var fillVertices = marchingSquaresFillVertices[squareIndex];\n                        this.calcPoint(fillVertices[0], squareX, squareY, threshold, point);\n                        shapePainter.beginPath(point[0], point[1]);\n                        for (var index = 1; index < fillVertices.length; index++) {\n                            this.calcPoint(fillVertices[index], squareX, squareY, threshold, point);\n                            shapePainter.lineTo(point[0], point[1]);\n                        }\n                        shapePainter.closePath();\n                        shapePainter.endPath(squareX, squareY);\n                    }\n                }\n            }\n        };\n        /**\n         * Draw the field squares\n         * @param minX {integer} left\n         * @param minY {integer} top\n         * @param maxX {integer} right\n         * @param maxY {integer} bottom\n         * @param threshold {float}\n         * @param drawUnder {boolean}\n         * @param shapePainter {ShapePainter}\n         */\n        MarchingSquares.prototype.outlineContour = function (minX, minY, maxX, maxY, threshold, drawUnder, shapePainter) {\n            var point = this.workingPoint;\n            for (var squareY = minY; squareY < maxY - 1; squareY++) {\n                for (var squareX = minX; squareX < maxX - 1; squareX++) {\n                    var squareIndex = this.getSquareIndex(squareX, squareY, threshold);\n                    if (drawUnder) {\n                        squareIndex = 15 - squareIndex;\n                    }\n                    if (squareIndex !== 0 && squareIndex !== 15) {\n                        for (var _i = 0, _a = marchingSquaresOutlineVertices[squareIndex]; _i < _a.length; _i++) {\n                            var outlineVertices = _a[_i];\n                            this.calcPoint(outlineVertices[0], squareX, squareY, threshold, point);\n                            shapePainter.beginPath(point[0], point[1]);\n                            for (var index = 1; index < outlineVertices.length; index++) {\n                                this.calcPoint(outlineVertices[index], squareX, squareY, threshold, point);\n                                shapePainter.lineTo(point[0], point[1]);\n                            }\n                            shapePainter.endPath(squareX, squareY);\n                        }\n                    }\n                }\n            }\n        };\n        return MarchingSquares;\n    }());\n\n    /**\n     * A coordinate converter between a surface and a grid.\n     */\n    var CoordConverter = /** @class */ (function () {\n        /**\n         * Create a coordinate converter between a surface and a grid.\n         * @param cellWidth {float}\n         * @param cellHeight {float}\n         * @param left {float}\n         * @param top {float}\n         * @param right {float}\n         * @param bottom {float}\n         */\n        function CoordConverter(cellWidth, cellHeight, left, top, right, bottom) {\n            this.cellWidth = cellWidth;\n            this.cellHeight = cellHeight;\n            this.left = left;\n            this.top = top;\n            this.right = right;\n            this.bottom = bottom;\n        }\n        /**\n         * @param x {float} in the scene basis\n         * @return {float} x in the grid basis\n         */\n        CoordConverter.prototype.convertToGridBasisX = function (x) {\n            return (x - this.left) / this.cellWidth;\n        };\n        /**\n         * @param y {float} in the scene basis\n         * @return {float} y in the grid basis\n         */\n        CoordConverter.prototype.convertToGridBasisY = function (y) {\n            return (y - this.top) / this.cellHeight;\n        };\n        /**\n         * @param x {float} in the grid basis\n         * @return {float} x in the scene basis\n         */\n        CoordConverter.prototype.convertFromGridBasisX = function (x) {\n            return x * this.cellWidth + this.left;\n        };\n        /**\n         * @param y {float} in the grid basis\n         * @return {float} y in the scene basis\n         */\n        CoordConverter.prototype.convertFromGridBasisY = function (y) {\n            return y * this.cellHeight + this.top;\n        };\n        /**\n         * @param distance {float} in the grid basis\n         * @return {float} distance in the scene basis\n         */\n        CoordConverter.prototype.convertToGridBasisDistance = function (distance) {\n            return distance / this.cellWidth;\n        };\n        return CoordConverter;\n    }());\n\n    /**\n     * A height map.\n     */\n    var HeightMap = /** @class */ (function () {\n        /**\n         * Create a height map.\n         * @param scalarField {ScalarField} a scalar field for the height values.\n         * @param coordConverter {CoordConverter} a coordinate converter between the\n         * surface and the scalar field grid.\n         */\n        function HeightMap(scalarField, coordConverter) {\n            this.scalarField = scalarField;\n            this.coordConverter = coordConverter;\n        }\n        /**\n         * @param pointX {float} in terrain basis\n         * @param pointY {float} in terrain basis\n         * @param normal {[float, float, float]} the result\n         * @return {[float, float, float]} the result\n         */\n        HeightMap.prototype.getFieldNormal = function (pointX, pointY, normal) {\n            if (!normal) {\n                normal = [0, 0, 0];\n            }\n            var x = this.coordConverter.convertToGridBasisX(pointX);\n            var y = this.coordConverter.convertToGridBasisY(pointY);\n            var squareX = Math.floor(x);\n            var squareY = Math.floor(y);\n            if (squareX < 0 ||\n                squareY < 0 ||\n                squareX >= this.scalarField.dimX() ||\n                squareY >= this.scalarField.dimY()) {\n                return null;\n            }\n            // This gives very approximating values on borders\n            // but it's the easiest way to avoid to be out of bounds.\n            // Why 1 but dim - 3?\n            // - 1 margin for the normal calculus on both side\n            // - 1 extra because extrapolation asks values on right and bottom.\n            if (squareX < 1) {\n                squareX = 1;\n                x = squareX;\n            }\n            if (squareX > this.scalarField.dimX() - 3) {\n                squareX = this.scalarField.dimX() - 3;\n                x = squareX;\n            }\n            if (squareY < 1) {\n                squareY = 1;\n                y = squareY;\n            }\n            if (squareY > this.scalarField.dimY() - 3) {\n                squareY = this.scalarField.dimY() - 3;\n                y = squareY;\n            }\n            // Extrapolate\n            var weighedValueSumX = 0;\n            var weighedValueSumY = 0;\n            var weighedValueSumZ = 0;\n            for (var vertexX = squareX; vertexX <= squareX + 1; vertexX++) {\n                for (var vertexY = squareY; vertexY <= squareY + 1; vertexY++) {\n                    normal[0] = 0;\n                    normal[1] = 0;\n                    normal[2] = 0;\n                    this.addGridPointNormal(vertexX, vertexY, normal);\n                    var dx = vertexX - x;\n                    var dy = vertexY - y;\n                    if (dx === 0 && dy === 0) {\n                        // Double break, no interpolation needed.\n                        vertexX += 2;\n                        vertexY += 2;\n                    }\n                    else {\n                        var distance = Math.hypot(dx, dy);\n                        weighedValueSumX += normal[0] / distance;\n                        weighedValueSumY += normal[1] / distance;\n                        weighedValueSumZ += normal[2] / distance;\n                    }\n                }\n            }\n            var length = Math.hypot(normal[0], normal[1], normal[2]);\n            normal[0] /= length;\n            normal[1] /= length;\n            normal[2] /= length;\n            return normal;\n        };\n        /**\n         * @param pointX {float} in terrain basis\n         * @param pointY {float} in terrain basis\n         * @return {float} the field value\n         */\n        HeightMap.prototype.getHeight = function (pointX, pointY) {\n            var x = this.coordConverter.convertToGridBasisX(pointX);\n            var y = this.coordConverter.convertToGridBasisY(pointY);\n            return this.scalarField.extrapolate(x, y);\n        };\n        /**\n         * Evaluate the normal at a given grid point.\n         *\n         * The normal is not normalized.\n         *\n         * @param x {integer} grid index\n         * @param y {integer} grid index\n         * @param normal {[float, float, float]} the result\n         */\n        HeightMap.prototype.addGridPointNormal = function (x, y, normal) {\n            var z = this.scalarField.get(x, y);\n            var rightX = 1;\n            var rightY = 0;\n            var rightZ = this.scalarField.get(x + 1, y) - z;\n            var rightLength = Math.hypot(rightX, rightZ);\n            rightX /= rightLength;\n            rightZ /= rightLength;\n            var leftX = -1;\n            var leftY = 0;\n            var leftZ = this.scalarField.get(x - 1, y) - z;\n            var leftLength = Math.hypot(leftX, leftZ);\n            leftX /= leftLength;\n            leftZ /= leftLength;\n            var bottomX = 0;\n            var bottomY = 1;\n            var bottomZ = this.scalarField.get(x, y + 1) - z;\n            var bottomLength = Math.hypot(bottomY, bottomZ);\n            bottomY /= bottomLength;\n            bottomZ /= bottomLength;\n            var topX = 0;\n            var topY = -1;\n            var topZ = this.scalarField.get(x, y - 1) - z;\n            var topLength = Math.hypot(topY, topZ);\n            topY /= topLength;\n            topZ /= topLength;\n            // The mean of the normal of the 4 triangles around the grid point.\n            this.addNormal(topX, topY, topZ, rightX, rightY, rightZ, normal);\n            this.addNormal(rightX, rightY, rightZ, bottomX, bottomY, bottomZ, normal);\n            this.addNormal(bottomX, bottomY, bottomZ, leftX, leftY, leftZ, normal);\n            this.addNormal(leftX, leftY, leftZ, topX, topY, topZ, normal);\n        };\n        /**\n         * @param uX {float}\n         * @param uY {float}\n         * @param uZ {float}\n         * @param vX {float}\n         * @param vY {float}\n         * @param vZ {float}\n         * @param normal {[float, float, float]} the result\n         */\n        HeightMap.prototype.addNormal = function (uX, uY, uZ, vX, vY, vZ, normal) {\n            normal[0] += uY * vZ - uZ * vY;\n            normal[1] += uZ * vX - uX * vZ;\n            normal[2] += uX * vY - uY * vX;\n        };\n        /**\n         * Clear the field by filling it with a give value.\n         * @param value {float}\n         */\n        HeightMap.prototype.clear = function (value) {\n            if (value === void 0) { value = 0; }\n            this.scalarField.clear(value);\n        };\n        /**\n         * Cap the field between 2 values.\n         * @param min {float}\n         * @param max {float}\n         */\n        HeightMap.prototype.clamp = function (min, max) {\n            this.scalarField.clamp(min, max);\n        };\n        /**\n         * Apply an affine transformation on each field value.\n         * @param a {float} factor\n         * @param b {float} offset\n         */\n        HeightMap.prototype.transform = function (a, b) {\n            this.scalarField.transform(a, b);\n        };\n        /**\n         * Merge a disk in the field.\n         * @param centerX {float} in terrain basis\n         * @param centerY {float} in terrain basis\n         * @param radius {float} in terrain basis\n         * @param cappingRadiusRatio {float}\n         * @param operation {function(float, float):float}\n         */\n        HeightMap.prototype.mergeDisk = function (centerX, centerY, radius, cappingRadiusRatio, operation) {\n            this.scalarField.mergeDisk(this.coordConverter.convertToGridBasisX(centerX), this.coordConverter.convertToGridBasisY(centerY), this.coordConverter.convertToGridBasisDistance(radius), cappingRadiusRatio, operation);\n        };\n        /**\n         * Merge a segment in the field.\n         * @param startX {float} in terrain basis\n         * @param startY {float} in terrain basis\n         * @param endX {float} in terrain basis\n         * @param endY {float} in terrain basis\n         * @param thickness {float} in terrain basis\n         * @param cappingRadiusRatio {float}\n         * @param operation {function(float, float):float}\n         */\n        HeightMap.prototype.mergeSegment = function (startX, startY, endX, endY, thickness, cappingRadiusRatio, operation) {\n            this.scalarField.mergeSegment(this.coordConverter.convertToGridBasisX(startX), this.coordConverter.convertToGridBasisY(startY), this.coordConverter.convertToGridBasisX(endX), this.coordConverter.convertToGridBasisY(endY), this.coordConverter.convertToGridBasisDistance(thickness), cappingRadiusRatio, operation);\n        };\n        /**\n         * Merge a hill in the field.\n         * @param centerX {float} in terrain basis\n         * @param centerY {float} in terrain basis\n         * @param height {float}\n         * @param radius {float} in terrain basis\n         * @param opacity {float}\n         * @param cappingRadiusRatio {float}\n         * @param operation {function(float, float):float}\n         */\n        HeightMap.prototype.mergeHill = function (centerX, centerY, height, radius, opacity, cappingRadiusRatio, operation) {\n            this.scalarField.mergeHill(this.coordConverter.convertToGridBasisX(centerX), this.coordConverter.convertToGridBasisY(centerY), height, this.coordConverter.convertToGridBasisDistance(radius), opacity, cappingRadiusRatio, operation);\n        };\n        /**\n         * Flood an area from a given location until a maximum field value is reached.\n         * @param originX {float} in terrain basis\n         * @param originY {float} in terrain basis\n         * @param valueMax {float}\n         * @param thickness {float}\n         * @param cappingRadiusRatio {float} the radius where to stop the contour shading\n         * @param isMinimum {boolean} when set to true, the threshold is a minimum\n         * or a maximum otherwise.\n         */\n        HeightMap.prototype.fillFrom = function (originX, originY, valueMax, thickness, cappingRadiusRatio) {\n            this.scalarField.fillFrom(this.coordConverter.convertToGridBasisX(originX), this.coordConverter.convertToGridBasisY(originY), valueMax, this.coordConverter.convertToGridBasisDistance(thickness), cappingRadiusRatio);\n        };\n        /**\n         * Flood an area from a given location until a maximum field value is reached.\n         * @param originX {float} in terrain basis\n         * @param originY {float} in terrain basis\n         * @param valueMax {float}\n         * @param thickness {float}\n         * @param cappingRadiusRatio {float} the radius where to stop the contour shading\n         * @param isMinimum {boolean} when set to true, the threshold is a minimum\n         * or a maximum otherwise.\n         */\n        HeightMap.prototype.unfillFrom = function (originX, originY, valueMax, thickness, cappingRadiusRatio) {\n            this.scalarField.unfillFrom(this.coordConverter.convertToGridBasisX(originX), this.coordConverter.convertToGridBasisY(originY), valueMax, this.coordConverter.convertToGridBasisDistance(thickness), cappingRadiusRatio);\n        };\n        return HeightMap;\n    }());\n\ngdjs.__marchingSquaresExtension = gdjs.__marchingSquaresExtension || {};\ngdjs.__marchingSquaresExtension.CoordConverter = CoordConverter;\ngdjs.__marchingSquaresExtension.HeightMap = HeightMap;\ngdjs.__marchingSquaresExtension.MarchingSquares = MarchingSquares;\ngdjs.__marchingSquaresExtension.ScalarField = ScalarField;\n",
          "parameterObjects": "",
          "useStrict": true,
          "eventsSheetExpanded": true
        }
      ],
      "parameters": [],
      "objectGroups": []
    },
    {
      "description": "Define helper classes JavaScript code.",
      "fullName": "Define helper classes",
      "functionType": "Action",
      "group": "",
      "name": "DefineHelperClasses",
      "private": true,
      "sentence": "Define helper classes JavaScript code",
      "events": [
        {
          "type": "BuiltinCommonInstructions::JsCode",
          "inlineCode": "gdjs.__marchingSquaresExtension = gdjs.__marchingSquaresExtension || {};\n\nconst parseOperation = function (operation) {\nswitch (operation) {\n    case \"Addition\":\n    return (value1, value2) => value1 + value2;\n    case \"Subtraction\":\n    return (value1, value2) => value1 - value2;\n    case \"Multiplication\":\n    return (value1, value2) => value1 * value2;\n    case \"Division\":\n    return (value1, value2) => value1 / value2;\n    case \"Minimum\":\n    return Math.min;\n    case \"Maximum\":\n    default:\n    return Math.max;\n}\nreturn;\n}\n\nconst HitboxesIterable = /** @class */ (function () {\n  /**\n   * The hitboxes in a rectangular area.\n   * @constructor\n         * @param {any} behavior\n         * @param {integer} xMin The fist column to include.\n         * @param {integer} yMin The fist row to include.\n         * @param {integer} xMax The last column to include.\n         * @param {integer} yMax The last row to include.\n   */\n  function HitboxesIterable(\n    behavior,\n    xMin,\n    yMin,\n    xMax,\n    yMax\n  ) {\n    this.behavior = behavior;\n    this.xMin = xMin;\n    this.yMin = yMin;\n    this.xMax = xMax;\n    this.yMax = yMax;\n  };\n\n  HitboxesIterable.prototype.setBounds = function (\n    xMin,\n    yMin,\n    xMax,\n    yMax\n  ) {\n    this.xMin = xMin;\n    this.yMin = yMin;\n    this.xMax = xMax;\n    this.yMax = yMax;\n  }\n\n  HitboxesIterable.prototype[Symbol.iterator] = function () {\n    // xMin and yMin next increment\n    let x = this.xMax;\n    let y = this.yMin - 1;\n    let hitbox = null;\n    let previousHitbox = null;\n    /** @type {IteratorReturnResult<gdjs.Polygon>} */\n    const result = { done: false, value: undefined };\n\n    return {\n      next: () => {\n        do {\n          x++;\n          if (x > this.xMax) {\n            y++;\n            x = this.xMin;\n          }\n          if (y > this.yMax) {\n            // done\n            result.done = true;\n            result.value = undefined;\n            return result;\n          }\n          hitbox = this.behavior.getHitbox(x, y);\n        }\n        while (!hitbox || hitbox === previousHitbox);\n\n        // happen with run-length encoding\n        previousHitbox = hitbox;\n        result.done = false;\n        result.value = hitbox;\n        return result;\n      },\n    };\n  };\n    return HitboxesIterable;\n}());\n\ngdjs.__marchingSquaresExtension = gdjs.__marchingSquaresExtension || {};\ngdjs.__marchingSquaresExtension.parseOperation = parseOperation;\ngdjs.__marchingSquaresExtension.HitboxesIterable = HitboxesIterable;\n",
          "parameterObjects": "",
          "useStrict": true,
          "eventsSheetExpanded": true
        }
      ],
      "parameters": [],
      "objectGroups": []
    }
  ],
  "eventsBasedBehaviors": [
    {
      "description": "Add to a Shape painter object and use the actions to draw a field. Useful for fog of wars, liquid effects (water, lava, blobs...).",
      "fullName": "Marching squares painter",
      "name": "MarchingSquaresBehavior",
      "objectType": "PrimitiveDrawing::Drawer",
      "eventsFunctions": [
        {
          "description": "Extend behavior class",
          "fullName": "Extend behavior class",
          "functionType": "Action",
          "group": "",
          "name": "ExtendBehaviorClass",
          "private": true,
          "sentence": "Extend behavior class",
          "events": [
            {
              "type": "BuiltinCommonInstructions::JsCode",
              "inlineCode": "const game = runtimeScene.getGame();\nconst behaviorName = eventsFunctionContext.getBehaviorName(\"Behavior\");\n\nconst behavior = objects[0].getBehavior(behaviorName);\n\nconst prototype = Object.getPrototypeOf(behavior);\nif (!prototype.drawField) {\n\n  prototype.createField = function () {\n    /** @type {float} */\n    const left = this._getAreaLeftBound();\n    /** @type {float} */\n    const top = this._getAreaTopBound();\n    /** @type {float} */\n    const right = this._getAreaRightBound();\n    /** @type {float} */\n    const bottom = this._getAreaBottomBound();\n    /** @type {float} */\n    const cellWidth = this._getCellWidth();\n    /** @type {float} */\n    const cellHeight = this._getCellHeight();\n\n    // Build the scalar field\n    const dimX = 1 + Math.ceil((right - left) / cellWidth);\n    const dimY = 1 + Math.ceil((bottom - top) / cellHeight);\n    const scalarField = new gdjs.__marchingSquaresExtension.ScalarField(dimX, dimY);\n    this.scalarField = scalarField;\n    \n    const coordConverter = new gdjs.__marchingSquaresExtension.CoordConverter(\n      cellWidth,\n      cellHeight,\n      left,\n      top,\n      right,\n      bottom);\n    this.coordConverter = coordConverter;\n\n    const heightMap = new gdjs.__marchingSquaresExtension.HeightMap(scalarField, coordConverter);\n    this.heightMap = heightMap;\n\n    const marchingSquares = new gdjs.__marchingSquaresExtension.MarchingSquares(scalarField);\n    this.marchingSquares = marchingSquares;\n\n    /** @type {gdjs.Polygon[][]} */\n    const hitboxTiles = new Array(dimY);\n    for (var y = 0; y < dimY; y++) {\n      hitboxTiles[y] = new Array(dimX).fill(null);\n    }\n    this.hitboxTiles = hitboxTiles;\n  }\n\n  /**\n   * @param pointX {float} in scene basis\n   * @param pointY {float} in scene basis\n   * @return {boolean} true if the point is inside the contour\n   */\n  prototype.containsPoint = function (\n    pointX,\n    pointY,\n  ) {\n    /** @type {boolean} */\n    const drawUnder = this._getFillOutside();\n\n    // It's a bit more precise than the contour\n    // so it's not completly accurate.\n    return !drawUnder && this.heightMap.getHeight(pointX, pointY) > this._getThreshold() ||\n      drawUnder && this.heightMap.getHeight(pointX, pointY) < this._getThreshold();\n  }\n\n  /**\n   * Draw the field squares\n   * @param minX {integer} left\n   * @param minY {integer} top\n   * @param maxX {integer} right\n   * @param maxY {integer} bottom\n   */\n  prototype.drawField = function (\n    minX,\n    minY,\n    maxX,\n    maxY\n  ) {\n    /** @type {boolean} */\n    const drawUnder = this._getFillOutside();\n    /** @type {gdjs.ShapePainterRuntimeObject} */\n    const shapePainter = this.owner;\n    /** @type {float} */\n    const threshold = this._getThreshold();\n\n    const fillOpacity = shapePainter.getFillOpacity();\n    const outlineSize = shapePainter.getOutlineSize();\n\n    // It draws bands and small polygons.\n    // The contour line is in a second loop, it's more efficient\n    // than switching the style constantly.\n\n    const that = this;\n    // fill\n    if (fillOpacity !== 0) {\n      shapePainter.setOutlineSize(0);\n      this.marchingSquares.fillContour(\n        minX,\n        minY,\n        maxX,\n        maxY,\n        threshold,\n        drawUnder,\n        {\n          drawRectangle(left, top, right, bottom) {\n            shapePainter.drawRectangle(\n              that.coordConverter.convertFromGridBasisX(left),\n              that.coordConverter.convertFromGridBasisY(top),\n              that.coordConverter.convertFromGridBasisX(right),\n              that.coordConverter.convertFromGridBasisY(bottom));\n          },\n          beginPath(x, y) {\n            shapePainter.beginFillPath(\n              that.coordConverter.convertFromGridBasisX(x),\n              that.coordConverter.convertFromGridBasisY(y));\n          },\n          lineTo(x, y) {\n            shapePainter.drawPathLineTo(\n              that.coordConverter.convertFromGridBasisX(x),\n              that.coordConverter.convertFromGridBasisY(y));\n          },\n          closePath() {\n            shapePainter.closePath();\n          },\n          endPath() {\n            shapePainter.endFillPath();\n          },\n          onFilledSquareChange(x, y) {\n\n          }\n        }\n      );\n      shapePainter.setOutlineSize(outlineSize);\n    }\n    // outline\n    if (outlineSize !== 0) {\n      shapePainter.setFillOpacity(0);\n      this.marchingSquares.outlineContour(\n        minX,\n        minY,\n        maxX,\n        maxY,\n        threshold,\n        drawUnder,\n        {\n          drawRectangle(left, top, right, bottom) {\n          },\n          beginPath(x, y) {\n            shapePainter.beginFillPath(\n              that.coordConverter.convertFromGridBasisX(x),\n              that.coordConverter.convertFromGridBasisY(y));\n          },\n          lineTo(x, y) {\n            shapePainter.drawPathLineTo(\n              that.coordConverter.convertFromGridBasisX(x),\n              that.coordConverter.convertFromGridBasisY(y));\n          },\n          closePath() {\n            shapePainter.closePath();\n          },\n          endPath() {\n            shapePainter.endFillPath();\n          },\n          onFilledSquareChange(x, y) {\n\n          }\n        }\n      );\n    }\n    shapePainter.setFillOpacity(fillOpacity);\n  }\n\n  /**\n   * Update the field hitboxes\n   * @param minX {integer} left\n   * @param minY {integer} top\n   * @param maxX {integer} right\n   * @param maxY {integer} bottom\n   */\n  prototype.updateMarchingSquareHitboxes = function (\n    minX,\n    minY,\n    maxX,\n    maxY\n  ) {\n    /** @type {boolean} */\n    const drawUnder = this._getFillOutside();\n    /** @type {float} */\n    const threshold = this._getThreshold();\n    /** @type {gdjs.ShapePainterRuntimeObject} */\n    const shapePainter = this.owner;\n\n    const point = this.workingPoint;\n\n    // Move all Polygons to recycledPolygons\n    if (this.recycledPolygons.length < shapePainter._defaultHitBoxes.length) {\n      const swapPolygons = this.recycledPolygons;\n      this.recycledPolygons = shapePainter._defaultHitBoxes;\n      shapePainter._defaultHitBoxes = swapPolygons;\n    }\n    const hitboxes = shapePainter._defaultHitBoxes;\n    this.recycledPolygons.push.apply(this, hitboxes);\n    hitboxes.length = 0;\n\n    for (const hitboxRowTiles of this.hitboxTiles) {\n      hitboxRowTiles.fill(null);\n    }\n    /** @type {gdjs.Polygon} */\n    let currentRectangle = null;\n    /** @type {gdjs.Polygon} */\n    let currentPolygon = null;\n    const that = this;\n    this.marchingSquares.fillContour(\n      minX,\n      minY,\n      maxX,\n      maxY,\n      threshold,\n      drawUnder,\n      {\n        drawRectangle(left, top, right, bottom) {\n          left = that.coordConverter.convertFromGridBasisX(left);\n          top = that.coordConverter.convertFromGridBasisY(top);\n          right = that.coordConverter.convertFromGridBasisX(right);\n          bottom = that.coordConverter.convertFromGridBasisY(bottom);\n          const vertices = currentRectangle.vertices;\n\n          vertices.length = 4;\n          vertices[0] || (vertices[0] = [0, 0]);\n          vertices[1] || (vertices[1] = [0, 0]);\n          vertices[2] || (vertices[2] = [0, 0]);\n          vertices[3] || (vertices[3] = [0, 0]);\n\n          vertices[0][0] = left;\n          vertices[0][1] = top;\n\n          vertices[1][0] = right;\n          vertices[1][1] = top;\n\n          vertices[2][0] = right;\n          vertices[2][1] = bottom;\n\n          vertices[3][0] = left;\n          vertices[3][1] = bottom;\n          hitboxes.push(currentRectangle);\n          currentRectangle = null;\n        },\n        beginPath(x, y) {\n          currentPolygon = that.recycledPolygons.length === 0 ? new gdjs.Polygon() : that.recycledPolygons.pop();\n          currentPolygon.vertices.length = 0;\n          currentPolygon.vertices.push([\n            that.coordConverter.convertFromGridBasisX(x),\n            that.coordConverter.convertFromGridBasisY(y)]);\n        },\n        lineTo(x, y) {\n          currentPolygon.vertices.push([\n            that.coordConverter.convertFromGridBasisX(x),\n            that.coordConverter.convertFromGridBasisY(y)]);\n        },\n        closePath() {\n        },\n        endPath(squareX, squareY) {\n          hitboxes.push(currentPolygon);\n          that.hitboxTiles[squareY][squareX] = currentPolygon;\n        },\n        onFilledSquareChange(squareX, squareY) {\n          if (!currentRectangle) {\n            currentRectangle = that.recycledPolygons.length === 0 ? new gdjs.Polygon() : that.recycledPolygons.pop();\n          }\n          that.hitboxTiles[squareY][squareX] = currentRectangle;\n        }\n      }\n    );\n\n    shapePainter.hitBoxes = hitboxes;\n    shapePainter.hitBoxesDirty = false;\n    shapePainter.aabb.min[0] = this._getAreaLeftBound();\n    shapePainter.aabb.min[1] = this._getAreaTopBound();\n    shapePainter.aabb.max[0] = shapePainter.aabb.min[0] + (this.scalarField.dimX() - 1) * this._getCellWidth();\n    shapePainter.aabb.max[1] = shapePainter.aabb.min[1] + (this.scalarField.dimY() - 1) * this._getCellHeight();\n  }\n\n  /**\n   * @param squareX {integer} x grid index\n   * @param squareY {integer} y grid index\n   * @return {gdjs.Polygon}\n   */\n  prototype.getHitbox = function (squareX, squareY) {\n    return this.hitboxTiles[squareY][squareX];\n  }\n}\n\n\n",
              "parameterObjects": "Object",
              "useStrict": true,
              "eventsSheetExpanded": true
            }
          ],
          "parameters": [
            {
              "codeOnly": false,
              "defaultValue": "",
              "description": "Object",
              "longDescription": "",
              "name": "Object",
              "optional": false,
              "supplementaryInformation": "PrimitiveDrawing::Drawer",
              "type": "object"
            },
            {
              "codeOnly": false,
              "defaultValue": "",
              "description": "Behavior",
              "longDescription": "",
              "name": "Behavior",
              "optional": false,
              "supplementaryInformation": "MarchingSquares::MarchingSquaresBehavior",
              "type": "behavior"
            }
          ],
          "objectGroups": []
        },
        {
          "description": "Extend object instance prototype.",
          "fullName": "Extend object instance prototype",
          "functionType": "Action",
          "group": "",
          "name": "ExtendObjectInstancePrototype",
          "private": true,
          "sentence": "Extend _PARAM0_ prototype",
          "events": [
            {
              "type": "BuiltinCommonInstructions::JsCode",
              "inlineCode": "const game = runtimeScene.getGame();\nconst behaviorName = eventsFunctionContext.getBehaviorName(\"Behavior\");\n\nconst behavior = objects[0].getBehavior(behaviorName);\n\n/**\n * @type {Iterable<gdjs.Polygon>}\n */\nbehavior.marchingSquaresHitBoxesIterable = new gdjs.__marchingSquaresExtension.HitboxesIterable(behavior, 0, 0, 0, 0);\n\n/** @type {gdjs.Polygon[]} Avoid allocations when updating hitboxes*/\nbehavior.recycledPolygons = [];\n\nbehavior.owner.updateHitBoxes = function () {\n  this.hitBoxesDirty = false;\n}\n\nbehavior.owner.getHitBoxesAround = function (\n  left,\n  top,\n  right,\n  bottom\n) {\n  const leftIndex = Math.max(0, Math.floor(behavior.coordConverter.convertToGridBasisX(left)));\n  const topIndex = Math.max(0, Math.floor(behavior.coordConverter.convertToGridBasisY(top)));\n  const rightIndex = Math.min(behavior.scalarField.dimX() - 1, Math.ceil(behavior.coordConverter.convertToGridBasisX(right)));\n  const bottomIndex = Math.min(behavior.scalarField.dimY() - 1, Math.ceil(behavior.coordConverter.convertToGridBasisY(bottom)));\n  /** @type {Iterable<gdjs.Polygon>} */\n  const iterable = behavior.marchingSquaresHitBoxesIterable;\n  iterable.setBounds(leftIndex, topIndex, rightIndex, bottomIndex);\n  return iterable;\n}\n",
              "parameterObjects": "Object",
              "useStrict": true,
              "eventsSheetExpanded": true
            }
          ],
          "parameters": [
            {
              "codeOnly": false,
              "defaultValue": "",
              "description": "Object",
              "longDescription": "",
              "name": "Object",
              "optional": false,
              "supplementaryInformation": "PrimitiveDrawing::Drawer",
              "type": "object"
            },
            {
              "codeOnly": false,
              "defaultValue": "",
              "description": "Behavior",
              "longDescription": "",
              "name": "Behavior",
              "optional": false,
              "supplementaryInformation": "MarchingSquares::MarchingSquaresBehavior",
              "type": "behavior"
            }
          ],
          "objectGroups": []
        },
        {
          "description": "",
          "fullName": "",
          "functionType": "Action",
          "group": "",
          "name": "onCreated",
          "private": false,
          "sentence": "",
          "events": [
            {
              "type": "BuiltinCommonInstructions::Standard",
              "conditions": [
                {
                  "type": {
                    "value": "MarchingSquares::MarchingSquaresBehavior::PropertyAreaRightBound"
                  },
                  "parameters": [
                    "Object",
                    "Behavior",
                    "<=",
                    "Object.Behavior::PropertyAreaLeftBound()"
                  ]
                }
              ],
              "actions": [
                {
                  "type": {
                    "value": "MarchingSquares::MarchingSquaresBehavior::SetPropertyAreaRightBound"
                  },
                  "parameters": [
                    "Object",
                    "Behavior",
                    "=",
                    "Object.Behavior::AreaLeft() + SceneWindowWidth()"
                  ]
                }
              ]
            },
            {
              "type": "BuiltinCommonInstructions::Standard",
              "conditions": [
                {
                  "type": {
                    "value": "MarchingSquares::MarchingSquaresBehavior::PropertyAreaBottomBound"
                  },
                  "parameters": [
                    "Object",
                    "Behavior",
                    "<=",
                    "Object.Behavior::PropertyAreaTopBound()"
                  ]
                }
              ],
              "actions": [
                {
                  "type": {
                    "value": "MarchingSquares::MarchingSquaresBehavior::SetPropertyAreaBottomBound"
                  },
                  "parameters": [
                    "Object",
                    "Behavior",
                    "=",
                    "Object.Behavior::PropertyAreaBottomBound() + SceneWindowHeight()"
                  ]
                }
              ]
            },
            {
              "type": "BuiltinCommonInstructions::Standard",
              "conditions": [
                {
                  "type": {
                    "value": "GlobalVariableAsBoolean"
                  },
                  "parameters": [
                    "__marchingSquares.IsJavaScriptDefined",
                    "False"
                  ]
                }
              ],
              "actions": [
                {
                  "type": {
                    "value": "SetGlobalVariableAsBoolean"
                  },
                  "parameters": [
                    "__marchingSquares.IsJavaScriptDefined",
                    "True"
                  ]
                },
                {
                  "type": {
                    "value": "MarchingSquares::DefineScalarFieldPainterLibrary"
                  },
                  "parameters": [
                    "",
                    ""
                  ]
                },
                {
                  "type": {
                    "value": "MarchingSquares::DefineHelperClasses"
                  },
                  "parameters": [
                    "",
                    ""
                  ]
                },
                {
                  "type": {
                    "value": "MarchingSquares::MarchingSquaresBehavior::ExtendBehaviorClass"
                  },
                  "parameters": [
                    "Object",
                    "Behavior",
                    ""
                  ]
                }
              ]
            },
            {
              "type": "BuiltinCommonInstructions::Standard",
              "conditions": [],
              "actions": [
                {
                  "type": {
                    "value": "MarchingSquares::MarchingSquaresBehavior::ExtendObjectInstancePrototype"
                  },
                  "parameters": [
                    "Object",
                    "Behavior",
                    ""
                  ]
                },
                {
                  "type": {
                    "value": "MarchingSquares::MarchingSquaresBehavior::RebuildField"
                  },
                  "parameters": [
                    "Object",
                    "Behavior",
                    ""
                  ]
                }
              ]
            }
          ],
          "parameters": [
            {
              "codeOnly": false,
              "defaultValue": "",
              "description": "Object",
              "longDescription": "",
              "name": "Object",
              "optional": false,
              "supplementaryInformation": "PrimitiveDrawing::Drawer",
              "type": "object"
            },
            {
              "codeOnly": false,
              "defaultValue": "",
              "description": "Behavior",
              "longDescription": "",
              "name": "Behavior",
              "optional": false,
              "supplementaryInformation": "MarchingSquares::MarchingSquaresBehavior",
              "type": "behavior"
            }
          ],
          "objectGroups": []
        },
        {
          "description": "Clear the field by setting every values to 0.",
          "fullName": "Clear the field",
          "functionType": "Action",
          "group": "Field operation",
          "name": "ClearField",
          "private": false,
          "sentence": "Clear the field of _PARAM0_",
          "events": [
            {
              "type": "BuiltinCommonInstructions::JsCode",
              "inlineCode": "const game = runtimeScene.getGame();\nconst behaviorName = eventsFunctionContext.getBehaviorName(\"Behavior\");\nconst behavior = objects[0].getBehavior(behaviorName);\n\nbehavior.heightMap.clear();",
              "parameterObjects": "Object",
              "useStrict": true,
              "eventsSheetExpanded": true
            }
          ],
          "parameters": [
            {
              "codeOnly": false,
              "defaultValue": "",
              "description": "Object",
              "longDescription": "",
              "name": "Object",
              "optional": false,
              "supplementaryInformation": "PrimitiveDrawing::Drawer",
              "type": "object"
            },
            {
              "codeOnly": false,
              "defaultValue": "",
              "description": "Behavior",
              "longDescription": "",
              "name": "Behavior",
              "optional": false,
              "supplementaryInformation": "MarchingSquares::MarchingSquaresBehavior",
              "type": "behavior"
            }
          ],
          "objectGroups": []
        },
        {
          "description": "Unfill an area of the field from a given location until a given hight is reached.",
          "fullName": "Unfill area",
          "functionType": "Action",
          "group": "Field painting",
          "name": "UpsidedownFloodFrom",
          "private": false,
          "sentence": "Unfill the field of _PARAM0_ from x: _PARAM2_, y: _PARAM3_, to a minimum of _PARAM4_ with trickness: _PARAM5_",
          "events": [
            {
              "type": "BuiltinCommonInstructions::JsCode",
              "inlineCode": "\nconst behaviorName = eventsFunctionContext.getBehaviorName(\"Behavior\");\n\nconst originX = eventsFunctionContext.getArgument(\"OriginX\");\nconst originY = eventsFunctionContext.getArgument(\"OriginY\");\nconst minimum = eventsFunctionContext.getArgument(\"Minimum\");\nconst thickness = eventsFunctionContext.getArgument(\"Thickness\");\nconst cappingRadiusRatio = eventsFunctionContext.getArgument(\"CappingRadiusRatio\");\n\nconst behavior = objects[0].getBehavior(behaviorName);\n\nbehavior.heightMap.unfillFrom(originX, originY, minimum, thickness, cappingRadiusRatio);",
              "parameterObjects": "Object",
              "useStrict": true,
              "eventsSheetExpanded": true
            }
          ],
          "parameters": [
            {
              "codeOnly": false,
              "defaultValue": "",
              "description": "Object",
              "longDescription": "",
              "name": "Object",
              "optional": false,
              "supplementaryInformation": "PrimitiveDrawing::Drawer",
              "type": "object"
            },
            {
              "codeOnly": false,
              "defaultValue": "",
              "description": "Behavior",
              "longDescription": "",
              "name": "Behavior",
              "optional": false,
              "supplementaryInformation": "MarchingSquares::MarchingSquaresBehavior",
              "type": "behavior"
            },
            {
              "codeOnly": false,
              "defaultValue": "",
              "description": "Origin X",
              "longDescription": "",
              "name": "OriginX",
              "optional": false,
              "supplementaryInformation": "",
              "type": "expression"
            },
            {
              "codeOnly": false,
              "defaultValue": "",
              "description": "Origin Y",
              "longDescription": "",
              "name": "OriginY",
              "optional": false,
              "supplementaryInformation": "",
              "type": "expression"
            },
            {
              "codeOnly": false,
              "defaultValue": "",
              "description": "Minimum height",
              "longDescription": "",
              "name": "Minimum",
              "optional": false,
              "supplementaryInformation": "",
              "type": "expression"
            },
            {
              "codeOnly": false,
              "defaultValue": "",
              "description": "Contour thickness",
              "longDescription": "",
              "name": "Thickness",
              "optional": false,
              "supplementaryInformation": "",
              "type": "expression"
            },
            {
              "codeOnly": false,
              "defaultValue": "",
              "description": "Capping radius ratio",
              "longDescription": "Small values allow quicker process, but can result to tearing. Try values around 8.",
              "name": "CappingRadiusRatio",
              "optional": false,
              "supplementaryInformation": "",
              "type": "expression"
            }
          ],
          "objectGroups": []
        },
        {
          "description": "Fill an area of the field from a given location until a given hight is reached.",
          "fullName": "Fill area",
          "functionType": "Action",
          "group": "Field painting",
          "name": "FloodFrom",
          "private": false,
          "sentence": "Fill the field of _PARAM0_ from x: _PARAM2_, y: _PARAM3_, to a maximum of _PARAM4_ with trickness: _PARAM5_",
          "events": [
            {
              "type": "BuiltinCommonInstructions::JsCode",
              "inlineCode": "\nconst behaviorName = eventsFunctionContext.getBehaviorName(\"Behavior\");\n\nconst originX = eventsFunctionContext.getArgument(\"OriginX\");\nconst originY = eventsFunctionContext.getArgument(\"OriginY\");\nconst maximum = eventsFunctionContext.getArgument(\"Maximum\");\nconst thickness = eventsFunctionContext.getArgument(\"Thickness\");\nconst cappingRadiusRatio = eventsFunctionContext.getArgument(\"CappingRadiusRatio\");\n\nconst behavior = objects[0].getBehavior(behaviorName);\n\nbehavior.heightMap.fillFrom(originX, originY, maximum, thickness, cappingRadiusRatio);",
              "parameterObjects": "Object",
              "useStrict": true,
              "eventsSheetExpanded": true
            }
          ],
          "parameters": [
            {
              "codeOnly": false,
              "defaultValue": "",
              "description": "Object",
              "longDescription": "",
              "name": "Object",
              "optional": false,
              "supplementaryInformation": "PrimitiveDrawing::Drawer",
              "type": "object"
            },
            {
              "codeOnly": false,
              "defaultValue": "",
              "description": "Behavior",
              "longDescription": "",
              "name": "Behavior",
              "optional": false,
              "supplementaryInformation": "MarchingSquares::MarchingSquaresBehavior",
              "type": "behavior"
            },
            {
              "codeOnly": false,
              "defaultValue": "",
              "description": "Origin X",
              "longDescription": "",
              "name": "OriginX",
              "optional": false,
              "supplementaryInformation": "",
              "type": "expression"
            },
            {
              "codeOnly": false,
              "defaultValue": "",
              "description": "Origin Y",
              "longDescription": "",
              "name": "OriginY",
              "optional": false,
              "supplementaryInformation": "",
              "type": "expression"
            },
            {
              "codeOnly": false,
              "defaultValue": "",
              "description": "Maximum height",
              "longDescription": "",
              "name": "Maximum",
              "optional": false,
              "supplementaryInformation": "",
              "type": "expression"
            },
            {
              "codeOnly": false,
              "defaultValue": "",
              "description": "Contour thickness",
              "longDescription": "",
              "name": "Thickness",
              "optional": false,
              "supplementaryInformation": "",
              "type": "expression"
            },
            {
              "codeOnly": false,
              "defaultValue": "",
              "description": "Capping radius ratio",
              "longDescription": "Small values allow quicker process, but can result to tearing. Try values around 8.",
              "name": "CappingRadiusRatio",
              "optional": false,
              "supplementaryInformation": "",
              "type": "expression"
            }
          ],
          "objectGroups": []
        },
        {
          "description": "Cap every value of the field to a range.",
          "fullName": "Clamp the field",
          "functionType": "Action",
          "group": "Field operation",
          "name": "ClampField",
          "private": false,
          "sentence": "Clamp the field of _PARAM0_ from: _PARAM2_ to: _PARAM3_",
          "events": [
            {
              "type": "BuiltinCommonInstructions::JsCode",
              "inlineCode": "const behaviorName = eventsFunctionContext.getBehaviorName(\"Behavior\");\n\nconst min = eventsFunctionContext.getArgument(\"Minimum\");\nconst max = eventsFunctionContext.getArgument(\"Maximum\");\n\nconst behavior = objects[0].getBehavior(behaviorName);\n\nbehavior.heightMap.clamp(min, max);",
              "parameterObjects": "Object",
              "useStrict": true,
              "eventsSheetExpanded": true
            }
          ],
          "parameters": [
            {
              "codeOnly": false,
              "defaultValue": "",
              "description": "Object",
              "longDescription": "",
              "name": "Object",
              "optional": false,
              "supplementaryInformation": "PrimitiveDrawing::Drawer",
              "type": "object"
            },
            {
              "codeOnly": false,
              "defaultValue": "",
              "description": "Behavior",
              "longDescription": "",
              "name": "Behavior",
              "optional": false,
              "supplementaryInformation": "MarchingSquares::MarchingSquaresBehavior",
              "type": "behavior"
            },
            {
              "codeOnly": false,
              "defaultValue": "",
              "description": "Minimum",
              "longDescription": "",
              "name": "Minimum",
              "optional": false,
              "supplementaryInformation": "",
              "type": "expression"
            },
            {
              "codeOnly": false,
              "defaultValue": "",
              "description": "Maximum",
              "longDescription": "",
              "name": "Maximum",
              "optional": false,
              "supplementaryInformation": "",
              "type": "expression"
            }
          ],
          "objectGroups": []
        },
        {
          "description": "Apply an affine on the field values.",
          "fullName": "Transform the field",
          "functionType": "Action",
          "group": "Field operation",
          "name": "TransformField",
          "private": false,
          "sentence": "Transform the field of _PARAM0_ with a coefficient: _PARAM2_ and an offset: _PARAM3_",
          "events": [
            {
              "type": "BuiltinCommonInstructions::JsCode",
              "inlineCode": "const behaviorName = eventsFunctionContext.getBehaviorName(\"Behavior\");\n\nconst a = eventsFunctionContext.getArgument(\"Coefficient\");\nconst b = eventsFunctionContext.getArgument(\"Offset\");\n\nconst behavior = objects[0].getBehavior(behaviorName);\n\nbehavior.heightMap.transform(a, b);",
              "parameterObjects": "Object",
              "useStrict": true,
              "eventsSheetExpanded": true
            }
          ],
          "parameters": [
            {
              "codeOnly": false,
              "defaultValue": "",
              "description": "Object",
              "longDescription": "",
              "name": "Object",
              "optional": false,
              "supplementaryInformation": "PrimitiveDrawing::Drawer",
              "type": "object"
            },
            {
              "codeOnly": false,
              "defaultValue": "",
              "description": "Behavior",
              "longDescription": "",
              "name": "Behavior",
              "optional": false,
              "supplementaryInformation": "MarchingSquares::MarchingSquaresBehavior",
              "type": "behavior"
            },
            {
              "codeOnly": false,
              "defaultValue": "",
              "description": "Coefficient",
              "longDescription": "",
              "name": "Coefficient",
              "optional": false,
              "supplementaryInformation": "",
              "type": "expression"
            },
            {
              "codeOnly": false,
              "defaultValue": "",
              "description": "Offset",
              "longDescription": "",
              "name": "Offset",
              "optional": false,
              "supplementaryInformation": "",
              "type": "expression"
            }
          ],
          "objectGroups": []
        },
        {
          "description": "Add a hill to the field.",
          "fullName": "Add a hill",
          "functionType": "Action",
          "group": "Field painting",
          "name": "AddHill",
          "private": false,
          "sentence": "Add a hill to the field of _PARAM0_ with center: _PARAM2_, _PARAM3_, _PARAM4_, radius: _PARAM5_, opacity: _PARAM6_ using: _PARAM8_",
          "events": [
            {
              "type": "BuiltinCommonInstructions::JsCode",
              "inlineCode": "\nconst behaviorName = eventsFunctionContext.getBehaviorName(\"Behavior\");\n\nconst centerX = eventsFunctionContext.getArgument(\"CenterX\");\nconst centerY = eventsFunctionContext.getArgument(\"CenterY\");\nconst height = Math.max(1, eventsFunctionContext.getArgument(\"Height\"));\nconst radius = eventsFunctionContext.getArgument(\"Radius\");\nconst opacity = eventsFunctionContext.getArgument(\"Opacity\");\nconst cappingRadiusRatio = eventsFunctionContext.getArgument(\"CappingRadiusRatio\");\nconst operation = gdjs.__marchingSquaresExtension.parseOperation(eventsFunctionContext.getArgument(\"Operation\"));\n\nconst behavior = objects[0].getBehavior(behaviorName);\n\nbehavior.heightMap.mergeHill(centerX, centerY, height, radius, opacity, cappingRadiusRatio, operation);",
              "parameterObjects": "Object",
              "useStrict": true,
              "eventsSheetExpanded": true
            }
          ],
          "parameters": [
            {
              "codeOnly": false,
              "defaultValue": "",
              "description": "Object",
              "longDescription": "",
              "name": "Object",
              "optional": false,
              "supplementaryInformation": "PrimitiveDrawing::Drawer",
              "type": "object"
            },
            {
              "codeOnly": false,
              "defaultValue": "",
              "description": "Behavior",
              "longDescription": "",
              "name": "Behavior",
              "optional": false,
              "supplementaryInformation": "MarchingSquares::MarchingSquaresBehavior",
              "type": "behavior"
            },
            {
              "codeOnly": false,
              "defaultValue": "",
              "description": "Center X",
              "longDescription": "",
              "name": "CenterX",
              "optional": false,
              "supplementaryInformation": "",
              "type": "expression"
            },
            {
              "codeOnly": false,
              "defaultValue": "",
              "description": "Center Y",
              "longDescription": "",
              "name": "CenterY",
              "optional": false,
              "supplementaryInformation": "",
              "type": "expression"
            },
            {
              "codeOnly": false,
              "defaultValue": "",
              "description": "Height",
              "longDescription": "The hill height at the center, a value of 1 or less means a flat hill.",
              "name": "Height",
              "optional": false,
              "supplementaryInformation": "",
              "type": "expression"
            },
            {
              "codeOnly": false,
              "defaultValue": "",
              "description": "Radius",
              "longDescription": "The hill height is 1 at this radius.",
              "name": "Radius",
              "optional": false,
              "supplementaryInformation": "",
              "type": "expression"
            },
            {
              "codeOnly": false,
              "defaultValue": "",
              "description": "Opacity",
              "longDescription": "Set to 1 to apply the hill instantly or repeat this action with a lower value to make is progressive.",
              "name": "Opacity",
              "optional": false,
              "supplementaryInformation": "",
              "type": "expression"
            },
            {
              "codeOnly": false,
              "defaultValue": "",
              "description": "Capping radius ratio",
              "longDescription": "Small values allow quicker process, but can result to tearing. Try values around 8.",
              "name": "CappingRadiusRatio",
              "optional": false,
              "supplementaryInformation": "",
              "type": "expression"
            },
            {
              "codeOnly": false,
              "defaultValue": "",
              "description": "Operation",
              "longDescription": "",
              "name": "Operation",
              "optional": false,
              "supplementaryInformation": "[\"Maximum\",\"Addition\",\"Subtraction\"]",
              "type": "stringWithSelector"
            }
          ],
          "objectGroups": []
        },
        {
          "description": "Add a disk to the field.",
          "fullName": "Add a disk",
          "functionType": "Action",
          "group": "Field painting",
          "name": "AddDisk",
          "private": false,
          "sentence": "Add a disk to the field of _PARAM0_ with center: _PARAM2_, _PARAM3_, radius: _PARAM4_ using: _PARAM6_",
          "events": [
            {
              "type": "BuiltinCommonInstructions::JsCode",
              "inlineCode": "\nconst behaviorName = eventsFunctionContext.getBehaviorName(\"Behavior\");\n\nconst centerX = eventsFunctionContext.getArgument(\"CenterX\");\nconst centerY = eventsFunctionContext.getArgument(\"CenterY\");\nconst radius = eventsFunctionContext.getArgument(\"Radius\");\nconst cappingRadiusRatio = eventsFunctionContext.getArgument(\"CappingRadiusRatio\");\nconst operation = gdjs.__marchingSquaresExtension.parseOperation(eventsFunctionContext.getArgument(\"Operation\"));\n\nconst behavior = objects[0].getBehavior(behaviorName);\n\nbehavior.heightMap.mergeDisk(centerX, centerY, radius, cappingRadiusRatio, operation);",
              "parameterObjects": "Object",
              "useStrict": true,
              "eventsSheetExpanded": true
            }
          ],
          "parameters": [
            {
              "codeOnly": false,
              "defaultValue": "",
              "description": "Object",
              "longDescription": "",
              "name": "Object",
              "optional": false,
              "supplementaryInformation": "PrimitiveDrawing::Drawer",
              "type": "object"
            },
            {
              "codeOnly": false,
              "defaultValue": "",
              "description": "Behavior",
              "longDescription": "",
              "name": "Behavior",
              "optional": false,
              "supplementaryInformation": "MarchingSquares::MarchingSquaresBehavior",
              "type": "behavior"
            },
            {
              "codeOnly": false,
              "defaultValue": "",
              "description": "Center X",
              "longDescription": "",
              "name": "CenterX",
              "optional": false,
              "supplementaryInformation": "",
              "type": "expression"
            },
            {
              "codeOnly": false,
              "defaultValue": "",
              "description": "Center Y",
              "longDescription": "",
              "name": "CenterY",
              "optional": false,
              "supplementaryInformation": "",
              "type": "expression"
            },
            {
              "codeOnly": false,
              "defaultValue": "",
              "description": "Radius",
              "longDescription": "The spike height is 1 at this radius.",
              "name": "Radius",
              "optional": false,
              "supplementaryInformation": "",
              "type": "expression"
            },
            {
              "codeOnly": false,
              "defaultValue": "",
              "description": "Capping radius ratio",
              "longDescription": "Small values allow quicker process, but can result to tearing. Try values around 8.",
              "name": "CappingRadiusRatio",
              "optional": false,
              "supplementaryInformation": "",
              "type": "expression"
            },
            {
              "codeOnly": false,
              "defaultValue": "",
              "description": "Operation",
              "longDescription": "",
              "name": "Operation",
              "optional": false,
              "supplementaryInformation": "[\"Maximum\",\"Addition\",\"Subtraction\"]",
              "type": "stringWithSelector"
            }
          ],
          "objectGroups": []
        },
        {
          "description": "Mask a disk to the field.",
          "fullName": "Mask a disk",
          "functionType": "Action",
          "group": "Field painting",
          "name": "MaskDisk",
          "private": false,
          "sentence": "Mask a disk on the field of _PARAM0_ with center: _PARAM2_, _PARAM3_, radius: _PARAM4_",
          "events": [
            {
              "type": "BuiltinCommonInstructions::JsCode",
              "inlineCode": "\nconst behaviorName = eventsFunctionContext.getBehaviorName(\"Behavior\");\n\nconst centerX = eventsFunctionContext.getArgument(\"CenterX\");\nconst centerY = eventsFunctionContext.getArgument(\"CenterY\");\nconst radius = eventsFunctionContext.getArgument(\"Radius\");\nconst cappingRadiusRatio = eventsFunctionContext.getArgument(\"CappingRadiusRatio\");\nconst cappingRadius = cappingRadiusRatio * radius;\n\nconst behavior = objects[0].getBehavior(behaviorName);\n\nbehavior.heightMap.mergeDisk(centerX, centerY, radius, cappingRadiusRatio, (fieldValue, value) => Math.min(fieldValue, 1 / value));",
              "parameterObjects": "Object",
              "useStrict": true,
              "eventsSheetExpanded": true
            }
          ],
          "parameters": [
            {
              "codeOnly": false,
              "defaultValue": "",
              "description": "Object",
              "longDescription": "",
              "name": "Object",
              "optional": false,
              "supplementaryInformation": "PrimitiveDrawing::Drawer",
              "type": "object"
            },
            {
              "codeOnly": false,
              "defaultValue": "",
              "description": "Behavior",
              "longDescription": "",
              "name": "Behavior",
              "optional": false,
              "supplementaryInformation": "MarchingSquares::MarchingSquaresBehavior",
              "type": "behavior"
            },
            {
              "codeOnly": false,
              "defaultValue": "",
              "description": "Center X",
              "longDescription": "",
              "name": "CenterX",
              "optional": false,
              "supplementaryInformation": "",
              "type": "expression"
            },
            {
              "codeOnly": false,
              "defaultValue": "",
              "description": "Center Y",
              "longDescription": "",
              "name": "CenterY",
              "optional": false,
              "supplementaryInformation": "",
              "type": "expression"
            },
            {
              "codeOnly": false,
              "defaultValue": "",
              "description": "Radius",
              "longDescription": "The spike height is 1 at this radius.",
              "name": "Radius",
              "optional": false,
              "supplementaryInformation": "",
              "type": "expression"
            },
            {
              "codeOnly": false,
              "defaultValue": "",
              "description": "Capping radius ratio",
              "longDescription": "Small values allow quicker process, but can result to tearing. Try values around 8.",
              "name": "CappingRadiusRatio",
              "optional": false,
              "supplementaryInformation": "",
              "type": "expression"
            }
          ],
          "objectGroups": []
        },
        {
          "description": "Add a line to the field.",
          "fullName": "Add a line",
          "functionType": "Action",
          "group": "Field painting",
          "name": "AddLine",
          "private": false,
          "sentence": "Add a line to the field of _PARAM0_ fom _PARAM2_ ; _PARAM3_ to _PARAM4_ ; _PARAM5_ with trickness: _PARAM6_ using: _PARAM8_",
          "events": [
            {
              "type": "BuiltinCommonInstructions::JsCode",
              "inlineCode": "\nconst behaviorName = eventsFunctionContext.getBehaviorName(\"Behavior\");\n\nconst startX = eventsFunctionContext.getArgument(\"StartX\");\nconst startY = eventsFunctionContext.getArgument(\"StartY\");\nconst endX = eventsFunctionContext.getArgument(\"EndX\");\nconst endY = eventsFunctionContext.getArgument(\"EndY\");\nconst thickness = eventsFunctionContext.getArgument(\"Thickness\");\nconst cappingRadiusRatio = eventsFunctionContext.getArgument(\"CappingRadiusRatio\");\nconst operation = gdjs.__marchingSquaresExtension.parseOperation(eventsFunctionContext.getArgument(\"Operation\"));\n\nconst behavior = objects[0].getBehavior(behaviorName);\n\nbehavior.heightMap.mergeSegment(startX, startY, endX, endY, thickness, cappingRadiusRatio, operation);",
              "parameterObjects": "Object",
              "useStrict": true,
              "eventsSheetExpanded": true
            }
          ],
          "parameters": [
            {
              "codeOnly": false,
              "defaultValue": "",
              "description": "Object",
              "longDescription": "",
              "name": "Object",
              "optional": false,
              "supplementaryInformation": "PrimitiveDrawing::Drawer",
              "type": "object"
            },
            {
              "codeOnly": false,
              "defaultValue": "",
              "description": "Behavior",
              "longDescription": "",
              "name": "Behavior",
              "optional": false,
              "supplementaryInformation": "MarchingSquares::MarchingSquaresBehavior",
              "type": "behavior"
            },
            {
              "codeOnly": false,
              "defaultValue": "",
              "description": "X position of the start",
              "longDescription": "",
              "name": "StartX",
              "optional": false,
              "supplementaryInformation": "",
              "type": "expression"
            },
            {
              "codeOnly": false,
              "defaultValue": "",
              "description": "Y position of the start",
              "longDescription": "",
              "name": "StartY",
              "optional": false,
              "supplementaryInformation": "",
              "type": "expression"
            },
            {
              "codeOnly": false,
              "defaultValue": "",
              "description": "X position of the end",
              "longDescription": "",
              "name": "EndX",
              "optional": false,
              "supplementaryInformation": "",
              "type": "expression"
            },
            {
              "codeOnly": false,
              "defaultValue": "",
              "description": "Y position of the end",
              "longDescription": "",
              "name": "EndY",
              "optional": false,
              "supplementaryInformation": "",
              "type": "expression"
            },
            {
              "codeOnly": false,
              "defaultValue": "",
              "description": "Thickness",
              "longDescription": "",
              "name": "Thickness",
              "optional": false,
              "supplementaryInformation": "",
              "type": "expression"
            },
            {
              "codeOnly": false,
              "defaultValue": "",
              "description": "Capping radius ratio",
              "longDescription": "Small values allow quicker process, but can result to tearing. Try values around 8.",
              "name": "CappingRadiusRatio",
              "optional": false,
              "supplementaryInformation": "",
              "type": "expression"
            },
            {
              "codeOnly": false,
              "defaultValue": "",
              "description": "Operation",
              "longDescription": "",
              "name": "Operation",
              "optional": false,
              "supplementaryInformation": "[\"Maximum\",\"Addition\",\"Subtraction\"]",
              "type": "stringWithSelector"
            }
          ],
          "objectGroups": []
        },
        {
          "description": "Mask a line to the field.",
          "fullName": "Mask a line",
          "functionType": "Action",
          "group": "Field painting",
          "name": "MaskLine",
          "private": false,
          "sentence": "Mask a line on the field of _PARAM0_ fom _PARAM2_ ; _PARAM3_ to _PARAM4_ ; _PARAM5_ with trickness: _PARAM6_",
          "events": [
            {
              "type": "BuiltinCommonInstructions::JsCode",
              "inlineCode": "\nconst behaviorName = eventsFunctionContext.getBehaviorName(\"Behavior\");\n\nconst startX = eventsFunctionContext.getArgument(\"StartX\");\nconst startY = eventsFunctionContext.getArgument(\"StartY\");\nconst endX = eventsFunctionContext.getArgument(\"EndX\");\nconst endY = eventsFunctionContext.getArgument(\"EndY\");\nconst thickness = eventsFunctionContext.getArgument(\"Thickness\");\nconst cappingRadiusRatio = eventsFunctionContext.getArgument(\"CappingRadiusRatio\");\n\nconst behavior = objects[0].getBehavior(behaviorName);\n\nbehavior.heightMap.mergeSegment(startX, startY, endX, endY, thickness, cappingRadiusRatio, (fieldValue, value) => Math.min(fieldValue, 1 / value));",
              "parameterObjects": "Object",
              "useStrict": true,
              "eventsSheetExpanded": true
            }
          ],
          "parameters": [
            {
              "codeOnly": false,
              "defaultValue": "",
              "description": "Object",
              "longDescription": "",
              "name": "Object",
              "optional": false,
              "supplementaryInformation": "PrimitiveDrawing::Drawer",
              "type": "object"
            },
            {
              "codeOnly": false,
              "defaultValue": "",
              "description": "Behavior",
              "longDescription": "",
              "name": "Behavior",
              "optional": false,
              "supplementaryInformation": "MarchingSquares::MarchingSquaresBehavior",
              "type": "behavior"
            },
            {
              "codeOnly": false,
              "defaultValue": "",
              "description": "X position of the start",
              "longDescription": "",
              "name": "StartX",
              "optional": false,
              "supplementaryInformation": "",
              "type": "expression"
            },
            {
              "codeOnly": false,
              "defaultValue": "",
              "description": "Y position of the start",
              "longDescription": "",
              "name": "StartY",
              "optional": false,
              "supplementaryInformation": "",
              "type": "expression"
            },
            {
              "codeOnly": false,
              "defaultValue": "",
              "description": "X position of the end",
              "longDescription": "",
              "name": "EndX",
              "optional": false,
              "supplementaryInformation": "",
              "type": "expression"
            },
            {
              "codeOnly": false,
              "defaultValue": "",
              "description": "Y position of the end",
              "longDescription": "",
              "name": "EndY",
              "optional": false,
              "supplementaryInformation": "",
              "type": "expression"
            },
            {
              "codeOnly": false,
              "defaultValue": "",
              "description": "Thickness",
              "longDescription": "The spike height is 1 at this radius.",
              "name": "Thickness",
              "optional": false,
              "supplementaryInformation": "",
              "type": "expression"
            },
            {
              "codeOnly": false,
              "defaultValue": "",
              "description": "Capping radius ratio",
              "longDescription": "Small values allow quicker process, but can result to tearing. Try values around 8.",
              "name": "CappingRadiusRatio",
              "optional": false,
              "supplementaryInformation": "",
              "type": "expression"
            }
          ],
          "objectGroups": []
        },
        {
          "description": "Apply a given operation on every value of the field using the value from the other field at the same position.",
          "fullName": "Merge a field",
          "functionType": "Action",
          "group": "Field operation",
          "name": "MergeField",
          "private": false,
          "sentence": "Merge _PARAM0_ with the field of _PARAM2_ using: _PARAM4_",
          "events": [
            {
              "type": "BuiltinCommonInstructions::JsCode",
              "inlineCode": "\nconst behaviorName = eventsFunctionContext.getBehaviorName(\"Behavior\");\n\nconst fieldObjects = eventsFunctionContext.getObjects(\"FieldObject\");\nconst fieldBehaviorName = eventsFunctionContext.getArgument(\"FieldBehavior\");\nconst operation = gdjs.__marchingSquaresExtension.parseOperation(eventsFunctionContext.getArgument(\"Operation\"));\n\nconst behavior = objects[0].getBehavior(behaviorName);\n\n/** @type {Array<number[]>} */\nconst fieldValues = behavior.scalarFieldValues;\n\nfor (const fieldObject of fieldObjects) {\n    const otherBehavior = fieldObject.getBehavior(behaviorName);\n    if (!otherBehavior) {\n        continue;\n    }\n    behavior.scalarField.mergeField(otherBehavior.scalarField, operation);\n}",
              "parameterObjects": "Object",
              "useStrict": true,
              "eventsSheetExpanded": true
            }
          ],
          "parameters": [
            {
              "codeOnly": false,
              "defaultValue": "",
              "description": "Object",
              "longDescription": "",
              "name": "Object",
              "optional": false,
              "supplementaryInformation": "PrimitiveDrawing::Drawer",
              "type": "object"
            },
            {
              "codeOnly": false,
              "defaultValue": "",
              "description": "Behavior",
              "longDescription": "",
              "name": "Behavior",
              "optional": false,
              "supplementaryInformation": "MarchingSquares::MarchingSquaresBehavior",
              "type": "behavior"
            },
            {
              "codeOnly": false,
              "defaultValue": "",
              "description": "Field object",
              "longDescription": "",
              "name": "FieldObject",
              "optional": false,
              "supplementaryInformation": "",
              "type": "objectList"
            },
            {
              "codeOnly": false,
              "defaultValue": "",
              "description": "Field behavior",
              "longDescription": "",
              "name": "FieldBehavior",
              "optional": false,
              "supplementaryInformation": "MarchingSquares::MarchingSquaresBehavior",
              "type": "behavior"
            },
            {
              "codeOnly": false,
              "defaultValue": "",
              "description": "Operation",
              "longDescription": "",
              "name": "Operation",
              "optional": false,
              "supplementaryInformation": "[\"Maximum\",\"Addition\",\"Subtraction\",\"Minimum\",\"Multiplication\",\"Division\"]",
              "type": "stringWithSelector"
            }
          ],
          "objectGroups": []
        },
        {
          "description": "Update the field hitboxes.",
          "fullName": "Update hitboxes",
          "functionType": "Action",
          "group": "Field evaluation",
          "name": "UpdateHitboxes",
          "private": false,
          "sentence": "Update the field hitboxes of _PARAM0_",
          "events": [
            {
              "type": "BuiltinCommonInstructions::JsCode",
              "inlineCode": "\nconst behaviorName = eventsFunctionContext.getBehaviorName(\"Behavior\");\n\nconst behavior = objects[0].getBehavior(behaviorName);\n\nbehavior.updateMarchingSquareHitboxes(0, 0, behavior.scalarField.dimX(), behavior.scalarField.dimY());",
              "parameterObjects": "Object",
              "useStrict": true,
              "eventsSheetExpanded": true
            }
          ],
          "parameters": [
            {
              "codeOnly": false,
              "defaultValue": "",
              "description": "Object",
              "longDescription": "",
              "name": "Object",
              "optional": false,
              "supplementaryInformation": "PrimitiveDrawing::Drawer",
              "type": "object"
            },
            {
              "codeOnly": false,
              "defaultValue": "",
              "description": "Behavior",
              "longDescription": "",
              "name": "Behavior",
              "optional": false,
              "supplementaryInformation": "MarchingSquares::MarchingSquaresBehavior",
              "type": "behavior"
            }
          ],
          "objectGroups": []
        },
        {
          "description": "Draw the field contours.",
          "fullName": "Draw the contours",
          "functionType": "Action",
          "group": "Field evaluation",
          "name": "DrawField",
          "private": false,
          "sentence": "Draw the field contours of _PARAM0_",
          "events": [
            {
              "type": "BuiltinCommonInstructions::JsCode",
              "inlineCode": "\nconst screenWidth = runtimeScene.getGame().getGameResolutionWidth();\nconst screenHeight = runtimeScene.getGame().getGameResolutionWidth();\n\nconst behaviorName = eventsFunctionContext.getBehaviorName(\"Behavior\");\n\nconst object = objects[0];\nconst behavior = object.getBehavior(behaviorName);\n\nif (behavior._behaviorData.MustOnlyDrawScreen) {\n    const layer = runtimeScene.getLayer(object.getLayer());\n    const screen1 = layer.convertCoords(0, 0);\n    const screen2 = layer.convertCoords(screenWidth, 0);\n    const screen3 = layer.convertCoords(0, screenHeight);\n    const screen4 = layer.convertCoords(screenWidth, screenHeight);\n\n    const screenLeft = Math.min(screen1[0], screen2[0], screen3[0], screen4[0]);\n    const screenTop = Math.min(screen1[1], screen2[1], screen3[1], screen4[1]);\n    const screenRight = Math.max(screen1[0], screen2[0], screen3[0], screen4[0]);\n    const screenBottom = Math.max(screen1[1], screen2[1], screen3[1], screen4[1]);\n\n    const minX = Math.max(0, Math.floor(behavior.coordConverter.convertToGridBasisX(screenLeft)));\n    const minY = Math.max(0, Math.floor(behavior.coordConverter.convertToGridBasisY(screenTop)));\n    // I don't know why the + 1 is needed\n    const maxX = Math.min(behavior.scalarField.dimX(), 1 + Math.ceil(behavior.coordConverter.convertToGridBasisX(screenRight)));\n    const maxY = Math.min(behavior.scalarField.dimY(), Math.ceil(behavior.coordConverter.convertToGridBasisY(screenBottom)));\n\n    behavior.drawField(minX, minY, maxX, maxY);\n}\nelse {\n    // This is useful for static content or games without scrolling.\n    behavior.drawField(0, 0, behavior.scalarField.dimX(), behavior.scalarField.dimY());\n}",
              "parameterObjects": "Object",
              "useStrict": true,
              "eventsSheetExpanded": true
            }
          ],
          "parameters": [
            {
              "codeOnly": false,
              "defaultValue": "",
              "description": "Object",
              "longDescription": "",
              "name": "Object",
              "optional": false,
              "supplementaryInformation": "PrimitiveDrawing::Drawer",
              "type": "object"
            },
            {
              "codeOnly": false,
              "defaultValue": "",
              "description": "Behavior",
              "longDescription": "",
              "name": "Behavior",
              "optional": false,
              "supplementaryInformation": "MarchingSquares::MarchingSquaresBehavior",
              "type": "behavior"
            }
          ],
          "objectGroups": []
        },
        {
          "description": "Change the width of the field cells.",
          "fullName": "Width of the cells",
          "functionType": "Action",
          "group": "Field configuration",
          "name": "SetCellWidth",
          "private": false,
          "sentence": "Change the width of the field cells of _PARAM0_: _PARAM2_",
          "events": [
            {
              "type": "BuiltinCommonInstructions::Standard",
              "conditions": [],
              "actions": [
                {
                  "type": {
                    "value": "MarchingSquares::MarchingSquaresBehavior::SetPropertyCellWidth"
                  },
                  "parameters": [
                    "Object",
                    "Behavior",
                    "=",
                    "GetArgumentAsNumber(\"CellWidth\")"
                  ]
                },
                {
                  "type": {
                    "value": "MarchingSquares::MarchingSquaresBehavior::RebuildField"
                  },
                  "parameters": [
                    "Object",
                    "Behavior",
                    ""
                  ]
                }
              ]
            }
          ],
          "parameters": [
            {
              "codeOnly": false,
              "defaultValue": "",
              "description": "Object",
              "longDescription": "",
              "name": "Object",
              "optional": false,
              "supplementaryInformation": "PrimitiveDrawing::Drawer",
              "type": "object"
            },
            {
              "codeOnly": false,
              "defaultValue": "",
              "description": "Behavior",
              "longDescription": "",
              "name": "Behavior",
              "optional": false,
              "supplementaryInformation": "MarchingSquares::MarchingSquaresBehavior",
              "type": "behavior"
            },
            {
              "codeOnly": false,
              "defaultValue": "",
              "description": "Value",
              "longDescription": "",
              "name": "CellWidth",
              "optional": false,
              "supplementaryInformation": "",
              "type": "expression"
            }
          ],
          "objectGroups": []
        },
        {
          "description": "Change the height of the field cells.",
          "fullName": "Height of the cells",
          "functionType": "Action",
          "group": "Field configuration",
          "name": "SetCellHeight",
          "private": false,
          "sentence": "Change the height of the field cells of _PARAM0_: _PARAM2_",
          "events": [
            {
              "type": "BuiltinCommonInstructions::Standard",
              "conditions": [],
              "actions": [
                {
                  "type": {
                    "value": "MarchingSquares::MarchingSquaresBehavior::SetPropertyCellHeight"
                  },
                  "parameters": [
                    "Object",
                    "Behavior",
                    "=",
                    "GetArgumentAsNumber(\"CellHeight\")"
                  ]
                },
                {
                  "type": {
                    "value": "MarchingSquares::MarchingSquaresBehavior::RebuildField"
                  },
                  "parameters": [
                    "Object",
                    "Behavior",
                    ""
                  ]
                }
              ]
            }
          ],
          "parameters": [
            {
              "codeOnly": false,
              "defaultValue": "",
              "description": "Object",
              "longDescription": "",
              "name": "Object",
              "optional": false,
              "supplementaryInformation": "PrimitiveDrawing::Drawer",
              "type": "object"
            },
            {
              "codeOnly": false,
              "defaultValue": "",
              "description": "Behavior",
              "longDescription": "",
              "name": "Behavior",
              "optional": false,
              "supplementaryInformation": "MarchingSquares::MarchingSquaresBehavior",
              "type": "behavior"
            },
            {
              "codeOnly": false,
              "defaultValue": "",
              "description": "Value",
              "longDescription": "",
              "name": "CellHeight",
              "optional": false,
              "supplementaryInformation": "",
              "type": "expression"
            }
          ],
          "objectGroups": []
        },
        {
          "description": "Rebuild the field with the new dimensions.",
          "fullName": "Rebuild the field",
          "functionType": "Action",
          "group": "",
          "name": "RebuildField",
          "private": true,
          "sentence": "Rebuild the field _PARAM0_",
          "events": [
            {
              "type": "BuiltinCommonInstructions::JsCode",
              "inlineCode": "const game = runtimeScene.getGame();\nconst behaviorName = eventsFunctionContext.getBehaviorName(\"Behavior\");\nconst behavior = objects[0].getBehavior(behaviorName);\n\n/** @type {float} */\nconst left = behavior._getAreaLeftBound();\n/** @type {float} */\nconst top = behavior._getAreaTopBound();\n/** @type {float} */\nconst right = behavior._getAreaRightBound() || game.getGameResolutionWidth();\n/** @type {float} */\nconst bottom = behavior._getAreaBottomBound() || game.getGameResolutionHeight();\n/** @type {float} */\nconst cellWidth = behavior._getCellWidth();\n/** @type {float} */\nconst cellHeight = behavior._getCellHeight();\n\nbehavior.createField();",
              "parameterObjects": "Object",
              "useStrict": true,
              "eventsSheetExpanded": true
            }
          ],
          "parameters": [
            {
              "codeOnly": false,
              "defaultValue": "",
              "description": "Object",
              "longDescription": "",
              "name": "Object",
              "optional": false,
              "supplementaryInformation": "PrimitiveDrawing::Drawer",
              "type": "object"
            },
            {
              "codeOnly": false,
              "defaultValue": "",
              "description": "Behavior",
              "longDescription": "",
              "name": "Behavior",
              "optional": false,
              "supplementaryInformation": "MarchingSquares::MarchingSquaresBehavior",
              "type": "behavior"
            }
          ],
          "objectGroups": []
        },
        {
          "description": "Fill outside or inside of the contours.",
          "fullName": "Fill outside",
          "functionType": "Action",
          "group": "Field configuration",
          "name": "SetFillOutside",
          "private": false,
          "sentence": "Fill outside of the contours of _PARAM0_: _PARAM2_",
          "events": [
            {
              "type": "BuiltinCommonInstructions::Standard",
              "conditions": [],
              "actions": [
                {
                  "type": {
                    "value": "MarchingSquares::MarchingSquaresBehavior::SetPropertyFillOutside"
                  },
                  "parameters": [
                    "Object",
                    "Behavior",
                    "="
                  ]
                }
              ]
            },
            {
              "type": "BuiltinCommonInstructions::Standard",
              "conditions": [
                {
                  "type": {
                    "value": "GetArgumentAsBoolean"
                  },
                  "parameters": [
                    "\"FillOutside\""
                  ]
                }
              ],
              "actions": [
                {
                  "type": {
                    "value": "MarchingSquares::MarchingSquaresBehavior::SetPropertyFillOutside"
                  },
                  "parameters": [
                    "Object",
                    "Behavior",
                    "yes"
                  ]
                }
              ]
            }
          ],
          "parameters": [
            {
              "codeOnly": false,
              "defaultValue": "",
              "description": "Object",
              "longDescription": "",
              "name": "Object",
              "optional": false,
              "supplementaryInformation": "PrimitiveDrawing::Drawer",
              "type": "object"
            },
            {
              "codeOnly": false,
              "defaultValue": "",
              "description": "Behavior",
              "longDescription": "",
              "name": "Behavior",
              "optional": false,
              "supplementaryInformation": "MarchingSquares::MarchingSquaresBehavior",
              "type": "behavior"
            },
            {
              "codeOnly": false,
              "defaultValue": "",
              "description": "Fill outside?",
              "longDescription": "",
              "name": "FillOutside",
              "optional": false,
              "supplementaryInformation": "",
              "type": "yesorno"
            }
          ],
          "objectGroups": []
        },
        {
          "description": "Change the contour threshold.",
          "fullName": "Contour threshold",
          "functionType": "Action",
          "group": "Field configuration",
          "name": "SetThreshold",
          "private": false,
          "sentence": "Change the contour threshold of _PARAM0_: _PARAM2_",
          "events": [
            {
              "type": "BuiltinCommonInstructions::Standard",
              "conditions": [],
              "actions": [
                {
                  "type": {
                    "value": "MarchingSquares::MarchingSquaresBehavior::SetPropertyThreshold"
                  },
                  "parameters": [
                    "Object",
                    "Behavior",
                    "=",
                    "GetArgumentAsNumber(\"Threshold\")"
                  ]
                }
              ]
            }
          ],
          "parameters": [
            {
              "codeOnly": false,
              "defaultValue": "",
              "description": "Object",
              "longDescription": "",
              "name": "Object",
              "optional": false,
              "supplementaryInformation": "PrimitiveDrawing::Drawer",
              "type": "object"
            },
            {
              "codeOnly": false,
              "defaultValue": "",
              "description": "Behavior",
              "longDescription": "",
              "name": "Behavior",
              "optional": false,
              "supplementaryInformation": "MarchingSquares::MarchingSquaresBehavior",
              "type": "behavior"
            },
            {
              "codeOnly": false,
              "defaultValue": "",
              "description": "Value",
              "longDescription": "",
              "name": "Threshold",
              "optional": false,
              "supplementaryInformation": "",
              "type": "expression"
            }
          ],
          "objectGroups": []
        },
        {
          "description": "Change the field area bounds.",
          "fullName": "Area bounds",
          "functionType": "Action",
          "group": "Field configuration",
          "name": "SetAreaBounds",
          "private": false,
          "sentence": "Change the field area bounds of _PARAM0_ left: _PARAM2_ top: _PARAM3_ right: _PARAM4_ bottom: _PARAM5_",
          "events": [
            {
              "type": "BuiltinCommonInstructions::Standard",
              "conditions": [],
              "actions": [
                {
                  "type": {
                    "value": "MarchingSquares::MarchingSquaresBehavior::SetPropertyAreaLeftBound"
                  },
                  "parameters": [
                    "Object",
                    "Behavior",
                    "=",
                    "GetArgumentAsNumber(\"LeftBound\")"
                  ]
                },
                {
                  "type": {
                    "value": "MarchingSquares::MarchingSquaresBehavior::SetPropertyAreaLeftBound"
                  },
                  "parameters": [
                    "Object",
                    "Behavior",
                    "=",
                    "GetArgumentAsNumber(\"TopBound\")"
                  ]
                },
                {
                  "type": {
                    "value": "MarchingSquares::MarchingSquaresBehavior::SetPropertyAreaLeftBound"
                  },
                  "parameters": [
                    "Object",
                    "Behavior",
                    "=",
                    "GetArgumentAsNumber(\"RightBound\")"
                  ]
                },
                {
                  "type": {
                    "value": "MarchingSquares::MarchingSquaresBehavior::SetPropertyAreaLeftBound"
                  },
                  "parameters": [
                    "Object",
                    "Behavior",
                    "=",
                    "GetArgumentAsNumber(\"BottomBound\")"
                  ]
                }
              ]
            }
          ],
          "parameters": [
            {
              "codeOnly": false,
              "defaultValue": "",
              "description": "Object",
              "longDescription": "",
              "name": "Object",
              "optional": false,
              "supplementaryInformation": "PrimitiveDrawing::Drawer",
              "type": "object"
            },
            {
              "codeOnly": false,
              "defaultValue": "",
              "description": "Behavior",
              "longDescription": "",
              "name": "Behavior",
              "optional": false,
              "supplementaryInformation": "MarchingSquares::MarchingSquaresBehavior",
              "type": "behavior"
            },
            {
              "codeOnly": false,
              "defaultValue": "",
              "description": "Left bound",
              "longDescription": "",
              "name": "LeftBound",
              "optional": false,
              "supplementaryInformation": "",
              "type": "expression"
            },
            {
              "codeOnly": false,
              "defaultValue": "",
              "description": "Top bound",
              "longDescription": "",
              "name": "TopBound",
              "optional": false,
              "supplementaryInformation": "",
              "type": "expression"
            },
            {
              "codeOnly": false,
              "defaultValue": "",
              "description": "Right bound",
              "longDescription": "",
              "name": "RightBound",
              "optional": false,
              "supplementaryInformation": "",
              "type": "expression"
            },
            {
              "codeOnly": false,
              "defaultValue": "",
              "description": "Bottom bound",
              "longDescription": "",
              "name": "BottomBound",
              "optional": false,
              "supplementaryInformation": "",
              "type": "expression"
            }
          ],
          "objectGroups": []
        },
        {
          "description": "Area left bound of the field.",
          "fullName": "Area left",
          "functionType": "Expression",
          "group": "Field configuration",
          "name": "AreaLeft",
          "private": false,
          "sentence": "",
          "events": [
            {
              "type": "BuiltinCommonInstructions::Standard",
              "conditions": [],
              "actions": [
                {
                  "type": {
                    "value": "SetReturnNumber"
                  },
                  "parameters": [
                    "Object.Behavior::PropertyAreaLeftBound()"
                  ]
                }
              ]
            }
          ],
          "parameters": [
            {
              "codeOnly": false,
              "defaultValue": "",
              "description": "Object",
              "longDescription": "",
              "name": "Object",
              "optional": false,
              "supplementaryInformation": "PrimitiveDrawing::Drawer",
              "type": "object"
            },
            {
              "codeOnly": false,
              "defaultValue": "",
              "description": "Behavior",
              "longDescription": "",
              "name": "Behavior",
              "optional": false,
              "supplementaryInformation": "MarchingSquares::MarchingSquaresBehavior",
              "type": "behavior"
            }
          ],
          "objectGroups": []
        },
        {
          "description": "Area top bound of the field.",
          "fullName": "Area top",
          "functionType": "Expression",
          "group": "Field configuration",
          "name": "AreaTop",
          "private": false,
          "sentence": "",
          "events": [
            {
              "type": "BuiltinCommonInstructions::Standard",
              "conditions": [],
              "actions": [
                {
                  "type": {
                    "value": "SetReturnNumber"
                  },
                  "parameters": [
                    "Object.Behavior::PropertyAreaTopBound()"
                  ]
                }
              ]
            }
          ],
          "parameters": [
            {
              "codeOnly": false,
              "defaultValue": "",
              "description": "Object",
              "longDescription": "",
              "name": "Object",
              "optional": false,
              "supplementaryInformation": "PrimitiveDrawing::Drawer",
              "type": "object"
            },
            {
              "codeOnly": false,
              "defaultValue": "",
              "description": "Behavior",
              "longDescription": "",
              "name": "Behavior",
              "optional": false,
              "supplementaryInformation": "MarchingSquares::MarchingSquaresBehavior",
              "type": "behavior"
            }
          ],
          "objectGroups": []
        },
        {
          "description": "Area right bound of the field.",
          "fullName": "Area right",
          "functionType": "Expression",
          "group": "Field configuration",
          "name": "AreaRight",
          "private": false,
          "sentence": "",
          "events": [
            {
              "type": "BuiltinCommonInstructions::Standard",
              "conditions": [],
              "actions": [
                {
                  "type": {
                    "value": "SetReturnNumber"
                  },
                  "parameters": [
                    "Object.Behavior::PropertyAreaRightBound()"
                  ]
                }
              ]
            },
            {
              "type": "BuiltinCommonInstructions::Standard",
              "conditions": [
                {
                  "type": {
                    "value": "Egal"
                  },
                  "parameters": [
                    "Object.Behavior::PropertyAreaLeftBound()",
                    "=",
                    "Object.Behavior::PropertyAreaRightBound()"
                  ]
                }
              ],
              "actions": [
                {
                  "type": {
                    "value": "SetReturnNumber"
                  },
                  "parameters": [
                    "Object.Behavior::PropertyAreaLeftBound() + SceneWindowWidth()"
                  ]
                }
              ]
            }
          ],
          "parameters": [
            {
              "codeOnly": false,
              "defaultValue": "",
              "description": "Object",
              "longDescription": "",
              "name": "Object",
              "optional": false,
              "supplementaryInformation": "PrimitiveDrawing::Drawer",
              "type": "object"
            },
            {
              "codeOnly": false,
              "defaultValue": "",
              "description": "Behavior",
              "longDescription": "",
              "name": "Behavior",
              "optional": false,
              "supplementaryInformation": "MarchingSquares::MarchingSquaresBehavior",
              "type": "behavior"
            }
          ],
          "objectGroups": []
        },
        {
          "description": "Area bottom bound of the field.",
          "fullName": "Area bottom",
          "functionType": "Expression",
          "group": "Field configuration",
          "name": "AreaBottom",
          "private": false,
          "sentence": "",
          "events": [
            {
              "type": "BuiltinCommonInstructions::Standard",
              "conditions": [],
              "actions": [
                {
                  "type": {
                    "value": "SetReturnNumber"
                  },
                  "parameters": [
                    "Object.Behavior::PropertyAreaBottomBound()"
                  ]
                }
              ]
            },
            {
              "type": "BuiltinCommonInstructions::Standard",
              "conditions": [
                {
                  "type": {
                    "value": "Egal"
                  },
                  "parameters": [
                    "Object.Behavior::PropertyAreaTopBound()",
                    "=",
                    "Object.Behavior::PropertyAreaBottomBound()"
                  ]
                }
              ],
              "actions": [
                {
                  "type": {
                    "value": "SetReturnNumber"
                  },
                  "parameters": [
                    "Object.Behavior::PropertyAreaTopBound() + SceneWindowHeight()"
                  ]
                }
              ]
            }
          ],
          "parameters": [
            {
              "codeOnly": false,
              "defaultValue": "",
              "description": "Object",
              "longDescription": "",
              "name": "Object",
              "optional": false,
              "supplementaryInformation": "PrimitiveDrawing::Drawer",
              "type": "object"
            },
            {
              "codeOnly": false,
              "defaultValue": "",
              "description": "Behavior",
              "longDescription": "",
              "name": "Behavior",
              "optional": false,
              "supplementaryInformation": "MarchingSquares::MarchingSquaresBehavior",
              "type": "behavior"
            }
          ],
          "objectGroups": []
        },
        {
          "description": "Width of the field cells.",
          "fullName": "Width of a cell",
          "functionType": "Expression",
          "group": "Field configuration",
          "name": "CellWidth",
          "private": false,
          "sentence": "",
          "events": [
            {
              "type": "BuiltinCommonInstructions::Standard",
              "conditions": [],
              "actions": [
                {
                  "type": {
                    "value": "SetReturnNumber"
                  },
                  "parameters": [
                    "Object.Behavior::PropertyCellWidth()"
                  ]
                }
              ]
            }
          ],
          "parameters": [
            {
              "codeOnly": false,
              "defaultValue": "",
              "description": "Object",
              "longDescription": "",
              "name": "Object",
              "optional": false,
              "supplementaryInformation": "PrimitiveDrawing::Drawer",
              "type": "object"
            },
            {
              "codeOnly": false,
              "defaultValue": "",
              "description": "Behavior",
              "longDescription": "",
              "name": "Behavior",
              "optional": false,
              "supplementaryInformation": "MarchingSquares::MarchingSquaresBehavior",
              "type": "behavior"
            }
          ],
          "objectGroups": []
        },
        {
          "description": "Height of the field cells.",
          "fullName": "Height of a cell",
          "functionType": "Expression",
          "group": "Field configuration",
          "name": "CellHeight",
          "private": false,
          "sentence": "",
          "events": [
            {
              "type": "BuiltinCommonInstructions::Standard",
              "conditions": [],
              "actions": [
                {
                  "type": {
                    "value": "SetReturnNumber"
                  },
                  "parameters": [
                    "Object.Behavior::PropertyCellHeight()"
                  ]
                }
              ]
            }
          ],
          "parameters": [
            {
              "codeOnly": false,
              "defaultValue": "",
              "description": "Object",
              "longDescription": "",
              "name": "Object",
              "optional": false,
              "supplementaryInformation": "PrimitiveDrawing::Drawer",
              "type": "object"
            },
            {
              "codeOnly": false,
              "defaultValue": "",
              "description": "Behavior",
              "longDescription": "",
              "name": "Behavior",
              "optional": false,
              "supplementaryInformation": "MarchingSquares::MarchingSquaresBehavior",
              "type": "behavior"
            }
          ],
          "objectGroups": []
        },
        {
          "description": "The number of cells on the x axis.",
          "fullName": "Dimension X",
          "functionType": "Expression",
          "group": "Field saving",
          "name": "DimensionX",
          "private": false,
          "sentence": "At _PARAM2_; _PARAM3_ the field value of _PARAM0_ is greater than _PARAM4_",
          "events": [
            {
              "type": "BuiltinCommonInstructions::JsCode",
              "inlineCode": "\nconst behaviorName = eventsFunctionContext.getBehaviorName(\"Behavior\");\n\nconst behavior = objects[0].getBehavior(behaviorName);\n\neventsFunctionContext.returnValue = behavior.scalarField.dimX();",
              "parameterObjects": "Object",
              "useStrict": true,
              "eventsSheetExpanded": true
            }
          ],
          "parameters": [
            {
              "codeOnly": false,
              "defaultValue": "",
              "description": "Object",
              "longDescription": "",
              "name": "Object",
              "optional": false,
              "supplementaryInformation": "PrimitiveDrawing::Drawer",
              "type": "object"
            },
            {
              "codeOnly": false,
              "defaultValue": "",
              "description": "Behavior",
              "longDescription": "",
              "name": "Behavior",
              "optional": false,
              "supplementaryInformation": "MarchingSquares::MarchingSquaresBehavior",
              "type": "behavior"
            }
          ],
          "objectGroups": []
        },
        {
          "description": "The number of cells on the y axis.",
          "fullName": "Dimension Y",
          "functionType": "Expression",
          "group": "Field saving",
          "name": "DimensionY",
          "private": false,
          "sentence": "At _PARAM2_; _PARAM3_ the field value of _PARAM0_ is greater than _PARAM4_",
          "events": [
            {
              "type": "BuiltinCommonInstructions::JsCode",
              "inlineCode": "\nconst behaviorName = eventsFunctionContext.getBehaviorName(\"Behavior\");\n\nconst behavior = objects[0].getBehavior(behaviorName);\n\neventsFunctionContext.returnValue = behavior.scalarField.dimY();",
              "parameterObjects": "Object",
              "useStrict": true,
              "eventsSheetExpanded": true
            }
          ],
          "parameters": [
            {
              "codeOnly": false,
              "defaultValue": "",
              "description": "Object",
              "longDescription": "",
              "name": "Object",
              "optional": false,
              "supplementaryInformation": "PrimitiveDrawing::Drawer",
              "type": "object"
            },
            {
              "codeOnly": false,
              "defaultValue": "",
              "description": "Behavior",
              "longDescription": "",
              "name": "Behavior",
              "optional": false,
              "supplementaryInformation": "MarchingSquares::MarchingSquaresBehavior",
              "type": "behavior"
            }
          ],
          "objectGroups": []
        },
        {
          "description": "The contour threshold.",
          "fullName": "Contour threshold",
          "functionType": "Expression",
          "group": "Field configuration",
          "name": "ContourThreshold",
          "private": false,
          "sentence": "",
          "events": [
            {
              "type": "BuiltinCommonInstructions::Standard",
              "conditions": [],
              "actions": [
                {
                  "type": {
                    "value": "SetReturnNumber"
                  },
                  "parameters": [
                    "Object.Behavior::PropertyThreshold()"
                  ]
                }
              ]
            }
          ],
          "parameters": [
            {
              "codeOnly": false,
              "defaultValue": "",
              "description": "Object",
              "longDescription": "",
              "name": "Object",
              "optional": false,
              "supplementaryInformation": "PrimitiveDrawing::Drawer",
              "type": "object"
            },
            {
              "codeOnly": false,
              "defaultValue": "",
              "description": "Behavior",
              "longDescription": "",
              "name": "Behavior",
              "optional": false,
              "supplementaryInformation": "MarchingSquares::MarchingSquaresBehavior",
              "type": "behavior"
            }
          ],
          "objectGroups": []
        },
        {
          "description": "The normal X coordinate at a given location.",
          "fullName": "Normal X",
          "functionType": "Expression",
          "group": "Field evaluation",
          "name": "NormalX",
          "private": false,
          "sentence": "At _PARAM2_; _PARAM3_ the field value of _PARAM0_ is greater than _PARAM4_",
          "events": [
            {
              "type": "BuiltinCommonInstructions::JsCode",
              "inlineCode": "\nconst behaviorName = eventsFunctionContext.getBehaviorName(\"Behavior\");\n\nconst pointX = eventsFunctionContext.getArgument(\"PointX\");\nconst pointY = eventsFunctionContext.getArgument(\"PointY\");\n\nconst behavior = objects[0].getBehavior(behaviorName);\n\neventsFunctionContext.returnValue = behavior.heightMap.getFieldNormal(pointX, pointY)[0];",
              "parameterObjects": "Object",
              "useStrict": true,
              "eventsSheetExpanded": true
            }
          ],
          "parameters": [
            {
              "codeOnly": false,
              "defaultValue": "",
              "description": "Object",
              "longDescription": "",
              "name": "Object",
              "optional": false,
              "supplementaryInformation": "PrimitiveDrawing::Drawer",
              "type": "object"
            },
            {
              "codeOnly": false,
              "defaultValue": "",
              "description": "Behavior",
              "longDescription": "",
              "name": "Behavior",
              "optional": false,
              "supplementaryInformation": "MarchingSquares::MarchingSquaresBehavior",
              "type": "behavior"
            },
            {
              "codeOnly": false,
              "defaultValue": "",
              "description": "X position of the point",
              "longDescription": "",
              "name": "PointX",
              "optional": false,
              "supplementaryInformation": "",
              "type": "expression"
            },
            {
              "codeOnly": false,
              "defaultValue": "",
              "description": "Y position of the point",
              "longDescription": "",
              "name": "PointY",
              "optional": false,
              "supplementaryInformation": "",
              "type": "expression"
            }
          ],
          "objectGroups": []
        },
        {
          "description": "The normal Y coordinate at a given location.",
          "fullName": "Normal Y",
          "functionType": "Expression",
          "group": "Field evaluation",
          "name": "NormalY",
          "private": false,
          "sentence": "At _PARAM2_; _PARAM3_ the field value of _PARAM0_ is greater than _PARAM4_",
          "events": [
            {
              "type": "BuiltinCommonInstructions::JsCode",
              "inlineCode": "\nconst behaviorName = eventsFunctionContext.getBehaviorName(\"Behavior\");\n\nconst pointX = eventsFunctionContext.getArgument(\"PointX\");\nconst pointY = eventsFunctionContext.getArgument(\"PointY\");\n\nconst behavior = objects[0].getBehavior(behaviorName);\n\neventsFunctionContext.returnValue = behavior.heightMap.getFieldNormal(pointX, pointY)[1];",
              "parameterObjects": "Object",
              "useStrict": true,
              "eventsSheetExpanded": true
            }
          ],
          "parameters": [
            {
              "codeOnly": false,
              "defaultValue": "",
              "description": "Object",
              "longDescription": "",
              "name": "Object",
              "optional": false,
              "supplementaryInformation": "PrimitiveDrawing::Drawer",
              "type": "object"
            },
            {
              "codeOnly": false,
              "defaultValue": "",
              "description": "Behavior",
              "longDescription": "",
              "name": "Behavior",
              "optional": false,
              "supplementaryInformation": "MarchingSquares::MarchingSquaresBehavior",
              "type": "behavior"
            },
            {
              "codeOnly": false,
              "defaultValue": "",
              "description": "X position of the point",
              "longDescription": "",
              "name": "PointX",
              "optional": false,
              "supplementaryInformation": "",
              "type": "expression"
            },
            {
              "codeOnly": false,
              "defaultValue": "",
              "description": "Y position of the point",
              "longDescription": "",
              "name": "PointY",
              "optional": false,
              "supplementaryInformation": "",
              "type": "expression"
            }
          ],
          "objectGroups": []
        },
        {
          "description": "The normal Z coordinate at a given location.",
          "fullName": "Normal Z",
          "functionType": "Expression",
          "group": "Field evaluation",
          "name": "NormalZ",
          "private": false,
          "sentence": "At _PARAM2_; _PARAM3_ the field value of _PARAM0_ is greater than _PARAM4_",
          "events": [
            {
              "type": "BuiltinCommonInstructions::JsCode",
              "inlineCode": "\nconst behaviorName = eventsFunctionContext.getBehaviorName(\"Behavior\");\n\nconst pointX = eventsFunctionContext.getArgument(\"PointX\");\nconst pointY = eventsFunctionContext.getArgument(\"PointY\");\n\nconst behavior = objects[0].getBehavior(behaviorName);\n\neventsFunctionContext.returnValue = behavior.heightMap.getFieldNormal(pointX, pointY)[2];",
              "parameterObjects": "Object",
              "useStrict": true,
              "eventsSheetExpanded": true
            }
          ],
          "parameters": [
            {
              "codeOnly": false,
              "defaultValue": "",
              "description": "Object",
              "longDescription": "",
              "name": "Object",
              "optional": false,
              "supplementaryInformation": "PrimitiveDrawing::Drawer",
              "type": "object"
            },
            {
              "codeOnly": false,
              "defaultValue": "",
              "description": "Behavior",
              "longDescription": "",
              "name": "Behavior",
              "optional": false,
              "supplementaryInformation": "MarchingSquares::MarchingSquaresBehavior",
              "type": "behavior"
            },
            {
              "codeOnly": false,
              "defaultValue": "",
              "description": "X position of the point",
              "longDescription": "",
              "name": "PointX",
              "optional": false,
              "supplementaryInformation": "",
              "type": "expression"
            },
            {
              "codeOnly": false,
              "defaultValue": "",
              "description": "Y position of the point",
              "longDescription": "",
              "name": "PointY",
              "optional": false,
              "supplementaryInformation": "",
              "type": "expression"
            }
          ],
          "objectGroups": []
        },
        {
          "description": "Change the field value at a grid point.",
          "fullName": "Grid value",
          "functionType": "Action",
          "group": "Field loading",
          "name": "SetGridValue",
          "private": false,
          "sentence": "Change the field value of _PARAM0_ at the grid point _PARAM2_; _PARAM3_ to _PARAM4_",
          "events": [
            {
              "type": "BuiltinCommonInstructions::JsCode",
              "inlineCode": "\nconst behaviorName = eventsFunctionContext.getBehaviorName(\"Behavior\");\n\nconst indexX = eventsFunctionContext.getArgument(\"IndexX\");\nconst indexY = eventsFunctionContext.getArgument(\"IndexY\");\nconst value = eventsFunctionContext.getArgument(\"Value\");\n\nconst behavior = objects[0].getBehavior(behaviorName);\n\neventsFunctionContext.returnValue = behavior.scalarField.setGridValue(indexX, indexY, value);",
              "parameterObjects": "Object",
              "useStrict": true,
              "eventsSheetExpanded": true
            }
          ],
          "parameters": [
            {
              "codeOnly": false,
              "defaultValue": "",
              "description": "Object",
              "longDescription": "",
              "name": "Object",
              "optional": false,
              "supplementaryInformation": "PrimitiveDrawing::Drawer",
              "type": "object"
            },
            {
              "codeOnly": false,
              "defaultValue": "",
              "description": "Behavior",
              "longDescription": "",
              "name": "Behavior",
              "optional": false,
              "supplementaryInformation": "MarchingSquares::MarchingSquaresBehavior",
              "type": "behavior"
            },
            {
              "codeOnly": false,
              "defaultValue": "",
              "description": "X grid index",
              "longDescription": "",
              "name": "IndexX",
              "optional": false,
              "supplementaryInformation": "",
              "type": "expression"
            },
            {
              "codeOnly": false,
              "defaultValue": "",
              "description": "Y grid index",
              "longDescription": "",
              "name": "IndexY",
              "optional": false,
              "supplementaryInformation": "",
              "type": "expression"
            },
            {
              "codeOnly": false,
              "defaultValue": "",
              "description": "Field value",
              "longDescription": "",
              "name": "Value",
              "optional": false,
              "supplementaryInformation": "",
              "type": "expression"
            }
          ],
          "objectGroups": []
        },
        {
          "description": "The field value at a grid point.",
          "fullName": "Grid value",
          "functionType": "Expression",
          "group": "Field saving",
          "name": "GridValue",
          "private": false,
          "sentence": "At _PARAM2_; _PARAM3_ the field value of _PARAM0_ is greater than _PARAM4_",
          "events": [
            {
              "type": "BuiltinCommonInstructions::JsCode",
              "inlineCode": "\nconst behaviorName = eventsFunctionContext.getBehaviorName(\"Behavior\");\n\nconst indexX = eventsFunctionContext.getArgument(\"IndexX\");\nconst indexY = eventsFunctionContext.getArgument(\"IndexY\");\n\nconst behavior = objects[0].getBehavior(behaviorName);\n\neventsFunctionContext.returnValue = behavior.scalarField.getGridValue(indexX, indexY);",
              "parameterObjects": "Object",
              "useStrict": true,
              "eventsSheetExpanded": true
            }
          ],
          "parameters": [
            {
              "codeOnly": false,
              "defaultValue": "",
              "description": "Object",
              "longDescription": "",
              "name": "Object",
              "optional": false,
              "supplementaryInformation": "PrimitiveDrawing::Drawer",
              "type": "object"
            },
            {
              "codeOnly": false,
              "defaultValue": "",
              "description": "Behavior",
              "longDescription": "",
              "name": "Behavior",
              "optional": false,
              "supplementaryInformation": "MarchingSquares::MarchingSquaresBehavior",
              "type": "behavior"
            },
            {
              "codeOnly": false,
              "defaultValue": "",
              "description": "X grid index",
              "longDescription": "",
              "name": "IndexX",
              "optional": false,
              "supplementaryInformation": "",
              "type": "expression"
            },
            {
              "codeOnly": false,
              "defaultValue": "",
              "description": "Y grid index",
              "longDescription": "",
              "name": "IndexY",
              "optional": false,
              "supplementaryInformation": "",
              "type": "expression"
            }
          ],
          "objectGroups": []
        },
        {
          "description": "The field value at a given location.",
          "fullName": "Field value",
          "functionType": "Expression",
          "group": "Field evaluation",
          "name": "FieldValue",
          "private": false,
          "sentence": "At _PARAM2_; _PARAM3_ the field value of _PARAM0_ is greater than _PARAM4_",
          "events": [
            {
              "type": "BuiltinCommonInstructions::JsCode",
              "inlineCode": "\nconst behaviorName = eventsFunctionContext.getBehaviorName(\"Behavior\");\n\nconst pointX = eventsFunctionContext.getArgument(\"PointX\");\nconst pointY = eventsFunctionContext.getArgument(\"PointY\");\n\nconst behavior = objects[0].getBehavior(behaviorName);\n\neventsFunctionContext.returnValue = behavior.heightMap.getHeight(pointX, pointY);",
              "parameterObjects": "Object",
              "useStrict": true,
              "eventsSheetExpanded": true
            }
          ],
          "parameters": [
            {
              "codeOnly": false,
              "defaultValue": "",
              "description": "Object",
              "longDescription": "",
              "name": "Object",
              "optional": false,
              "supplementaryInformation": "PrimitiveDrawing::Drawer",
              "type": "object"
            },
            {
              "codeOnly": false,
              "defaultValue": "",
              "description": "Behavior",
              "longDescription": "",
              "name": "Behavior",
              "optional": false,
              "supplementaryInformation": "MarchingSquares::MarchingSquaresBehavior",
              "type": "behavior"
            },
            {
              "codeOnly": false,
              "defaultValue": "",
              "description": "X position of the point",
              "longDescription": "",
              "name": "PointX",
              "optional": false,
              "supplementaryInformation": "",
              "type": "expression"
            },
            {
              "codeOnly": false,
              "defaultValue": "",
              "description": "Y position of the point",
              "longDescription": "",
              "name": "PointY",
              "optional": false,
              "supplementaryInformation": "",
              "type": "expression"
            }
          ],
          "objectGroups": []
        },
        {
          "description": "Check if the contours are filled outside.",
          "fullName": "Fill outside",
          "functionType": "Condition",
          "group": "Field configuration",
          "name": "CheckFillOutside",
          "private": false,
          "sentence": "The contours of _PARAM0_ are filled outside",
          "events": [
            {
              "type": "BuiltinCommonInstructions::Standard",
              "conditions": [],
              "actions": [
                {
                  "type": {
                    "value": "SetReturnBoolean"
                  },
                  "parameters": [
                    "False"
                  ]
                }
              ]
            },
            {
              "type": "BuiltinCommonInstructions::Standard",
              "conditions": [
                {
                  "type": {
                    "value": "MarchingSquares::MarchingSquaresBehavior::PropertyFillOutside"
                  },
                  "parameters": [
                    "Object",
                    "Behavior"
                  ]
                }
              ],
              "actions": [
                {
                  "type": {
                    "value": "SetReturnBoolean"
                  },
                  "parameters": [
                    "True"
                  ]
                }
              ]
            }
          ],
          "parameters": [
            {
              "codeOnly": false,
              "defaultValue": "",
              "description": "Object",
              "longDescription": "",
              "name": "Object",
              "optional": false,
              "supplementaryInformation": "PrimitiveDrawing::Drawer",
              "type": "object"
            },
            {
              "codeOnly": false,
              "defaultValue": "",
              "description": "Behavior",
              "longDescription": "",
              "name": "Behavior",
              "optional": false,
              "supplementaryInformation": "MarchingSquares::MarchingSquaresBehavior",
              "type": "behavior"
            }
          ],
          "objectGroups": []
        },
        {
          "description": "Check if a field is greater than a given value.",
          "fullName": "Field value",
          "functionType": "Condition",
          "group": "Field evaluation",
          "name": "CheckFieldValue",
          "private": false,
          "sentence": "At _PARAM2_; _PARAM3_ the field value of _PARAM0_ is greater than _PARAM4_",
          "events": [
            {
              "type": "BuiltinCommonInstructions::JsCode",
              "inlineCode": "\nconst behaviorName = eventsFunctionContext.getBehaviorName(\"Behavior\");\n\nconst pointX = eventsFunctionContext.getArgument(\"PointX\");\nconst pointY = eventsFunctionContext.getArgument(\"PointY\");\nconst value = eventsFunctionContext.getArgument(\"Value\");\n\nconst behavior = objects[0].getBehavior(behaviorName);\n\neventsFunctionContext.returnValue = behavior.heightMap.getHeight(pointX, pointY) > value;",
              "parameterObjects": "Object",
              "useStrict": true,
              "eventsSheetExpanded": true
            }
          ],
          "parameters": [
            {
              "codeOnly": false,
              "defaultValue": "",
              "description": "Object",
              "longDescription": "",
              "name": "Object",
              "optional": false,
              "supplementaryInformation": "PrimitiveDrawing::Drawer",
              "type": "object"
            },
            {
              "codeOnly": false,
              "defaultValue": "",
              "description": "Behavior",
              "longDescription": "",
              "name": "Behavior",
              "optional": false,
              "supplementaryInformation": "MarchingSquares::MarchingSquaresBehavior",
              "type": "behavior"
            },
            {
              "codeOnly": false,
              "defaultValue": "",
              "description": "X position of the point",
              "longDescription": "",
              "name": "PointX",
              "optional": false,
              "supplementaryInformation": "",
              "type": "expression"
            },
            {
              "codeOnly": false,
              "defaultValue": "",
              "description": "Y position of the point",
              "longDescription": "",
              "name": "PointY",
              "optional": false,
              "supplementaryInformation": "",
              "type": "expression"
            },
            {
              "codeOnly": false,
              "defaultValue": "",
              "description": "Value",
              "longDescription": "",
              "name": "Value",
              "optional": false,
              "supplementaryInformation": "",
              "type": "expression"
            }
          ],
          "objectGroups": []
        },
        {
          "description": "Check if a point is inside the contour.",
          "fullName": "Point is inside",
          "functionType": "Condition",
          "group": "Field evaluation",
          "name": "ContainsPoint",
          "private": false,
          "sentence": "_PARAM2_; _PARAM3_ is inside _PARAM0_",
          "events": [
            {
              "type": "BuiltinCommonInstructions::JsCode",
              "inlineCode": "\nconst behaviorName = eventsFunctionContext.getBehaviorName(\"Behavior\");\n\nconst pointX = eventsFunctionContext.getArgument(\"PointX\");\nconst pointY = eventsFunctionContext.getArgument(\"PointY\");\n\nconst behavior = objects[0].getBehavior(behaviorName);\n\neventsFunctionContext.returnValue = behavior.containsPoint(pointX, pointY);",
              "parameterObjects": "Object",
              "useStrict": true,
              "eventsSheetExpanded": true
            }
          ],
          "parameters": [
            {
              "codeOnly": false,
              "defaultValue": "",
              "description": "Object",
              "longDescription": "",
              "name": "Object",
              "optional": false,
              "supplementaryInformation": "PrimitiveDrawing::Drawer",
              "type": "object"
            },
            {
              "codeOnly": false,
              "defaultValue": "",
              "description": "Behavior",
              "longDescription": "",
              "name": "Behavior",
              "optional": false,
              "supplementaryInformation": "MarchingSquares::MarchingSquaresBehavior",
              "type": "behavior"
            },
            {
              "codeOnly": false,
              "defaultValue": "",
              "description": "X position of the point",
              "longDescription": "",
              "name": "PointX",
              "optional": false,
              "supplementaryInformation": "",
              "type": "expression"
            },
            {
              "codeOnly": false,
              "defaultValue": "",
              "description": "Y position of the point",
              "longDescription": "",
              "name": "PointY",
              "optional": false,
              "supplementaryInformation": "",
              "type": "expression"
            }
          ],
          "objectGroups": []
        }
      ],
      "propertyDescriptors": [
        {
          "value": "0",
          "type": "Number",
          "label": "Area left bound",
          "description": "",
          "group": "",
          "extraInformation": [],
          "hidden": false,
          "name": "AreaLeftBound"
        },
        {
          "value": "0",
          "type": "Number",
          "label": "Area top bound",
          "description": "",
          "group": "",
          "extraInformation": [],
          "hidden": false,
          "name": "AreaTopBound"
        },
        {
          "value": "0",
          "type": "Number",
          "label": "Area right bound",
          "description": "",
          "group": "",
          "extraInformation": [],
          "hidden": false,
          "name": "AreaRightBound"
        },
        {
          "value": "0",
          "type": "Number",
          "label": "Area bottom bound",
          "description": "",
          "group": "",
          "extraInformation": [],
          "hidden": false,
          "name": "AreaBottomBound"
        },
        {
          "value": "20",
          "type": "Number",
          "label": "Cell width",
          "description": "",
          "group": "",
          "extraInformation": [],
          "hidden": false,
          "name": "CellWidth"
        },
        {
          "value": "20",
          "type": "Number",
          "label": "Cell height",
          "description": "",
          "group": "",
          "extraInformation": [],
          "hidden": false,
          "name": "CellHeight"
        },
        {
          "value": "",
          "type": "Boolean",
          "label": "Fill outside",
          "description": "",
          "group": "",
          "extraInformation": [],
          "hidden": false,
          "name": "FillOutside"
        },
        {
          "value": "1",
          "type": "Number",
          "label": "Contour threshold",
          "description": "",
          "group": "",
          "extraInformation": [],
          "hidden": false,
          "name": "Threshold"
        },
        {
          "value": "",
          "type": "Boolean",
          "label": "Must only draw what is on the screen",
          "description": "",
          "group": "",
          "extraInformation": [],
          "hidden": false,
          "name": "MustOnlyDrawScreen"
        }
      ]
    }
  ],
  "eventsBasedObjects": []
}