{
  "author": "D8H",
  "category": "Visual effect",
  "extensionNamespace": "",
  "gdevelopVersion": ">=5.5.222",
  "fullName": "Marching Squares (experimental)",
  "helpPath": "/extensions/marching-squares/details",
  "iconUrl": "data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0iVVRGLTgiPz48IURPQ1RZUEUgc3ZnIFBVQkxJQyAiLS8vVzNDLy9EVEQgU1ZHIDEuMS8vRU4iICJodHRwOi8vd3d3LnczLm9yZy9HcmFwaGljcy9TVkcvMS4xL0RURC9zdmcxMS5kdGQiPjxzdmcgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIiB4bWxuczp4bGluaz0iaHR0cDovL3d3dy53My5vcmcvMTk5OS94bGluayIgdmVyc2lvbj0iMS4xIiBpZD0ibWRpLXBlYW51dC1vdXRsaW5lIiB3aWR0aD0iMjQiIGhlaWdodD0iMjQiIHZpZXdCb3g9IjAgMCAyNCAyNCI+PHBhdGggZD0iTTEyIDIzQzExLjUzIDIzIDExLjA3IDIyLjk1IDEwLjYxIDIyLjg1QzcuMSAyMi4xIDQuODcgMTguNjQgNS42MiAxNS4xM0M1Ljg3IDEzLjk1IDYuNDUgMTIuODcgNy4yOCAxMkM3LjYyIDExLjY0IDcuNjIgMTEuMDggNy4yOCAxMC43MkM1LjIgOC4xNCA1LjYgNC4zNiA4LjE4IDIuMjhTMTQuNTQuNjA3IDE2LjYyIDMuMTlDMTguMzkgNS4zOCAxOC4zOSA4LjUgMTYuNjIgMTAuNzJDMTYuMzMgMTEuMTMgMTYuMzcgMTEuNyAxNi43MiAxMi4wNkMxOS4xNyAxNC42OCAxOS4wNCAxOC44IDE2LjQxIDIxLjI1QzE1LjIyIDIyLjM3IDEzLjY0IDIzIDEyIDIzTTEyIDNDMTEuMDkgMyAxMC4yIDMuMzEgOS41IDMuODlDOC41NSA0LjY1IDggNS43OSA4IDdDOCA3LjkxIDguMzEgOC43OSA4Ljg4IDkuNUM5Ljg0IDEwLjY0IDkuNzcgMTIuMzMgOC43MyAxMy40MUM3LjAzIDE1LjIyIDcuMTMgMTguMDcgOC45NCAxOS43N1MxMy42IDIxLjM4IDE1LjMgMTkuNTZDMTYuOTIgMTcuODMgMTYuOTIgMTUuMTQgMTUuMyAxMy40MUMxNC4yMyAxMi4zMiAxNC4xNSAxMC42IDE1LjEyIDkuNDFDMTYuNSA3LjY5IDE2LjIyIDUuMTcgMTQuNSAzLjc5QzE0IDMuNDEgMTMuNDcgMy4xNCAxMi44OCAzQzEyLjU5IDMgMTIuMjkgMyAxMiAzTTEyIDZDMTIgNi41NSAxMi40NSA3IDEzIDdTMTQgNi41NSAxNCA2IDEzLjU1IDUgMTMgNSAxMiA1LjQ1IDEyIDZNMTQgMTlDMTQuNTUgMTkgMTUgMTguNTUgMTUgMThTMTQuNTUgMTcgMTQgMTcgMTMgMTcuNDUgMTMgMTggMTMuNDUgMTkgMTQgMTlNMTMgMTZDMTMuNTUgMTYgMTQgMTUuNTUgMTQgMTVTMTMuNTUgMTQgMTMgMTQgMTIgMTQuNDUgMTIgMTUgMTIuNDUgMTYgMTMgMTZNMTEgMThDMTEuNTUgMTggMTIgMTcuNTUgMTIgMTdTMTEuNTUgMTYgMTEgMTYgMTAgMTYuNDUgMTAgMTcgMTAuNDUgMTggMTEgMThaIiAvPjwvc3ZnPg==",
  "name": "MarchingSquares",
  "previewIconUrl": "https://resources.gdevelop-app.com/assets/Icons/peanut-outline.svg",
  "shortDescription": "Allow to build a \"scalar field\" and draw contour lines of it: useful for fog of wars, liquid effects, paint the ground, etc...",
  "version": "0.6.0",
  "description": [
    "It can be helpful for:",
    "  * Liquid effects like water, blobs or lava ([open the project online](https://editor.gdevelop.io/?project=example://marching-squares-liquids))",
    "  * Fog of wars ([open the project online](https://editor.gdevelop.io/?project=example://marching-squares-fog-of-war))",
    "  * Platformer with destructible platforms ([open the project online](https://editor.gdevelop.io/?project=example://marching-squares-platforms-painter))",
    "  * Dynamically paint territories ([open the project online](https://editor.gdevelop.io/?project=example://marching-squares-qix))",
    "  * Top-down relief with physics ([open the project online](https://editor.gdevelop.io/?project=example://marching-squares-terraforming))",
    "  * Island generator ([open the project online](https://editor.gdevelop.io/?project=example://marching-squares-island-generator))"
  ],
  "origin": {
    "identifier": "MarchingSquares",
    "name": "gdevelop-extension-store"
  },
  "tags": [
    "blobs",
    "liquid",
    "lava",
    "water",
    "fog",
    "paint",
    "heightmap"
  ],
  "authorIds": [
    "IWykYNRvhCZBN3vEgKEbBPOR3Oc2"
  ],
  "dependencies": [],
  "globalVariables": [],
  "sceneVariables": [],
  "eventsFunctions": [
    {
      "description": "Define the scalar field painter library JavaScript code.",
      "fullName": "Define scalar field painter library",
      "functionType": "Action",
      "name": "DefineScalarFieldPainterLibrary",
      "private": true,
      "sentence": "Define the scalar field painter library JavaScript code",
      "events": [
        {
          "type": "BuiltinCommonInstructions::JsCode",
          "inlineCode": [
            "// This library comes from https://github.com/D8H/scalar-field-painter",
            "// It can be generated with \"npm run build\" to the dist/ScalarFieldPainter.js",
            "",
            "/**",
            " * A stock to reuse instances and avoid allocation.",
            " */",
            "class Stock {",
            "    /**",
            "     * Create a stock.",
            "     */",
            "    constructor() {",
            "        this.elements = [];",
            "    }",
            "    /**",
            "     * Get an element to avoid allocation or create a new one if the stock is",
            "     * empty.",
            "     * @param create",
            "     * @returns an element",
            "     */",
            "    getOrCreate(create) {",
            "        return this.elements.pop() || create();",
            "    }",
            "    /**",
            "     * Stock an element to use it later.",
            "     * @param element",
            "     */",
            "    stock(element) {",
            "        this.elements.push(element);",
            "    }",
            "    /**",
            "     * Free all the elements from the stock.",
            "     */",
            "    flush() {",
            "        this.elements.length = 0;",
            "    }",
            "}",
            "",
            "const deltas = [",
            "    { x: -1, y: 0 },",
            "    { x: 1, y: 0 },",
            "    { x: 0, y: -1 },",
            "    { x: 0, y: 1 },",
            "];",
            "const createNode = () => ({ x: 0, y: 0 });",
            "const createContourNode = () => ({",
            "    x: 0,",
            "    y: 0,",
            "    originX: 0,",
            "    originY: 0,",
            "    value: 0,",
            "});",
            "/**",
            " *",
            " */",
            "class FloodFill {",
            "    constructor(scalarField) {",
            "        this.floodStack = [];",
            "        this.nodeStock = new Stock();",
            "        this.contourStack = [];",
            "        this.nextContourStack = [];",
            "        this.contourNodeStock = new Stock();",
            "        this.scalarField = scalarField;",
            "    }",
            "    /**",
            "     * Fill an area from a given location until a maximum field value is reached.",
            "     *",
            "     * The result is the same as drawing circles at every point of the area.",
            "     * This mean that the area will be filled with a value a lot gibber than 1.",
            "     *",
            "     * @param originX {float} in grid basis",
            "     * @param originY {float} in grid basis",
            "     * @param valueMax {float} the value where to stop the flooding",
            "     * @param thickness {float} the thickness of the contour shading.",
            "     * The field will have the value 1 at this given distance from the area.",
            "     * @param cappingRadiusRatio {float} the radius where to stop the contour shading",
            "     * or a maximum otherwise.",
            "     */",
            "    fillFrom(originX, originY, valueMax, thickness, cappingRadiusRatio) {",
            "        const thicknessSq = thickness * thickness;",
            "        const fillingValue = Math.max(valueMax, thicknessSq * 1024 * 1024);",
            "        const cappingRadius = cappingRadiusRatio * thickness;",
            "        const cappingRadiusSq = cappingRadius * cappingRadius;",
            "        const getContourValue = (fieldValue, distanceSq) => {",
            "            const value = thicknessSq / distanceSq;",
            "            return fieldValue < value && distanceSq < cappingRadiusSq ? value : null;",
            "        };",
            "        this.floodFrom(originX, originY, (fieldValue) => fieldValue < valueMax, fillingValue, getContourValue);",
            "        this.shadeContour(getContourValue);",
            "    }",
            "    /**",
            "     * Unfill an area from a given location until a minimum field value is reached.",
            "     *",
            "     * It fills the area with the value 0.",
            "     *",
            "     * @param originX {float} in grid basis",
            "     * @param originY {float} in grid basis",
            "     * @param valueMax {float} the value where to stop the flooding",
            "     * @param thickness {float} the thickness of the contour shading.",
            "     * The field will have the value 1 at this given distance from the area.",
            "     * @param cappingRadiusRatio {float} the radius where to stop the contour shading",
            "     * or a maximum otherwise.",
            "     */",
            "    unfillFrom(originX, originY, valueMin, thickness, cappingRadiusRatio) {",
            "        const fillingValue = 0;",
            "        const thicknessSq = thickness * thickness;",
            "        const cappingRadius = cappingRadiusRatio * thickness;",
            "        const cappingRadiusSq = cappingRadius * cappingRadius;",
            "        const getContourValue = (fieldValue, distanceSq) => {",
            "            const value = distanceSq / thicknessSq;",
            "            return fieldValue > value && distanceSq < cappingRadiusSq ? value : null;",
            "        };",
            "        this.floodFrom(originX, originY, (fieldValue) => fieldValue > valueMin, fillingValue, getContourValue);",
            "        this.shadeContour(getContourValue);",
            "    }",
            "    /**",
            "     * Flood an area from a given location until a condition is reached.",
            "     * @param originX {float} in grid basis",
            "     * @param originY {float} in grid basis",
            "     * @param canFlood {(float) => boolean}",
            "     * @param fillingValue {float}",
            "     * @param getContourValue {(number, number) => number}",
            "     * or a maximum otherwise.",
            "     */",
            "    floodFrom(originX, originY, canFlood, fillingValue, getContourValue) {",
            "        const scalarField = this.scalarField;",
            "        // They should already be empty at this point.",
            "        this.floodStack.length = 0;",
            "        this.contourStack.length = 0;",
            "        this.nextContourStack.length = 0;",
            "        {",
            "            const x = Math.round(originX);",
            "            const y = Math.round(originY);",
            "            if (!scalarField.isInside(x, y)) {",
            "                return;",
            "            }",
            "            const fieldValue = scalarField.get(x, y);",
            "            if (canFlood(fieldValue)) {",
            "                const node = this.nodeStock.getOrCreate(createNode);",
            "                node.x = x;",
            "                node.y = y;",
            "                this.floodStack.push(node);",
            "            }",
            "        }",
            "        while (this.floodStack.length > 0) {",
            "            const node = this.floodStack.pop();",
            "            const x = node.x;",
            "            const y = node.y;",
            "            scalarField.set(x, y, fillingValue);",
            "            for (const delta of deltas) {",
            "                const neighborX = x + delta.x;",
            "                const neighborY = y + delta.y;",
            "                if (!scalarField.isInside(neighborX, neighborY)) {",
            "                    continue;",
            "                }",
            "                const fieldValue = scalarField.get(neighborX, neighborY);",
            "                if (canFlood(fieldValue)) {",
            "                    const neighbor = this.nodeStock.getOrCreate(createNode);",
            "                    neighbor.x = neighborX;",
            "                    neighbor.y = neighborY;",
            "                    this.floodStack.push(neighbor);",
            "                }",
            "                else {",
            "                    this.checkAnAddContourNode(neighborX, neighborY, x, y, getContourValue);",
            "                }",
            "            }",
            "            this.nodeStock.stock(node);",
            "        }",
            "    }",
            "    /**",
            "     * Shade the contour to keep the field somewhat continuous.",
            "     * @param getContourValue",
            "     */",
            "    shadeContour(getContourValue) {",
            "        const scalarField = this.scalarField;",
            "        const swap = this.nextContourStack;",
            "        this.nextContourStack = this.contourStack;",
            "        this.contourStack = swap;",
            "        while (this.contourStack.length > 0) {",
            "            while (this.contourStack.length > 0) {",
            "                const node = this.contourStack.pop();",
            "                if (scalarField.get(node.x, node.y) > node.value) {",
            "                    // This node wasn't the nearest one.",
            "                    continue;",
            "                }",
            "                for (const delta of deltas) {",
            "                    const neighborX = node.x + delta.x;",
            "                    const neighborY = node.y + delta.y;",
            "                    this.checkAnAddContourNode(neighborX, neighborY, node.originX, node.originY, getContourValue);",
            "                }",
            "                this.contourNodeStock.stock(node);",
            "            }",
            "            const swap = this.nextContourStack;",
            "            this.nextContourStack = this.contourStack;",
            "            this.contourStack = swap;",
            "        }",
            "    }",
            "    checkAnAddContourNode(nodeX, nodeY, originX, originY, getContourValue) {",
            "        const scalarField = this.scalarField;",
            "        if (!scalarField.isInside(nodeX, nodeY)) {",
            "            return;",
            "        }",
            "        // Avoid too big values",
            "        const minDistanceSq = 1 / 1024 / 1024;",
            "        const deltaX = nodeX - originX;",
            "        const deltaY = nodeY - originY;",
            "        const distanceSq = Math.max(minDistanceSq, deltaX * deltaX + deltaY * deltaY);",
            "        const value = getContourValue(scalarField.get(nodeX, nodeY), distanceSq);",
            "        if (value !== null) {",
            "            scalarField.set(nodeX, nodeY, value);",
            "            const newNode = this.contourNodeStock.getOrCreate(createContourNode);",
            "            newNode.x = nodeX;",
            "            newNode.y = nodeY;",
            "            newNode.originX = originX;",
            "            newNode.originY = originY;",
            "            newNode.value = value;",
            "            this.nextContourStack.push(newNode);",
            "        }",
            "    }",
            "}",
            "",
            "/**",
            " * @param x1 {float} first point x",
            " * @param y1 {float} first point y",
            " * @param x2 {float} second point x",
            " * @param y2 {float} second point y",
            " * @return {float} the square distance between 2 points",
            " */",
            "const getDistanceSq = (x1, y1, x2, y2) => {",
            "    const deltaX = x2 - x1;",
            "    const deltaY = y2 - y1;",
            "    return deltaX * deltaX + deltaY * deltaY;",
            "};",
            "/**",
            " * @param x {float} point x",
            " * @param y {float} point y",
            " * @param x1 {float} segment extremity x",
            " * @param y1 {float} segment extremity y",
            " * @param x2 {float} segment extremity x",
            " * @param y2 {float} segment extremity y",
            " * @return {float} the square distance between a point and a segment",
            " */",
            "const getDistanceSqToSegment = (x, y, x1, y1, x2, y2) => {",
            "    const length2 = getDistanceSq(x1, y1, x2, y2);",
            "    if (length2 === 0)",
            "        return getDistanceSq(x, y, x1, y1);",
            "    const t = Math.max(0, Math.min(1, ((x - x1) * (x2 - x1) + (y - y1) * (y2 - y1)) / length2));",
            "    return getDistanceSq(x, y, x1 + t * (x2 - x1), y1 + t * (y2 - y1));",
            "};",
            "/**",
            " * A scalar field.",
            " */",
            "class ScalarField {",
            "    /**",
            "     * Create a scalar field.",
            "     * @param dimX {integer}",
            "     * @param dimY {integer}",
            "     */",
            "    constructor(dimX, dimY) {",
            "        const fieldValues = new Array(dimY);",
            "        for (var y = 0; y < dimY; y++) {",
            "            fieldValues[y] = new Array(dimX).fill(0);",
            "        }",
            "        this.values = fieldValues;",
            "        this.floodFill = new FloodFill(this);",
            "    }",
            "    /**",
            "     * @return {integer} grid dimension on y",
            "     */",
            "    dimY() {",
            "        return this.values.length;",
            "    }",
            "    /**",
            "     * @return {integer} grid dimension on y",
            "     */",
            "    dimX() {",
            "        const firstColumn = this.values[0];",
            "        return firstColumn ? firstColumn.length : 0;",
            "    }",
            "    isInside(x, y) {",
            "        return x >= 0 && x <= this.dimX() - 1 && y >= 0 && y <= this.dimY() - 1;",
            "    }",
            "    get(x, y) {",
            "        return this.values[y][x];",
            "    }",
            "    /**",
            "     * @param squareX {integer} x grid index",
            "     * @param squareY {integer} y grid index",
            "     * @param value {float} the field value",
            "     */",
            "    set(x, y, value) {",
            "        this.values[y][x] = value;",
            "    }",
            "    /**",
            "     * @param pointX {float} in grid basis",
            "     * @param pointY {float} in grid basis",
            "     * @return {float} the field value",
            "     */",
            "    extrapolate(x, y) {",
            "        const squareX = Math.floor(x);",
            "        const squareY = Math.floor(y);",
            "        if (squareX < 0 ||",
            "            squareY < 0 ||",
            "            // - 1 because the extrapolation uses the next value.",
            "            squareX >= this.dimX() - 1 ||",
            "            squareY >= this.dimY() - 1) {",
            "            return 0;",
            "        }",
            "        // Extrapolate",
            "        let weighedValueSum = 0;",
            "        let weightSum = 0;",
            "        for (let vertexX = squareX; vertexX <= squareX + 1; vertexX++) {",
            "            for (let vertexY = squareY; vertexY <= squareY + 1; vertexY++) {",
            "                const value = this.values[vertexY][vertexX];",
            "                const dx = vertexX - x;",
            "                const dy = vertexY - y;",
            "                if (dx === 0 && dy === 0) {",
            "                    // No interpolation needed.",
            "                    return value;",
            "                }",
            "                else {",
            "                    const distance = Math.hypot(dx, dy);",
            "                    weighedValueSum += value / distance;",
            "                    weightSum += 1 / distance;",
            "                }",
            "            }",
            "        }",
            "        const mean = weighedValueSum / weightSum;",
            "        return mean;",
            "    }",
            "    /**",
            "     * Clear the field by filling it with a give value.",
            "     * @param value {float}",
            "     */",
            "    clear(value = 0) {",
            "        for (let rowValues of this.values) {",
            "            for (let x = 0; x < rowValues.length; x++) {",
            "                rowValues[x] = value;",
            "            }",
            "        }",
            "    }",
            "    /**",
            "     * Cap the field between 2 values.",
            "     * @param min {float}",
            "     * @param max {float}",
            "     */",
            "    clamp(min, max) {",
            "        for (let rowValues of this.values) {",
            "            for (let x = 0; x < rowValues.length; x++) {",
            "                rowValues[x] = Math.min(Math.max(min, rowValues[x]), max);",
            "            }",
            "        }",
            "    }",
            "    /**",
            "     * Apply an affine transformation on each field value.",
            "     * @param a {float} factor",
            "     * @param b {float} offset",
            "     */",
            "    transform(a, b) {",
            "        for (let rowValues of this.values) {",
            "            for (let x = 0; x < rowValues.length; x++) {",
            "                rowValues[x] = a * rowValues[x] + b;",
            "            }",
            "        }",
            "    }",
            "    /**",
            "     * Merge the values from another field.",
            "     * @param scalarField {ScalarField}",
            "     * @param operation {function(float, float):float}",
            "     */",
            "    mergeField(scalarField, operation) {",
            "        const dimX = Math.min(this.dimX(), scalarField.dimX());",
            "        const dimY = Math.min(this.dimY(), scalarField.dimY());",
            "        for (let y = 0; y < dimY; y++) {",
            "            const thisRowValues = this.values[y];",
            "            const otherRowValues = scalarField.values[y];",
            "            for (let x = 0; x < dimX; x++) {",
            "                thisRowValues[x] = operation(thisRowValues[x], otherRowValues[x]);",
            "            }",
            "        }",
            "    }",
            "    /**",
            "     * Merge a disk in the field.",
            "     * @param centerX {float} in grid basis",
            "     * @param centerY {float} in grid basis",
            "     * @param radius {float} in grid basis",
            "     * @param cappingRadiusRatio {float}",
            "     * @param operation {function(float, float):float}",
            "     */",
            "    mergeDisk(centerX, centerY, radius, cappingRadiusRatio, operation) {",
            "        const cappingRadius = cappingRadiusRatio * radius;",
            "        const minX = Math.max(0, Math.floor(centerX - cappingRadius));",
            "        const minY = Math.max(0, Math.floor(centerY - cappingRadius));",
            "        const maxX = Math.min(this.dimX() - 1, Math.ceil(centerX + cappingRadius));",
            "        const maxY = Math.min(this.dimY() - 1, Math.ceil(centerY + cappingRadius));",
            "        const radiusSq = radius * radius;",
            "        // Avoid too big values",
            "        const minDistanceSq = 1 / 1024 / 1024;",
            "        for (let y = minY; y <= maxY; y++) {",
            "            const rowValues = this.values[y];",
            "            for (let x = minX; x <= maxX; x++) {",
            "                const distanceSq = Math.max(minDistanceSq, getDistanceSq(x, y, centerX, centerY));",
            "                rowValues[x] = operation(rowValues[x], radiusSq / distanceSq);",
            "            }",
            "        }",
            "    }",
            "    /**",
            "     * Merge a segment in the field.",
            "     * @param startX {float} in grid basis",
            "     * @param startY {float} in grid basis",
            "     * @param endX {float} in grid basis",
            "     * @param endY {float} in grid basis",
            "     * @param thickness {float} in grid basis",
            "     * @param cappingRadiusRatio {float}",
            "     * @param operation {function(float, float):float}",
            "     */",
            "    mergeSegment(startX, startY, endX, endY, thickness, cappingRadiusRatio, operation) {",
            "        const cappingRadius = cappingRadiusRatio * thickness;",
            "        const minX = Math.max(0, Math.floor(Math.min(startX, endX) - cappingRadius));",
            "        const minY = Math.max(0, Math.floor(Math.min(startY, endY) - cappingRadius));",
            "        const maxX = Math.min(this.dimX() - 1, Math.ceil(Math.max(startX, endX) + cappingRadius));",
            "        const maxY = Math.min(this.dimY() - 1, Math.ceil(Math.max(startY, endY) + cappingRadius));",
            "        const thicknessSq = thickness * thickness;",
            "        // Avoid too big values",
            "        const minDistanceSq = 1 / 1024 / 1024;",
            "        for (let y = minY; y <= maxY; y++) {",
            "            const rowValues = this.values[y];",
            "            for (let x = minX; x <= maxX; x++) {",
            "                const distanceSq = Math.max(minDistanceSq, getDistanceSqToSegment(x, y, startX, startY, endX, endY));",
            "                rowValues[x] = operation(rowValues[x], thicknessSq / distanceSq);",
            "            }",
            "        }",
            "    }",
            "    /**",
            "     * Merge a hill in the field.",
            "     * @param centerX {float} in grid basis",
            "     * @param centerY {float} in grid basis",
            "     * @param height {float}",
            "     * @param radius {float} in grid basis",
            "     * @param opacity {float}",
            "     * @param cappingRadiusRatio {float}",
            "     * @param operation {function(float, float):float}",
            "     */",
            "    mergeHill(centerX, centerY, height, radius, opacity, cappingRadiusRatio, operation) {",
            "        const cappingRadius = cappingRadiusRatio * radius;",
            "        const minX = Math.max(0, Math.floor(centerX - cappingRadius));",
            "        const minY = Math.max(0, Math.floor(centerY - cappingRadius));",
            "        const maxX = Math.min(this.dimX() - 1, Math.ceil(centerX + cappingRadius));",
            "        const maxY = Math.min(this.dimY() - 1, Math.ceil(centerY + cappingRadius));",
            "        const logHeightDividedByRadiusSq = Math.log(height) / (radius * radius);",
            "        const opacityMultipliedByHeight = opacity * height;",
            "        // Avoid too big values",
            "        const minDistanceSq = 1 / 1024 / 1024;",
            "        for (let y = minY; y <= maxY; y++) {",
            "            const rowValues = this.values[y];",
            "            for (let x = minX; x <= maxX; x++) {",
            "                const distanceSq = Math.max(minDistanceSq, getDistanceSq(x, y, centerX, centerY));",
            "                // This is like a gaussian, but parametrized differently.",
            "                rowValues[x] = operation(rowValues[x], opacityMultipliedByHeight *",
            "                    Math.exp(-distanceSq * logHeightDividedByRadiusSq));",
            "            }",
            "        }",
            "    }",
            "    /**",
            "     * Flood an area from a given location until a maximum field value is reached.",
            "     * @param originX {float} in grid basis",
            "     * @param originY {float} in grid basis",
            "     * @param valueMax {float}",
            "     * @param thickness {float}",
            "     * @param cappingRadiusRatio {float} the radius where to stop the contour shading",
            "     * @param isMinimum {boolean} when set to true, the threshold is a minimum",
            "     * or a maximum otherwise.",
            "     */",
            "    fillFrom(originX, originY, valueMax, thickness, cappingRadiusRatio) {",
            "        this.floodFill.fillFrom(originX, originY, valueMax, thickness, cappingRadiusRatio);",
            "    }",
            "    /**",
            "     * Flood an area from a given location until a maximum field value is reached.",
            "     * @param originX {float} in grid basis",
            "     * @param originY {float} in grid basis",
            "     * @param valueMax {float}",
            "     * @param thickness {float}",
            "     * @param cappingRadiusRatio {float} the radius where to stop the contour shading",
            "     * @param isMinimum {boolean} when set to true, the threshold is a minimum",
            "     * or a maximum otherwise.",
            "     */",
            "    unfillFrom(originX, originY, valueMin, thickness, cappingRadiusRatio) {",
            "        this.floodFill.unfillFrom(originX, originY, valueMin, thickness, cappingRadiusRatio);",
            "    }",
            "}",
            "",
            "const South = 0;",
            "const East = 1;",
            "const North = 2;",
            "const West = 3;",
            "const SouthWest = 4;",
            "const SouthEast = 5;",
            "const NorthEast = 6;",
            "const NorthWest = 7;",
            "const SouthWestMask = 1;",
            "const SouthEastMask = 2;",
            "const NorthEastMask = 4;",
            "const NorthWestMask = 8;",
            "const marchingSquaresFillVertices = [",
            "    [],",
            "    [South, West, SouthWest],",
            "    [East, South, SouthEast],",
            "    [East, West, SouthWest, SouthEast],",
            "    [North, East, NorthEast],",
            "    [South, SouthWest, West, North, NorthEast, East],",
            "    [South, North, NorthEast, SouthEast],",
            "    [West, North, NorthEast, SouthEast, SouthWest],",
            "    [West, North, NorthWest],",
            "    [North, South, SouthWest, NorthWest],",
            "    [South, West, NorthWest, North, East, SouthEast],",
            "    [North, East, SouthEast, SouthWest, NorthWest],",
            "    [East, West, NorthWest, NorthEast],",
            "    [East, South, SouthWest, NorthWest, NorthEast],",
            "    [South, West, NorthWest, NorthEast, SouthEast],",
            "    [],",
            "];",
            "const marchingSquaresOutlineVertices = [",
            "    [[]],",
            "    [[South, West]],",
            "    [[East, South]],",
            "    [[East, West]],",
            "    [[North, East]],",
            "    [",
            "        [East, South],",
            "        [West, North],",
            "    ],",
            "    [[South, North]],",
            "    [[West, North]],",
            "    [[West, North]],",
            "    [[North, South]],",
            "    [",
            "        [South, West],",
            "        [North, East],",
            "    ],",
            "    [[North, East]],",
            "    [[East, West]],",
            "    [[East, South]],",
            "    [[South, West]],",
            "    [[]],",
            "];",
            "/**",
            " * A marching square algorithm implementation.",
            " */",
            "class MarchingSquares {",
            "    /**",
            "     *",
            "     * @param scalarField",
            "     */",
            "    constructor(scalarField) {",
            "        /** {FloatPoint} Avoid memory allocations when returning points */",
            "        this.workingPoint = [0, 0];",
            "        this.scalarField = scalarField;",
            "    }",
            "    /**",
            "     * @param x {integer} the square top in the grid",
            "     * @param y {integer} the square left in the grid",
            "     * @param threshold {float}",
            "     * @return {integer} one of the 16 marching squares cases",
            "     */",
            "    getSquareIndex(x, y, threshold) {",
            "        /** @type {float} */",
            "        let squareIndex = 0;",
            "        if (this.scalarField.get(x, y + 1) > threshold) {",
            "            squareIndex |= SouthWestMask;",
            "        }",
            "        if (this.scalarField.get(x + 1, y + 1) > threshold) {",
            "            squareIndex |= SouthEastMask;",
            "        }",
            "        if (this.scalarField.get(x + 1, y) > threshold) {",
            "            squareIndex |= NorthEastMask;",
            "        }",
            "        if (this.scalarField.get(x, y) > threshold) {",
            "            squareIndex |= NorthWestMask;",
            "        }",
            "        return squareIndex;",
            "    }",
            "    /**",
            "     * Returns the mean between 2 corners weighted by their field value.",
            "     * @param indexX1 {integer} first corner x",
            "     * @param indexY1 {integer} first corner y",
            "     * @param indexX2 {integer} second corner x",
            "     * @param indexY2 {integer} second corner y",
            "     * @param threshold {float}",
            "     * @return {float} x in the grid",
            "     */",
            "    betweenX(indexX1, indexY1, indexX2, indexY2, threshold) {",
            "        const value1 = this.scalarField.get(indexX1, indexY1);",
            "        const value2 = this.scalarField.get(indexX2, indexY2);",
            "        const weight1 = Math.abs(value1 - threshold);",
            "        const weight2 = Math.abs(value2 - threshold);",
            "        return (weight2 * indexX1 + weight1 * indexX2) / (weight1 + weight2);",
            "    }",
            "    /**",
            "     * Returns the mean between 2 corners weighted by their field value.",
            "     * @param indexX1 {integer} first corner x",
            "     * @param indexY1 {integer} first corner y",
            "     * @param indexX2 {integer} second corner x",
            "     * @param indexY2 {integer} second corner y",
            "     * @param threshold {float}",
            "     * @return {float} y in the grid",
            "     */",
            "    betweenY(indexX1, indexY1, indexX2, indexY2, threshold) {",
            "        const value1 = this.scalarField.get(indexX1, indexY1);",
            "        const value2 = this.scalarField.get(indexX2, indexY2);",
            "        const weight1 = Math.abs(value1 - threshold);",
            "        const weight2 = Math.abs(value2 - threshold);",
            "        return (weight2 * indexY1 + weight1 * indexY2) / (weight1 + weight2);",
            "    }",
            "    /**",
            "     * @param side {integer} point location",
            "     * @param indexX {integer} the square top in the grid",
            "     * @param indexY {integer} the square left in the grid",
            "     * @param threshold {float}",
            "     * @param point {FloatPoint} is the result",
            "     */",
            "    calcPoint(side, indexX, indexY, threshold, point) {",
            "        let gridX = 0;",
            "        let gridY = 0;",
            "        switch (side) {",
            "            case South:",
            "                gridY = indexY + 1;",
            "                gridX = this.betweenX(indexX, gridY, indexX + 1, gridY, threshold);",
            "                break;",
            "            case East:",
            "                gridX = indexX + 1;",
            "                gridY = this.betweenY(gridX, indexY, gridX, indexY + 1, threshold);",
            "                break;",
            "            case North:",
            "                gridY = indexY;",
            "                gridX = this.betweenX(indexX, gridY, indexX + 1, gridY, threshold);",
            "                break;",
            "            case West:",
            "                gridX = indexX;",
            "                gridY = this.betweenY(gridX, indexY, gridX, indexY + 1, threshold);",
            "                break;",
            "            case SouthWest:",
            "                gridX = indexX;",
            "                gridY = indexY + 1;",
            "                break;",
            "            case SouthEast:",
            "                gridX = indexX + 1;",
            "                gridY = indexY + 1;",
            "                break;",
            "            case NorthEast:",
            "                gridX = indexX + 1;",
            "                gridY = indexY;",
            "                break;",
            "            case NorthWest:",
            "                gridX = indexX;",
            "                gridY = indexY;",
            "                break;",
            "        }",
            "        point[0] = gridX;",
            "        point[1] = gridY;",
            "    }",
            "    /**",
            "     * Draw the field squares",
            "     * @param minX {integer} left",
            "     * @param minY {integer} top",
            "     * @param maxX {integer} right",
            "     * @param maxY {integer} bottom",
            "     * @param threshold {float}",
            "     * @param drawUnder {boolean}",
            "     * @param shapePainter {ShapePainter}",
            "     */",
            "    fillContour(minX, minY, maxX, maxY, threshold, drawUnder, shapePainter) {",
            "        const point = this.workingPoint;",
            "        // It draws bands and small polygons.",
            "        // The contour line is in a second loop, it's more efficient",
            "        // than switching the style constantly.",
            "        for (let squareY = minY; squareY < maxY - 1; squareY++) {",
            "            // for run-length encoding",
            "            let first15SquareX = -1;",
            "            for (let squareX = minX; squareX < maxX - 1; squareX++) {",
            "                let squareIndex = this.getSquareIndex(squareX, squareY, threshold);",
            "                if (drawUnder) {",
            "                    squareIndex = 15 - squareIndex;",
            "                }",
            "                if (squareIndex === 15) {",
            "                    shapePainter.onFilledSquareChange(squareX, squareY);",
            "                }",
            "                if (first15SquareX === -1 && squareIndex === 15) {",
            "                    first15SquareX = squareX;",
            "                }",
            "                if (first15SquareX !== -1) {",
            "                    if (squareIndex !== 15) {",
            "                        shapePainter.drawRectangle(first15SquareX, squareY, squareX, squareY + 1);",
            "                        first15SquareX = -1;",
            "                    }",
            "                    else if (squareX === maxX - 2) {",
            "                        shapePainter.drawRectangle(first15SquareX, squareY, squareX + 1, squareY + 1);",
            "                        first15SquareX = -1;",
            "                    }",
            "                }",
            "                if (squareIndex !== 0 && squareIndex !== 15) {",
            "                    let fillVertices = marchingSquaresFillVertices[squareIndex];",
            "                    this.calcPoint(fillVertices[0], squareX, squareY, threshold, point);",
            "                    shapePainter.beginPath(point[0], point[1]);",
            "                    for (let index = 1; index < fillVertices.length; index++) {",
            "                        this.calcPoint(fillVertices[index], squareX, squareY, threshold, point);",
            "                        shapePainter.lineTo(point[0], point[1]);",
            "                    }",
            "                    shapePainter.closePath();",
            "                    shapePainter.endPath(squareX, squareY);",
            "                }",
            "            }",
            "        }",
            "    }",
            "    /**",
            "     * Draw the field squares",
            "     * @param minX {integer} left",
            "     * @param minY {integer} top",
            "     * @param maxX {integer} right",
            "     * @param maxY {integer} bottom",
            "     * @param threshold {float}",
            "     * @param drawUnder {boolean}",
            "     * @param shapePainter {ShapePainter}",
            "     */",
            "    outlineContour(minX, minY, maxX, maxY, threshold, drawUnder, shapePainter) {",
            "        const point = this.workingPoint;",
            "        for (let squareY = minY; squareY < maxY - 1; squareY++) {",
            "            for (let squareX = minX; squareX < maxX - 1; squareX++) {",
            "                let squareIndex = this.getSquareIndex(squareX, squareY, threshold);",
            "                if (drawUnder) {",
            "                    squareIndex = 15 - squareIndex;",
            "                }",
            "                if (squareIndex !== 0 && squareIndex !== 15) {",
            "                    for (let outlineVertices of marchingSquaresOutlineVertices[squareIndex]) {",
            "                        this.calcPoint(outlineVertices[0], squareX, squareY, threshold, point);",
            "                        shapePainter.beginPath(point[0], point[1]);",
            "                        for (let index = 1; index < outlineVertices.length; index++) {",
            "                            this.calcPoint(outlineVertices[index], squareX, squareY, threshold, point);",
            "                            shapePainter.lineTo(point[0], point[1]);",
            "                        }",
            "                        shapePainter.endPath(squareX, squareY);",
            "                    }",
            "                }",
            "            }",
            "        }",
            "    }",
            "}",
            "",
            "/**",
            " * A coordinate converter between a surface and a grid.",
            " */",
            "class CoordConverter {",
            "    /**",
            "     * Create a coordinate converter between a surface and a grid.",
            "     * @param cellWidth {float}",
            "     * @param cellHeight {float}",
            "     * @param left {float}",
            "     * @param top {float}",
            "     * @param right {float}",
            "     * @param bottom {float}",
            "     */",
            "    constructor(cellWidth, cellHeight, left, top, right, bottom) {",
            "        this.cellWidth = cellWidth;",
            "        this.cellHeight = cellHeight;",
            "        this.left = left;",
            "        this.top = top;",
            "        this.right = right;",
            "        this.bottom = bottom;",
            "    }",
            "    /**",
            "     * @param x {float} in the scene basis",
            "     * @return {float} x in the grid basis",
            "     */",
            "    convertToGridBasisX(x) {",
            "        return (x - this.left) / this.cellWidth;",
            "    }",
            "    /**",
            "     * @param y {float} in the scene basis",
            "     * @return {float} y in the grid basis",
            "     */",
            "    convertToGridBasisY(y) {",
            "        return (y - this.top) / this.cellHeight;",
            "    }",
            "    /**",
            "     * @param x {float} in the grid basis",
            "     * @return {float} x in the scene basis",
            "     */",
            "    convertFromGridBasisX(x) {",
            "        return x * this.cellWidth + this.left;",
            "    }",
            "    /**",
            "     * @param y {float} in the grid basis",
            "     * @return {float} y in the scene basis",
            "     */",
            "    convertFromGridBasisY(y) {",
            "        return y * this.cellHeight + this.top;",
            "    }",
            "    /**",
            "     * @param distance {float} in the grid basis",
            "     * @return {float} distance in the scene basis",
            "     */",
            "    convertToGridBasisDistance(distance) {",
            "        return distance / this.cellWidth;",
            "    }",
            "}",
            "",
            "/**",
            " * A height map.",
            " */",
            "class HeightMap {",
            "    /**",
            "     * Create a height map.",
            "     * @param scalarField {ScalarField} a scalar field for the height values.",
            "     * @param coordConverter {CoordConverter} a coordinate converter between the",
            "     * surface and the scalar field grid.",
            "     */",
            "    constructor(scalarField, coordConverter) {",
            "        this.scalarField = scalarField;",
            "        this.coordConverter = coordConverter;",
            "    }",
            "    /**",
            "     * @param pointX {float} in terrain basis",
            "     * @param pointY {float} in terrain basis",
            "     * @param normal {[float, float, float]} the result",
            "     * @return {[float, float, float]} the result",
            "     */",
            "    getFieldNormal(pointX, pointY, normal) {",
            "        if (!normal) {",
            "            normal = [0, 0, 0];",
            "        }",
            "        let x = this.coordConverter.convertToGridBasisX(pointX);",
            "        let y = this.coordConverter.convertToGridBasisY(pointY);",
            "        let squareX = Math.floor(x);",
            "        let squareY = Math.floor(y);",
            "        if (squareX < 0 ||",
            "            squareY < 0 ||",
            "            squareX >= this.scalarField.dimX() ||",
            "            squareY >= this.scalarField.dimY()) {",
            "            return null;",
            "        }",
            "        // This gives very approximating values on borders",
            "        // but it's the easiest way to avoid to be out of bounds.",
            "        // Why 1 but dim - 3?",
            "        // - 1 margin for the normal calculus on both side",
            "        // - 1 extra because extrapolation asks values on right and bottom.",
            "        if (squareX < 1) {",
            "            squareX = 1;",
            "            x = squareX;",
            "        }",
            "        if (squareX > this.scalarField.dimX() - 3) {",
            "            squareX = this.scalarField.dimX() - 3;",
            "            x = squareX;",
            "        }",
            "        if (squareY < 1) {",
            "            squareY = 1;",
            "            y = squareY;",
            "        }",
            "        if (squareY > this.scalarField.dimY() - 3) {",
            "            squareY = this.scalarField.dimY() - 3;",
            "            y = squareY;",
            "        }",
            "        // Extrapolate",
            "        let weighedValueSumX = 0;",
            "        let weighedValueSumY = 0;",
            "        let weighedValueSumZ = 0;",
            "        for (let vertexX = squareX; vertexX <= squareX + 1; vertexX++) {",
            "            for (let vertexY = squareY; vertexY <= squareY + 1; vertexY++) {",
            "                normal[0] = 0;",
            "                normal[1] = 0;",
            "                normal[2] = 0;",
            "                this.addGridPointNormal(vertexX, vertexY, normal);",
            "                const dx = vertexX - x;",
            "                const dy = vertexY - y;",
            "                if (dx === 0 && dy === 0) {",
            "                    // Double break, no interpolation needed.",
            "                    vertexX += 2;",
            "                    vertexY += 2;",
            "                }",
            "                else {",
            "                    const distance = Math.hypot(dx, dy);",
            "                    weighedValueSumX += normal[0] / distance;",
            "                    weighedValueSumY += normal[1] / distance;",
            "                    weighedValueSumZ += normal[2] / distance;",
            "                }",
            "            }",
            "        }",
            "        const length = Math.hypot(normal[0], normal[1], normal[2]);",
            "        normal[0] /= length;",
            "        normal[1] /= length;",
            "        normal[2] /= length;",
            "        return normal;",
            "    }",
            "    /**",
            "     * @param pointX {float} in terrain basis",
            "     * @param pointY {float} in terrain basis",
            "     * @return {float} the field value",
            "     */",
            "    getHeight(pointX, pointY) {",
            "        let x = this.coordConverter.convertToGridBasisX(pointX);",
            "        let y = this.coordConverter.convertToGridBasisY(pointY);",
            "        return this.scalarField.extrapolate(x, y);",
            "    }",
            "    /**",
            "     * Evaluate the normal at a given grid point.",
            "     *",
            "     * The normal is not normalized.",
            "     *",
            "     * @param x {integer} grid index",
            "     * @param y {integer} grid index",
            "     * @param normal {[float, float, float]} the result",
            "     */",
            "    addGridPointNormal(x, y, normal) {",
            "        const z = this.scalarField.get(x, y);",
            "        let rightX = 1;",
            "        const rightY = 0;",
            "        let rightZ = this.scalarField.get(x + 1, y) - z;",
            "        const rightLength = Math.hypot(rightX, rightZ);",
            "        rightX /= rightLength;",
            "        rightZ /= rightLength;",
            "        let leftX = -1;",
            "        const leftY = 0;",
            "        let leftZ = this.scalarField.get(x - 1, y) - z;",
            "        const leftLength = Math.hypot(leftX, leftZ);",
            "        leftX /= leftLength;",
            "        leftZ /= leftLength;",
            "        const bottomX = 0;",
            "        let bottomY = 1;",
            "        let bottomZ = this.scalarField.get(x, y + 1) - z;",
            "        const bottomLength = Math.hypot(bottomY, bottomZ);",
            "        bottomY /= bottomLength;",
            "        bottomZ /= bottomLength;",
            "        const topX = 0;",
            "        let topY = -1;",
            "        let topZ = this.scalarField.get(x, y - 1) - z;",
            "        const topLength = Math.hypot(topY, topZ);",
            "        topY /= topLength;",
            "        topZ /= topLength;",
            "        // The mean of the normal of the 4 triangles around the grid point.",
            "        this.addNormal(topX, topY, topZ, rightX, rightY, rightZ, normal);",
            "        this.addNormal(rightX, rightY, rightZ, bottomX, bottomY, bottomZ, normal);",
            "        this.addNormal(bottomX, bottomY, bottomZ, leftX, leftY, leftZ, normal);",
            "        this.addNormal(leftX, leftY, leftZ, topX, topY, topZ, normal);",
            "    }",
            "    /**",
            "     * @param uX {float}",
            "     * @param uY {float}",
            "     * @param uZ {float}",
            "     * @param vX {float}",
            "     * @param vY {float}",
            "     * @param vZ {float}",
            "     * @param normal {[float, float, float]} the result",
            "     */",
            "    addNormal(uX, uY, uZ, vX, vY, vZ, normal) {",
            "        normal[0] += uY * vZ - uZ * vY;",
            "        normal[1] += uZ * vX - uX * vZ;",
            "        normal[2] += uX * vY - uY * vX;",
            "    }",
            "    /**",
            "     * Clear the field by filling it with a give value.",
            "     * @param value {float}",
            "     */",
            "    clear(value = 0) {",
            "        this.scalarField.clear(value);",
            "    }",
            "    /**",
            "     * Cap the field between 2 values.",
            "     * @param min {float}",
            "     * @param max {float}",
            "     */",
            "    clamp(min, max) {",
            "        this.scalarField.clamp(min, max);",
            "    }",
            "    /**",
            "     * Apply an affine transformation on each field value.",
            "     * @param a {float} factor",
            "     * @param b {float} offset",
            "     */",
            "    transform(a, b) {",
            "        this.scalarField.transform(a, b);",
            "    }",
            "    /**",
            "     * Merge a disk in the field.",
            "     * @param centerX {float} in terrain basis",
            "     * @param centerY {float} in terrain basis",
            "     * @param radius {float} in terrain basis",
            "     * @param cappingRadiusRatio {float}",
            "     * @param operation {function(float, float):float}",
            "     */",
            "    mergeDisk(centerX, centerY, radius, cappingRadiusRatio, operation) {",
            "        this.scalarField.mergeDisk(this.coordConverter.convertToGridBasisX(centerX), this.coordConverter.convertToGridBasisY(centerY), this.coordConverter.convertToGridBasisDistance(radius), cappingRadiusRatio, operation);",
            "    }",
            "    /**",
            "     * Merge a segment in the field.",
            "     * @param startX {float} in terrain basis",
            "     * @param startY {float} in terrain basis",
            "     * @param endX {float} in terrain basis",
            "     * @param endY {float} in terrain basis",
            "     * @param thickness {float} in terrain basis",
            "     * @param cappingRadiusRatio {float}",
            "     * @param operation {function(float, float):float}",
            "     */",
            "    mergeSegment(startX, startY, endX, endY, thickness, cappingRadiusRatio, operation) {",
            "        this.scalarField.mergeSegment(this.coordConverter.convertToGridBasisX(startX), this.coordConverter.convertToGridBasisY(startY), this.coordConverter.convertToGridBasisX(endX), this.coordConverter.convertToGridBasisY(endY), this.coordConverter.convertToGridBasisDistance(thickness), cappingRadiusRatio, operation);",
            "    }",
            "    /**",
            "     * Merge a hill in the field.",
            "     * @param centerX {float} in terrain basis",
            "     * @param centerY {float} in terrain basis",
            "     * @param height {float}",
            "     * @param radius {float} in terrain basis",
            "     * @param opacity {float}",
            "     * @param cappingRadiusRatio {float}",
            "     * @param operation {function(float, float):float}",
            "     */",
            "    mergeHill(centerX, centerY, height, radius, opacity, cappingRadiusRatio, operation) {",
            "        this.scalarField.mergeHill(this.coordConverter.convertToGridBasisX(centerX), this.coordConverter.convertToGridBasisY(centerY), height, this.coordConverter.convertToGridBasisDistance(radius), opacity, cappingRadiusRatio, operation);",
            "    }",
            "    /**",
            "     * Flood an area from a given location until a maximum field value is reached.",
            "     * @param originX {float} in terrain basis",
            "     * @param originY {float} in terrain basis",
            "     * @param valueMax {float}",
            "     * @param thickness {float}",
            "     * @param cappingRadiusRatio {float} the radius where to stop the contour shading",
            "     * @param isMinimum {boolean} when set to true, the threshold is a minimum",
            "     * or a maximum otherwise.",
            "     */",
            "    fillFrom(originX, originY, valueMax, thickness, cappingRadiusRatio) {",
            "        this.scalarField.fillFrom(this.coordConverter.convertToGridBasisX(originX), this.coordConverter.convertToGridBasisY(originY), valueMax, this.coordConverter.convertToGridBasisDistance(thickness), cappingRadiusRatio);",
            "    }",
            "    /**",
            "     * Flood an area from a given location until a maximum field value is reached.",
            "     * @param originX {float} in terrain basis",
            "     * @param originY {float} in terrain basis",
            "     * @param valueMax {float}",
            "     * @param thickness {float}",
            "     * @param cappingRadiusRatio {float} the radius where to stop the contour shading",
            "     * @param isMinimum {boolean} when set to true, the threshold is a minimum",
            "     * or a maximum otherwise.",
            "     */",
            "    unfillFrom(originX, originY, valueMax, thickness, cappingRadiusRatio) {",
            "        this.scalarField.unfillFrom(this.coordConverter.convertToGridBasisX(originX), this.coordConverter.convertToGridBasisY(originY), valueMax, this.coordConverter.convertToGridBasisDistance(thickness), cappingRadiusRatio);",
            "    }",
            "}",
            "",
            "gdjs.__marchingSquaresExtension = gdjs.__marchingSquaresExtension || {};",
            "gdjs.__marchingSquaresExtension.CoordConverter = CoordConverter;",
            "gdjs.__marchingSquaresExtension.HeightMap = HeightMap;",
            "gdjs.__marchingSquaresExtension.MarchingSquares = MarchingSquares;",
            "gdjs.__marchingSquaresExtension.ScalarField = ScalarField;",
            ""
          ],
          "parameterObjects": "",
          "useStrict": true,
          "eventsSheetExpanded": true
        }
      ],
      "parameters": [],
      "objectGroups": []
    },
    {
      "description": "Define helper classes JavaScript code.",
      "fullName": "Define helper classes",
      "functionType": "Action",
      "name": "DefineHelperClasses",
      "private": true,
      "sentence": "Define helper classes JavaScript code",
      "events": [
        {
          "type": "BuiltinCommonInstructions::JsCode",
          "inlineCode": [
            "gdjs.__marchingSquaresExtension = gdjs.__marchingSquaresExtension || {};",
            "",
            "const parseOperation = function (operation) {",
            "  switch (operation) {",
            "    case \"Addition\":",
            "      return (value1, value2) => value1 + value2;",
            "    case \"Subtraction\":",
            "      return (value1, value2) => value1 - value2;",
            "    case \"Multiplication\":",
            "      return (value1, value2) => value1 * value2;",
            "    case \"Division\":",
            "      return (value1, value2) => value1 / value2;",
            "    case \"Minimum\":",
            "      return Math.min;",
            "    case \"Maximum\":",
            "    default:",
            "      return Math.max;",
            "  }",
            "  return;",
            "}",
            "",
            "class HitboxesIterable {",
            "  /**",
            "   * The hitboxes in a rectangular area.",
            "   * @constructor",
            "         * @param {any} behavior",
            "         * @param {integer} xMin The fist column to include.",
            "         * @param {integer} yMin The fist row to include.",
            "         * @param {integer} xMax The last column to include.",
            "         * @param {integer} yMax The last row to include.",
            "   */",
            "  constructor(",
            "    behavior,",
            "    xMin,",
            "    yMin,",
            "    xMax,",
            "    yMax",
            "  ) {",
            "    this.behavior = behavior;",
            "    this.xMin = xMin;",
            "    this.yMin = yMin;",
            "    this.xMax = xMax;",
            "    this.yMax = yMax;",
            "  };",
            "",
            "  setBounds(",
            "    xMin,",
            "    yMin,",
            "    xMax,",
            "    yMax",
            "  ) {",
            "    this.xMin = xMin;",
            "    this.yMin = yMin;",
            "    this.xMax = xMax;",
            "    this.yMax = yMax;",
            "  }",
            "",
            "  [Symbol.iterator]() {",
            "    // xMin and yMin next increment",
            "    let x = this.xMax;",
            "    let y = this.yMin - 1;",
            "    let hitbox = null;",
            "    let previousHitbox = null;",
            "    /** @type {IteratorReturnResult<gdjs.Polygon>} */",
            "    const result = { done: false, value: undefined };",
            "",
            "    return {",
            "      next: () => {",
            "        do {",
            "          x++;",
            "          if (x > this.xMax) {",
            "            y++;",
            "            x = this.xMin;",
            "          }",
            "          if (y > this.yMax) {",
            "            // done",
            "            result.done = true;",
            "            result.value = undefined;",
            "            return result;",
            "          }",
            "          hitbox = this.behavior.getHitbox(x, y);",
            "        }",
            "        while (!hitbox || hitbox === previousHitbox);",
            "",
            "        // happen with run-length encoding",
            "        previousHitbox = hitbox;",
            "        result.done = false;",
            "        result.value = hitbox;",
            "        return result;",
            "      },",
            "    };",
            "  };",
            "};",
            "",
            "gdjs.__marchingSquaresExtension = gdjs.__marchingSquaresExtension || {};",
            "gdjs.__marchingSquaresExtension.parseOperation = parseOperation;",
            "gdjs.__marchingSquaresExtension.HitboxesIterable = HitboxesIterable;",
            ""
          ],
          "parameterObjects": "",
          "useStrict": true,
          "eventsSheetExpanded": true
        }
      ],
      "parameters": [],
      "objectGroups": []
    }
  ],
  "eventsBasedBehaviors": [
    {
      "description": "Add to a Shape painter object and use the actions to draw a field. Useful for fog of wars, liquid effects (water, lava, blobs...).",
      "fullName": "Marching squares painter",
      "name": "MarchingSquaresBehavior",
      "objectType": "PrimitiveDrawing::Drawer",
      "eventsFunctions": [
        {
          "description": "Extend behavior class",
          "fullName": "Extend behavior class",
          "functionType": "Action",
          "name": "ExtendBehaviorClass",
          "private": true,
          "sentence": "Extend behavior class",
          "events": [
            {
              "type": "BuiltinCommonInstructions::JsCode",
              "inlineCode": [
                "const game = runtimeScene.getGame();",
                "const behaviorName = eventsFunctionContext.getBehaviorName(\"Behavior\");",
                "",
                "const behavior = objects[0].getBehavior(behaviorName);",
                "",
                "const prototype = Object.getPrototypeOf(behavior);",
                "if (!prototype.drawField) {",
                "",
                "  prototype.createField = function () {",
                "    /** @type {float} */",
                "    const left = this._getAreaLeftBound();",
                "    /** @type {float} */",
                "    const top = this._getAreaTopBound();",
                "    /** @type {float} */",
                "    const right = this._getAreaRightBound();",
                "    /** @type {float} */",
                "    const bottom = this._getAreaBottomBound();",
                "    /** @type {float} */",
                "    const cellWidth = this._getCellWidth();",
                "    /** @type {float} */",
                "    const cellHeight = this._getCellHeight();",
                "",
                "    // Build the scalar field",
                "    const dimX = 1 + Math.ceil((right - left) / cellWidth);",
                "    const dimY = 1 + Math.ceil((bottom - top) / cellHeight);",
                "    const scalarField = new gdjs.__marchingSquaresExtension.ScalarField(dimX, dimY);",
                "    this.scalarField = scalarField;",
                "    ",
                "    const coordConverter = new gdjs.__marchingSquaresExtension.CoordConverter(",
                "      cellWidth,",
                "      cellHeight,",
                "      left,",
                "      top,",
                "      right,",
                "      bottom);",
                "    this.coordConverter = coordConverter;",
                "",
                "    const heightMap = new gdjs.__marchingSquaresExtension.HeightMap(scalarField, coordConverter);",
                "    this.heightMap = heightMap;",
                "",
                "    const marchingSquares = new gdjs.__marchingSquaresExtension.MarchingSquares(scalarField);",
                "    this.marchingSquares = marchingSquares;",
                "",
                "    /** @type {gdjs.Polygon[][]} */",
                "    const hitboxTiles = new Array(dimY);",
                "    for (var y = 0; y < dimY; y++) {",
                "      hitboxTiles[y] = new Array(dimX).fill(null);",
                "    }",
                "    this.hitboxTiles = hitboxTiles;",
                "  }",
                "",
                "  /**",
                "   * @param pointX {float} in scene basis",
                "   * @param pointY {float} in scene basis",
                "   * @return {boolean} true if the point is inside the contour",
                "   */",
                "  prototype.containsPoint = function (",
                "    pointX,",
                "    pointY,",
                "  ) {",
                "    /** @type {boolean} */",
                "    const drawUnder = this._getFillOutside();",
                "",
                "    // It's a bit more precise than the contour",
                "    // so it's not completly accurate.",
                "    return !drawUnder && this.heightMap.getHeight(pointX, pointY) > this._getThreshold() ||",
                "      drawUnder && this.heightMap.getHeight(pointX, pointY) < this._getThreshold();",
                "  }",
                "",
                "  /**",
                "   * Draw the field squares",
                "   * @param minX {integer} left",
                "   * @param minY {integer} top",
                "   * @param maxX {integer} right",
                "   * @param maxY {integer} bottom",
                "   */",
                "  prototype.drawField = function (",
                "    minX,",
                "    minY,",
                "    maxX,",
                "    maxY",
                "  ) {",
                "    /** @type {boolean} */",
                "    const drawUnder = this._getFillOutside();",
                "    /** @type {gdjs.ShapePainterRuntimeObject} */",
                "    const shapePainter = this.owner;",
                "    /** @type {float} */",
                "    const threshold = this._getThreshold();",
                "",
                "    const fillOpacity = shapePainter.getFillOpacity();",
                "    const outlineSize = shapePainter.getOutlineSize();",
                "",
                "    // It draws bands and small polygons.",
                "    // The contour line is in a second loop, it's more efficient",
                "    // than switching the style constantly.",
                "",
                "    const that = this;",
                "    // fill",
                "    if (fillOpacity !== 0) {",
                "      shapePainter.setOutlineSize(0);",
                "      this.marchingSquares.fillContour(",
                "        minX,",
                "        minY,",
                "        maxX,",
                "        maxY,",
                "        threshold,",
                "        drawUnder,",
                "        {",
                "          drawRectangle(left, top, right, bottom) {",
                "            shapePainter.drawRectangle(",
                "              that.coordConverter.convertFromGridBasisX(left),",
                "              that.coordConverter.convertFromGridBasisY(top),",
                "              that.coordConverter.convertFromGridBasisX(right),",
                "              that.coordConverter.convertFromGridBasisY(bottom));",
                "          },",
                "          beginPath(x, y) {",
                "            shapePainter.beginFillPath(",
                "              that.coordConverter.convertFromGridBasisX(x),",
                "              that.coordConverter.convertFromGridBasisY(y));",
                "          },",
                "          lineTo(x, y) {",
                "            shapePainter.drawPathLineTo(",
                "              that.coordConverter.convertFromGridBasisX(x),",
                "              that.coordConverter.convertFromGridBasisY(y));",
                "          },",
                "          closePath() {",
                "            shapePainter.closePath();",
                "          },",
                "          endPath() {",
                "            shapePainter.endFillPath();",
                "          },",
                "          onFilledSquareChange(x, y) {",
                "",
                "          }",
                "        }",
                "      );",
                "      shapePainter.setOutlineSize(outlineSize);",
                "    }",
                "    // outline",
                "    if (outlineSize !== 0) {",
                "      shapePainter.setFillOpacity(0);",
                "      this.marchingSquares.outlineContour(",
                "        minX,",
                "        minY,",
                "        maxX,",
                "        maxY,",
                "        threshold,",
                "        drawUnder,",
                "        {",
                "          drawRectangle(left, top, right, bottom) {",
                "          },",
                "          beginPath(x, y) {",
                "            shapePainter.beginFillPath(",
                "              that.coordConverter.convertFromGridBasisX(x),",
                "              that.coordConverter.convertFromGridBasisY(y));",
                "          },",
                "          lineTo(x, y) {",
                "            shapePainter.drawPathLineTo(",
                "              that.coordConverter.convertFromGridBasisX(x),",
                "              that.coordConverter.convertFromGridBasisY(y));",
                "          },",
                "          closePath() {",
                "            shapePainter.closePath();",
                "          },",
                "          endPath() {",
                "            shapePainter.endFillPath();",
                "          },",
                "          onFilledSquareChange(x, y) {",
                "",
                "          }",
                "        }",
                "      );",
                "    }",
                "    shapePainter.setFillOpacity(fillOpacity);",
                "  }",
                "",
                "  /**",
                "   * Update the field hitboxes",
                "   * @param minX {integer} left",
                "   * @param minY {integer} top",
                "   * @param maxX {integer} right",
                "   * @param maxY {integer} bottom",
                "   */",
                "  prototype.updateMarchingSquareHitboxes = function (",
                "    minX,",
                "    minY,",
                "    maxX,",
                "    maxY",
                "  ) {",
                "    /** @type {boolean} */",
                "    const drawUnder = this._getFillOutside();",
                "    /** @type {float} */",
                "    const threshold = this._getThreshold();",
                "    /** @type {gdjs.ShapePainterRuntimeObject} */",
                "    const shapePainter = this.owner;",
                "",
                "    const point = this.workingPoint;",
                "",
                "    // Move all Polygons to recycledPolygons",
                "    if (this.recycledPolygons.length < shapePainter._defaultHitBoxes.length) {",
                "      const swapPolygons = this.recycledPolygons;",
                "      this.recycledPolygons = shapePainter._defaultHitBoxes;",
                "      shapePainter._defaultHitBoxes = swapPolygons;",
                "    }",
                "    const hitboxes = shapePainter._defaultHitBoxes;",
                "    this.recycledPolygons.push.apply(this, hitboxes);",
                "    hitboxes.length = 0;",
                "",
                "    for (const hitboxRowTiles of this.hitboxTiles) {",
                "      hitboxRowTiles.fill(null);",
                "    }",
                "    /** @type {gdjs.Polygon} */",
                "    let currentRectangle = null;",
                "    /** @type {gdjs.Polygon} */",
                "    let currentPolygon = null;",
                "    const that = this;",
                "    this.marchingSquares.fillContour(",
                "      minX,",
                "      minY,",
                "      maxX,",
                "      maxY,",
                "      threshold,",
                "      drawUnder,",
                "      {",
                "        drawRectangle(left, top, right, bottom) {",
                "          left = that.coordConverter.convertFromGridBasisX(left);",
                "          top = that.coordConverter.convertFromGridBasisY(top);",
                "          right = that.coordConverter.convertFromGridBasisX(right);",
                "          bottom = that.coordConverter.convertFromGridBasisY(bottom);",
                "          const vertices = currentRectangle.vertices;",
                "",
                "          vertices.length = 4;",
                "          vertices[0] || (vertices[0] = [0, 0]);",
                "          vertices[1] || (vertices[1] = [0, 0]);",
                "          vertices[2] || (vertices[2] = [0, 0]);",
                "          vertices[3] || (vertices[3] = [0, 0]);",
                "",
                "          vertices[0][0] = left;",
                "          vertices[0][1] = top;",
                "",
                "          vertices[1][0] = right;",
                "          vertices[1][1] = top;",
                "",
                "          vertices[2][0] = right;",
                "          vertices[2][1] = bottom;",
                "",
                "          vertices[3][0] = left;",
                "          vertices[3][1] = bottom;",
                "          hitboxes.push(currentRectangle);",
                "          currentRectangle = null;",
                "        },",
                "        beginPath(x, y) {",
                "          currentPolygon = that.recycledPolygons.length === 0 ? new gdjs.Polygon() : that.recycledPolygons.pop();",
                "          currentPolygon.vertices.length = 0;",
                "          currentPolygon.vertices.push([",
                "            that.coordConverter.convertFromGridBasisX(x),",
                "            that.coordConverter.convertFromGridBasisY(y)]);",
                "        },",
                "        lineTo(x, y) {",
                "          currentPolygon.vertices.push([",
                "            that.coordConverter.convertFromGridBasisX(x),",
                "            that.coordConverter.convertFromGridBasisY(y)]);",
                "        },",
                "        closePath() {",
                "        },",
                "        endPath(squareX, squareY) {",
                "          hitboxes.push(currentPolygon);",
                "          that.hitboxTiles[squareY][squareX] = currentPolygon;",
                "        },",
                "        onFilledSquareChange(squareX, squareY) {",
                "          if (!currentRectangle) {",
                "            currentRectangle = that.recycledPolygons.length === 0 ? new gdjs.Polygon() : that.recycledPolygons.pop();",
                "          }",
                "          that.hitboxTiles[squareY][squareX] = currentRectangle;",
                "        }",
                "      }",
                "    );",
                "",
                "    shapePainter.hitBoxes = hitboxes;",
                "    shapePainter.hitBoxesDirty = false;",
                "    shapePainter.aabb.min[0] = this._getAreaLeftBound();",
                "    shapePainter.aabb.min[1] = this._getAreaTopBound();",
                "    shapePainter.aabb.max[0] = shapePainter.aabb.min[0] + (this.scalarField.dimX() - 1) * this._getCellWidth();",
                "    shapePainter.aabb.max[1] = shapePainter.aabb.min[1] + (this.scalarField.dimY() - 1) * this._getCellHeight();",
                "  }",
                "",
                "  /**",
                "   * @param squareX {integer} x grid index",
                "   * @param squareY {integer} y grid index",
                "   * @return {gdjs.Polygon}",
                "   */",
                "  prototype.getHitbox = function (squareX, squareY) {",
                "    return this.hitboxTiles[squareY][squareX];",
                "  }",
                "}",
                "",
                "",
                ""
              ],
              "parameterObjects": "Object",
              "useStrict": true,
              "eventsSheetExpanded": true
            }
          ],
          "parameters": [
            {
              "description": "Object",
              "name": "Object",
              "supplementaryInformation": "PrimitiveDrawing::Drawer",
              "type": "object"
            },
            {
              "description": "Behavior",
              "name": "Behavior",
              "supplementaryInformation": "MarchingSquares::MarchingSquaresBehavior",
              "type": "behavior"
            }
          ],
          "objectGroups": []
        },
        {
          "description": "Extend object instance prototype.",
          "fullName": "Extend object instance prototype",
          "functionType": "Action",
          "name": "ExtendObjectInstancePrototype",
          "private": true,
          "sentence": "Extend _PARAM0_ prototype",
          "events": [
            {
              "type": "BuiltinCommonInstructions::JsCode",
              "inlineCode": [
                "const game = runtimeScene.getGame();",
                "const behaviorName = eventsFunctionContext.getBehaviorName(\"Behavior\");",
                "",
                "const behavior = objects[0].getBehavior(behaviorName);",
                "",
                "/**",
                " * @type {Iterable<gdjs.Polygon>}",
                " */",
                "behavior.marchingSquaresHitBoxesIterable = new gdjs.__marchingSquaresExtension.HitboxesIterable(behavior, 0, 0, 0, 0);",
                "",
                "/** @type {gdjs.Polygon[]} Avoid allocations when updating hitboxes*/",
                "behavior.recycledPolygons = [];",
                "",
                "behavior.owner.updateHitBoxes = function () {",
                "  this.hitBoxesDirty = false;",
                "}",
                "",
                "behavior.owner.getHitBoxesAround = function (",
                "  left,",
                "  top,",
                "  right,",
                "  bottom",
                ") {",
                "  const leftIndex = Math.max(0, Math.floor(behavior.coordConverter.convertToGridBasisX(left)));",
                "  const topIndex = Math.max(0, Math.floor(behavior.coordConverter.convertToGridBasisY(top)));",
                "  const rightIndex = Math.min(behavior.scalarField.dimX() - 1, Math.ceil(behavior.coordConverter.convertToGridBasisX(right)));",
                "  const bottomIndex = Math.min(behavior.scalarField.dimY() - 1, Math.ceil(behavior.coordConverter.convertToGridBasisY(bottom)));",
                "  /** @type {Iterable<gdjs.Polygon>} */",
                "  const iterable = behavior.marchingSquaresHitBoxesIterable;",
                "  iterable.setBounds(leftIndex, topIndex, rightIndex, bottomIndex);",
                "  return iterable;",
                "}",
                ""
              ],
              "parameterObjects": "Object",
              "useStrict": true,
              "eventsSheetExpanded": true
            }
          ],
          "parameters": [
            {
              "description": "Object",
              "name": "Object",
              "supplementaryInformation": "PrimitiveDrawing::Drawer",
              "type": "object"
            },
            {
              "description": "Behavior",
              "name": "Behavior",
              "supplementaryInformation": "MarchingSquares::MarchingSquaresBehavior",
              "type": "behavior"
            }
          ],
          "objectGroups": []
        },
        {
          "fullName": "",
          "functionType": "Action",
          "name": "onCreated",
          "sentence": "",
          "events": [
            {
              "type": "BuiltinCommonInstructions::Standard",
              "conditions": [
                {
                  "type": {
                    "value": "NumberVariable"
                  },
                  "parameters": [
                    "AreaRightBound",
                    "<=",
                    "AreaLeftBound"
                  ]
                }
              ],
              "actions": [
                {
                  "type": {
                    "value": "SetNumberVariable"
                  },
                  "parameters": [
                    "AreaRightBound",
                    "=",
                    "Object.Behavior::AreaLeft() + SceneWindowWidth()"
                  ]
                }
              ]
            },
            {
              "type": "BuiltinCommonInstructions::Standard",
              "conditions": [
                {
                  "type": {
                    "value": "NumberVariable"
                  },
                  "parameters": [
                    "AreaBottomBound",
                    "<=",
                    "AreaTopBound"
                  ]
                }
              ],
              "actions": [
                {
                  "type": {
                    "value": "SetNumberVariable"
                  },
                  "parameters": [
                    "AreaBottomBound",
                    "=",
                    "AreaBottomBound + SceneWindowHeight()"
                  ]
                }
              ]
            },
            {
              "type": "BuiltinCommonInstructions::Standard",
              "conditions": [
                {
                  "type": {
                    "value": "GlobalVariableAsBoolean"
                  },
                  "parameters": [
                    "__marchingSquares.IsJavaScriptDefined",
                    "False"
                  ]
                }
              ],
              "actions": [
                {
                  "type": {
                    "value": "SetGlobalVariableAsBoolean"
                  },
                  "parameters": [
                    "__marchingSquares.IsJavaScriptDefined",
                    "True"
                  ]
                },
                {
                  "type": {
                    "value": "MarchingSquares::DefineScalarFieldPainterLibrary"
                  },
                  "parameters": [
                    "",
                    ""
                  ]
                },
                {
                  "type": {
                    "value": "MarchingSquares::DefineHelperClasses"
                  },
                  "parameters": [
                    "",
                    ""
                  ]
                },
                {
                  "type": {
                    "value": "MarchingSquares::MarchingSquaresBehavior::ExtendBehaviorClass"
                  },
                  "parameters": [
                    "Object",
                    "Behavior",
                    ""
                  ]
                }
              ]
            },
            {
              "type": "BuiltinCommonInstructions::Standard",
              "conditions": [],
              "actions": [
                {
                  "type": {
                    "value": "MarchingSquares::MarchingSquaresBehavior::ExtendObjectInstancePrototype"
                  },
                  "parameters": [
                    "Object",
                    "Behavior",
                    ""
                  ]
                },
                {
                  "type": {
                    "value": "MarchingSquares::MarchingSquaresBehavior::RebuildField"
                  },
                  "parameters": [
                    "Object",
                    "Behavior",
                    ""
                  ]
                }
              ]
            }
          ],
          "parameters": [
            {
              "description": "Object",
              "name": "Object",
              "supplementaryInformation": "PrimitiveDrawing::Drawer",
              "type": "object"
            },
            {
              "description": "Behavior",
              "name": "Behavior",
              "supplementaryInformation": "MarchingSquares::MarchingSquaresBehavior",
              "type": "behavior"
            }
          ],
          "objectGroups": []
        },
        {
          "description": "Clear the field by setting every values to 0.",
          "fullName": "Clear the field",
          "functionType": "Action",
          "group": "Field operation",
          "name": "ClearField",
          "sentence": "Clear the field of _PARAM0_",
          "events": [
            {
              "type": "BuiltinCommonInstructions::JsCode",
              "inlineCode": [
                "const game = runtimeScene.getGame();",
                "const behaviorName = eventsFunctionContext.getBehaviorName(\"Behavior\");",
                "const behavior = objects[0].getBehavior(behaviorName);",
                "",
                "behavior.heightMap.clear();"
              ],
              "parameterObjects": "Object",
              "useStrict": true,
              "eventsSheetExpanded": true
            }
          ],
          "parameters": [
            {
              "description": "Object",
              "name": "Object",
              "supplementaryInformation": "PrimitiveDrawing::Drawer",
              "type": "object"
            },
            {
              "description": "Behavior",
              "name": "Behavior",
              "supplementaryInformation": "MarchingSquares::MarchingSquaresBehavior",
              "type": "behavior"
            }
          ],
          "objectGroups": []
        },
        {
          "description": "Unfill an area of the field from a given location until a given height is reached.",
          "fullName": "Unfill area",
          "functionType": "Action",
          "group": "Field painting",
          "name": "UpsidedownFloodFrom",
          "sentence": "Unfill the field of _PARAM0_ from x: _PARAM2_, y: _PARAM3_, to a minimum of _PARAM4_ with thickness: _PARAM5_",
          "events": [
            {
              "type": "BuiltinCommonInstructions::JsCode",
              "inlineCode": [
                "const behaviorName = eventsFunctionContext.getBehaviorName(\"Behavior\");",
                "",
                "const originX = eventsFunctionContext.getArgument(\"OriginX\");",
                "const originY = eventsFunctionContext.getArgument(\"OriginY\");",
                "const minimum = eventsFunctionContext.getArgument(\"Minimum\");",
                "const thickness = eventsFunctionContext.getArgument(\"Thickness\");",
                "const cappingRadiusRatio = eventsFunctionContext.getArgument(\"CappingRadiusRatio\");",
                "",
                "const behavior = objects[0].getBehavior(behaviorName);",
                "",
                "behavior.heightMap.unfillFrom(originX, originY, minimum, thickness, cappingRadiusRatio);"
              ],
              "parameterObjects": "Object",
              "useStrict": true,
              "eventsSheetExpanded": true
            }
          ],
          "parameters": [
            {
              "description": "Object",
              "name": "Object",
              "supplementaryInformation": "PrimitiveDrawing::Drawer",
              "type": "object"
            },
            {
              "description": "Behavior",
              "name": "Behavior",
              "supplementaryInformation": "MarchingSquares::MarchingSquaresBehavior",
              "type": "behavior"
            },
            {
              "description": "Origin X",
              "name": "OriginX",
              "type": "expression"
            },
            {
              "description": "Origin Y",
              "name": "OriginY",
              "type": "expression"
            },
            {
              "description": "Minimum height",
              "name": "Minimum",
              "type": "expression"
            },
            {
              "description": "Contour thickness",
              "name": "Thickness",
              "type": "expression"
            },
            {
              "description": "Capping radius ratio",
              "longDescription": "Small values allow quicker process, but can result to tearing. Try values around 8.",
              "name": "CappingRadiusRatio",
              "type": "expression"
            }
          ],
          "objectGroups": []
        },
        {
          "description": "Fill an area of the field from a given location until a given height is reached.",
          "fullName": "Fill area",
          "functionType": "Action",
          "group": "Field painting",
          "name": "FloodFrom",
          "sentence": "Fill the field of _PARAM0_ from x: _PARAM2_, y: _PARAM3_, to a maximum of _PARAM4_ with thickness: _PARAM5_",
          "events": [
            {
              "type": "BuiltinCommonInstructions::JsCode",
              "inlineCode": [
                "const behaviorName = eventsFunctionContext.getBehaviorName(\"Behavior\");",
                "",
                "const originX = eventsFunctionContext.getArgument(\"OriginX\");",
                "const originY = eventsFunctionContext.getArgument(\"OriginY\");",
                "const maximum = eventsFunctionContext.getArgument(\"Maximum\");",
                "const thickness = eventsFunctionContext.getArgument(\"Thickness\");",
                "const cappingRadiusRatio = eventsFunctionContext.getArgument(\"CappingRadiusRatio\");",
                "",
                "const behavior = objects[0].getBehavior(behaviorName);",
                "",
                "behavior.heightMap.fillFrom(originX, originY, maximum, thickness, cappingRadiusRatio);"
              ],
              "parameterObjects": "Object",
              "useStrict": true,
              "eventsSheetExpanded": true
            }
          ],
          "parameters": [
            {
              "description": "Object",
              "name": "Object",
              "supplementaryInformation": "PrimitiveDrawing::Drawer",
              "type": "object"
            },
            {
              "description": "Behavior",
              "name": "Behavior",
              "supplementaryInformation": "MarchingSquares::MarchingSquaresBehavior",
              "type": "behavior"
            },
            {
              "description": "Origin X",
              "name": "OriginX",
              "type": "expression"
            },
            {
              "description": "Origin Y",
              "name": "OriginY",
              "type": "expression"
            },
            {
              "description": "Maximum height",
              "name": "Maximum",
              "type": "expression"
            },
            {
              "description": "Contour thickness",
              "name": "Thickness",
              "type": "expression"
            },
            {
              "description": "Capping radius ratio",
              "longDescription": "Small values allow quicker process, but can result to tearing. Try values around 8.",
              "name": "CappingRadiusRatio",
              "type": "expression"
            }
          ],
          "objectGroups": []
        },
        {
          "description": "Cap every value of the field to a range.",
          "fullName": "Clamp the field",
          "functionType": "Action",
          "group": "Field operation",
          "name": "ClampField",
          "sentence": "Clamp the field of _PARAM0_ from: _PARAM2_ to: _PARAM3_",
          "events": [
            {
              "type": "BuiltinCommonInstructions::JsCode",
              "inlineCode": [
                "const behaviorName = eventsFunctionContext.getBehaviorName(\"Behavior\");",
                "",
                "const min = eventsFunctionContext.getArgument(\"Minimum\");",
                "const max = eventsFunctionContext.getArgument(\"Maximum\");",
                "",
                "const behavior = objects[0].getBehavior(behaviorName);",
                "",
                "behavior.heightMap.clamp(min, max);"
              ],
              "parameterObjects": "Object",
              "useStrict": true,
              "eventsSheetExpanded": true
            }
          ],
          "parameters": [
            {
              "description": "Object",
              "name": "Object",
              "supplementaryInformation": "PrimitiveDrawing::Drawer",
              "type": "object"
            },
            {
              "description": "Behavior",
              "name": "Behavior",
              "supplementaryInformation": "MarchingSquares::MarchingSquaresBehavior",
              "type": "behavior"
            },
            {
              "description": "Minimum",
              "name": "Minimum",
              "type": "expression"
            },
            {
              "description": "Maximum",
              "name": "Maximum",
              "type": "expression"
            }
          ],
          "objectGroups": []
        },
        {
          "description": "Apply an affine on the field values.",
          "fullName": "Transform the field",
          "functionType": "Action",
          "group": "Field operation",
          "name": "TransformField",
          "sentence": "Transform the field of _PARAM0_ with a coefficient: _PARAM2_ and an offset: _PARAM3_",
          "events": [
            {
              "type": "BuiltinCommonInstructions::JsCode",
              "inlineCode": [
                "const behaviorName = eventsFunctionContext.getBehaviorName(\"Behavior\");",
                "",
                "const a = eventsFunctionContext.getArgument(\"Coefficient\");",
                "const b = eventsFunctionContext.getArgument(\"Offset\");",
                "",
                "const behavior = objects[0].getBehavior(behaviorName);",
                "",
                "behavior.heightMap.transform(a, b);"
              ],
              "parameterObjects": "Object",
              "useStrict": true,
              "eventsSheetExpanded": true
            }
          ],
          "parameters": [
            {
              "description": "Object",
              "name": "Object",
              "supplementaryInformation": "PrimitiveDrawing::Drawer",
              "type": "object"
            },
            {
              "description": "Behavior",
              "name": "Behavior",
              "supplementaryInformation": "MarchingSquares::MarchingSquaresBehavior",
              "type": "behavior"
            },
            {
              "description": "Coefficient",
              "name": "Coefficient",
              "type": "expression"
            },
            {
              "description": "Offset",
              "name": "Offset",
              "type": "expression"
            }
          ],
          "objectGroups": []
        },
        {
          "description": "Add a hill to the field.",
          "fullName": "Add a hill",
          "functionType": "Action",
          "group": "Field painting",
          "name": "AddHill",
          "sentence": "Add a hill to the field of _PARAM0_ with center: _PARAM2_, _PARAM3_, _PARAM4_, radius: _PARAM5_, opacity: _PARAM6_ using: _PARAM8_",
          "events": [
            {
              "type": "BuiltinCommonInstructions::JsCode",
              "inlineCode": [
                "const behaviorName = eventsFunctionContext.getBehaviorName(\"Behavior\");",
                "",
                "const centerX = eventsFunctionContext.getArgument(\"CenterX\");",
                "const centerY = eventsFunctionContext.getArgument(\"CenterY\");",
                "const height = Math.max(1, eventsFunctionContext.getArgument(\"Height\"));",
                "const radius = eventsFunctionContext.getArgument(\"Radius\");",
                "const opacity = eventsFunctionContext.getArgument(\"Opacity\");",
                "const cappingRadiusRatio = eventsFunctionContext.getArgument(\"CappingRadiusRatio\");",
                "const operation = gdjs.__marchingSquaresExtension.parseOperation(eventsFunctionContext.getArgument(\"Operation\"));",
                "",
                "const behavior = objects[0].getBehavior(behaviorName);",
                "",
                "behavior.heightMap.mergeHill(centerX, centerY, height, radius, opacity, cappingRadiusRatio, operation);"
              ],
              "parameterObjects": "Object",
              "useStrict": true,
              "eventsSheetExpanded": true
            }
          ],
          "parameters": [
            {
              "description": "Object",
              "name": "Object",
              "supplementaryInformation": "PrimitiveDrawing::Drawer",
              "type": "object"
            },
            {
              "description": "Behavior",
              "name": "Behavior",
              "supplementaryInformation": "MarchingSquares::MarchingSquaresBehavior",
              "type": "behavior"
            },
            {
              "description": "Center X",
              "name": "CenterX",
              "type": "expression"
            },
            {
              "description": "Center Y",
              "name": "CenterY",
              "type": "expression"
            },
            {
              "description": "Height",
              "longDescription": "The hill height at the center, a value of 1 or less means a flat hill.",
              "name": "Height",
              "type": "expression"
            },
            {
              "description": "Radius",
              "longDescription": "The hill height is 1 at this radius.",
              "name": "Radius",
              "type": "expression"
            },
            {
              "description": "Opacity",
              "longDescription": "Set to 1 to apply the hill instantly or repeat this action with a lower value to make is progressive.",
              "name": "Opacity",
              "type": "expression"
            },
            {
              "description": "Capping radius ratio",
              "longDescription": "Small values allow quicker process, but can result to tearing. Try values around 8.",
              "name": "CappingRadiusRatio",
              "type": "expression"
            },
            {
              "description": "Operation",
              "name": "Operation",
              "supplementaryInformation": "[\"Maximum\",\"Addition\",\"Subtraction\"]",
              "type": "stringWithSelector"
            }
          ],
          "objectGroups": []
        },
        {
          "description": "Add a disk to the field.",
          "fullName": "Add a disk",
          "functionType": "Action",
          "group": "Field painting",
          "name": "AddDisk",
          "sentence": "Add a disk to the field of _PARAM0_ with center: _PARAM2_, _PARAM3_, radius: _PARAM4_ using: _PARAM6_",
          "events": [
            {
              "type": "BuiltinCommonInstructions::JsCode",
              "inlineCode": [
                "const behaviorName = eventsFunctionContext.getBehaviorName(\"Behavior\");",
                "",
                "const centerX = eventsFunctionContext.getArgument(\"CenterX\");",
                "const centerY = eventsFunctionContext.getArgument(\"CenterY\");",
                "const radius = eventsFunctionContext.getArgument(\"Radius\");",
                "const cappingRadiusRatio = eventsFunctionContext.getArgument(\"CappingRadiusRatio\");",
                "const operation = gdjs.__marchingSquaresExtension.parseOperation(eventsFunctionContext.getArgument(\"Operation\"));",
                "",
                "const behavior = objects[0].getBehavior(behaviorName);",
                "",
                "behavior.heightMap.mergeDisk(centerX, centerY, radius, cappingRadiusRatio, operation);"
              ],
              "parameterObjects": "Object",
              "useStrict": true,
              "eventsSheetExpanded": true
            }
          ],
          "parameters": [
            {
              "description": "Object",
              "name": "Object",
              "supplementaryInformation": "PrimitiveDrawing::Drawer",
              "type": "object"
            },
            {
              "description": "Behavior",
              "name": "Behavior",
              "supplementaryInformation": "MarchingSquares::MarchingSquaresBehavior",
              "type": "behavior"
            },
            {
              "description": "Center X",
              "name": "CenterX",
              "type": "expression"
            },
            {
              "description": "Center Y",
              "name": "CenterY",
              "type": "expression"
            },
            {
              "description": "Radius",
              "longDescription": "The spike height is 1 at this radius.",
              "name": "Radius",
              "type": "expression"
            },
            {
              "description": "Capping radius ratio",
              "longDescription": "Small values allow quicker process, but can result to tearing. Try values around 8.",
              "name": "CappingRadiusRatio",
              "type": "expression"
            },
            {
              "description": "Operation",
              "name": "Operation",
              "supplementaryInformation": "[\"Maximum\",\"Addition\",\"Subtraction\"]",
              "type": "stringWithSelector"
            }
          ],
          "objectGroups": []
        },
        {
          "description": "Mask a disk to the field.",
          "fullName": "Mask a disk",
          "functionType": "Action",
          "group": "Field painting",
          "name": "MaskDisk",
          "sentence": "Mask a disk on the field of _PARAM0_ with center: _PARAM2_, _PARAM3_, radius: _PARAM4_",
          "events": [
            {
              "type": "BuiltinCommonInstructions::JsCode",
              "inlineCode": [
                "const behaviorName = eventsFunctionContext.getBehaviorName(\"Behavior\");",
                "",
                "const centerX = eventsFunctionContext.getArgument(\"CenterX\");",
                "const centerY = eventsFunctionContext.getArgument(\"CenterY\");",
                "const radius = eventsFunctionContext.getArgument(\"Radius\");",
                "const cappingRadiusRatio = eventsFunctionContext.getArgument(\"CappingRadiusRatio\");",
                "const cappingRadius = cappingRadiusRatio * radius;",
                "",
                "const behavior = objects[0].getBehavior(behaviorName);",
                "",
                "behavior.heightMap.mergeDisk(centerX, centerY, radius, cappingRadiusRatio, (fieldValue, value) => Math.min(fieldValue, 1 / value));"
              ],
              "parameterObjects": "Object",
              "useStrict": true,
              "eventsSheetExpanded": true
            }
          ],
          "parameters": [
            {
              "description": "Object",
              "name": "Object",
              "supplementaryInformation": "PrimitiveDrawing::Drawer",
              "type": "object"
            },
            {
              "description": "Behavior",
              "name": "Behavior",
              "supplementaryInformation": "MarchingSquares::MarchingSquaresBehavior",
              "type": "behavior"
            },
            {
              "description": "Center X",
              "name": "CenterX",
              "type": "expression"
            },
            {
              "description": "Center Y",
              "name": "CenterY",
              "type": "expression"
            },
            {
              "description": "Radius",
              "longDescription": "The spike height is 1 at this radius.",
              "name": "Radius",
              "type": "expression"
            },
            {
              "description": "Capping radius ratio",
              "longDescription": "Small values allow quicker process, but can result to tearing. Try values around 8.",
              "name": "CappingRadiusRatio",
              "type": "expression"
            }
          ],
          "objectGroups": []
        },
        {
          "description": "Add a line to the field.",
          "fullName": "Add a line",
          "functionType": "Action",
          "group": "Field painting",
          "name": "AddLine",
          "sentence": "Add a line to the field of _PARAM0_ from _PARAM2_ ; _PARAM3_ to _PARAM4_ ; _PARAM5_ with thickness: _PARAM6_ using: _PARAM8_",
          "events": [
            {
              "type": "BuiltinCommonInstructions::JsCode",
              "inlineCode": [
                "const behaviorName = eventsFunctionContext.getBehaviorName(\"Behavior\");",
                "",
                "const startX = eventsFunctionContext.getArgument(\"StartX\");",
                "const startY = eventsFunctionContext.getArgument(\"StartY\");",
                "const endX = eventsFunctionContext.getArgument(\"EndX\");",
                "const endY = eventsFunctionContext.getArgument(\"EndY\");",
                "const thickness = eventsFunctionContext.getArgument(\"Thickness\");",
                "const cappingRadiusRatio = eventsFunctionContext.getArgument(\"CappingRadiusRatio\");",
                "const operation = gdjs.__marchingSquaresExtension.parseOperation(eventsFunctionContext.getArgument(\"Operation\"));",
                "",
                "const behavior = objects[0].getBehavior(behaviorName);",
                "",
                "behavior.heightMap.mergeSegment(startX, startY, endX, endY, thickness, cappingRadiusRatio, operation);"
              ],
              "parameterObjects": "Object",
              "useStrict": true,
              "eventsSheetExpanded": true
            }
          ],
          "parameters": [
            {
              "description": "Object",
              "name": "Object",
              "supplementaryInformation": "PrimitiveDrawing::Drawer",
              "type": "object"
            },
            {
              "description": "Behavior",
              "name": "Behavior",
              "supplementaryInformation": "MarchingSquares::MarchingSquaresBehavior",
              "type": "behavior"
            },
            {
              "description": "X position of the start",
              "name": "StartX",
              "type": "expression"
            },
            {
              "description": "Y position of the start",
              "name": "StartY",
              "type": "expression"
            },
            {
              "description": "X position of the end",
              "name": "EndX",
              "type": "expression"
            },
            {
              "description": "Y position of the end",
              "name": "EndY",
              "type": "expression"
            },
            {
              "description": "Thickness",
              "name": "Thickness",
              "type": "expression"
            },
            {
              "description": "Capping radius ratio",
              "longDescription": "Small values allow quicker process, but can result to tearing. Try values around 8.",
              "name": "CappingRadiusRatio",
              "type": "expression"
            },
            {
              "description": "Operation",
              "name": "Operation",
              "supplementaryInformation": "[\"Maximum\",\"Addition\",\"Subtraction\"]",
              "type": "stringWithSelector"
            }
          ],
          "objectGroups": []
        },
        {
          "description": "Mask a line to the field.",
          "fullName": "Mask a line",
          "functionType": "Action",
          "group": "Field painting",
          "name": "MaskLine",
          "sentence": "Mask a line on the field of _PARAM0_ from _PARAM2_ ; _PARAM3_ to _PARAM4_ ; _PARAM5_ with thickness: _PARAM6_",
          "events": [
            {
              "type": "BuiltinCommonInstructions::JsCode",
              "inlineCode": [
                "const behaviorName = eventsFunctionContext.getBehaviorName(\"Behavior\");",
                "",
                "const startX = eventsFunctionContext.getArgument(\"StartX\");",
                "const startY = eventsFunctionContext.getArgument(\"StartY\");",
                "const endX = eventsFunctionContext.getArgument(\"EndX\");",
                "const endY = eventsFunctionContext.getArgument(\"EndY\");",
                "const thickness = eventsFunctionContext.getArgument(\"Thickness\");",
                "const cappingRadiusRatio = eventsFunctionContext.getArgument(\"CappingRadiusRatio\");",
                "",
                "const behavior = objects[0].getBehavior(behaviorName);",
                "",
                "behavior.heightMap.mergeSegment(startX, startY, endX, endY, thickness, cappingRadiusRatio, (fieldValue, value) => Math.min(fieldValue, 1 / value));"
              ],
              "parameterObjects": "Object",
              "useStrict": true,
              "eventsSheetExpanded": true
            }
          ],
          "parameters": [
            {
              "description": "Object",
              "name": "Object",
              "supplementaryInformation": "PrimitiveDrawing::Drawer",
              "type": "object"
            },
            {
              "description": "Behavior",
              "name": "Behavior",
              "supplementaryInformation": "MarchingSquares::MarchingSquaresBehavior",
              "type": "behavior"
            },
            {
              "description": "X position of the start",
              "name": "StartX",
              "type": "expression"
            },
            {
              "description": "Y position of the start",
              "name": "StartY",
              "type": "expression"
            },
            {
              "description": "X position of the end",
              "name": "EndX",
              "type": "expression"
            },
            {
              "description": "Y position of the end",
              "name": "EndY",
              "type": "expression"
            },
            {
              "description": "Thickness",
              "longDescription": "The spike height is 1 at this radius.",
              "name": "Thickness",
              "type": "expression"
            },
            {
              "description": "Capping radius ratio",
              "longDescription": "Small values allow quicker process, but can result to tearing. Try values around 8.",
              "name": "CappingRadiusRatio",
              "type": "expression"
            }
          ],
          "objectGroups": []
        },
        {
          "description": "Apply a given operation on every value of the field using the value from the other field at the same position.",
          "fullName": "Merge a field",
          "functionType": "Action",
          "group": "Field operation",
          "name": "MergeField",
          "sentence": "Merge _PARAM0_ with the field of _PARAM2_ using: _PARAM4_",
          "events": [
            {
              "type": "BuiltinCommonInstructions::JsCode",
              "inlineCode": [
                "const behaviorName = eventsFunctionContext.getBehaviorName(\"Behavior\");",
                "",
                "const fieldObjects = eventsFunctionContext.getObjects(\"FieldObject\");",
                "const fieldBehaviorName = eventsFunctionContext.getArgument(\"FieldBehavior\");",
                "const operation = gdjs.__marchingSquaresExtension.parseOperation(eventsFunctionContext.getArgument(\"Operation\"));",
                "",
                "const behavior = objects[0].getBehavior(behaviorName);",
                "",
                "/** @type {Array<number[]>} */",
                "const fieldValues = behavior.scalarFieldValues;",
                "",
                "for (const fieldObject of fieldObjects) {",
                "    const otherBehavior = fieldObject.getBehavior(behaviorName);",
                "    if (!otherBehavior) {",
                "        continue;",
                "    }",
                "    behavior.scalarField.mergeField(otherBehavior.scalarField, operation);",
                "}"
              ],
              "parameterObjects": "Object",
              "useStrict": true,
              "eventsSheetExpanded": true
            }
          ],
          "parameters": [
            {
              "description": "Object",
              "name": "Object",
              "supplementaryInformation": "PrimitiveDrawing::Drawer",
              "type": "object"
            },
            {
              "description": "Behavior",
              "name": "Behavior",
              "supplementaryInformation": "MarchingSquares::MarchingSquaresBehavior",
              "type": "behavior"
            },
            {
              "description": "Field object",
              "name": "FieldObject",
              "type": "objectList"
            },
            {
              "description": "Field behavior",
              "name": "FieldBehavior",
              "supplementaryInformation": "MarchingSquares::MarchingSquaresBehavior",
              "type": "behavior"
            },
            {
              "description": "Operation",
              "name": "Operation",
              "supplementaryInformation": "[\"Maximum\",\"Addition\",\"Subtraction\",\"Minimum\",\"Multiplication\",\"Division\"]",
              "type": "stringWithSelector"
            }
          ],
          "objectGroups": []
        },
        {
          "description": "Update the field hitboxes.",
          "fullName": "Update hitboxes",
          "functionType": "Action",
          "group": "Field evaluation",
          "name": "UpdateHitboxes",
          "sentence": "Update the field hitboxes of _PARAM0_",
          "events": [
            {
              "type": "BuiltinCommonInstructions::JsCode",
              "inlineCode": [
                "const behaviorName = eventsFunctionContext.getBehaviorName(\"Behavior\");",
                "",
                "const behavior = objects[0].getBehavior(behaviorName);",
                "",
                "behavior.updateMarchingSquareHitboxes(0, 0, behavior.scalarField.dimX(), behavior.scalarField.dimY());"
              ],
              "parameterObjects": "Object",
              "useStrict": true,
              "eventsSheetExpanded": true
            }
          ],
          "parameters": [
            {
              "description": "Object",
              "name": "Object",
              "supplementaryInformation": "PrimitiveDrawing::Drawer",
              "type": "object"
            },
            {
              "description": "Behavior",
              "name": "Behavior",
              "supplementaryInformation": "MarchingSquares::MarchingSquaresBehavior",
              "type": "behavior"
            }
          ],
          "objectGroups": []
        },
        {
          "description": "Draw the field contours.",
          "fullName": "Draw the contours",
          "functionType": "Action",
          "group": "Field evaluation",
          "name": "DrawField",
          "sentence": "Draw the field contours of _PARAM0_",
          "events": [
            {
              "type": "BuiltinCommonInstructions::JsCode",
              "inlineCode": [
                "const screenWidth = runtimeScene.getGame().getGameResolutionWidth();",
                "const screenHeight = runtimeScene.getGame().getGameResolutionHeight();",
                "",
                "const behaviorName = eventsFunctionContext.getBehaviorName(\"Behavior\");",
                "",
                "const object = objects[0];",
                "const behavior = object.getBehavior(behaviorName);",
                "",
                "if (behavior._behaviorData.MustOnlyDrawScreen) {",
                "    const layer = runtimeScene.getLayer(object.getLayer());",
                "    const screen1 = layer.convertCoords(0, 0);",
                "    const screen2 = layer.convertCoords(screenWidth, 0);",
                "    const screen3 = layer.convertCoords(0, screenHeight);",
                "    const screen4 = layer.convertCoords(screenWidth, screenHeight);",
                "",
                "    const screenLeft = Math.min(screen1[0], screen2[0], screen3[0], screen4[0]);",
                "    const screenTop = Math.min(screen1[1], screen2[1], screen3[1], screen4[1]);",
                "    const screenRight = Math.max(screen1[0], screen2[0], screen3[0], screen4[0]);",
                "    const screenBottom = Math.max(screen1[1], screen2[1], screen3[1], screen4[1]);",
                "",
                "    const minX = Math.max(0, Math.floor(behavior.coordConverter.convertToGridBasisX(screenLeft)));",
                "    const minY = Math.max(0, Math.floor(behavior.coordConverter.convertToGridBasisY(screenTop)));",
                "",
                "    const maxX = Math.min(behavior.scalarField.dimX(), 1 + Math.ceil(behavior.coordConverter.convertToGridBasisX(screenRight)));",
                "    const maxY = Math.min(behavior.scalarField.dimY(), 1 + Math.ceil(behavior.coordConverter.convertToGridBasisY(screenBottom)));",
                "",
                "    behavior.drawField(minX, minY, maxX, maxY);",
                "}",
                "else {",
                "    // This is useful for static content or games without scrolling.",
                "    behavior.drawField(0, 0, behavior.scalarField.dimX(), behavior.scalarField.dimY());",
                "}"
              ],
              "parameterObjects": "Object",
              "useStrict": true,
              "eventsSheetExpanded": true
            }
          ],
          "parameters": [
            {
              "description": "Object",
              "name": "Object",
              "supplementaryInformation": "PrimitiveDrawing::Drawer",
              "type": "object"
            },
            {
              "description": "Behavior",
              "name": "Behavior",
              "supplementaryInformation": "MarchingSquares::MarchingSquaresBehavior",
              "type": "behavior"
            }
          ],
          "objectGroups": []
        },
        {
          "description": "Change the width of the field cells.",
          "fullName": "Width of the cells",
          "functionType": "Action",
          "group": "Field configuration",
          "name": "SetCellWidth",
          "sentence": "Change the width of the field cells of _PARAM0_: _PARAM2_",
          "events": [
            {
              "type": "BuiltinCommonInstructions::Standard",
              "conditions": [],
              "actions": [
                {
                  "type": {
                    "value": "SetNumberVariable"
                  },
                  "parameters": [
                    "CellWidth",
                    "=",
                    "Value"
                  ]
                },
                {
                  "type": {
                    "value": "MarchingSquares::MarchingSquaresBehavior::RebuildField"
                  },
                  "parameters": [
                    "Object",
                    "Behavior",
                    ""
                  ]
                }
              ]
            }
          ],
          "parameters": [
            {
              "description": "Object",
              "name": "Object",
              "supplementaryInformation": "PrimitiveDrawing::Drawer",
              "type": "object"
            },
            {
              "description": "Behavior",
              "name": "Behavior",
              "supplementaryInformation": "MarchingSquares::MarchingSquaresBehavior",
              "type": "behavior"
            },
            {
              "description": "Value",
              "name": "Value",
              "type": "expression"
            }
          ],
          "objectGroups": []
        },
        {
          "description": "Change the height of the field cells.",
          "fullName": "Height of the cells",
          "functionType": "Action",
          "group": "Field configuration",
          "name": "SetCellHeight",
          "sentence": "Change the height of the field cells of _PARAM0_: _PARAM2_",
          "events": [
            {
              "type": "BuiltinCommonInstructions::Standard",
              "conditions": [],
              "actions": [
                {
                  "type": {
                    "value": "SetNumberVariable"
                  },
                  "parameters": [
                    "CellHeight",
                    "=",
                    "Value"
                  ]
                },
                {
                  "type": {
                    "value": "MarchingSquares::MarchingSquaresBehavior::RebuildField"
                  },
                  "parameters": [
                    "Object",
                    "Behavior",
                    ""
                  ]
                }
              ]
            }
          ],
          "parameters": [
            {
              "description": "Object",
              "name": "Object",
              "supplementaryInformation": "PrimitiveDrawing::Drawer",
              "type": "object"
            },
            {
              "description": "Behavior",
              "name": "Behavior",
              "supplementaryInformation": "MarchingSquares::MarchingSquaresBehavior",
              "type": "behavior"
            },
            {
              "description": "Value",
              "name": "Value",
              "type": "expression"
            }
          ],
          "objectGroups": []
        },
        {
          "description": "Rebuild the field with the new dimensions.",
          "fullName": "Rebuild the field",
          "functionType": "Action",
          "name": "RebuildField",
          "private": true,
          "sentence": "Rebuild the field _PARAM0_",
          "events": [
            {
              "type": "BuiltinCommonInstructions::JsCode",
              "inlineCode": [
                "const game = runtimeScene.getGame();",
                "const behaviorName = eventsFunctionContext.getBehaviorName(\"Behavior\");",
                "const behavior = objects[0].getBehavior(behaviorName);",
                "",
                "/** @type {float} */",
                "const left = behavior._getAreaLeftBound();",
                "/** @type {float} */",
                "const top = behavior._getAreaTopBound();",
                "/** @type {float} */",
                "const right = behavior._getAreaRightBound() || game.getGameResolutionWidth();",
                "/** @type {float} */",
                "const bottom = behavior._getAreaBottomBound() || game.getGameResolutionHeight();",
                "/** @type {float} */",
                "const cellWidth = behavior._getCellWidth();",
                "/** @type {float} */",
                "const cellHeight = behavior._getCellHeight();",
                "",
                "behavior.createField();"
              ],
              "parameterObjects": "Object",
              "useStrict": true,
              "eventsSheetExpanded": true
            }
          ],
          "parameters": [
            {
              "description": "Object",
              "name": "Object",
              "supplementaryInformation": "PrimitiveDrawing::Drawer",
              "type": "object"
            },
            {
              "description": "Behavior",
              "name": "Behavior",
              "supplementaryInformation": "MarchingSquares::MarchingSquaresBehavior",
              "type": "behavior"
            }
          ],
          "objectGroups": []
        },
        {
          "description": "Fill outside or inside of the contours.",
          "fullName": "Fill outside",
          "functionType": "Action",
          "group": "Field configuration",
          "name": "SetFillOutside",
          "sentence": "Fill outside of the contours of _PARAM0_: _PARAM2_",
          "events": [
            {
              "type": "BuiltinCommonInstructions::Standard",
              "conditions": [],
              "actions": [
                {
                  "type": {
                    "value": "SetBooleanVariable"
                  },
                  "parameters": [
                    "FillOutside",
                    "False",
                    ""
                  ]
                }
              ]
            },
            {
              "type": "BuiltinCommonInstructions::Standard",
              "conditions": [
                {
                  "type": {
                    "value": "BooleanVariable"
                  },
                  "parameters": [
                    "Value",
                    "True",
                    ""
                  ]
                }
              ],
              "actions": [
                {
                  "type": {
                    "value": "SetBooleanVariable"
                  },
                  "parameters": [
                    "FillOutside",
                    "True",
                    ""
                  ]
                }
              ]
            }
          ],
          "parameters": [
            {
              "description": "Object",
              "name": "Object",
              "supplementaryInformation": "PrimitiveDrawing::Drawer",
              "type": "object"
            },
            {
              "description": "Behavior",
              "name": "Behavior",
              "supplementaryInformation": "MarchingSquares::MarchingSquaresBehavior",
              "type": "behavior"
            },
            {
              "description": "Fill outside?",
              "name": "Value",
              "type": "yesorno"
            }
          ],
          "objectGroups": []
        },
        {
          "description": "Change the contour threshold.",
          "fullName": "Contour threshold",
          "functionType": "Action",
          "group": "Field configuration",
          "name": "SetThreshold",
          "sentence": "Change the contour threshold of _PARAM0_: _PARAM2_",
          "events": [
            {
              "type": "BuiltinCommonInstructions::Standard",
              "conditions": [],
              "actions": [
                {
                  "type": {
                    "value": "SetNumberVariable"
                  },
                  "parameters": [
                    "Threshold",
                    "=",
                    "Value"
                  ]
                }
              ]
            }
          ],
          "parameters": [
            {
              "description": "Object",
              "name": "Object",
              "supplementaryInformation": "PrimitiveDrawing::Drawer",
              "type": "object"
            },
            {
              "description": "Behavior",
              "name": "Behavior",
              "supplementaryInformation": "MarchingSquares::MarchingSquaresBehavior",
              "type": "behavior"
            },
            {
              "description": "Value",
              "name": "Value",
              "type": "expression"
            }
          ],
          "objectGroups": []
        },
        {
          "description": "Change the field area bounds.",
          "fullName": "Area bounds",
          "functionType": "Action",
          "group": "Field configuration",
          "name": "SetAreaBounds",
          "sentence": "Change the field area bounds of _PARAM0_ left: _PARAM2_ top: _PARAM3_ right: _PARAM4_ bottom: _PARAM5_",
          "events": [
            {
              "type": "BuiltinCommonInstructions::Standard",
              "conditions": [],
              "actions": [
                {
                  "type": {
                    "value": "SetNumberVariable"
                  },
                  "parameters": [
                    "AreaLeftBound",
                    "=",
                    "LeftBound"
                  ]
                },
                {
                  "type": {
                    "value": "SetNumberVariable"
                  },
                  "parameters": [
                    "AreaTopBound",
                    "=",
                    "TopBound"
                  ]
                },
                {
                  "type": {
                    "value": "SetNumberVariable"
                  },
                  "parameters": [
                    "AreaRightBound",
                    "=",
                    "RightBound"
                  ]
                },
                {
                  "type": {
                    "value": "SetNumberVariable"
                  },
                  "parameters": [
                    "AreaBottomBound",
                    "=",
                    "BottomBound"
                  ]
                },
                {
                  "type": {
                    "value": "MarchingSquares::MarchingSquaresBehavior::RebuildField"
                  },
                  "parameters": [
                    "Object",
                    "Behavior",
                    ""
                  ]
                }
              ]
            }
          ],
          "parameters": [
            {
              "description": "Object",
              "name": "Object",
              "supplementaryInformation": "PrimitiveDrawing::Drawer",
              "type": "object"
            },
            {
              "description": "Behavior",
              "name": "Behavior",
              "supplementaryInformation": "MarchingSquares::MarchingSquaresBehavior",
              "type": "behavior"
            },
            {
              "description": "Left bound",
              "name": "LeftBound",
              "type": "expression"
            },
            {
              "description": "Top bound",
              "name": "TopBound",
              "type": "expression"
            },
            {
              "description": "Right bound",
              "name": "RightBound",
              "type": "expression"
            },
            {
              "description": "Bottom bound",
              "name": "BottomBound",
              "type": "expression"
            }
          ],
          "objectGroups": []
        },
        {
          "description": "Area left bound of the field.",
          "fullName": "Area left",
          "functionType": "Expression",
          "group": "Field configuration",
          "name": "AreaLeft",
          "sentence": "",
          "events": [
            {
              "type": "BuiltinCommonInstructions::Standard",
              "conditions": [],
              "actions": [
                {
                  "type": {
                    "value": "SetReturnNumber"
                  },
                  "parameters": [
                    "AreaLeftBound"
                  ]
                }
              ]
            }
          ],
          "expressionType": {
            "type": "expression"
          },
          "parameters": [
            {
              "description": "Object",
              "name": "Object",
              "supplementaryInformation": "PrimitiveDrawing::Drawer",
              "type": "object"
            },
            {
              "description": "Behavior",
              "name": "Behavior",
              "supplementaryInformation": "MarchingSquares::MarchingSquaresBehavior",
              "type": "behavior"
            }
          ],
          "objectGroups": []
        },
        {
          "description": "Area top bound of the field.",
          "fullName": "Area top",
          "functionType": "Expression",
          "group": "Field configuration",
          "name": "AreaTop",
          "sentence": "",
          "events": [
            {
              "type": "BuiltinCommonInstructions::Standard",
              "conditions": [],
              "actions": [
                {
                  "type": {
                    "value": "SetReturnNumber"
                  },
                  "parameters": [
                    "AreaTopBound"
                  ]
                }
              ]
            }
          ],
          "expressionType": {
            "type": "expression"
          },
          "parameters": [
            {
              "description": "Object",
              "name": "Object",
              "supplementaryInformation": "PrimitiveDrawing::Drawer",
              "type": "object"
            },
            {
              "description": "Behavior",
              "name": "Behavior",
              "supplementaryInformation": "MarchingSquares::MarchingSquaresBehavior",
              "type": "behavior"
            }
          ],
          "objectGroups": []
        },
        {
          "description": "Area right bound of the field.",
          "fullName": "Area right",
          "functionType": "Expression",
          "group": "Field configuration",
          "name": "AreaRight",
          "sentence": "",
          "events": [
            {
              "type": "BuiltinCommonInstructions::Standard",
              "conditions": [],
              "actions": [
                {
                  "type": {
                    "value": "SetReturnNumber"
                  },
                  "parameters": [
                    "AreaRightBound"
                  ]
                }
              ]
            },
            {
              "type": "BuiltinCommonInstructions::Standard",
              "conditions": [
                {
                  "type": {
                    "value": "Egal"
                  },
                  "parameters": [
                    "AreaLeftBound",
                    "=",
                    "AreaRightBound"
                  ]
                }
              ],
              "actions": [
                {
                  "type": {
                    "value": "SetReturnNumber"
                  },
                  "parameters": [
                    "AreaLeftBound + SceneWindowWidth()"
                  ]
                }
              ]
            }
          ],
          "expressionType": {
            "type": "expression"
          },
          "parameters": [
            {
              "description": "Object",
              "name": "Object",
              "supplementaryInformation": "PrimitiveDrawing::Drawer",
              "type": "object"
            },
            {
              "description": "Behavior",
              "name": "Behavior",
              "supplementaryInformation": "MarchingSquares::MarchingSquaresBehavior",
              "type": "behavior"
            }
          ],
          "objectGroups": []
        },
        {
          "description": "Area bottom bound of the field.",
          "fullName": "Area bottom",
          "functionType": "Expression",
          "group": "Field configuration",
          "name": "AreaBottom",
          "sentence": "",
          "events": [
            {
              "type": "BuiltinCommonInstructions::Standard",
              "conditions": [],
              "actions": [
                {
                  "type": {
                    "value": "SetReturnNumber"
                  },
                  "parameters": [
                    "AreaBottomBound"
                  ]
                }
              ]
            },
            {
              "type": "BuiltinCommonInstructions::Standard",
              "conditions": [
                {
                  "type": {
                    "value": "Egal"
                  },
                  "parameters": [
                    "AreaTopBound",
                    "=",
                    "AreaBottomBound"
                  ]
                }
              ],
              "actions": [
                {
                  "type": {
                    "value": "SetReturnNumber"
                  },
                  "parameters": [
                    "AreaTopBound + SceneWindowHeight()"
                  ]
                }
              ]
            }
          ],
          "expressionType": {
            "type": "expression"
          },
          "parameters": [
            {
              "description": "Object",
              "name": "Object",
              "supplementaryInformation": "PrimitiveDrawing::Drawer",
              "type": "object"
            },
            {
              "description": "Behavior",
              "name": "Behavior",
              "supplementaryInformation": "MarchingSquares::MarchingSquaresBehavior",
              "type": "behavior"
            }
          ],
          "objectGroups": []
        },
        {
          "description": "Width of the field cells.",
          "fullName": "Width of a cell",
          "functionType": "Expression",
          "group": "Field configuration",
          "name": "CellWidth",
          "sentence": "",
          "events": [
            {
              "type": "BuiltinCommonInstructions::Standard",
              "conditions": [],
              "actions": [
                {
                  "type": {
                    "value": "SetReturnNumber"
                  },
                  "parameters": [
                    "CellWidth"
                  ]
                }
              ]
            }
          ],
          "expressionType": {
            "type": "expression"
          },
          "parameters": [
            {
              "description": "Object",
              "name": "Object",
              "supplementaryInformation": "PrimitiveDrawing::Drawer",
              "type": "object"
            },
            {
              "description": "Behavior",
              "name": "Behavior",
              "supplementaryInformation": "MarchingSquares::MarchingSquaresBehavior",
              "type": "behavior"
            }
          ],
          "objectGroups": []
        },
        {
          "description": "Height of the field cells.",
          "fullName": "Height of a cell",
          "functionType": "Expression",
          "group": "Field configuration",
          "name": "CellHeight",
          "sentence": "",
          "events": [
            {
              "type": "BuiltinCommonInstructions::Standard",
              "conditions": [],
              "actions": [
                {
                  "type": {
                    "value": "SetReturnNumber"
                  },
                  "parameters": [
                    "CellHeight"
                  ]
                }
              ]
            }
          ],
          "expressionType": {
            "type": "expression"
          },
          "parameters": [
            {
              "description": "Object",
              "name": "Object",
              "supplementaryInformation": "PrimitiveDrawing::Drawer",
              "type": "object"
            },
            {
              "description": "Behavior",
              "name": "Behavior",
              "supplementaryInformation": "MarchingSquares::MarchingSquaresBehavior",
              "type": "behavior"
            }
          ],
          "objectGroups": []
        },
        {
          "description": "The number of cells on the x axis.",
          "fullName": "Dimension X",
          "functionType": "Expression",
          "group": "Field saving",
          "name": "DimensionX",
          "sentence": "At _PARAM2_; _PARAM3_ the field value of _PARAM0_ is greater than _PARAM4_",
          "events": [
            {
              "type": "BuiltinCommonInstructions::JsCode",
              "inlineCode": [
                "const behaviorName = eventsFunctionContext.getBehaviorName(\"Behavior\");",
                "",
                "const behavior = objects[0].getBehavior(behaviorName);",
                "",
                "eventsFunctionContext.returnValue = behavior.scalarField.dimX();"
              ],
              "parameterObjects": "Object",
              "useStrict": true,
              "eventsSheetExpanded": true
            }
          ],
          "expressionType": {
            "type": "expression"
          },
          "parameters": [
            {
              "description": "Object",
              "name": "Object",
              "supplementaryInformation": "PrimitiveDrawing::Drawer",
              "type": "object"
            },
            {
              "description": "Behavior",
              "name": "Behavior",
              "supplementaryInformation": "MarchingSquares::MarchingSquaresBehavior",
              "type": "behavior"
            }
          ],
          "objectGroups": []
        },
        {
          "description": "The number of cells on the y axis.",
          "fullName": "Dimension Y",
          "functionType": "Expression",
          "group": "Field saving",
          "name": "DimensionY",
          "sentence": "At _PARAM2_; _PARAM3_ the field value of _PARAM0_ is greater than _PARAM4_",
          "events": [
            {
              "type": "BuiltinCommonInstructions::JsCode",
              "inlineCode": [
                "const behaviorName = eventsFunctionContext.getBehaviorName(\"Behavior\");",
                "",
                "const behavior = objects[0].getBehavior(behaviorName);",
                "",
                "eventsFunctionContext.returnValue = behavior.scalarField.dimY();"
              ],
              "parameterObjects": "Object",
              "useStrict": true,
              "eventsSheetExpanded": true
            }
          ],
          "expressionType": {
            "type": "expression"
          },
          "parameters": [
            {
              "description": "Object",
              "name": "Object",
              "supplementaryInformation": "PrimitiveDrawing::Drawer",
              "type": "object"
            },
            {
              "description": "Behavior",
              "name": "Behavior",
              "supplementaryInformation": "MarchingSquares::MarchingSquaresBehavior",
              "type": "behavior"
            }
          ],
          "objectGroups": []
        },
        {
          "description": "The contour threshold.",
          "fullName": "Contour threshold",
          "functionType": "Expression",
          "group": "Field configuration",
          "name": "ContourThreshold",
          "sentence": "",
          "events": [
            {
              "type": "BuiltinCommonInstructions::Standard",
              "conditions": [],
              "actions": [
                {
                  "type": {
                    "value": "SetReturnNumber"
                  },
                  "parameters": [
                    "Threshold"
                  ]
                }
              ]
            }
          ],
          "expressionType": {
            "type": "expression"
          },
          "parameters": [
            {
              "description": "Object",
              "name": "Object",
              "supplementaryInformation": "PrimitiveDrawing::Drawer",
              "type": "object"
            },
            {
              "description": "Behavior",
              "name": "Behavior",
              "supplementaryInformation": "MarchingSquares::MarchingSquaresBehavior",
              "type": "behavior"
            }
          ],
          "objectGroups": []
        },
        {
          "description": "The normal X coordinate at a given location.",
          "fullName": "Normal X",
          "functionType": "Expression",
          "group": "Field evaluation",
          "name": "NormalX",
          "sentence": "At _PARAM2_; _PARAM3_ the field value of _PARAM0_ is greater than _PARAM4_",
          "events": [
            {
              "type": "BuiltinCommonInstructions::JsCode",
              "inlineCode": [
                "const behaviorName = eventsFunctionContext.getBehaviorName(\"Behavior\");",
                "",
                "const pointX = eventsFunctionContext.getArgument(\"PointX\");",
                "const pointY = eventsFunctionContext.getArgument(\"PointY\");",
                "",
                "const behavior = objects[0].getBehavior(behaviorName);",
                "",
                "eventsFunctionContext.returnValue = behavior.heightMap.getFieldNormal(pointX, pointY)[0];"
              ],
              "parameterObjects": "Object",
              "useStrict": true,
              "eventsSheetExpanded": true
            }
          ],
          "expressionType": {
            "type": "expression"
          },
          "parameters": [
            {
              "description": "Object",
              "name": "Object",
              "supplementaryInformation": "PrimitiveDrawing::Drawer",
              "type": "object"
            },
            {
              "description": "Behavior",
              "name": "Behavior",
              "supplementaryInformation": "MarchingSquares::MarchingSquaresBehavior",
              "type": "behavior"
            },
            {
              "description": "X position of the point",
              "name": "PointX",
              "type": "expression"
            },
            {
              "description": "Y position of the point",
              "name": "PointY",
              "type": "expression"
            }
          ],
          "objectGroups": []
        },
        {
          "description": "The normal Y coordinate at a given location.",
          "fullName": "Normal Y",
          "functionType": "Expression",
          "group": "Field evaluation",
          "name": "NormalY",
          "sentence": "At _PARAM2_; _PARAM3_ the field value of _PARAM0_ is greater than _PARAM4_",
          "events": [
            {
              "type": "BuiltinCommonInstructions::JsCode",
              "inlineCode": [
                "const behaviorName = eventsFunctionContext.getBehaviorName(\"Behavior\");",
                "",
                "const pointX = eventsFunctionContext.getArgument(\"PointX\");",
                "const pointY = eventsFunctionContext.getArgument(\"PointY\");",
                "",
                "const behavior = objects[0].getBehavior(behaviorName);",
                "",
                "eventsFunctionContext.returnValue = behavior.heightMap.getFieldNormal(pointX, pointY)[1];"
              ],
              "parameterObjects": "Object",
              "useStrict": true,
              "eventsSheetExpanded": true
            }
          ],
          "expressionType": {
            "type": "expression"
          },
          "parameters": [
            {
              "description": "Object",
              "name": "Object",
              "supplementaryInformation": "PrimitiveDrawing::Drawer",
              "type": "object"
            },
            {
              "description": "Behavior",
              "name": "Behavior",
              "supplementaryInformation": "MarchingSquares::MarchingSquaresBehavior",
              "type": "behavior"
            },
            {
              "description": "X position of the point",
              "name": "PointX",
              "type": "expression"
            },
            {
              "description": "Y position of the point",
              "name": "PointY",
              "type": "expression"
            }
          ],
          "objectGroups": []
        },
        {
          "description": "The normal Z coordinate at a given location.",
          "fullName": "Normal Z",
          "functionType": "Expression",
          "group": "Field evaluation",
          "name": "NormalZ",
          "sentence": "At _PARAM2_; _PARAM3_ the field value of _PARAM0_ is greater than _PARAM4_",
          "events": [
            {
              "type": "BuiltinCommonInstructions::JsCode",
              "inlineCode": [
                "const behaviorName = eventsFunctionContext.getBehaviorName(\"Behavior\");",
                "",
                "const pointX = eventsFunctionContext.getArgument(\"PointX\");",
                "const pointY = eventsFunctionContext.getArgument(\"PointY\");",
                "",
                "const behavior = objects[0].getBehavior(behaviorName);",
                "",
                "eventsFunctionContext.returnValue = behavior.heightMap.getFieldNormal(pointX, pointY)[2];"
              ],
              "parameterObjects": "Object",
              "useStrict": true,
              "eventsSheetExpanded": true
            }
          ],
          "expressionType": {
            "type": "expression"
          },
          "parameters": [
            {
              "description": "Object",
              "name": "Object",
              "supplementaryInformation": "PrimitiveDrawing::Drawer",
              "type": "object"
            },
            {
              "description": "Behavior",
              "name": "Behavior",
              "supplementaryInformation": "MarchingSquares::MarchingSquaresBehavior",
              "type": "behavior"
            },
            {
              "description": "X position of the point",
              "name": "PointX",
              "type": "expression"
            },
            {
              "description": "Y position of the point",
              "name": "PointY",
              "type": "expression"
            }
          ],
          "objectGroups": []
        },
        {
          "description": "Change the field value at a grid point.",
          "fullName": "Grid value",
          "functionType": "Action",
          "group": "Field loading",
          "name": "SetGridValue",
          "sentence": "Change the field value of _PARAM0_ at the grid point _PARAM2_; _PARAM3_ to _PARAM4_",
          "events": [
            {
              "type": "BuiltinCommonInstructions::JsCode",
              "inlineCode": [
                "const behaviorName = eventsFunctionContext.getBehaviorName(\"Behavior\");",
                "",
                "const indexX = eventsFunctionContext.getArgument(\"IndexX\");",
                "const indexY = eventsFunctionContext.getArgument(\"IndexY\");",
                "const value = eventsFunctionContext.getArgument(\"Value\");",
                "",
                "const behavior = objects[0].getBehavior(behaviorName);",
                "",
                "eventsFunctionContext.returnValue = behavior.scalarField.set(indexX, indexY, value);"
              ],
              "parameterObjects": "Object",
              "useStrict": true,
              "eventsSheetExpanded": true
            }
          ],
          "parameters": [
            {
              "description": "Object",
              "name": "Object",
              "supplementaryInformation": "PrimitiveDrawing::Drawer",
              "type": "object"
            },
            {
              "description": "Behavior",
              "name": "Behavior",
              "supplementaryInformation": "MarchingSquares::MarchingSquaresBehavior",
              "type": "behavior"
            },
            {
              "description": "X grid index",
              "name": "IndexX",
              "type": "expression"
            },
            {
              "description": "Y grid index",
              "name": "IndexY",
              "type": "expression"
            },
            {
              "description": "Field value",
              "name": "Value",
              "type": "expression"
            }
          ],
          "objectGroups": []
        },
        {
          "description": "The field value at a grid point.",
          "fullName": "Grid value",
          "functionType": "Expression",
          "group": "Field saving",
          "name": "GridValue",
          "sentence": "At _PARAM2_; _PARAM3_ the field value of _PARAM0_ is greater than _PARAM4_",
          "events": [
            {
              "type": "BuiltinCommonInstructions::JsCode",
              "inlineCode": [
                "const behaviorName = eventsFunctionContext.getBehaviorName(\"Behavior\");",
                "",
                "const indexX = eventsFunctionContext.getArgument(\"IndexX\");",
                "const indexY = eventsFunctionContext.getArgument(\"IndexY\");",
                "",
                "const behavior = objects[0].getBehavior(behaviorName);",
                "",
                "eventsFunctionContext.returnValue = behavior.scalarField.get(indexX, indexY);"
              ],
              "parameterObjects": "Object",
              "useStrict": true,
              "eventsSheetExpanded": true
            }
          ],
          "expressionType": {
            "type": "expression"
          },
          "parameters": [
            {
              "description": "Object",
              "name": "Object",
              "supplementaryInformation": "PrimitiveDrawing::Drawer",
              "type": "object"
            },
            {
              "description": "Behavior",
              "name": "Behavior",
              "supplementaryInformation": "MarchingSquares::MarchingSquaresBehavior",
              "type": "behavior"
            },
            {
              "description": "X grid index",
              "name": "IndexX",
              "type": "expression"
            },
            {
              "description": "Y grid index",
              "name": "IndexY",
              "type": "expression"
            }
          ],
          "objectGroups": []
        },
        {
          "description": "The field value at a given location.",
          "fullName": "Field value",
          "functionType": "Expression",
          "group": "Field evaluation",
          "name": "FieldValue",
          "sentence": "At _PARAM2_; _PARAM3_ the field value of _PARAM0_ is greater than _PARAM4_",
          "events": [
            {
              "type": "BuiltinCommonInstructions::JsCode",
              "inlineCode": [
                "const behaviorName = eventsFunctionContext.getBehaviorName(\"Behavior\");",
                "",
                "const pointX = eventsFunctionContext.getArgument(\"PointX\");",
                "const pointY = eventsFunctionContext.getArgument(\"PointY\");",
                "",
                "const behavior = objects[0].getBehavior(behaviorName);",
                "",
                "eventsFunctionContext.returnValue = behavior.heightMap.getHeight(pointX, pointY);"
              ],
              "parameterObjects": "Object",
              "useStrict": true,
              "eventsSheetExpanded": true
            }
          ],
          "expressionType": {
            "type": "expression"
          },
          "parameters": [
            {
              "description": "Object",
              "name": "Object",
              "supplementaryInformation": "PrimitiveDrawing::Drawer",
              "type": "object"
            },
            {
              "description": "Behavior",
              "name": "Behavior",
              "supplementaryInformation": "MarchingSquares::MarchingSquaresBehavior",
              "type": "behavior"
            },
            {
              "description": "X position of the point",
              "name": "PointX",
              "type": "expression"
            },
            {
              "description": "Y position of the point",
              "name": "PointY",
              "type": "expression"
            }
          ],
          "objectGroups": []
        },
        {
          "description": "Check if the contours are filled outside.",
          "fullName": "Fill outside",
          "functionType": "Condition",
          "group": "Field configuration",
          "name": "CheckFillOutside",
          "sentence": "The contours of _PARAM0_ are filled outside",
          "events": [
            {
              "type": "BuiltinCommonInstructions::Standard",
              "conditions": [],
              "actions": [
                {
                  "type": {
                    "value": "SetReturnBoolean"
                  },
                  "parameters": [
                    "False"
                  ]
                }
              ]
            },
            {
              "type": "BuiltinCommonInstructions::Standard",
              "conditions": [
                {
                  "type": {
                    "value": "BooleanVariable"
                  },
                  "parameters": [
                    "FillOutside",
                    "True",
                    ""
                  ]
                }
              ],
              "actions": [
                {
                  "type": {
                    "value": "SetReturnBoolean"
                  },
                  "parameters": [
                    "True"
                  ]
                }
              ]
            }
          ],
          "parameters": [
            {
              "description": "Object",
              "name": "Object",
              "supplementaryInformation": "PrimitiveDrawing::Drawer",
              "type": "object"
            },
            {
              "description": "Behavior",
              "name": "Behavior",
              "supplementaryInformation": "MarchingSquares::MarchingSquaresBehavior",
              "type": "behavior"
            }
          ],
          "objectGroups": []
        },
        {
          "description": "Check if a field is greater than a given value.",
          "fullName": "Field value",
          "functionType": "Condition",
          "group": "Field evaluation",
          "name": "CheckFieldValue",
          "sentence": "At _PARAM2_; _PARAM3_ the field value of _PARAM0_ is greater than _PARAM4_",
          "events": [
            {
              "type": "BuiltinCommonInstructions::JsCode",
              "inlineCode": [
                "const behaviorName = eventsFunctionContext.getBehaviorName(\"Behavior\");",
                "",
                "const pointX = eventsFunctionContext.getArgument(\"PointX\");",
                "const pointY = eventsFunctionContext.getArgument(\"PointY\");",
                "const value = eventsFunctionContext.getArgument(\"Value\");",
                "",
                "const behavior = objects[0].getBehavior(behaviorName);",
                "",
                "eventsFunctionContext.returnValue = behavior.heightMap.getHeight(pointX, pointY) > value;"
              ],
              "parameterObjects": "Object",
              "useStrict": true,
              "eventsSheetExpanded": true
            }
          ],
          "parameters": [
            {
              "description": "Object",
              "name": "Object",
              "supplementaryInformation": "PrimitiveDrawing::Drawer",
              "type": "object"
            },
            {
              "description": "Behavior",
              "name": "Behavior",
              "supplementaryInformation": "MarchingSquares::MarchingSquaresBehavior",
              "type": "behavior"
            },
            {
              "description": "X position of the point",
              "name": "PointX",
              "type": "expression"
            },
            {
              "description": "Y position of the point",
              "name": "PointY",
              "type": "expression"
            },
            {
              "description": "Value",
              "name": "Value",
              "type": "expression"
            }
          ],
          "objectGroups": []
        },
        {
          "description": "Check if a point is inside the contour.",
          "fullName": "Point is inside",
          "functionType": "Condition",
          "group": "Field evaluation",
          "name": "ContainsPoint",
          "sentence": "_PARAM2_; _PARAM3_ is inside _PARAM0_",
          "events": [
            {
              "type": "BuiltinCommonInstructions::JsCode",
              "inlineCode": [
                "const behaviorName = eventsFunctionContext.getBehaviorName(\"Behavior\");",
                "",
                "const pointX = eventsFunctionContext.getArgument(\"PointX\");",
                "const pointY = eventsFunctionContext.getArgument(\"PointY\");",
                "",
                "const behavior = objects[0].getBehavior(behaviorName);",
                "",
                "eventsFunctionContext.returnValue = behavior.containsPoint(pointX, pointY);"
              ],
              "parameterObjects": "Object",
              "useStrict": true,
              "eventsSheetExpanded": true
            }
          ],
          "parameters": [
            {
              "description": "Object",
              "name": "Object",
              "supplementaryInformation": "PrimitiveDrawing::Drawer",
              "type": "object"
            },
            {
              "description": "Behavior",
              "name": "Behavior",
              "supplementaryInformation": "MarchingSquares::MarchingSquaresBehavior",
              "type": "behavior"
            },
            {
              "description": "X position of the point",
              "name": "PointX",
              "type": "expression"
            },
            {
              "description": "Y position of the point",
              "name": "PointY",
              "type": "expression"
            }
          ],
          "objectGroups": []
        }
      ],
      "propertyDescriptors": [
        {
          "value": "0",
          "type": "Number",
          "unit": "Pixel",
          "label": "Area left bound",
          "description": "",
          "group": "",
          "extraInformation": [],
          "name": "AreaLeftBound"
        },
        {
          "value": "0",
          "type": "Number",
          "unit": "Pixel",
          "label": "Area top bound",
          "description": "",
          "group": "",
          "extraInformation": [],
          "name": "AreaTopBound"
        },
        {
          "value": "0",
          "type": "Number",
          "unit": "Pixel",
          "label": "Area right bound",
          "description": "",
          "group": "",
          "extraInformation": [],
          "name": "AreaRightBound"
        },
        {
          "value": "0",
          "type": "Number",
          "unit": "Pixel",
          "label": "Area bottom bound",
          "description": "",
          "group": "",
          "extraInformation": [],
          "name": "AreaBottomBound"
        },
        {
          "value": "20",
          "type": "Number",
          "unit": "Pixel",
          "label": "Cell width",
          "description": "",
          "group": "",
          "extraInformation": [],
          "name": "CellWidth"
        },
        {
          "value": "20",
          "type": "Number",
          "unit": "Pixel",
          "label": "Cell height",
          "description": "",
          "group": "",
          "extraInformation": [],
          "name": "CellHeight"
        },
        {
          "value": "",
          "type": "Boolean",
          "label": "Fill outside",
          "description": "",
          "group": "",
          "extraInformation": [],
          "name": "FillOutside"
        },
        {
          "value": "1",
          "type": "Number",
          "unit": "Dimensionless",
          "label": "Contour threshold",
          "description": "",
          "group": "",
          "extraInformation": [],
          "name": "Threshold"
        },
        {
          "value": "",
          "type": "Boolean",
          "label": "Must only draw what is on the screen",
          "description": "",
          "group": "",
          "extraInformation": [],
          "name": "MustOnlyDrawScreen"
        }
      ],
      "sharedPropertyDescriptors": []
    }
  ],
  "eventsBasedObjects": []
}