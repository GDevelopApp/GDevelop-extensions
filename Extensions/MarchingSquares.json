{
  "author": "D8H",
  "description": "It can be helpful to draw:\n* fog of wars\n* liquids effects (water, blobs, lava)\n* dynamically paint territories\n* other effects based on \"contour lines\"",
  "extensionNamespace": "",
  "fullName": "Marching Squares (experimental)",
  "helpPath": "",
  "iconUrl": "data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0iVVRGLTgiPz48IURPQ1RZUEUgc3ZnIFBVQkxJQyAiLS8vVzNDLy9EVEQgU1ZHIDEuMS8vRU4iICJodHRwOi8vd3d3LnczLm9yZy9HcmFwaGljcy9TVkcvMS4xL0RURC9zdmcxMS5kdGQiPjxzdmcgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIiB4bWxuczp4bGluaz0iaHR0cDovL3d3dy53My5vcmcvMTk5OS94bGluayIgdmVyc2lvbj0iMS4xIiBpZD0ibWRpLXBlYW51dC1vdXRsaW5lIiB3aWR0aD0iMjQiIGhlaWdodD0iMjQiIHZpZXdCb3g9IjAgMCAyNCAyNCI+PHBhdGggZD0iTTEyIDIzQzExLjUzIDIzIDExLjA3IDIyLjk1IDEwLjYxIDIyLjg1QzcuMSAyMi4xIDQuODcgMTguNjQgNS42MiAxNS4xM0M1Ljg3IDEzLjk1IDYuNDUgMTIuODcgNy4yOCAxMkM3LjYyIDExLjY0IDcuNjIgMTEuMDggNy4yOCAxMC43MkM1LjIgOC4xNCA1LjYgNC4zNiA4LjE4IDIuMjhTMTQuNTQuNjA3IDE2LjYyIDMuMTlDMTguMzkgNS4zOCAxOC4zOSA4LjUgMTYuNjIgMTAuNzJDMTYuMzMgMTEuMTMgMTYuMzcgMTEuNyAxNi43MiAxMi4wNkMxOS4xNyAxNC42OCAxOS4wNCAxOC44IDE2LjQxIDIxLjI1QzE1LjIyIDIyLjM3IDEzLjY0IDIzIDEyIDIzTTEyIDNDMTEuMDkgMyAxMC4yIDMuMzEgOS41IDMuODlDOC41NSA0LjY1IDggNS43OSA4IDdDOCA3LjkxIDguMzEgOC43OSA4Ljg4IDkuNUM5Ljg0IDEwLjY0IDkuNzcgMTIuMzMgOC43MyAxMy40MUM3LjAzIDE1LjIyIDcuMTMgMTguMDcgOC45NCAxOS43N1MxMy42IDIxLjM4IDE1LjMgMTkuNTZDMTYuOTIgMTcuODMgMTYuOTIgMTUuMTQgMTUuMyAxMy40MUMxNC4yMyAxMi4zMiAxNC4xNSAxMC42IDE1LjEyIDkuNDFDMTYuNSA3LjY5IDE2LjIyIDUuMTcgMTQuNSAzLjc5QzE0IDMuNDEgMTMuNDcgMy4xNCAxMi44OCAzQzEyLjU5IDMgMTIuMjkgMyAxMiAzTTEyIDZDMTIgNi41NSAxMi40NSA3IDEzIDdTMTQgNi41NSAxNCA2IDEzLjU1IDUgMTMgNSAxMiA1LjQ1IDEyIDZNMTQgMTlDMTQuNTUgMTkgMTUgMTguNTUgMTUgMThTMTQuNTUgMTcgMTQgMTcgMTMgMTcuNDUgMTMgMTggMTMuNDUgMTkgMTQgMTlNMTMgMTZDMTMuNTUgMTYgMTQgMTUuNTUgMTQgMTVTMTMuNTUgMTQgMTMgMTQgMTIgMTQuNDUgMTIgMTUgMTIuNDUgMTYgMTMgMTZNMTEgMThDMTEuNTUgMTggMTIgMTcuNTUgMTIgMTdTMTEuNTUgMTYgMTEgMTYgMTAgMTYuNDUgMTAgMTcgMTAuNDUgMTggMTEgMThaIiAvPjwvc3ZnPg==",
  "name": "MarchingSquares",
  "previewIconUrl": "https://resources.gdevelop-app.com/assets/Icons/peanut-outline.svg",
  "shortDescription": "Allow to build a \"scalar field\" and draw contour lines of it: useful for fog of wars, liquid effects, paint the ground, etc...",
  "version": "0.1.1",
  "tags": [
    "blobs",
    "liquid",
    "lava",
    "water",
    "fog",
    "paint"
  ],
  "authorIds": [
    "IWykYNRvhCZBN3vEgKEbBPOR3Oc2"
  ],
  "dependencies": [],
  "eventsFunctions": [],
  "eventsBasedBehaviors": [
    {
      "description": "Add to a Shape painter object and use the actions to draw a field. Useful for fog of wars, liquid effects (water, lava, blobs...).",
      "fullName": "Marching squares painter",
      "name": "MarchingSquaresBehavior",
      "objectType": "PrimitiveDrawing::Drawer",
      "eventsFunctions": [
        {
          "description": "",
          "fullName": "",
          "functionType": "Action",
          "name": "onCreated",
          "private": false,
          "sentence": "",
          "events": [
            {
              "disabled": false,
              "folded": false,
              "type": "BuiltinCommonInstructions::JsCode",
              "inlineCode": "const game = runtimeScene.getGame();\nconst behaviorName = eventsFunctionContext.getBehaviorName(\"Behavior\");\n\nfor (const object of objects) {\n  const behavior = object.getBehavior(behaviorName);\n\n  /** @type {float} */\n  const left = behavior._getAreaLeftBound();\n  /** @type {float} */\n  const top = behavior._getAreaTopBound();\n  /** @type {float} */\n  const right = behavior._getAreaRightBound() || game.getGameResolutionWidth();\n  /** @type {float} */\n  const bottom = behavior._getAreaBottomBound() || game.getGameResolutionHeight();\n  /** @type {float} */\n  const cellWidth = behavior._getCellWidth();\n  /** @type {float} */\n  const cellHeight = behavior._getCellHeight();\n\n  // Build the scalar field\n  const dimX = 1 + Math.ceil((right - left) / cellWidth);\n  const dimY = 1 + Math.ceil((bottom - top) / cellHeight);\n\n  /** @type {Array<number[]>} */\n  const fieldValues = new Array(dimY);\n  for (var y = 0; y < dimY; y++) {\n    fieldValues[y] = new Array(dimX).fill(0);\n  }\n  behavior.scalarFieldValues = fieldValues;\n\n  /** @type {gdjs.Polygon[]} Avoid allocations when updating hitboxes*/\n  behavior.recycledPolygons = [];\n\n  const prototype = Object.getPrototypeOf(behavior);\n  if (!prototype.convertToGridBasisX) {\n    const South = 0;\n    const East = 1;\n    const North = 2;\n    const West = 3;\n    const SouthWest = 4;\n    const SouthEast = 5;\n    const NorthEast = 6;\n    const NorthWest = 7;\n\n    const SouthWestMask = 1;\n    const SouthEastMask = 2;\n    const NorthEastMask = 4;\n    const NorthWestMask = 8;\n\n    gdjs.__marchingSquares = {\n      parseOperation: function (operation) {\n        switch (operation) {\n          case \"Addition\":\n            return (value1, value2) => value1 + value2;\n          case \"Subtraction\":\n            return (value1, value2) => value1 - value2;\n          case \"Minimum\":\n            return Math.min;\n          case \"Maximum\":\n          default:\n            return Math.max;\n        }\n        return;\n      }\n    };\n\n    /** {FloatPoint} Avoid memory allocations when returning points */\n    prototype.workingPoint = [0, 0];\n    prototype.marchingSquaresFillVertices = [\n      [],\n      [South, West, SouthWest],\n      [East, South, SouthEast],\n      [East, West, SouthWest, SouthEast],\n\n      [North, East, NorthEast],\n      [\n        South,\n        SouthWest,\n        West,\n        North,\n        NorthEast,\n        East,\n      ],\n      [South, North, NorthEast, SouthEast],\n      [West, North, NorthEast, SouthEast, SouthWest],\n\n      [West, North, NorthWest],\n      [North, South, SouthWest, NorthWest],\n      [\n        South,\n        West,\n        NorthWest,\n        North,\n        East,\n        SouthEast,\n      ],\n      [North, East, SouthEast, SouthWest, NorthWest],\n\n      [East, West, NorthWest, NorthEast],\n      [East, South, SouthWest, NorthWest, NorthEast],\n      [South, West, NorthWest, NorthEast, SouthEast],\n      [],\n    ];\n    prototype.marchingSquaresOutlineVertices = [\n      [[]],\n      [[South, West]],\n      [[East, South]],\n      [[East, West]],\n\n      [[North, East]],\n      [\n        [East, South],\n        [West, North]\n      ],\n      [[South, North]],\n      [[West, North]],\n\n      [[West, North]],\n      [[North, South]],\n      [\n        [South, West],\n        [North, East]\n      ],\n      [[North, East]],\n\n      [[East, West]],\n      [[East, South]],\n      [[South, West]],\n      [[]],\n    ];\n\n    /**\n     * @param x {float} in the scene basis\n     * @return {float} x in the grid basis\n     */\n    prototype.convertToGridBasisX = function (x) {\n      return (x - this._getAreaLeftBound()) / this._getCellWidth();\n    }\n\n    /**\n     * @param y {float} in the scene basis\n     * @return {float} y in the grid basis\n     */\n    prototype.convertToGridBasisY = function (y) {\n      return (y - this._getAreaTopBound()) / this._getCellHeight();\n    }\n\n    /**\n     * @param x {float} in the grid basis\n     * @return {float} x in the scene basis\n     */\n    prototype.convertFromGridBasisX = function (x) {\n      return x * this._getCellWidth() + this._getAreaLeftBound();\n    }\n\n    /**\n     * @param y {float} in the grid basis\n     * @return {float} y in the scene basis\n     */\n    prototype.convertFromGridBasisY = function (y) {\n      return y * this._getCellHeight() + this._getAreaTopBound();\n    }\n\n    /**\n     * @return {integer} grid dimension on y\n     */\n    prototype.dimY = function () {\n      return this.scalarFieldValues.length;\n    }\n\n    /**\n     * @return {integer} grid dimension on y\n     */\n    prototype.dimX = function () {\n      const firstColumn = this.scalarFieldValues[0];\n      return firstColumn ? firstColumn.length : 0;\n    }\n\n    /**\n     * @param x {integer} the square top in the grid\n     * @param y {integer} the square left in the grid\n     * @return {integer} one of the 16 marching squares cases\n     */\n    prototype.getSquareIndex = function (x, y) {\n      /** @type {float} */\n      const threshold = this._getThreshold();\n      let squareIndex = 0;\n      if (this.scalarFieldValues[y + 1][x] > threshold) {\n        squareIndex |= SouthWestMask;\n      }\n      if (this.scalarFieldValues[y + 1][x + 1] > threshold) {\n        squareIndex |= SouthEastMask;\n      }\n      if (this.scalarFieldValues[y][x + 1] > threshold) {\n        squareIndex |= NorthEastMask;\n      }\n      if (this.scalarFieldValues[y][x] > threshold) {\n        squareIndex |= NorthWestMask;\n      }\n      return squareIndex;\n    }\n\n    /**\n     * @param side {integer} point location\n     * @param indexX {integer} the square top in the grid\n     * @param indexY {integer} the square left in the grid\n     * @param point {FloatPoint} is the result\n     */\n    prototype.calcPoint = function (\n      side,\n      indexX,\n      indexY,\n      point\n    ) {\n      let gridX = 0;\n      let gridY = 0;\n\n      switch (side) {\n        case South:\n          gridY = indexY + 1;\n          gridX = this.betweenX(indexX, gridY, indexX + 1, gridY);\n          break;\n\n        case East:\n          gridX = indexX + 1;\n          gridY = this.betweenY(gridX, indexY, gridX, indexY + 1);\n          break;\n\n        case North:\n          gridY = indexY;\n          gridX = this.betweenX(indexX, gridY, indexX + 1, gridY);\n          break;\n\n        case West:\n          gridX = indexX;\n          gridY = this.betweenY(gridX, indexY, gridX, indexY + 1);\n          break;\n\n        case SouthWest:\n          gridX = indexX;\n          gridY = indexY + 1;\n          break;\n\n        case SouthEast:\n          gridX = indexX + 1;\n          gridY = indexY + 1;\n          break;\n\n        case NorthEast:\n          gridX = indexX + 1;\n          gridY = indexY;\n          break;\n\n        case NorthWest:\n          gridX = indexX;\n          gridY = indexY;\n          break;\n      }\n\n      point[0] = this.convertFromGridBasisX(gridX);\n      point[1] = this.convertFromGridBasisY(gridY);\n    }\n\n    /**\n     * Returns the mean between 2 corners weighted by their field value.\n     * @param indexX1 {integer} first corner x\n     * @param indexY1 {integer} first corner y\n     * @param indexX2 {integer} second corner x\n     * @param indexY2 {integer} second corner y\n     * @return {float} x in the grid\n     */\n    prototype.betweenX = function (\n      indexX1,\n      indexY1,\n      indexX2,\n      indexY2\n    ) {\n      const value1 = this.scalarFieldValues[indexY1][indexX1];\n      const value2 = this.scalarFieldValues[indexY2][indexX2];\n\n      /** @type {float} */\n      const threshold = this._getThreshold();\n      const wight1 = Math.abs(value1 - threshold);\n      const wight2 = Math.abs(value2 - threshold);\n\n      return (wight2 * indexX1 + wight1 * indexX2) / (wight1 + wight2);\n    }\n\n    /**\n     * Returns the mean between 2 corners weighted by their field value.\n     * @param indexX1 {integer} first corner x\n     * @param indexY1 {integer} first corner y\n     * @param indexX2 {integer} second corner x\n     * @param indexY2 {integer} second corner y\n     * @return {float} y in the grid\n     */\n    prototype.betweenY = function (\n      indexX1,\n      indexY1,\n      indexX2,\n      indexY2\n    ) {\n      const value1 = this.scalarFieldValues[indexY1][indexX1];\n      const value2 = this.scalarFieldValues[indexY2][indexX2];\n\n      /** @type {float} */\n      const threshold = this._getThreshold();\n      const weight1 = Math.abs(value1 - threshold);\n      const weight2 = Math.abs(value2 - threshold);\n\n      return (weight2 * indexY1 + weight1 * indexY2) / (weight1 + weight2);\n    }\n\n    /**\n     * @param pointX {float} in scene basis\n     * @param pointY {float} in scene basis\n     * @return {float} true if the point is inside the contour\n     */\n    prototype.getFieldValue = function (\n      pointX,\n      pointY,\n    ) {\n      /** @type {Array<number[]>} */\n      const fieldValues = this.scalarFieldValues;\n\n      const x = this.convertToGridBasisX(pointX);\n      const y = this.convertToGridBasisY(pointY);\n\n      const squareX = Math.floor(x);\n      const squareY = Math.floor(y);\n\n      if (squareX < 0 || squareY < 0 || squareX >= behavior.dimX() || squareY >= behavior.dimY()) {\n        return 0;\n      }\n\n      // Extrapolate\n      let weigtedValueSum = 0;\n      let weightSum = 0;\n      for (let vertexX = squareX; vertexX <= squareX + 1; vertexX++) {\n        for (let vertexY = squareY; vertexY <= squareY + 1; vertexY++) {\n          const value = fieldValues[vertexY][vertexX];\n          const dx = vertexX - x;\n          const dy = vertexY - y;\n          if (dx === 0 && dy === 0) {\n            return value;\n          }\n          else {\n            const distance = Math.hypot(dx, dy);\n            weigtedValueSum += value / distance;\n            weightSum += 1 / distance;\n          }\n        }\n      }\n      const mean = weigtedValueSum / weightSum;\n      return mean;\n    }\n\n    /**\n     * @param x1 {float} fist point x\n     * @param y1 {float} fist point y\n     * @param x2 {float} second point x\n     * @param y2 {float} second point y\n     * @return {float} the square distance between 2 points\n     */\n    prototype.distanceSq = function (x1, y1, x2, y2) {\n      const deltaX = x2 - x1;\n      const deltaY = y2 - y1;\n      return deltaX * deltaX + deltaY * deltaY;\n    }\n\n    /**\n     * @param x {float} point x\n     * @param y {float} point y\n     * @param x1 {float} segment extremity x\n     * @param y1 {float} segment extremity y\n     * @param x2 {float} segment extremity x\n     * @param y2 {float} segment extremity y\n     * @return {float} the square distance between a point and a segment\n     */\n    prototype.distanceSqToSegment = function (x, y, x1, y1, x2, y2) {\n      const length2 = this.distanceSq(x1, y1, x2, y2);\n      if (length2 === 0) return this.distanceSq(x, y, x1, y1);\n      const t = Math.max(0, Math.min(1, ((x - x1) * (x2 - x1) + (y - y1) * (y2 - y1)) / length2));\n      return this.distanceSq(\n        x, y, x1 + t * (x2 - x1),\n        y1 + t * (y2 - y1));\n    }\n\n    /**\n     * Merge a disk in the field.\n     * @param centerX {float} in scene basis\n     * @param centerY {float} in scene basis\n     * @param radius {float} in scene basis\n     * @param cappingRadiusRatio {float}\n     * @param operation {function(float, float):float}\n     */\n    prototype.mergeDisk = function (centerX, centerY, radius, cappingRadiusRatio, operation) {\n      /** @type {float} */\n      const cellWidth = this._getCellWidth();\n      /** @type {float} */\n      const cellHeight = this._getCellHeight();\n\n      /** @type {Array<number[]>} */\n      const fieldValues = this.scalarFieldValues;\n\n      /** @type {float} */\n      const cX = this.convertToGridBasisX(centerX);\n      /** @type {float} */\n      const cY = this.convertToGridBasisY(centerY);\n\n      const cappingRadius = cappingRadiusRatio * radius;\n      const minX = Math.max(\n        0,\n        Math.floor(this.convertToGridBasisX(centerX - cappingRadius))\n      );\n      const minY = Math.max(\n        0,\n        Math.floor(this.convertToGridBasisY(centerY - cappingRadius))\n      );\n      const maxX = Math.min(\n        this.dimX() - 1,\n        Math.ceil(this.convertToGridBasisX(centerX + cappingRadius))\n      );\n      const maxY = Math.min(\n        this.dimY() - 1,\n        Math.ceil(this.convertToGridBasisY(centerY + cappingRadius))\n      );\n\n      const radiusSq = radius * radius / cellWidth / cellWidth;\n      // Avoid too big values\n      const minDistanceSq = 1 / 1024 / 1024;\n      for (let y = minY; y <= maxY; y++) {\n        const rowValues = fieldValues[y];\n        for (let x = minX; x <= maxX; x++) {\n          const distanceSq = Math.max(minDistanceSq, behavior.distanceSq(x, y, cX, cY));\n          rowValues[x] = operation(\n            rowValues[x],\n            radiusSq / distanceSq\n          );\n        }\n      }\n    }\n\n    /**\n     * Merge a segment in the field.\n     * @param startX {float} in scene basis\n     * @param startY {float} in scene basis\n     * @param endX {float} in scene basis\n     * @param endY {float} in scene basis\n     * @param radius {float} in scene basis\n     * @param cappingRadiusRatio {float}\n     * @param operation {function(float, float):float}\n     */\n    prototype.mergeSegment = function (startX, startY, endX, endY, trickness, cappingRadiusRatio, operation) {\n      /** @type {float} */\n      const cellWidth = this._getCellWidth();\n      /** @type {float} */\n      const cellHeight = this._getCellHeight();\n\n      /** @type {Array<number[]>} */\n      const fieldValues = this.scalarFieldValues;\n\n      /** @type {float} */\n      const x1 = this.convertToGridBasisX(startX);\n      /** @type {float} */\n      const y1 = this.convertToGridBasisY(startY);\n      /** @type {float} */\n      const x2 = this.convertToGridBasisX(endX);\n      /** @type {float} */\n      const y2 = this.convertToGridBasisY(endY);\n\n      const cappingRadius = cappingRadiusRatio * trickness;\n      const minX = Math.max(\n        0,\n        Math.floor(this.convertToGridBasisX(Math.min(startX, endX) - cappingRadius))\n      );\n      const minY = Math.max(\n        0,\n        Math.floor(this.convertToGridBasisY(Math.min(startY, endY) - cappingRadius))\n      );\n      const maxX = Math.min(\n        this.dimX() - 1,\n        Math.ceil(this.convertToGridBasisX(Math.max(startX, endX) + cappingRadius))\n      );\n      const maxY = Math.min(\n        this.dimY() - 1,\n        Math.ceil(this.convertToGridBasisY(Math.max(startY, endY) + cappingRadius))\n      );\n\n      const tricknessSq = trickness * trickness / cellWidth / cellWidth;\n      // Avoid too big values\n      const minDistanceSq = 1 / 1024 / 1024;\n      for (let y = minY; y <= maxY; y++) {\n        const rowValues = fieldValues[y];\n        for (let x = minX; x <= maxX; x++) {\n          const distanceSq = Math.max(minDistanceSq, behavior.distanceSqToSegment(x, y, x1, y1, x2, y2));\n          rowValues[x] = operation(\n            rowValues[x],\n            tricknessSq / distanceSq\n          );\n        }\n      }\n    }\n\n    /**\n     * Flood an area from a given location until a maximum field value is reached.\n     * @param originX {float} in scene basis\n     * @param originY {float} in scene basis\n     * @param maximum {float} maximum field value to go through\n     */\n    prototype.floodFrom = function (originX, originY, maximum) {\n      /** @type {Array<number[]>} */\n      const fieldValues = this.scalarFieldValues;\n\n      if (!this.marchingSquareFloodStackX) {\n        this.marchingSquareFloodStackX = [];\n      }\n      if (!this.marchingSquareFloodStackY) {\n        this.marchingSquareFloodStackY = [];\n      }\n      /** @type {Array<integer>} */\n      const floodStackX = this.marchingSquareFloodStackX;\n      /** @type {Array<integer>} */\n      const floodStackY = this.marchingSquareFloodStackY;\n      floodStackX.push(Math.round(this.convertToGridBasisX(originX)));\n      floodStackY.push(Math.round(this.convertToGridBasisY(originY)));\n      while (floodStackX.length > 0) {\n        const x = floodStackX.pop();\n        const y = floodStackY.pop();\n        if (x < 0 || x >= this.dimX()\n          || y < 0 || y >= this.dimY()) {\n          continue;\n        }\n        const fieldValue = fieldValues[y][x];\n        if (fieldValue < maximum) {\n          fieldValues[y][x] = maximum;\n\n          floodStackX.push(x - 1);\n          floodStackY.push(y);\n\n          floodStackX.push(x + 1);\n          floodStackY.push(y);\n\n          floodStackX.push(x);\n          floodStackY.push(y - 1);\n\n          floodStackX.push(x);\n          floodStackY.push(y + 1);\n        }\n      }\n    }\n\n    /**\n     * @param pointX {float} in scene basis\n     * @param pointY {float} in scene basis\n     * @return {boolean} true if the point is inside the contour\n     */\n    prototype.containsPoint = function (\n      pointX,\n      pointY,\n    ) {\n      /** @type {boolean} */\n      const drawUnder = this._getFillOutside();\n\n      // It's a bit more precise than the contour\n      // so it's not completly accurate.\n      return !drawUnder && this.getFieldValue(pointX, pointY) > this._getThreshold() ||\n        drawUnder && this.getFieldValue(pointX, pointY) < this._getThreshold();\n    }\n\n    /**\n     * Draw the field squares\n     * @param minX {integer} left\n     * @param minY {integer} top\n     * @param maxX {integer} right\n     * @param maxY {integer} bottom\n     */\n    prototype.drawField = function (\n      minX,\n      minY,\n      maxX,\n      maxY\n    ) {\n      /** @type {boolean} */\n      const drawUnder = this._getFillOutside();\n\n      /** @type {Array<number[]>} */\n      const fieldValues = this.scalarFieldValues;\n\n      const point = this.workingPoint;\n\n      const shapePainter = this.owner;\n\n      const fillOpacity = shapePainter.getFillOpacity();\n      const outlineSize = shapePainter.getOutlineSize();\n\n      // It draws bands and small polygons.\n      // The coutline is in a second loop, it's more efficient\n      // than switching the style constently.\n\n      // fill\n      if (fillOpacity !== 0) {\n        shapePainter.setOutlineSize(0);\n        for (let squareY = minY; squareY < maxY - 1; squareY++) {\n          let first15SquareX = -1;\n          for (let squareX = minX; squareX < maxX - 1; squareX++) {\n            let squareIndex = this.getSquareIndex(squareX, squareY);\n            if (drawUnder) {\n              squareIndex = 15 - squareIndex;\n            }\n\n            if (first15SquareX === -1 && squareIndex === 15) {\n              first15SquareX = squareX;\n            }\n            if (first15SquareX !== -1) {\n              if (squareIndex !== 15) {\n                shapePainter.drawRectangle(\n                  this.convertFromGridBasisX(first15SquareX),\n                  this.convertFromGridBasisY(squareY),\n                  this.convertFromGridBasisX(squareX),\n                  this.convertFromGridBasisY(squareY + 1)\n                );\n                first15SquareX = -1;\n              }\n              else if (squareX === maxX - 2) {\n                shapePainter.drawRectangle(\n                  this.convertFromGridBasisX(first15SquareX),\n                  this.convertFromGridBasisY(squareY),\n                  this.convertFromGridBasisX(squareX + 1),\n                  this.convertFromGridBasisY(squareY + 1)\n                );\n                first15SquareX = -1;\n              }\n            }\n            if (squareIndex !== 0) {\n              let fillVertices = this.marchingSquaresFillVertices[squareIndex];\n              this.calcPoint(fillVertices[0], squareX, squareY, point);\n              shapePainter.beginFillPath(point[0], point[1]);\n              for (let index = 1; index < fillVertices.length; index++) {\n                this.calcPoint(fillVertices[index], squareX, squareY, point);\n                shapePainter.drawPathLineTo(point[0], point[1]);\n              }\n              shapePainter.closePath();\n              shapePainter.endFillPath();\n            }\n          }\n        }\n        shapePainter.setOutlineSize(outlineSize);\n      }\n      // outline\n      if (outlineSize !== 0) {\n        shapePainter.setFillOpacity(0);\n        for (let squareY = minY; squareY < maxY - 1; squareY++) {\n          for (let squareX = minX; squareX < maxX - 1; squareX++) {\n            let squareIndex = this.getSquareIndex(squareX, squareY);\n            if (drawUnder) {\n              squareIndex = 15 - squareIndex;\n            }\n\n            if (squareIndex !== 0 && squareIndex !== 15) {\n              for (let outlineVertices of this.marchingSquaresOutlineVertices[squareIndex]) {\n                this.calcPoint(outlineVertices[0], squareX, squareY, point);\n                shapePainter.beginFillPath(point[0], point[1]);\n                for (let index = 1; index < outlineVertices.length; index++) {\n                  this.calcPoint(outlineVertices[index], squareX, squareY, point);\n                  shapePainter.drawPathLineTo(point[0], point[1]);\n                }\n                shapePainter.endFillPath();\n              }\n            }\n          }\n        }\n        shapePainter.setFillOpacity(fillOpacity);\n      }\n    }\n\n    /**\n     * Update the field hitboxes\n     * @param minX {integer} left\n     * @param minY {integer} top\n     * @param maxX {integer} right\n     * @param maxY {integer} bottom\n     */\n    prototype.updateMarchingSquareHitboxes = function (\n      minX,\n      minY,\n      maxX,\n      maxY\n    ) {\n      /** @type {boolean} */\n      const drawUnder = this._getFillOutside();\n\n      /** @type {Array<number[]>} */\n      const fieldValues = this.scalarFieldValues;\n\n      const point = this.workingPoint;\n\n      /** @type {gdjs.ShapePainterRuntimeObject} */\n      const shapePainter = this.owner;\n\n      // Move all Polygons to recycledPolygons\n      if (this.recycledPolygons.length < shapePainter._defaultHitBoxes.length) {\n        const swapPolygons = this.recycledPolygons;\n        this.recycledPolygons = shapePainter._defaultHitBoxes;\n        shapePainter._defaultHitBoxes = swapPolygons;\n      }\n      const hitboxes = shapePainter._defaultHitBoxes;\n      this.recycledPolygons.push.apply(this, hitboxes);\n      hitboxes.length = 0;\n\n      for (let squareY = minY; squareY < maxY - 1; squareY++) {\n        for (let squareX = minX; squareX < maxX - 1; squareX++) {\n          let squareIndex = this.getSquareIndex(squareX, squareY);\n          if (squareIndex === 0 || squareIndex === 15) {\n            continue;\n          }\n          if (drawUnder) {\n            squareIndex = 15 - squareIndex;\n          }\n          let fillVertices = this.marchingSquaresFillVertices[squareIndex];\n          const polygon = this.recycledPolygons.length === 0 ? new gdjs.Polygon() : this.recycledPolygons.pop();\n          polygon.vertices.length = fillVertices.length;\n          for (let index = 0; index < fillVertices.length; index++) {\n            this.calcPoint(fillVertices[index], squareX, squareY, point);\n            polygon.vertices[index] = [point[0], point[1]];\n          }\n          hitboxes.push(polygon);\n        }\n      }\n      shapePainter.hitBoxes = hitboxes;\n      shapePainter.hitBoxesDirty = false;\n      shapePainter.aabb.min[0] = this._getAreaLeftBound();\n      shapePainter.aabb.min[1] = this._getAreaTopBound();\n      shapePainter.aabb.max[0] = shapePainter.aabb.min[0] + this.dimX() * this._getCellWidth();\n      shapePainter.aabb.max[1] = shapePainter.aabb.min[1] + this.dimY() * this._getCellHeight();\n\n      // Hack for the \"separate\" action that calculates a bounding disk with dimensions.\n      shapePainter.width = this.dimX() * this._getCellWidth();\n      shapePainter.height = this.dimY() * this._getCellHeight();\n      shapePainter.getWidth = function () {\n        return this.width;\n      }\n      shapePainter.getHeight = function () {\n        return this.height;\n      }\n    }\n  }\n}\n",
              "parameterObjects": "Object",
              "useStrict": true,
              "eventsSheetExpanded": true
            }
          ],
          "parameters": [
            {
              "codeOnly": false,
              "defaultValue": "",
              "description": "Object",
              "longDescription": "",
              "name": "Object",
              "optional": false,
              "supplementaryInformation": "PrimitiveDrawing::Drawer",
              "type": "object"
            },
            {
              "codeOnly": false,
              "defaultValue": "",
              "description": "Behavior",
              "longDescription": "",
              "name": "Behavior",
              "optional": false,
              "supplementaryInformation": "MarchingSquares::MarchingSquaresBehavior",
              "type": "behavior"
            }
          ],
          "objectGroups": []
        },
        {
          "description": "Clear the field.",
          "fullName": "Clear the field",
          "functionType": "Action",
          "name": "ClearField",
          "private": false,
          "sentence": "Clear the field of _PARAM0_",
          "events": [
            {
              "disabled": false,
              "folded": false,
              "type": "BuiltinCommonInstructions::JsCode",
              "inlineCode": "const game = runtimeScene.getGame();\nconst behaviorName = eventsFunctionContext.getBehaviorName(\"Behavior\");\nconst behavior = objects[0].getBehavior(behaviorName);\n\n/** @type {float} */\nconst left = behavior._getAreaLeftBound();\n/** @type {float} */\nconst top = behavior._getAreaTopBound();\n/** @type {float} */\nconst right = behavior._getAreaRightBound() || game.getGameResolutionWidth();\n/** @type {float} */\nconst bottom = behavior._getAreaBottomBound() || game.getGameResolutionHeight();\n/** @type {float} */\nconst cellWidth = behavior._getCellWidth();\n/** @type {float} */\nconst cellHeight = behavior._getCellHeight();\n\nconst dimX = 1 + Math.ceil((right - left) / cellWidth);\nconst dimY = 1 + Math.ceil((bottom - top) / cellHeight);\n\nconst oldDimX = behavior.dimX();\nconst oldDimY = behavior.dimY();\n\n/** @type {Array<number[]>} */\nconst fieldValues = behavior.scalarFieldValues;\n\n// Update the grid dimension if properties changed.\nif (dimY !== oldDimY) {\n    fieldValues.length = dimY;\n}\nfor (let y = oldDimY; y < dimY; y++) {\n    fieldValues[y] = new Array(dimX);\n}\nif (dimX !== behavior.dimX()) {\n    for (let rowValues of fieldValues) {\n        rowValues.length = dimX;\n    }\n}\n\n// Fill the grid with 0\nfor (let rowValues of fieldValues) {\n    for (let x = 0; x < rowValues.length; x++) {\n        rowValues[x] = 0;\n    }\n}",
              "parameterObjects": "Object",
              "useStrict": true,
              "eventsSheetExpanded": true
            }
          ],
          "parameters": [
            {
              "codeOnly": false,
              "defaultValue": "",
              "description": "Object",
              "longDescription": "",
              "name": "Object",
              "optional": false,
              "supplementaryInformation": "PrimitiveDrawing::Drawer",
              "type": "object"
            },
            {
              "codeOnly": false,
              "defaultValue": "",
              "description": "Behavior",
              "longDescription": "",
              "name": "Behavior",
              "optional": false,
              "supplementaryInformation": "MarchingSquares::MarchingSquaresBehavior",
              "type": "behavior"
            }
          ],
          "objectGroups": []
        },
        {
          "description": "Flood an area of the field from a given location.",
          "fullName": "Flood area",
          "functionType": "Action",
          "name": "FloodFrom",
          "private": false,
          "sentence": "Flood the field of _PARAM0_ from x: _PARAM2_, y: _PARAM3_, to a maximum of _PARAM4_",
          "events": [
            {
              "disabled": false,
              "folded": false,
              "type": "BuiltinCommonInstructions::JsCode",
              "inlineCode": "\nconst behaviorName = eventsFunctionContext.getBehaviorName(\"Behavior\");\n\nconst originX = eventsFunctionContext.getArgument(\"OriginX\");\nconst originY = eventsFunctionContext.getArgument(\"OriginY\");\nconst maximum = eventsFunctionContext.getArgument(\"Maximum\");\n\nconst behavior = objects[0].getBehavior(behaviorName);\n\nbehavior.floodFrom(originX, originY, maximum);",
              "parameterObjects": "Object",
              "useStrict": true,
              "eventsSheetExpanded": true
            }
          ],
          "parameters": [
            {
              "codeOnly": false,
              "defaultValue": "",
              "description": "Object",
              "longDescription": "",
              "name": "Object",
              "optional": false,
              "supplementaryInformation": "PrimitiveDrawing::Drawer",
              "type": "object"
            },
            {
              "codeOnly": false,
              "defaultValue": "",
              "description": "Behavior",
              "longDescription": "",
              "name": "Behavior",
              "optional": false,
              "supplementaryInformation": "MarchingSquares::MarchingSquaresBehavior",
              "type": "behavior"
            },
            {
              "codeOnly": false,
              "defaultValue": "",
              "description": "Origin X",
              "longDescription": "",
              "name": "OriginX",
              "optional": false,
              "supplementaryInformation": "",
              "type": "expression"
            },
            {
              "codeOnly": false,
              "defaultValue": "",
              "description": "Origin Y",
              "longDescription": "",
              "name": "OriginY",
              "optional": false,
              "supplementaryInformation": "",
              "type": "expression"
            },
            {
              "codeOnly": false,
              "defaultValue": "",
              "description": "Maximum",
              "longDescription": "",
              "name": "Maximum",
              "optional": false,
              "supplementaryInformation": "",
              "type": "expression"
            }
          ],
          "objectGroups": []
        },
        {
          "description": "Apply an affine on the the field values.",
          "fullName": "Transform the field",
          "functionType": "Action",
          "name": "TransformField",
          "private": false,
          "sentence": "Transform the field of _PARAM0_ with a coefficient: _PARAM2_ and an offset: _PARAM3_",
          "events": [
            {
              "disabled": false,
              "folded": false,
              "type": "BuiltinCommonInstructions::JsCode",
              "inlineCode": "const behaviorName = eventsFunctionContext.getBehaviorName(\"Behavior\");\n\nconst a = eventsFunctionContext.getArgument(\"Coefficient\");\nconst b = eventsFunctionContext.getArgument(\"Offset\");\n\nconst behavior = objects[0].getBehavior(behaviorName);\n\n/** @type {Array<number[]>} */\nconst fieldValues = behavior.scalarFieldValues;\n\nfor (let rowValues of fieldValues) {\n    for (let x = 0; x < rowValues.length; x++) {\n        rowValues[x] = a * rowValues[x] + b;\n    }\n}",
              "parameterObjects": "Object",
              "useStrict": true,
              "eventsSheetExpanded": true
            }
          ],
          "parameters": [
            {
              "codeOnly": false,
              "defaultValue": "",
              "description": "Object",
              "longDescription": "",
              "name": "Object",
              "optional": false,
              "supplementaryInformation": "PrimitiveDrawing::Drawer",
              "type": "object"
            },
            {
              "codeOnly": false,
              "defaultValue": "",
              "description": "Behavior",
              "longDescription": "",
              "name": "Behavior",
              "optional": false,
              "supplementaryInformation": "MarchingSquares::MarchingSquaresBehavior",
              "type": "behavior"
            },
            {
              "codeOnly": false,
              "defaultValue": "",
              "description": "Coefficient",
              "longDescription": "",
              "name": "Coefficient",
              "optional": false,
              "supplementaryInformation": "",
              "type": "expression"
            },
            {
              "codeOnly": false,
              "defaultValue": "",
              "description": "Offset",
              "longDescription": "",
              "name": "Offset",
              "optional": false,
              "supplementaryInformation": "",
              "type": "expression"
            }
          ],
          "objectGroups": []
        },
        {
          "description": "Mask a disk to the field.",
          "fullName": "Mask a disk",
          "functionType": "Action",
          "name": "MaskDisk",
          "private": false,
          "sentence": "Mask a disk on the field of _PARAM0_ with center: _PARAM2_, _PARAM3_, radius: _PARAM4_",
          "events": [
            {
              "disabled": false,
              "folded": false,
              "type": "BuiltinCommonInstructions::JsCode",
              "inlineCode": "\nconst behaviorName = eventsFunctionContext.getBehaviorName(\"Behavior\");\n\nconst centerX = eventsFunctionContext.getArgument(\"CenterX\");\nconst centerY = eventsFunctionContext.getArgument(\"CenterY\");\nconst radius = eventsFunctionContext.getArgument(\"Radius\");\nconst cappingRadiusRatio = eventsFunctionContext.getArgument(\"CappingRadiusRatio\");\nconst cappingRadius = cappingRadiusRatio * radius;\n\nconst behavior = objects[0].getBehavior(behaviorName);\n\nbehavior.mergeDisk(centerX, centerY, radius, cappingRadiusRatio, (fieldValue, value) => Math.min(fieldValue, 1 / value));",
              "parameterObjects": "Object",
              "useStrict": true,
              "eventsSheetExpanded": true
            }
          ],
          "parameters": [
            {
              "codeOnly": false,
              "defaultValue": "",
              "description": "Object",
              "longDescription": "",
              "name": "Object",
              "optional": false,
              "supplementaryInformation": "PrimitiveDrawing::Drawer",
              "type": "object"
            },
            {
              "codeOnly": false,
              "defaultValue": "",
              "description": "Behavior",
              "longDescription": "",
              "name": "Behavior",
              "optional": false,
              "supplementaryInformation": "MarchingSquares::MarchingSquaresBehavior",
              "type": "behavior"
            },
            {
              "codeOnly": false,
              "defaultValue": "",
              "description": "Center X",
              "longDescription": "",
              "name": "CenterX",
              "optional": false,
              "supplementaryInformation": "",
              "type": "expression"
            },
            {
              "codeOnly": false,
              "defaultValue": "",
              "description": "Center Y",
              "longDescription": "",
              "name": "CenterY",
              "optional": false,
              "supplementaryInformation": "",
              "type": "expression"
            },
            {
              "codeOnly": false,
              "defaultValue": "",
              "description": "Radius",
              "longDescription": "",
              "name": "Radius",
              "optional": false,
              "supplementaryInformation": "",
              "type": "expression"
            },
            {
              "codeOnly": false,
              "defaultValue": "",
              "description": "Capping radius ratio",
              "longDescription": "",
              "name": "CappingRadiusRatio",
              "optional": false,
              "supplementaryInformation": "",
              "type": "expression"
            }
          ],
          "objectGroups": []
        },
        {
          "description": "Add a disk to the field.",
          "fullName": "Add a disk",
          "functionType": "Action",
          "name": "AddDisk",
          "private": false,
          "sentence": "Add a disk to the field of _PARAM0_ with center: _PARAM2_, _PARAM3_, radius: _PARAM4_ using: _PARAM6_",
          "events": [
            {
              "disabled": false,
              "folded": false,
              "type": "BuiltinCommonInstructions::JsCode",
              "inlineCode": "\nconst behaviorName = eventsFunctionContext.getBehaviorName(\"Behavior\");\n\nconst centerX = eventsFunctionContext.getArgument(\"CenterX\");\nconst centerY = eventsFunctionContext.getArgument(\"CenterY\");\nconst radius = eventsFunctionContext.getArgument(\"Radius\");\nconst cappingRadiusRatio = eventsFunctionContext.getArgument(\"CappingRadiusRatio\");\nconst operation = gdjs.__marchingSquares.parseOperation(eventsFunctionContext.getArgument(\"Operation\"));\n\nconst behavior = objects[0].getBehavior(behaviorName);\n\nbehavior.mergeDisk(centerX, centerY, radius, cappingRadiusRatio, operation);",
              "parameterObjects": "Object",
              "useStrict": true,
              "eventsSheetExpanded": true
            }
          ],
          "parameters": [
            {
              "codeOnly": false,
              "defaultValue": "",
              "description": "Object",
              "longDescription": "",
              "name": "Object",
              "optional": false,
              "supplementaryInformation": "PrimitiveDrawing::Drawer",
              "type": "object"
            },
            {
              "codeOnly": false,
              "defaultValue": "",
              "description": "Behavior",
              "longDescription": "",
              "name": "Behavior",
              "optional": false,
              "supplementaryInformation": "MarchingSquares::MarchingSquaresBehavior",
              "type": "behavior"
            },
            {
              "codeOnly": false,
              "defaultValue": "",
              "description": "Center X",
              "longDescription": "",
              "name": "CenterX",
              "optional": false,
              "supplementaryInformation": "",
              "type": "expression"
            },
            {
              "codeOnly": false,
              "defaultValue": "",
              "description": "Center Y",
              "longDescription": "",
              "name": "CenterY",
              "optional": false,
              "supplementaryInformation": "",
              "type": "expression"
            },
            {
              "codeOnly": false,
              "defaultValue": "",
              "description": "Radius",
              "longDescription": "",
              "name": "Radius",
              "optional": false,
              "supplementaryInformation": "",
              "type": "expression"
            },
            {
              "codeOnly": false,
              "defaultValue": "",
              "description": "Capping radius ratio",
              "longDescription": "",
              "name": "CappingRadiusRatio",
              "optional": false,
              "supplementaryInformation": "",
              "type": "expression"
            },
            {
              "codeOnly": false,
              "defaultValue": "",
              "description": "Operation",
              "longDescription": "",
              "name": "Operation",
              "optional": false,
              "supplementaryInformation": "[\"Maximum\",\"Addition\",\"Subtraction\"]",
              "type": "stringWithSelector"
            }
          ],
          "objectGroups": []
        },
        {
          "description": "Mask a line to the field.",
          "fullName": "Mask a line",
          "functionType": "Action",
          "name": "MaskLine",
          "private": false,
          "sentence": "Mask a line on the field of _PARAM0_ fom _PARAM2_ ; _PARAM3_ to _PARAM4_ ; _PARAM5_ with trickness: _PARAM6_",
          "events": [
            {
              "disabled": false,
              "folded": false,
              "type": "BuiltinCommonInstructions::JsCode",
              "inlineCode": "\nconst behaviorName = eventsFunctionContext.getBehaviorName(\"Behavior\");\n\nconst startX = eventsFunctionContext.getArgument(\"StartX\");\nconst startY = eventsFunctionContext.getArgument(\"StartY\");\nconst endX = eventsFunctionContext.getArgument(\"EndX\");\nconst endY = eventsFunctionContext.getArgument(\"EndY\");\nconst trickness = eventsFunctionContext.getArgument(\"Trickness\");\nconst cappingRadiusRatio = eventsFunctionContext.getArgument(\"CappingRadiusRatio\");\n\nconst behavior = objects[0].getBehavior(behaviorName);\n\nbehavior.mergeSegment(startX, startY, endX, endY, trickness, cappingRadiusRatio, (fieldValue, value) => Math.min(fieldValue, 1 / value));",
              "parameterObjects": "Object",
              "useStrict": true,
              "eventsSheetExpanded": true
            }
          ],
          "parameters": [
            {
              "codeOnly": false,
              "defaultValue": "",
              "description": "Object",
              "longDescription": "",
              "name": "Object",
              "optional": false,
              "supplementaryInformation": "PrimitiveDrawing::Drawer",
              "type": "object"
            },
            {
              "codeOnly": false,
              "defaultValue": "",
              "description": "Behavior",
              "longDescription": "",
              "name": "Behavior",
              "optional": false,
              "supplementaryInformation": "MarchingSquares::MarchingSquaresBehavior",
              "type": "behavior"
            },
            {
              "codeOnly": false,
              "defaultValue": "",
              "description": "X position of the start",
              "longDescription": "",
              "name": "StartX",
              "optional": false,
              "supplementaryInformation": "",
              "type": "expression"
            },
            {
              "codeOnly": false,
              "defaultValue": "",
              "description": "Y position of the start",
              "longDescription": "",
              "name": "StartY",
              "optional": false,
              "supplementaryInformation": "",
              "type": "expression"
            },
            {
              "codeOnly": false,
              "defaultValue": "",
              "description": "X position of the end",
              "longDescription": "",
              "name": "EndX",
              "optional": false,
              "supplementaryInformation": "",
              "type": "expression"
            },
            {
              "codeOnly": false,
              "defaultValue": "",
              "description": "Y position of the end",
              "longDescription": "",
              "name": "EndY",
              "optional": false,
              "supplementaryInformation": "",
              "type": "expression"
            },
            {
              "codeOnly": false,
              "defaultValue": "",
              "description": "Trickness",
              "longDescription": "",
              "name": "Trickness",
              "optional": false,
              "supplementaryInformation": "",
              "type": "expression"
            },
            {
              "codeOnly": false,
              "defaultValue": "",
              "description": "Capping radius ratio",
              "longDescription": "",
              "name": "CappingRadiusRatio",
              "optional": false,
              "supplementaryInformation": "",
              "type": "expression"
            }
          ],
          "objectGroups": []
        },
        {
          "description": "Add a line to the field.",
          "fullName": "Add a line",
          "functionType": "Action",
          "name": "AddLine",
          "private": false,
          "sentence": "Add a line to the field of _PARAM0_ fom _PARAM2_ ; _PARAM3_ to _PARAM4_ ; _PARAM5_ with trickness: _PARAM6_ using: _PARAM8_",
          "events": [
            {
              "disabled": false,
              "folded": false,
              "type": "BuiltinCommonInstructions::JsCode",
              "inlineCode": "\nconst behaviorName = eventsFunctionContext.getBehaviorName(\"Behavior\");\n\nconst startX = eventsFunctionContext.getArgument(\"StartX\");\nconst startY = eventsFunctionContext.getArgument(\"StartY\");\nconst endX = eventsFunctionContext.getArgument(\"EndX\");\nconst endY = eventsFunctionContext.getArgument(\"EndY\");\nconst trickness = eventsFunctionContext.getArgument(\"Trickness\");\nconst cappingRadiusRatio = eventsFunctionContext.getArgument(\"CappingRadiusRatio\");\nconst operation = gdjs.__marchingSquares.parseOperation(eventsFunctionContext.getArgument(\"Operation\"));\n\nconst behavior = objects[0].getBehavior(behaviorName);\n\nbehavior.mergeSegment(startX, startY, endX, endY, trickness, cappingRadiusRatio, operation);",
              "parameterObjects": "Object",
              "useStrict": true,
              "eventsSheetExpanded": true
            }
          ],
          "parameters": [
            {
              "codeOnly": false,
              "defaultValue": "",
              "description": "Object",
              "longDescription": "",
              "name": "Object",
              "optional": false,
              "supplementaryInformation": "PrimitiveDrawing::Drawer",
              "type": "object"
            },
            {
              "codeOnly": false,
              "defaultValue": "",
              "description": "Behavior",
              "longDescription": "",
              "name": "Behavior",
              "optional": false,
              "supplementaryInformation": "MarchingSquares::MarchingSquaresBehavior",
              "type": "behavior"
            },
            {
              "codeOnly": false,
              "defaultValue": "",
              "description": "X position of the start",
              "longDescription": "",
              "name": "StartX",
              "optional": false,
              "supplementaryInformation": "",
              "type": "expression"
            },
            {
              "codeOnly": false,
              "defaultValue": "",
              "description": "Y position of the start",
              "longDescription": "",
              "name": "StartY",
              "optional": false,
              "supplementaryInformation": "",
              "type": "expression"
            },
            {
              "codeOnly": false,
              "defaultValue": "",
              "description": "X position of the end",
              "longDescription": "",
              "name": "EndX",
              "optional": false,
              "supplementaryInformation": "",
              "type": "expression"
            },
            {
              "codeOnly": false,
              "defaultValue": "",
              "description": "Y position of the end",
              "longDescription": "",
              "name": "EndY",
              "optional": false,
              "supplementaryInformation": "",
              "type": "expression"
            },
            {
              "codeOnly": false,
              "defaultValue": "",
              "description": "Trickness",
              "longDescription": "",
              "name": "Trickness",
              "optional": false,
              "supplementaryInformation": "",
              "type": "expression"
            },
            {
              "codeOnly": false,
              "defaultValue": "",
              "description": "Capping radius ratio",
              "longDescription": "",
              "name": "CappingRadiusRatio",
              "optional": false,
              "supplementaryInformation": "",
              "type": "expression"
            },
            {
              "codeOnly": false,
              "defaultValue": "",
              "description": "Operation",
              "longDescription": "",
              "name": "Operation",
              "optional": false,
              "supplementaryInformation": "[\"Maximum\",\"Addition\",\"Subtraction\"]",
              "type": "stringWithSelector"
            }
          ],
          "objectGroups": []
        },
        {
          "description": "Merge with another field.",
          "fullName": "Merge a field",
          "functionType": "Action",
          "name": "MergeField",
          "private": false,
          "sentence": "Merge _PARAM0_ with the field of _PARAM2_ using: _PARAM4_",
          "events": [
            {
              "disabled": false,
              "folded": false,
              "type": "BuiltinCommonInstructions::JsCode",
              "inlineCode": "\nconst behaviorName = eventsFunctionContext.getBehaviorName(\"Behavior\");\n\nconst fieldObjects = eventsFunctionContext.getObjects(\"FieldObject\");\nconst fieldBehaviorName = eventsFunctionContext.getArgument(\"FieldBehavior\");\nconst operation = gdjs.__marchingSquares.parseOperation(eventsFunctionContext.getArgument(\"Operation\"));\n\nconst behavior = objects[0].getBehavior(behaviorName);\n\n/** @type {Array<number[]>} */\nconst fieldValues = behavior.scalarFieldValues;\n\nfor (const fieldObject of fieldObjects) {\n    const otherBehavior = fieldObject.getBehavior(behaviorName);\n    if (!otherBehavior) {\n        continue;\n    }\n    const otherFieldValues = otherBehavior.scalarFieldValues;\n\n    for (let y = 0; y < fieldValues.length; y++) {\n        const thisRowValues = fieldValues[y];\n        const otherRowValues = otherFieldValues[y];\n        for (let x = 0; x < thisRowValues.length; x++) {\n            thisRowValues[x] = operation(thisRowValues[x], otherRowValues[x]);\n        }\n    }\n}",
              "parameterObjects": "Object",
              "useStrict": true,
              "eventsSheetExpanded": true
            }
          ],
          "parameters": [
            {
              "codeOnly": false,
              "defaultValue": "",
              "description": "Object",
              "longDescription": "",
              "name": "Object",
              "optional": false,
              "supplementaryInformation": "PrimitiveDrawing::Drawer",
              "type": "object"
            },
            {
              "codeOnly": false,
              "defaultValue": "",
              "description": "Behavior",
              "longDescription": "",
              "name": "Behavior",
              "optional": false,
              "supplementaryInformation": "MarchingSquares::MarchingSquaresBehavior",
              "type": "behavior"
            },
            {
              "codeOnly": false,
              "defaultValue": "",
              "description": "Field object",
              "longDescription": "",
              "name": "FieldObject",
              "optional": false,
              "supplementaryInformation": "",
              "type": "objectList"
            },
            {
              "codeOnly": false,
              "defaultValue": "",
              "description": "Field behavior",
              "longDescription": "",
              "name": "FieldBehavior",
              "optional": false,
              "supplementaryInformation": "MarchingSquares::MarchingSquaresBehavior",
              "type": "behavior"
            },
            {
              "codeOnly": false,
              "defaultValue": "",
              "description": "Operation",
              "longDescription": "",
              "name": "Operation",
              "optional": false,
              "supplementaryInformation": "[\"Maximum\",\"Addition\",\"Subtraction\",\"Minimum\"]",
              "type": "stringWithSelector"
            }
          ],
          "objectGroups": []
        },
        {
          "description": "Update the field hitboxes.",
          "fullName": "Update hitboxes",
          "functionType": "Action",
          "name": "UpdateHitboxes",
          "private": false,
          "sentence": "Update the field hitboxes of _PARAM0_",
          "events": [
            {
              "disabled": false,
              "folded": false,
              "type": "BuiltinCommonInstructions::JsCode",
              "inlineCode": "\nconst behaviorName = eventsFunctionContext.getBehaviorName(\"Behavior\");\n\nconst behavior = objects[0].getBehavior(behaviorName);\n\nbehavior.updateMarchingSquareHitboxes(0, 0, behavior.dimX(), behavior.dimY());",
              "parameterObjects": "Object",
              "useStrict": true,
              "eventsSheetExpanded": true
            }
          ],
          "parameters": [
            {
              "codeOnly": false,
              "defaultValue": "",
              "description": "Object",
              "longDescription": "",
              "name": "Object",
              "optional": false,
              "supplementaryInformation": "PrimitiveDrawing::Drawer",
              "type": "object"
            },
            {
              "codeOnly": false,
              "defaultValue": "",
              "description": "Behavior",
              "longDescription": "",
              "name": "Behavior",
              "optional": false,
              "supplementaryInformation": "MarchingSquares::MarchingSquaresBehavior",
              "type": "behavior"
            }
          ],
          "objectGroups": []
        },
        {
          "description": "Draw the field contours.",
          "fullName": "Draw the contours",
          "functionType": "Action",
          "name": "DrawField",
          "private": false,
          "sentence": "Draw the field contours of _PARAM0_",
          "events": [
            {
              "disabled": false,
              "folded": false,
              "type": "BuiltinCommonInstructions::JsCode",
              "inlineCode": "\nconst screenWidth = runtimeScene.getGame().getGameResolutionWidth();\nconst screenHeight = runtimeScene.getGame().getGameResolutionWidth();\n\nconst behaviorName = eventsFunctionContext.getBehaviorName(\"Behavior\");\n\nconst object = objects[0];\nconst behavior = object.getBehavior(behaviorName);\n\nif (behavior._behaviorData.MustOnlyDrawScreen) {\n    const layer = runtimeScene.getLayer(object.getLayer());\n    const screen1 = layer.convertCoords(0, 0);\n    const screen2 = layer.convertCoords(screenWidth, 0);\n    const screen3 = layer.convertCoords(0, screenHeight);\n    const screen4 = layer.convertCoords(screenWidth, screenHeight);\n\n    const screenLeft = Math.min(screen1[0], screen2[0], screen3[0], screen4[0]);\n    const screenTop = Math.min(screen1[1], screen2[1], screen3[1], screen4[1]);\n    const screenRight = Math.max(screen1[0], screen2[0], screen3[0], screen4[0]);\n    const screenBottom = Math.max(screen1[1], screen2[1], screen3[1], screen4[1]);\n\n    const minX = Math.max(0, Math.floor(behavior.convertToGridBasisX(screenLeft)));\n    const minY = Math.max(0, Math.floor(behavior.convertToGridBasisY(screenTop)));\n    // I don't know why the + 1 is needed\n    const maxX = Math.min(behavior.dimX(), 1 + Math.ceil(behavior.convertToGridBasisX(screenRight)));\n    const maxY = Math.min(behavior.dimY(), Math.ceil(behavior.convertToGridBasisY(screenBottom)));\n\n    behavior.drawField(minX, minY, maxX, maxY);\n}\nelse {\n    // This is useful for static content or games without scrolling.\n    behavior.drawField(0, 0, behavior.dimX(), behavior.dimY());\n}",
              "parameterObjects": "Object",
              "useStrict": true,
              "eventsSheetExpanded": true
            }
          ],
          "parameters": [
            {
              "codeOnly": false,
              "defaultValue": "",
              "description": "Object",
              "longDescription": "",
              "name": "Object",
              "optional": false,
              "supplementaryInformation": "PrimitiveDrawing::Drawer",
              "type": "object"
            },
            {
              "codeOnly": false,
              "defaultValue": "",
              "description": "Behavior",
              "longDescription": "",
              "name": "Behavior",
              "optional": false,
              "supplementaryInformation": "MarchingSquares::MarchingSquaresBehavior",
              "type": "behavior"
            }
          ],
          "objectGroups": []
        },
        {
          "description": "Change the width of the field cells.",
          "fullName": "Width of the cells",
          "functionType": "Action",
          "name": "SetCellWidth",
          "private": false,
          "sentence": "Change the width of the field cells of _PARAM0_: _PARAM2_",
          "events": [
            {
              "disabled": false,
              "folded": false,
              "type": "BuiltinCommonInstructions::Standard",
              "conditions": [],
              "actions": [
                {
                  "type": {
                    "inverted": false,
                    "value": "MarchingSquares::MarchingSquaresBehavior::SetPropertyCellWidth"
                  },
                  "parameters": [
                    "Object",
                    "Behavior",
                    "=",
                    "GetArgumentAsNumber(\"CellWidth\")"
                  ],
                  "subInstructions": []
                }
              ],
              "events": []
            }
          ],
          "parameters": [
            {
              "codeOnly": false,
              "defaultValue": "",
              "description": "Object",
              "longDescription": "",
              "name": "Object",
              "optional": false,
              "supplementaryInformation": "PrimitiveDrawing::Drawer",
              "type": "object"
            },
            {
              "codeOnly": false,
              "defaultValue": "",
              "description": "Behavior",
              "longDescription": "",
              "name": "Behavior",
              "optional": false,
              "supplementaryInformation": "MarchingSquares::MarchingSquaresBehavior",
              "type": "behavior"
            },
            {
              "codeOnly": false,
              "defaultValue": "",
              "description": "Value",
              "longDescription": "",
              "name": "CellWidth",
              "optional": false,
              "supplementaryInformation": "",
              "type": "expression"
            }
          ],
          "objectGroups": []
        },
        {
          "description": "Change the height of the field cells.",
          "fullName": "Height of the cells",
          "functionType": "Action",
          "name": "SetCellHeight",
          "private": false,
          "sentence": "Change the height of the field cells of _PARAM0_: _PARAM2_",
          "events": [
            {
              "disabled": false,
              "folded": false,
              "type": "BuiltinCommonInstructions::Standard",
              "conditions": [],
              "actions": [
                {
                  "type": {
                    "inverted": false,
                    "value": "MarchingSquares::MarchingSquaresBehavior::SetPropertyCellHeight"
                  },
                  "parameters": [
                    "Object",
                    "Behavior",
                    "=",
                    "GetArgumentAsNumber(\"CellHeight\")"
                  ],
                  "subInstructions": []
                }
              ],
              "events": []
            }
          ],
          "parameters": [
            {
              "codeOnly": false,
              "defaultValue": "",
              "description": "Object",
              "longDescription": "",
              "name": "Object",
              "optional": false,
              "supplementaryInformation": "PrimitiveDrawing::Drawer",
              "type": "object"
            },
            {
              "codeOnly": false,
              "defaultValue": "",
              "description": "Behavior",
              "longDescription": "",
              "name": "Behavior",
              "optional": false,
              "supplementaryInformation": "MarchingSquares::MarchingSquaresBehavior",
              "type": "behavior"
            },
            {
              "codeOnly": false,
              "defaultValue": "",
              "description": "Value",
              "longDescription": "",
              "name": "CellHeight",
              "optional": false,
              "supplementaryInformation": "",
              "type": "expression"
            }
          ],
          "objectGroups": []
        },
        {
          "description": "Fill outside or inside of the contours.",
          "fullName": "Fill outside",
          "functionType": "Action",
          "name": "SetFillOutside",
          "private": false,
          "sentence": "Fill outside of the contours of _PARAM0_: _PARAM2_",
          "events": [
            {
              "disabled": false,
              "folded": false,
              "type": "BuiltinCommonInstructions::Standard",
              "conditions": [],
              "actions": [
                {
                  "type": {
                    "inverted": false,
                    "value": "MarchingSquares::MarchingSquaresBehavior::SetPropertyFillOutside"
                  },
                  "parameters": [
                    "Object",
                    "Behavior",
                    "="
                  ],
                  "subInstructions": []
                }
              ],
              "events": []
            },
            {
              "disabled": false,
              "folded": false,
              "type": "BuiltinCommonInstructions::Standard",
              "conditions": [
                {
                  "type": {
                    "inverted": false,
                    "value": "GetArgumentAsBoolean"
                  },
                  "parameters": [
                    "\"FillOutside\""
                  ],
                  "subInstructions": []
                }
              ],
              "actions": [
                {
                  "type": {
                    "inverted": false,
                    "value": "MarchingSquares::MarchingSquaresBehavior::SetPropertyFillOutside"
                  },
                  "parameters": [
                    "Object",
                    "Behavior",
                    "yes"
                  ],
                  "subInstructions": []
                }
              ],
              "events": []
            }
          ],
          "parameters": [
            {
              "codeOnly": false,
              "defaultValue": "",
              "description": "Object",
              "longDescription": "",
              "name": "Object",
              "optional": false,
              "supplementaryInformation": "PrimitiveDrawing::Drawer",
              "type": "object"
            },
            {
              "codeOnly": false,
              "defaultValue": "",
              "description": "Behavior",
              "longDescription": "",
              "name": "Behavior",
              "optional": false,
              "supplementaryInformation": "MarchingSquares::MarchingSquaresBehavior",
              "type": "behavior"
            },
            {
              "codeOnly": false,
              "defaultValue": "",
              "description": "Fill outside?",
              "longDescription": "",
              "name": "FillOutside",
              "optional": false,
              "supplementaryInformation": "",
              "type": "yesorno"
            }
          ],
          "objectGroups": []
        },
        {
          "description": "Change the contour threshold.",
          "fullName": "Contour threshold",
          "functionType": "Action",
          "name": "SetThreshold",
          "private": false,
          "sentence": "Change the contour threshold of _PARAM0_: _PARAM2_",
          "events": [
            {
              "disabled": false,
              "folded": false,
              "type": "BuiltinCommonInstructions::Standard",
              "conditions": [],
              "actions": [
                {
                  "type": {
                    "inverted": false,
                    "value": "MarchingSquares::MarchingSquaresBehavior::SetPropertyThreshold"
                  },
                  "parameters": [
                    "Object",
                    "Behavior",
                    "=",
                    "GetArgumentAsNumber(\"Threshold\")"
                  ],
                  "subInstructions": []
                }
              ],
              "events": []
            }
          ],
          "parameters": [
            {
              "codeOnly": false,
              "defaultValue": "",
              "description": "Object",
              "longDescription": "",
              "name": "Object",
              "optional": false,
              "supplementaryInformation": "PrimitiveDrawing::Drawer",
              "type": "object"
            },
            {
              "codeOnly": false,
              "defaultValue": "",
              "description": "Behavior",
              "longDescription": "",
              "name": "Behavior",
              "optional": false,
              "supplementaryInformation": "MarchingSquares::MarchingSquaresBehavior",
              "type": "behavior"
            },
            {
              "codeOnly": false,
              "defaultValue": "",
              "description": "Value",
              "longDescription": "",
              "name": "Threshold",
              "optional": false,
              "supplementaryInformation": "",
              "type": "expression"
            }
          ],
          "objectGroups": []
        },
        {
          "description": "Change the field area bounds.",
          "fullName": "Area bounds",
          "functionType": "Action",
          "name": "SetAreaBounds",
          "private": false,
          "sentence": "Change the field area bounds of _PARAM0_ left: _PARAM2_ top: _PARAM3_ right: _PARAM4_ bottom: _PARAM5_",
          "events": [
            {
              "disabled": false,
              "folded": false,
              "type": "BuiltinCommonInstructions::Standard",
              "conditions": [],
              "actions": [
                {
                  "type": {
                    "inverted": false,
                    "value": "MarchingSquares::MarchingSquaresBehavior::SetPropertyAreaLeftBound"
                  },
                  "parameters": [
                    "Object",
                    "Behavior",
                    "=",
                    "GetArgumentAsNumber(\"LeftBound\")"
                  ],
                  "subInstructions": []
                },
                {
                  "type": {
                    "inverted": false,
                    "value": "MarchingSquares::MarchingSquaresBehavior::SetPropertyAreaLeftBound"
                  },
                  "parameters": [
                    "Object",
                    "Behavior",
                    "=",
                    "GetArgumentAsNumber(\"TopBound\")"
                  ],
                  "subInstructions": []
                },
                {
                  "type": {
                    "inverted": false,
                    "value": "MarchingSquares::MarchingSquaresBehavior::SetPropertyAreaLeftBound"
                  },
                  "parameters": [
                    "Object",
                    "Behavior",
                    "=",
                    "GetArgumentAsNumber(\"RightBound\")"
                  ],
                  "subInstructions": []
                },
                {
                  "type": {
                    "inverted": false,
                    "value": "MarchingSquares::MarchingSquaresBehavior::SetPropertyAreaLeftBound"
                  },
                  "parameters": [
                    "Object",
                    "Behavior",
                    "=",
                    "GetArgumentAsNumber(\"BottomBound\")"
                  ],
                  "subInstructions": []
                }
              ],
              "events": []
            }
          ],
          "parameters": [
            {
              "codeOnly": false,
              "defaultValue": "",
              "description": "Object",
              "longDescription": "",
              "name": "Object",
              "optional": false,
              "supplementaryInformation": "PrimitiveDrawing::Drawer",
              "type": "object"
            },
            {
              "codeOnly": false,
              "defaultValue": "",
              "description": "Behavior",
              "longDescription": "",
              "name": "Behavior",
              "optional": false,
              "supplementaryInformation": "MarchingSquares::MarchingSquaresBehavior",
              "type": "behavior"
            },
            {
              "codeOnly": false,
              "defaultValue": "",
              "description": "Left bound",
              "longDescription": "",
              "name": "LeftBound",
              "optional": false,
              "supplementaryInformation": "",
              "type": "expression"
            },
            {
              "codeOnly": false,
              "defaultValue": "",
              "description": "Top bound",
              "longDescription": "",
              "name": "TopBound",
              "optional": false,
              "supplementaryInformation": "",
              "type": "expression"
            },
            {
              "codeOnly": false,
              "defaultValue": "",
              "description": "Right bound",
              "longDescription": "",
              "name": "RightBound",
              "optional": false,
              "supplementaryInformation": "",
              "type": "expression"
            },
            {
              "codeOnly": false,
              "defaultValue": "",
              "description": "Bottom bound",
              "longDescription": "",
              "name": "BottomBound",
              "optional": false,
              "supplementaryInformation": "",
              "type": "expression"
            }
          ],
          "objectGroups": []
        },
        {
          "description": "Width of the field cells.",
          "fullName": "Width of a cell",
          "functionType": "Expression",
          "name": "CellWidth",
          "private": false,
          "sentence": "",
          "events": [
            {
              "disabled": false,
              "folded": false,
              "type": "BuiltinCommonInstructions::Standard",
              "conditions": [],
              "actions": [
                {
                  "type": {
                    "inverted": false,
                    "value": "SetReturnNumber"
                  },
                  "parameters": [
                    "Object.Behavior::PropertyCellWidth()"
                  ],
                  "subInstructions": []
                }
              ],
              "events": []
            }
          ],
          "parameters": [
            {
              "codeOnly": false,
              "defaultValue": "",
              "description": "Object",
              "longDescription": "",
              "name": "Object",
              "optional": false,
              "supplementaryInformation": "PrimitiveDrawing::Drawer",
              "type": "object"
            },
            {
              "codeOnly": false,
              "defaultValue": "",
              "description": "Behavior",
              "longDescription": "",
              "name": "Behavior",
              "optional": false,
              "supplementaryInformation": "MarchingSquares::MarchingSquaresBehavior",
              "type": "behavior"
            }
          ],
          "objectGroups": []
        },
        {
          "description": "Height of the field cells.",
          "fullName": "Height of a cell",
          "functionType": "Expression",
          "name": "CellHeight",
          "private": false,
          "sentence": "",
          "events": [
            {
              "disabled": false,
              "folded": false,
              "type": "BuiltinCommonInstructions::Standard",
              "conditions": [],
              "actions": [
                {
                  "type": {
                    "inverted": false,
                    "value": "SetReturnNumber"
                  },
                  "parameters": [
                    "Object.Behavior::PropertyCellHeight()"
                  ],
                  "subInstructions": []
                }
              ],
              "events": []
            }
          ],
          "parameters": [
            {
              "codeOnly": false,
              "defaultValue": "",
              "description": "Object",
              "longDescription": "",
              "name": "Object",
              "optional": false,
              "supplementaryInformation": "PrimitiveDrawing::Drawer",
              "type": "object"
            },
            {
              "codeOnly": false,
              "defaultValue": "",
              "description": "Behavior",
              "longDescription": "",
              "name": "Behavior",
              "optional": false,
              "supplementaryInformation": "MarchingSquares::MarchingSquaresBehavior",
              "type": "behavior"
            }
          ],
          "objectGroups": []
        },
        {
          "description": "The contour threshold.",
          "fullName": "Contour threshold",
          "functionType": "Expression",
          "name": "ContourThreshold",
          "private": false,
          "sentence": "",
          "events": [
            {
              "disabled": false,
              "folded": false,
              "type": "BuiltinCommonInstructions::Standard",
              "conditions": [],
              "actions": [
                {
                  "type": {
                    "inverted": false,
                    "value": "SetReturnNumber"
                  },
                  "parameters": [
                    "Object.Behavior::PropertyThreshold()"
                  ],
                  "subInstructions": []
                }
              ],
              "events": []
            }
          ],
          "parameters": [
            {
              "codeOnly": false,
              "defaultValue": "",
              "description": "Object",
              "longDescription": "",
              "name": "Object",
              "optional": false,
              "supplementaryInformation": "PrimitiveDrawing::Drawer",
              "type": "object"
            },
            {
              "codeOnly": false,
              "defaultValue": "",
              "description": "Behavior",
              "longDescription": "",
              "name": "Behavior",
              "optional": false,
              "supplementaryInformation": "MarchingSquares::MarchingSquaresBehavior",
              "type": "behavior"
            }
          ],
          "objectGroups": []
        },
        {
          "description": "The field value at a given location.",
          "fullName": "Field value",
          "functionType": "Expression",
          "name": "FieldValue",
          "private": false,
          "sentence": "At _PARAM2_; _PARAM3_ the field value of _PARAM0_ is greater than _PARAM4_",
          "events": [
            {
              "disabled": false,
              "folded": false,
              "type": "BuiltinCommonInstructions::JsCode",
              "inlineCode": "\nconst behaviorName = eventsFunctionContext.getBehaviorName(\"Behavior\");\n\nconst pointX = eventsFunctionContext.getArgument(\"PointX\");\nconst pointY = eventsFunctionContext.getArgument(\"PointY\");\n\nconst behavior = objects[0].getBehavior(behaviorName);\n\neventsFunctionContext.returnValue = behavior.getFieldValue(pointX, pointY);",
              "parameterObjects": "Object",
              "useStrict": true,
              "eventsSheetExpanded": true
            }
          ],
          "parameters": [
            {
              "codeOnly": false,
              "defaultValue": "",
              "description": "Object",
              "longDescription": "",
              "name": "Object",
              "optional": false,
              "supplementaryInformation": "PrimitiveDrawing::Drawer",
              "type": "object"
            },
            {
              "codeOnly": false,
              "defaultValue": "",
              "description": "Behavior",
              "longDescription": "",
              "name": "Behavior",
              "optional": false,
              "supplementaryInformation": "MarchingSquares::MarchingSquaresBehavior",
              "type": "behavior"
            },
            {
              "codeOnly": false,
              "defaultValue": "",
              "description": "X position of the point",
              "longDescription": "",
              "name": "PointX",
              "optional": false,
              "supplementaryInformation": "",
              "type": "expression"
            },
            {
              "codeOnly": false,
              "defaultValue": "",
              "description": "Y position of the point",
              "longDescription": "",
              "name": "PointY",
              "optional": false,
              "supplementaryInformation": "",
              "type": "expression"
            }
          ],
          "objectGroups": []
        },
        {
          "description": "Check if the contours are filled outside.",
          "fullName": "Fill outside",
          "functionType": "Condition",
          "name": "CheckFillOutside",
          "private": false,
          "sentence": "The contours of _PARAM0_ are filled outside",
          "events": [
            {
              "disabled": false,
              "folded": false,
              "type": "BuiltinCommonInstructions::Standard",
              "conditions": [],
              "actions": [
                {
                  "type": {
                    "inverted": false,
                    "value": "SetReturnBoolean"
                  },
                  "parameters": [
                    "False"
                  ],
                  "subInstructions": []
                }
              ],
              "events": []
            },
            {
              "disabled": false,
              "folded": false,
              "type": "BuiltinCommonInstructions::Standard",
              "conditions": [
                {
                  "type": {
                    "inverted": false,
                    "value": "MarchingSquares::MarchingSquaresBehavior::PropertyFillOutside"
                  },
                  "parameters": [
                    "Object",
                    "Behavior"
                  ],
                  "subInstructions": []
                }
              ],
              "actions": [
                {
                  "type": {
                    "inverted": false,
                    "value": "SetReturnBoolean"
                  },
                  "parameters": [
                    "True"
                  ],
                  "subInstructions": []
                }
              ],
              "events": []
            }
          ],
          "parameters": [
            {
              "codeOnly": false,
              "defaultValue": "",
              "description": "Object",
              "longDescription": "",
              "name": "Object",
              "optional": false,
              "supplementaryInformation": "PrimitiveDrawing::Drawer",
              "type": "object"
            },
            {
              "codeOnly": false,
              "defaultValue": "",
              "description": "Behavior",
              "longDescription": "",
              "name": "Behavior",
              "optional": false,
              "supplementaryInformation": "MarchingSquares::MarchingSquaresBehavior",
              "type": "behavior"
            }
          ],
          "objectGroups": []
        },
        {
          "description": "Check if a field is greater than a given value.",
          "fullName": "Field value",
          "functionType": "Condition",
          "name": "CheckFieldValue",
          "private": false,
          "sentence": "At _PARAM2_; _PARAM3_ the field value of _PARAM0_ is greater than _PARAM4_",
          "events": [
            {
              "disabled": false,
              "folded": false,
              "type": "BuiltinCommonInstructions::JsCode",
              "inlineCode": "\nconst behaviorName = eventsFunctionContext.getBehaviorName(\"Behavior\");\n\nconst pointX = eventsFunctionContext.getArgument(\"PointX\");\nconst pointY = eventsFunctionContext.getArgument(\"PointY\");\nconst value = eventsFunctionContext.getArgument(\"Value\");\n\nconst behavior = objects[0].getBehavior(behaviorName);\n\neventsFunctionContext.returnValue = behavior.getFieldValue(pointX, pointY) > value;",
              "parameterObjects": "Object",
              "useStrict": true,
              "eventsSheetExpanded": false
            }
          ],
          "parameters": [
            {
              "codeOnly": false,
              "defaultValue": "",
              "description": "Object",
              "longDescription": "",
              "name": "Object",
              "optional": false,
              "supplementaryInformation": "PrimitiveDrawing::Drawer",
              "type": "object"
            },
            {
              "codeOnly": false,
              "defaultValue": "",
              "description": "Behavior",
              "longDescription": "",
              "name": "Behavior",
              "optional": false,
              "supplementaryInformation": "MarchingSquares::MarchingSquaresBehavior",
              "type": "behavior"
            },
            {
              "codeOnly": false,
              "defaultValue": "",
              "description": "X position of the point",
              "longDescription": "",
              "name": "PointX",
              "optional": false,
              "supplementaryInformation": "",
              "type": "expression"
            },
            {
              "codeOnly": false,
              "defaultValue": "",
              "description": "Y position of the point",
              "longDescription": "",
              "name": "PointY",
              "optional": false,
              "supplementaryInformation": "",
              "type": "expression"
            },
            {
              "codeOnly": false,
              "defaultValue": "",
              "description": "Value",
              "longDescription": "",
              "name": "Value",
              "optional": false,
              "supplementaryInformation": "",
              "type": "expression"
            }
          ],
          "objectGroups": []
        },
        {
          "description": "Check if a point is inside the contour.",
          "fullName": "Point is inside",
          "functionType": "Condition",
          "name": "ContainsPoint",
          "private": false,
          "sentence": "_PARAM2_; _PARAM3_ is inside _PARAM0_",
          "events": [
            {
              "disabled": false,
              "folded": false,
              "type": "BuiltinCommonInstructions::JsCode",
              "inlineCode": "\nconst behaviorName = eventsFunctionContext.getBehaviorName(\"Behavior\");\n\nconst pointX = eventsFunctionContext.getArgument(\"PointX\");\nconst pointY = eventsFunctionContext.getArgument(\"PointY\");\n\nconst behavior = objects[0].getBehavior(behaviorName);\n\neventsFunctionContext.returnValue = behavior.containsPoint(pointX, pointY);",
              "parameterObjects": "Object",
              "useStrict": true,
              "eventsSheetExpanded": true
            }
          ],
          "parameters": [
            {
              "codeOnly": false,
              "defaultValue": "",
              "description": "Object",
              "longDescription": "",
              "name": "Object",
              "optional": false,
              "supplementaryInformation": "PrimitiveDrawing::Drawer",
              "type": "object"
            },
            {
              "codeOnly": false,
              "defaultValue": "",
              "description": "Behavior",
              "longDescription": "",
              "name": "Behavior",
              "optional": false,
              "supplementaryInformation": "MarchingSquares::MarchingSquaresBehavior",
              "type": "behavior"
            },
            {
              "codeOnly": false,
              "defaultValue": "",
              "description": "X position of the point",
              "longDescription": "",
              "name": "PointX",
              "optional": false,
              "supplementaryInformation": "",
              "type": "expression"
            },
            {
              "codeOnly": false,
              "defaultValue": "",
              "description": "Y position of the point",
              "longDescription": "",
              "name": "PointY",
              "optional": false,
              "supplementaryInformation": "",
              "type": "expression"
            }
          ],
          "objectGroups": []
        }
      ],
      "propertyDescriptors": [
        {
          "value": "0",
          "type": "Number",
          "label": "Area left bound",
          "description": "",
          "extraInformation": [],
          "hidden": false,
          "name": "AreaLeftBound"
        },
        {
          "value": "0",
          "type": "Number",
          "label": "Area top bound",
          "description": "",
          "extraInformation": [],
          "hidden": false,
          "name": "AreaTopBound"
        },
        {
          "value": "0",
          "type": "Number",
          "label": "Area right bound",
          "description": "",
          "extraInformation": [],
          "hidden": false,
          "name": "AreaRightBound"
        },
        {
          "value": "0",
          "type": "Number",
          "label": "Area bottom bound",
          "description": "",
          "extraInformation": [],
          "hidden": false,
          "name": "AreaBottomBound"
        },
        {
          "value": "20",
          "type": "Number",
          "label": "Cell width",
          "description": "",
          "extraInformation": [],
          "hidden": false,
          "name": "CellWidth"
        },
        {
          "value": "20",
          "type": "Number",
          "label": "Cell height",
          "description": "",
          "extraInformation": [],
          "hidden": false,
          "name": "CellHeight"
        },
        {
          "value": "",
          "type": "Boolean",
          "label": "Fill outside",
          "description": "",
          "extraInformation": [],
          "hidden": false,
          "name": "FillOutside"
        },
        {
          "value": "1",
          "type": "Number",
          "label": "Contour threshold",
          "description": "",
          "extraInformation": [],
          "hidden": false,
          "name": "Threshold"
        },
        {
          "value": "",
          "type": "Boolean",
          "label": "Must only draw what is on the screen",
          "description": "",
          "extraInformation": [],
          "hidden": false,
          "name": "MustOnlyDrawScreen"
        }
      ]
    }
  ]
}