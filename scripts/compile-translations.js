const shell = require('shelljs');
const path = require('path');
const fs = require('fs');
const {
  getLocales,
  getLocalePath,
  getLocaleSourceCatalogFiles,
  getLocaleCatalogPath,
  getLocaleCompiledCatalogPath,
  getLocaleMetadataPath,
  getLocaleName,
  getLocaleNativeName,
} = require('./lib/Locales');

/**
 * @param {string} path
 * @returns {Promise<string>}
 */
const readUtf8File = (path) =>
  new Promise((resolve, reject) => {
    fs.readFile(path, 'utf8', function (err, content) {
      if (err) {
        reject(err);
        return;
      }

      resolve(content);
    });
  });

/**
 * @param {string} path
 * @param {string} content
 * @returns {Promise<void>}
 */
const writeUtf8File = (path, content) =>
  new Promise((resolve, reject) => {
    fs.writeFile(path, content, 'utf8', function (err) {
      if (err) {
        return reject(err);
      }

      resolve();
    });
  });

// Identify where msgcat is on the system
let msgcat = '';
msgcat = shell.exec('which msgcat 2>/dev/null', { silent: true }).stdout;
if (!msgcat) {
  msgcat = shell.exec('find /usr -name "msgcat" -print -quit 2>/dev/null', {
    silent: true,
  }).stdout;
}

msgcat = msgcat.trim();
if (!msgcat) {
  shell.echo(
    `ℹ️ msgcat not found not found on your computer - skipping translations compilation.`
  );
  shell.echo(
    `ℹ️ Install "gettext" with "brew install gettext" (macOS) or your Linux package manager.`
  );
  shell.exit(0);
}

/**
 * @param {{ messages: {[key: string]: string}}} compiledCatalog
 * @returns {number} The ratio of translations.
 */
const computeTranslationRatio = (compiledCatalog) => {
  const allMessages = Object.keys(compiledCatalog.messages);
  const sameAsKeyCount = allMessages.filter(
    (key) => compiledCatalog.messages[key] === key
  ).length;

  return 1 - sameAsKeyCount / allMessages.length;
};

/**
 * @param {{}} object
 */
const writeLocaleMetadata = (object) => {
  const content = [
    `// This file is generated by compile-translations.js script`,
    `// prettier-ignore`,
    `module.exports = ${JSON.stringify(object, null, 2)};`,
    ``,
  ].join('\n');
  fs.writeFileSync(getLocaleMetadataPath(), content);
};

/**
 *
 * @param {string} path
 * @returns {Promise<{forbiddenStringsFound: {str: string, regex: RegExp}[]}>}
 */
const sanitizeMessagePo = (path) => {
  return readUtf8File(path).then((content) => {
    /** @type {{str: string, regex: RegExp}[]} */
    let forbiddenStringsFound = [];
    let forbiddenStrings = [
      {
        str: 'n\\\\',
        regex: /n\\\\/g,
      },
      {
        str: '\\\\',
        regex: /\\\\/g,
      },
      {
        str: '\\ n',
        regex: /\\ n/g,
      },
      {
        str: '\\ t',
        regex: /\\ t/g,
      },
      {
        str: '\\ ',
        regex: /\\ /g,
      },
      {
        str: '{',
        regex: /{/g,
      },
      {
        str: '}',
        regex: /}/g,
      },
    ];
    let sanitizedContent = content;
    forbiddenStrings.forEach((forbiddenString) => {
      if (sanitizedContent.search(forbiddenString.regex) !== -1) {
        forbiddenStringsFound.push(forbiddenString);
        sanitizedContent = sanitizedContent.replace(forbiddenString.regex, ' ');
      }
    });

    return writeUtf8File(path, sanitizedContent).then(() => {
      return {
        forbiddenStringsFound,
      };
    });
  });
};

getLocales()
  .then((locales) => {
    console.info(`ℹ️ Compiling translations for ${locales.join(', ')}`);
    return Promise.all(
      locales.map((locale) => {
        return new Promise((resolve) => {
          console.info(`ℹ️ Compiling translations for ${locale}`);
          // Concatenate all message catalogs into a single one for lingui-js.
          const files = getLocaleSourceCatalogFiles(locale);
          console.info(`ℹ️ Concatenating ${files.join(', ')} for ${locale}`);

          if (locale === 'en' || locale === 'pseudo_LOCALE') {
            // For languages with a single source ("en" and "pseudo_LOCALE"),
            // don't concatenate anything, create the 'messages.po' file.
            const cpResult = shell.cp(
              path.join(getLocalePath(locale), files[0]),
              path.join(getLocalePath(locale), 'messages.po')
            );

            return resolve({
              locale,
              shellOutput: {
                code: cpResult.code,
                stdout: cpResult.stdout,
                stderr: cpResult.stderr,
              },
            });
          }

          // Run msgcat. Use --no-wrap to allow to sanitize the catalog with
          // regex/string replace.
          // Use --use-first to avoid merging multiple translations for the same
          // string.
          shell.exec(
            msgcat + ` --no-wrap --use-first ${files.join(' ')} -o messages.po`,
            {
              cwd: getLocalePath(locale),
              silent: true,
            },
            (code, stdout, stderr) =>
              resolve({
                locale,
                shellOutput: {
                  code,
                  stdout,
                  stderr,
                },
              })
          );
        });
      })
    );
  })
  .catch((error) => {
    shell.echo(`❌ occurred while listing locales folders: ` + error);
    shell.exit(1);
    return;
  })
  .then((results) => {
    console.info('ℹ️ Returning successes & failures:');
    // Display success and errors while concatenating translation catalogs for each locale.
    const successes = (results || []).filter(
      ({ shellOutput }) => shellOutput.code === 0
    );
    const failures = (results || []).filter(
      ({ shellOutput }) => shellOutput.code !== 0
    );

    const successesLocales = successes.map(({ locale }) => locale).join(',');
    if (successesLocales) {
      shell.echo(`ℹ️ Concatenated translations for ${successesLocales}.`);
    }
    if (failures.length) {
      failures.forEach(({ locale, shellOutput }) => {
        shell.echo(
          `❌ Error(s) occurred while concatenating translations for ${locale}: ` +
            shellOutput.stderr
        );
      });
    }

    return successes.map(({ locale }) => locale);
  })
  .then((locales) => {
    console.info('ℹ️ Sanitizing catalogs...');
    // "Sanitize" all catalogs by removing and warning about bad characters
    // in translations that would break js-lingui (incorrect ICU message format).
    return Promise.all(
      locales.map((locale) =>
        sanitizeMessagePo(getLocaleCatalogPath(locale)).then((results) => {
          if (results.forbiddenStringsFound.length) {
            shell.echo(
              `⚠️ Found forbidden strings for locale ${locale} (replaced by spaces):`
            );
            results.forbiddenStringsFound.forEach(({ str }) => {
              shell.echo(`  * Found ${str}`);
            });
          }
        })
      )
    ).then(() => locales);
  })
  .then((locales) => {
    console.info('ℹ️ Compiling catalogs...');
    // Launch "lingui compile" for transforming .PO files into
    // js files ready to be used with @lingui/react IDE translations
    shell.exec('node node_modules/.bin/lingui compile');

    return locales;
  })
  .then((locales) => {
    console.info('ℹ️ Computing stats...');
    // Compute some stats about the languages...
    return locales
      .map((locale) => {
        try {
          const compiledCatalog = require(getLocaleCompiledCatalogPath(locale));

          return {
            languageCode: locale,
            languageName: getLocaleName(locale),
            languageNativeName: getLocaleNativeName(locale),
            translationRatio: computeTranslationRatio(compiledCatalog),
          };
        } catch (error) {
          shell.echo(
            `⚠️ Can't find catalog for ${locale} (${error}) - ignoring this language.`
          );
          return null;
        }
      })
      .filter(Boolean);
  })
  .then(
    // ... and store the stats in LocaleMetadata.js, to be displayed/used
    // in the editor.
    (localesMetadata) => {
      console.info('ℹ️ Writing metadata...');
      writeLocaleMetadata(localesMetadata);
    },
    (error) => {
      shell.echo(
        `❌ Error(s) occurred while computing ${getLocaleMetadataPath()}: ` +
          error
      );
      shell.exit(1);
      return;
    }
  )
  .then(
    () => {
      shell.echo(
        `✅ Translations compiled and metadata written in ${getLocaleMetadataPath()}`
      );
      shell.exit(0);
      return;
    },
    (error) => {
      shell.echo(
        `❌ Error(s) occurred while writing ${getLocaleMetadataPath()}: ` +
          error
      );
      shell.exit(1);
      return;
    }
  );
